<!doctype html>
<html lang="en" id="top" class="no-js" data-version="2025-01-12-waves-130-v7">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta http-equiv="Last-Modified" content="Fri, 10 Jan 2025 00:00:00 GMT" />
  <title>BEAR Park — BEARcade</title>
  <meta name="description" content="Welcome to BEAR Park — play BEARcade games, explore the lore of Bearableguy123, view BEAR NFTs, watch the live stream, and join the $BEAR community." />
  <meta name="theme-color" content="#edb723" />
  <meta name="color-scheme" content="dark light" />
  <link rel="canonical" href="https://bearpark.xyz/" />

  <!-- Open Graph / Twitter -->
  <meta property="og:type" content="website" />
  <meta property="og:title" content="BEAR Park — BEARcade" />
  <meta property="og:description" content="Defend the castle. Play BEARcade. Join the $BEAR fam." />
  <meta property="og:image" content="https://files.catbox.moe/qnd2tx.png" />
  <meta property="og:url" content="https://bearpark.xyz/" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="BEAR Park — BEARcade" />
  <meta name="twitter:description" content="Defend the castle. Play BEARcade. Join the $BEAR fam." />
  <meta name="twitter:image" content="https://files.catbox.moe/qnd2tx.png" />

  <!-- Favicons -->
  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" href="/favicon-16x16.png" sizes="16x16" type="image/png">
  <link rel="icon" href="/favicon-32x32.png" sizes="32x32" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="icon" href="/android-chrome-192x192.png" sizes="192x192" type="image/png">
  <link rel="icon" href="/android-chrome-512x512.png" sizes="512x512" type="image/png">
  <link rel="manifest" href="/site.webmanifest">

  <!-- PWA Meta Tags -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="BEAR Park">
  <meta name="mobile-web-app-capable" content="yes">

  <!-- Performance: preconnects + hero preload -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="preload" as="image" href="https://files.catbox.moe/qnd2tx.png" fetchpriority="high" />
  <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap" rel="stylesheet" />

  <!-- XRPL Library -->
  <script src="https://unpkg.com/xrpl@3.0.0/build/xrpl-latest-min.js"></script>

  <!-- Chart.js for P&L Graph -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>

  <style>
  /* ==== THEME =========================================================== */
  :root{
    --gold:#ffae00;
    --gold-ink:#231b04;
    --charcoal:#141619;
    --card:#1e2226;
    --ink:#0b0d0e;
    --accent:#d75c46;
    --honey:#ffefb3;
    --elev: 0 0.8px 1.6px rgba(0,0,0,.18), 0 5px 18px rgba(0,0,0,.28);
    --elev-strong: 0 10px 28px rgba(0,0,0,.45), 0 1px 0 rgba(255,255,255,.03) inset;
    --ease-spring:cubic-bezier(.18,.9,.2,1);
    --ring: 0 0 0 4px #000, 0 0 0 6px rgba(255,174,0,.66);
    accent-color: var(--gold);
    --stripe-purple: #680cd9;
    --stripe-yellow: #ffae00;
    --stripe-green: #07ae08;
    --tri-gradient: linear-gradient(to right, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
  }

  /* ==== BASE ============================================================ */
  *{box-sizing:border-box}
  html,body{margin:0;padding:0;background:var(--charcoal);color:#fff}
  body{padding-bottom:calc(160px + env(safe-area-inset-bottom))}

  /* Tri-color border utility for rounded elements */
  .tri-border-rounded {
    position: relative;
    border: none;
  }
  .tri-border-rounded::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: inherit;
    padding: 6px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: -1;
  }
  html{scroll-behavior:smooth}
  img{max-width:100%;height:auto;display:block}
  a{color:inherit;text-decoration:none}
  .wrap{max-width:1100px;margin:0 auto;padding:52px 20px}
  .center{display:flex;justify-content:center;align-items:center}

  /* Global font */
  body, p, .tile .lbl, button, a, small {
    font-family:"Luckiest Guy","Arial Black",Impact,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    text-rendering:optimizeLegibility;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  /* Decorative grain + aurora */
  body::before{
    content:"";
    position:fixed; inset:-20vmax; pointer-events:none; z-index:-2;
    background:
      radial-gradient(100vmax 60vmax at 10% -10%, rgba(237,183,35,.055), transparent 60%),
      radial-gradient(80vmax 60vmax at 100% 10%, rgba(215,92,70,.055), transparent 60%),
      radial-gradient(80vmax 60vmax at 50% 110%, rgba(118,174,255,.045), transparent 60%);
    filter:blur(24px) saturate(1.05);
  }
  body::after{
    content:"";
    position:fixed; inset:0; pointer-events:none; z-index:-1;
    background-image:
      radial-gradient(rgba(255,255,255,.05), transparent 40%),
      repeating-linear-gradient(0deg, rgba(255,255,255,.02) 0 2px, transparent 2px 4px);
    mix-blend-mode:overlay; opacity:.18;
  }

  /* Skip link */
  .skip-link{position:absolute;left:-999px;top:auto;width:1px;height:1px;overflow:hidden}
  .skip-link:focus{left:12px;top:12px;width:auto;height:auto;z-index:1000;background:#000;color:#fff;border:3px solid var(--gold);border-radius:10px;padding:10px 14px}

  /* Sticky nav + scroll progress */
  .site-nav{position:sticky;top:0;z-index:50;background:linear-gradient(180deg, #0f1114, rgba(15,17,20,.8));backdrop-filter:saturate(1.05) blur(6px);border-bottom:4px solid transparent; border-image: var(--tri-gradient) 1}
  .site-nav .bar{max-width:1100px;margin:0 auto;display:flex;align-items:center;gap:14px;padding:10px 20px}
  .brand{display:flex;align-items:center;gap:10px;font-weight:900}
  .brand img{width:36px;height:36px}
  .links{display:flex;gap:10px;flex-wrap:wrap}
  .links a{font-weight:900;padding:8px 12px;border-radius:12px}
  .links a[aria-current="true"], .links a:hover{background:#1c1f23}
  .nav-cta{margin-left:auto}
  .progress{position:absolute;inset-inline:0;top:0;height:4px;background:linear-gradient(90deg,var(--gold),#ffe280);transform-origin:left center;transform:scaleX(0)}

  /* Headings */
  .h1,.h2,.h3{font-weight:900; letter-spacing:.5px; text-align:center; line-height:1.05; margin:0 0 14px; color:#fff; text-shadow:0 4px 0 rgba(0,0,0,.35), 0 1px 0 rgba(0,0,0,.25)}
  .h1{font-size:clamp(44px,7vw,96px)}
  .h2{font-size:clamp(38px,5.5vw,72px)}
  .h3{font-size:clamp(28px,3.5vw,44px)}
  p{margin:0 0 14px;font-weight:600;font-size:18px;line-height:1.35}
  .on-dark{color:var(--gold)!important}

  /* Sections */
  section{
    position:relative;
    border-top: 6px solid;
    border-bottom: 6px solid;
    border-image: linear-gradient(to right, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%) 1;
  }
  section.alt{background:var(--gold);color:var(--gold-ink)}
  section.dark{background:linear-gradient(180deg,#141619 0%, #101215 100%);color:#fff}
  .spacer{height:12px}

  /* Buttons */
  .btn{display:inline-flex;align-items:center;justify-content:center;gap:.6rem;font:900 clamp(18px,2.5vw,24px)/1 "Luckiest Guy","Arial Black",Impact,system-ui,sans-serif;border-radius:26px;padding:1.1rem 1.6rem;color:#fff;background:var(--accent);border:none; box-shadow:0 10px 0 #7b2a20, 0 18px 24px rgba(0,0,0,.35);transition:transform .12s var(--ease-spring), box-shadow .12s var(--ease-spring), filter .2s ease;white-space:nowrap; position:relative; will-change:transform}
  .btn::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 26px;
    padding: 6px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: -1;
  }
  .btn{transition:all 0.2s ease;}
  .btn:hover{filter:brightness(1.12); transform:translateY(-2px);}
  .btn:active{transform:translateY(4px); box-shadow:0 6px 0 #7b2a20, 0 10px 16px rgba(0,0,0,.35)}
  .btn.ghost{background:#1c1f23;color:#fff;box-shadow:0 10px 0 #000,0 18px 24px rgba(0,0,0,.35)}
  .btn.gold{background:var(--gold);color:#000;box-shadow:0 10px 0 #9b7a0d,0 18px 24px rgba(0,0,0,.35)}
  .btn.gold:hover{box-shadow:0 12px 0 #9b7a0d,0 22px 28px rgba(0,0,0,.4); filter:brightness(1.15);}
  .btn:focus-visible{outline:none; box-shadow:var(--ring)}

  /* Input Styles */
  input[type="text"]:focus{
    border-color:var(--gold) !important;
    box-shadow:0 0 0 3px rgba(237,183,35,0.2);
    outline:none;
  }

  /* Cards */
  .card{
    background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    border:4px solid transparent;
    border-radius:20px;
    padding:22px;
    box-shadow:var(--elev-strong);
    overflow:hidden;
    -webkit-overflow-scrolling:auto;
    backdrop-filter:saturate(1.1) blur(2px);
    transform-style:preserve-3d;
    will-change:transform;
    transition:transform .4s var(--ease-spring), box-shadow .4s var(--ease-spring);
    background-image: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02)), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
  }
  .card:hover{ transform:translateY(-4px); box-shadow:0 18px 40px rgba(0,0,0,.5) }
  .card:focus-within{ box-shadow:var(--ring), var(--elev-strong) }

  /* Hero */
  .hero{--hero-bg:url("https://files.catbox.moe/qnd2tx.png"); background:radial-gradient(1200px 500px at 50% -10%, rgba(255,255,255,.065), transparent 60%) , var(--hero-bg) center/cover no-repeat; min-height:56vh; display:flex; align-items:center; position:relative; border-bottom:6px solid transparent; border-image: var(--tri-gradient) 1; overflow:hidden}
  .hero .plate{background:var(--gold); color:var(--ink); border:6px solid transparent; border-radius:22px; box-shadow:0 22px 48px rgba(0,0,0,.45), 0 2px 0 rgba(255,255,255,.25) inset; padding:20px 28px; display:inline-block; margin:0 auto; position:relative; transform:perspective(800px) rotateX(0) rotateY(0) translateZ(0); transition:transform .6s var(--ease-spring), box-shadow .4s var(--ease-spring); will-change:transform; background-image: linear-gradient(var(--gold), var(--gold)), var(--tri-gradient); background-origin: padding-box, border-box; background-clip: padding-box, border-box;}
  .hero .logo{position:absolute; left:-72px; top:-40px; width:120px; transform:rotate(-4deg); filter:drop-shadow(0 8px 0 rgba(0,0,0,.4))}
  .hero .subtitle{font:800 clamp(16px,2.4vw,22px)/1.2 "Luckiest Guy"; margin-top:-6px; color:var(--ink)}

  /* Side honey rails */
  .rails::before,.rails::after{content:"";position:fixed;top:0;bottom:0;width:18px;z-index:1;pointer-events:none;opacity:.65}
  .rails::before{left:80px;background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0)), repeating-linear-gradient(180deg, rgba(0,0,0,.8) 0 3px, rgba(0,0,0,0) 3px 6px), linear-gradient(180deg, var(--gold) 0%, #946e00 100%);border:3px solid transparent;border-image: var(--tri-gradient) 1;border-radius:999px}
  .rails::after{right:6px;background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0)), repeating-linear-gradient(180deg, rgba(0,0,0,.8) 0 3px, rgba(0,0,0,0) 3px 6px), linear-gradient(180deg, var(--gold) 0%, #946e00 100%);border:3px solid transparent;border-image: var(--tri-gradient) 1;border-radius:999px}

  /* Arcade image */
  .arcade{position:relative;width:100%;max-width:1100px;margin:0 auto}
  .arcade img{width:100%;height:auto;display:block;border:4px solid transparent;border-radius:20px;box-shadow:0 18px 40px rgba(0,0,0,.45); background-image: linear-gradient(rgba(0,0,0,0), rgba(0,0,0,0)), var(--tri-gradient); background-origin: padding-box, border-box; background-clip: padding-box, border-box;}
  .arcade a.hotspot{position:absolute;display:block;border-radius:16px;text-indent:-9999px;overflow:hidden;outline:none;background:transparent;transition: box-shadow .25s var(--ease-spring), transform .25s var(--ease-spring)}
  .arcade a.hotspot:focus-visible{outline:6px solid rgba(237,183,35,.7)}
  .arcade a.hotspot:hover, .arcade a.hotspot:focus-visible{ box-shadow: 0 0 0 6px rgba(237,183,35,.35), 0 0 0 10px rgba(0,0,0,.6); }
  .arcade a.hotspot::after{
    content:"";
    position:absolute; left:50%; top:0; width:20px; height:0; transform:translate(-50%,0);
    background: linear-gradient(180deg, #fff6c7 0%, #ffe280 40%, #edb723 70%, #9b7a0d 100%);
  border:3px solid transparent; border-top:none; border-radius:0 0 16px 16px; border-image: var(--tri-gradient) 1; box-shadow:0 6px 0 #946e00, 0 12px 20px rgba(0,0,0,.4);
    transition:height .35s var(--ease-spring), opacity .25s ease; opacity:0;
  }
  .arcade a.hotspot:hover::after, .arcade a.hotspot:focus-visible::after{ height:36px; opacity:1 }

  /* Game cards */
  .game-card {
    position: relative;
  }
  .game-card a > div {
    cursor: pointer;
  }
  .game-card:hover a > div {
    transform: translateY(-8px) scale(1.02);
    box-shadow: 0 16px 40px rgba(0,0,0,0.6), 0 0 40px rgba(104, 12, 217, 0.3);
  }
  .game-card:active a > div {
    transform: translateY(-4px) scale(1.01);
    box-shadow: 0 12px 32px rgba(0,0,0,0.5);
  }

  /* Grid & tiles */
  .grid-2{display:grid;grid-template-columns:repeat(2,1fr);gap:22px}
  @media (max-width:820px){.grid-2{grid-template-columns:1fr}}
  .grid-3{display:grid;grid-template-columns:repeat(3,1fr);gap:22px}
  @media (max-width:1024px){.grid-3{grid-template-columns:1fr}}
  .tile{text-decoration:none;display:flex;flex-direction:column;align-items:center;gap:14px}
  .tile .face{width:100%;min-height:140px;padding:22px;background:var(--card);border:4px solid transparent;border-radius:18px;box-shadow:0 12px 0 #000,0 18px 28px rgba(0,0,0,.35);display:flex;align-items:center;justify-content:center;transition:transform .35s var(--ease-spring), box-shadow .35s var(--ease-spring);transform-style:preserve-3d; will-change:transform; background-image: linear-gradient(var(--card), var(--card)), var(--tri-gradient); background-origin: padding-box, border-box; background-clip: padding-box, border-box;}
  .tile:hover .face{ transform:translateY(-4px); box-shadow:0 16px 0 #000,0 26px 40px rgba(0,0,0,.45) }
  .tile img{max-width:220px;max-height:64px;object-fit:contain;filter:drop-shadow(0 2px 0 rgba(0,0,0,.4))}
  .tile .lbl{font-weight:800;font-size:18px;line-height:1.2;color:var(--ink);opacity:.9}
  .dark .tile .lbl{color:var(--gold)}

  /* NFTs */
  #nfts .card{padding:26px}
  #nfts .card{background:linear-gradient(180deg,#141619 0%, #101215 100%) !important; border:4px solid transparent !important; border-radius:20px !important; background-image: linear-gradient(180deg,#141619 0%, #101215 100%), var(--tri-gradient) !important; background-origin: padding-box, border-box !important; background-clip: padding-box, border-box !important;}
  .nft-media{display:block;border:6px solid transparent;border-radius:16px;overflow:hidden; background-image: linear-gradient(rgba(0,0,0,0), rgba(0,0,0,0)), var(--tri-gradient); background-origin: padding-box, border-box; background-clip: padding-box, border-box;}
  .nft-media img,.nft-media video{display:block;width:100%;height:auto}
  #nfts .card h3,#nfts .card p{color:var(--gold)!important}

  /* Leaderboards */
  .leaderboard-card{
    position:relative;
    background:radial-gradient(500px 200px at 50% -20%, rgba(118,174,255,.12), transparent 60%), var(--ink);
    border-radius:28px;
    padding:32px 24px;
    isolation:isolate;
  }
  .leaderboard-card::before{
    content:'';
    position:absolute;
    inset:0;
    border-radius:28px;
    padding:4px;
    background:var(--tri-gradient);
    -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite:xor;
    mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite:exclude;
    pointer-events:none;
    z-index:0;
    opacity:1;
  }
  .leaderboard-list{
    display:flex;
    flex-direction:column;
    gap:12px;
    overflow-y:auto;
    max-height:520px;
    padding-right:8px;
  }

  .leaderboard-list::-webkit-scrollbar{
    width:8px;
  }

  .leaderboard-list::-webkit-scrollbar-track{
    background:rgba(0,0,0,0.2);
    border-radius:4px;
  }

  .leaderboard-list::-webkit-scrollbar-thumb{
    background:var(--gold);
    border-radius:4px;
  }
  .leaderboard-entry{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:16px;
    border-radius:12px;
    background:linear-gradient(135deg, rgba(104, 12, 217, 0.15) 0%, rgba(7, 174, 8, 0.15) 100%);
    border-left:4px solid var(--gold);
    transition:all 0.2s ease;
  }
  .leaderboard-entry:hover{transform:translateX(8px);background:linear-gradient(135deg, rgba(104, 12, 217, 0.25) 0%, rgba(7, 174, 8, 0.25) 100%)}
  .leaderboard-entry.rank-1{background:linear-gradient(135deg, rgba(237, 183, 35, 0.3) 0%, rgba(255, 215, 0, 0.2) 100%);border-left-color:#FFD700;border-left-width:6px}
  .leaderboard-entry.rank-2{background:linear-gradient(135deg, rgba(192, 192, 192, 0.2) 0%, rgba(169, 169, 169, 0.15) 100%);border-left-color:#C0C0C0;border-left-width:5px}
  .leaderboard-entry.rank-3{background:linear-gradient(135deg, rgba(205, 127, 50, 0.2) 0%, rgba(184, 115, 51, 0.15) 100%);border-left-color:#CD7F32;border-left-width:5px}
  .leaderboard-rank{font-size:24px;color:var(--gold);text-shadow:2px 2px 0px #000;min-width:50px;font-family:'Luckiest Guy',cursive}
  .leaderboard-name{font-size:18px;color:#fff;text-shadow:2px 2px 0px #000;flex:1;margin:0 16px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .leaderboard-score{font-size:22px;color:var(--stripe-yellow);text-shadow:2px 2px 0px #000;font-weight:800}
  .leaderboard-wallet{font-size:11px;color:#888;font-family:monospace;margin-top:4px}
  .loading{text-align:center;padding:32px;color:#888;font-size:16px}

  /* Community banner */
  .community-banner{position:relative;overflow:hidden;border-radius:22px;border:6px solid transparent;background:#000;box-shadow:0 20px 40px rgba(0,0,0,.45); background-image: linear-gradient(#000, #000), var(--tri-gradient); background-origin: padding-box, border-box; background-clip: padding-box, border-box; min-height:500px;}
  .community-banner img.bg{position:absolute;top:50%;left:50%;width:140%;height:140%;min-width:140%;min-height:140%;object-fit:cover;opacity:.5;filter:saturate(1.15) contrast(1.1) blur(1px);animation:slow-pan 60s linear infinite;will-change:transform;transition:transform 0.3s ease-out;transform:translate(-50%, -50%)}
  @keyframes slow-pan{0%{transform:translate(-50%, -50%) translateX(0)}50%{transform:translate(-50%, -50%) translateX(-14.29%)}100%{transform:translate(-50%, -50%) translateX(0)}}
  .community-banner .overlay{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:32px 24px;background:radial-gradient(circle at center, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.7) 100%)}
  .community-content{display:flex;flex-direction:column;align-items:center;max-width:700px;position:relative;z-index:2}
  .community-badge{width:160px;height:160px;background:var(--gold);border-radius:50%;display:flex;align-items:center;justify-content:center;box-shadow:0 12px 32px rgba(237,183,35,0.5), 0 0 0 8px rgba(237,183,35,0.3), 0 0 0 16px rgba(0,0,0,0.4);animation:badge-float 3s ease-in-out infinite}
  @keyframes badge-float{0%,100%{transform:translateY(0)}50%{transform:translateY(-10px)}}
  .community-buttons{display:flex;gap:16px;flex-wrap:wrap;justify-content:center;margin-bottom:32px}
  .community-btn{display:flex;align-items:center;gap:10px;font-size:16px;padding:14px 28px;transition:all 0.3s ease;position:relative;overflow:hidden}
  .community-btn::before{content:"";position:absolute;top:50%;left:50%;width:0;height:0;border-radius:50%;background:rgba(255,255,255,0.3);transform:translate(-50%,-50%);transition:width 0.6s,height 0.6s}
  .community-btn:hover::before{width:300px;height:300px}
  .community-btn:hover{transform:translateY(-4px) scale(1.05);box-shadow:0 12px 32px rgba(237,183,35,0.5)}
  .btn-icon{font-size:22px;filter:drop-shadow(2px 2px 0 rgba(0,0,0,0.3))}
  .btn-text{position:relative;z-index:1}
  .community-stats{display:grid;grid-template-columns:repeat(4,1fr);gap:24px;padding:20px;background:rgba(0,0,0,0.4);border-radius:16px;border:2px solid rgba(237,183,35,0.2);backdrop-filter:blur(10px);max-width:700px}
  .stat-item{display:flex;flex-direction:column;align-items:center;gap:8px;min-width:100px}
  .stat-emoji{font-size:32px;animation:stat-pulse 2s ease-in-out infinite}
  .stat-text{font-size:13px;color:rgba(255,255,255,0.85);font-weight:700;text-align:center;text-shadow:1px 1px 2px #000}
  @keyframes stat-pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.1)}}
  .paw-prints{position:absolute;top:20px;left:20px;right:20px;bottom:20px;pointer-events:none;z-index:1}
  .paw{position:absolute;font-size:24px;opacity:0.15;animation:paw-walk 20s linear infinite}
  .paw:nth-child(1){top:10%;left:-50px;animation-delay:0s}
  .paw:nth-child(2){top:30%;left:-50px;animation-delay:5s}
  .paw:nth-child(3){top:50%;left:-50px;animation-delay:10s}
  .paw:nth-child(4){top:70%;left:-50px;animation-delay:15s}
  @keyframes paw-walk{0%{left:-50px;transform:rotate(-15deg)}100%{left:calc(100% + 50px);transform:rotate(15deg)}}
  @media (max-width:640px){
    .community-banner{min-height:700px}
    .community-badge{width:140px;height:140px}
    .community-buttons{flex-direction:column;width:100%;max-width:280px}
    .community-btn{width:100%;justify-content:center}
    .community-stats{grid-template-columns:repeat(2,1fr);gap:16px;padding:16px;max-width:100%}
    .stat-item{min-width:auto}
    .stat-emoji{font-size:28px}
    .stat-text{font-size:12px}
  }
  .pair{display:flex;gap:16px;flex-wrap:wrap;justify-content:center}

  /* Kick stream (true 16:9) */
  .square{position:relative;width:100%;max-width:900px;margin:0 auto;aspect-ratio:16/9;border-radius:16px;overflow:hidden}
  .square iframe,.square .placeholder{position:absolute;inset:0;width:100%;height:100%;border:0;border-radius:16px}
  .square .placeholder{display:grid;place-items:center;background:#0b0d0e;border:0}

  /* Carousel */
  .carousel{position:relative;overflow:visible;border:6px solid transparent;border-radius:16px; background-image: linear-gradient(rgba(0,0,0,0), rgba(0,0,0,0)), var(--tri-gradient); background-origin: padding-box, border-box; background-clip: padding-box, border-box;}
  .carousel .viewport{position:relative;width:100%;min-height:400px;overflow:hidden;touch-action:none;cursor:grab;background:#0b0d0e;display:flex;align-items:center;border-radius:12px}
  .carousel .viewport.grabbing{cursor:grabbing}
  .slides{display:flex;will-change:transform;transition:transform .7s var(--ease-spring);align-items:center}
  .slides img{width:100%;height:auto;flex:0 0 100%;object-fit:contain; user-select:none;-webkit-user-drag:none;pointer-events:none;background:#0b0d0e; transform-origin:center center;display:block;max-height:600px}

  /* Carousel Navigation Arrows */
  .carousel-arrow{position:absolute;top:50%;transform:translateY(-50%);z-index:10;width:56px;height:56px;border-radius:50%;border:3px solid transparent;background:linear-gradient(#0b0d0e, #0b0d0e) padding-box, var(--tri-gradient) border-box;color:var(--gold);cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all 0.3s var(--ease-spring);opacity:0.7;backdrop-filter:blur(10px)}
  .carousel-arrow:hover{opacity:1;transform:translateY(-50%) scale(1.1);box-shadow:0 8px 24px rgba(0,0,0,0.5), 0 0 20px rgba(237,183,35,0.3)}
  .carousel-arrow:active{transform:translateY(-50%) scale(0.95)}
  .carousel-arrow-left{left:-28px}
  .carousel-arrow-right{right:-28px}
  .carousel-arrow svg{filter:drop-shadow(0 2px 4px rgba(0,0,0,0.8))}

  /* Hide arrows on mobile/tablet */
  @media (max-width: 1024px) {
    .carousel-arrow{display:none}
  }

  .dots{display:flex;gap:8px;justify-content:center;margin-top:12px}
  .dot{width:16px;height:16px;border-radius:50%;background:#000;border:3px solid transparent;background-image:linear-gradient(#000, #000), var(--tri-gradient);background-origin:padding-box, border-box;background-clip:padding-box, border-box;opacity:1;transition:all .25s var(--ease-spring);cursor:pointer}
  .dot:hover{transform:scale(1.1)}
  .dot.active{background-image:linear-gradient(var(--gold), var(--gold)), var(--tri-gradient);transform:scale(1.15);box-shadow:0 0 12px rgba(237,183,35,0.6)}
  footer{border-top:6px solid transparent; border-image: var(--tri-gradient) 1}

  /* Scroll reveal */
  .reveal{opacity:1; transform:translateY(0) scale(1); filter:blur(0)}
  .reveal.in{opacity:1; transform:translateY(0) scale(1); filter:blur(0); transition:opacity .6s var(--ease-spring), transform .6s var(--ease-spring), filter .6s var(--ease-spring)}

  /* Reduced motion */
  @media (prefers-reduced-motion:reduce){
    html{scroll-behavior:auto}
    .reveal{opacity:1; transform:none; filter:none}
    .slides{transition:none}
    .btn, .card, .tile .face{transition:none}
  }

  /* Buy drawer + FAB base styles used by JS */
  .fab-buy{
    position:fixed; right:20px; bottom:calc(20px + env(safe-area-inset-bottom)); z-index:60;
    display:inline-flex; align-items:center; justify-content:center; gap:.6rem;
    font:900 22px/1 "Luckiest Guy","Arial Black",Impact,system-ui,sans-serif;
    padding:18px 28px; border-radius:999px;
    color:var(--gold);
    background:#1a1a1a;
    text-shadow: 0 2px 8px rgba(237, 183, 35, 0.4), 0 0 20px rgba(237, 183, 35, 0.3);
    border: 4px solid transparent;
    box-shadow:0 8px 0 #000, 0 12px 32px rgba(0,0,0,0.8);
    background-image: linear-gradient(#1a1a1a, #1a1a1a), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    transition:transform .12s var(--ease-spring), filter .15s ease, box-shadow .2s ease;
    cursor: pointer;
  }
  .fab-buy:hover{
    filter:brightness(1.15);
    transform:translateY(-3px);
    box-shadow:0 10px 0 #000, 0 16px 40px rgba(0,0,0,0.9), 0 0 30px rgba(237, 183, 35, 0.4);
    text-shadow: 0 2px 10px rgba(237, 183, 35, 0.6), 0 0 30px rgba(237, 183, 35, 0.5);
  }
  .fab-buy:active{
    transform:translateY(2px);
    box-shadow:0 4px 0 #000, 0 6px 16px rgba(0,0,0,0.6);
  }

  /* Disconnect button inside drawer */
  .drawer-disconnect-btn {
    display:flex; align-items:center; justify-content:center; gap:.6rem;
    font:900 18px/1 "Luckiest Guy","Arial Black",Impact,system-ui,sans-serif;
    padding:14px 20px; border-radius:20px; color:#fff; background:var(--accent);
    border: 3px solid transparent;
    box-shadow:0 6px 0 #7b2a20, 0 8px 16px rgba(0,0,0,.35);
    transition:all .2s ease;
    cursor:pointer;
    width:100%;
    margin-top:8px;
    margin-bottom:0;
    text-transform:uppercase;
    background-image: linear-gradient(var(--accent), var(--accent)), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
  }

  #drawerDisconnectContainer {
    margin-top: auto;
    padding-top: 8px;
  }
  .drawer-disconnect-btn:hover{
    filter:brightness(1.15);
    transform:translateY(-2px);
    box-shadow:0 8px 0 #7b2a20, 0 10px 20px rgba(0,0,0,.45);
  }
  .drawer-disconnect-btn:active{transform:translateY(0); box-shadow:0 2px 0 #7b2a20, 0 4px 10px rgba(0,0,0,.35);}

  .drawer{
    position:fixed; top:0; right:0; bottom:0;
    width:min(420px, calc(100% - 72px));
    background:linear-gradient(180deg,#141619 0%, #0e1013 100%);
    border-left:6px solid;
    border-image: linear-gradient(to bottom, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%) 1;
    z-index:70;
    transform:translateX(102%); transition:transform .38s var(--ease-spring);
    box-shadow:-24px 0 40px rgba(0,0,0,.55);
    display:flex; flex-direction:column;
  }
  .drawer.open{ transform:translateX(0) }
  .drawer-scrim{ position:fixed; inset:0; background:rgba(0,0,0,.55); backdrop-filter:blur(2px); z-index:65 }
  .drawer-head{ flex-shrink:0; display:flex; align-items:center; justify-content:space-between; gap:12px; padding:14px 18px; padding-top:calc(88px + env(safe-area-inset-top)); border-bottom:4px solid; border-image: linear-gradient(to right, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%) 1; background:linear-gradient(180deg, rgba(237,183,35,0.12) 0%, #1a1d22 100%); z-index:71 }
  .drawer-body{ flex:1; padding:20px; padding-bottom:calc(220px + env(safe-area-inset-bottom)); overflow:auto; display:flex; flex-direction:column; gap:20px }

  .drawer-close-btn{
    position:relative;
    width:48px;
    height:48px;
    border-radius:50%;
    background:linear-gradient(135deg, var(--gold) 0%, #d4a617 100%);
    color:#000;
    border:3px solid rgba(255,255,255,.5);
    cursor:pointer;
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow:0 4px 16px rgba(237,183,35,.5), 0 0 0 2px rgba(0,0,0,.3), inset 0 1px 0 rgba(255,255,255,.3);
    transition:all .25s cubic-bezier(0.4, 0, 0.2, 1);
    font-weight:900;
    font-size:26px;
    flex-shrink:0;
  }
  .drawer-close-btn:hover{
    background:linear-gradient(135deg, #ffd700 0%, var(--gold) 100%);
    border-color:rgba(255,255,255,.7);
    transform:scale(1.1) rotate(90deg);
    box-shadow:0 6px 20px rgba(237,183,35,.7), 0 0 0 3px rgba(237,183,35,.2), inset 0 1px 0 rgba(255,255,255,.4);
  }
  .drawer-close-btn:active{
    transform:scale(0.9) rotate(90deg);
    box-shadow:0 2px 10px rgba(237,183,35,.6), 0 0 0 2px rgba(237,183,35,.15);
  }

  /* BEAR Space Popup Teaser */
  .bear-space-popup {
    position: fixed;
    inset: 0;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,.75);
    backdrop-filter: blur(8px);
    opacity: 0;
    pointer-events: none;
    transition: opacity .3s var(--ease-spring);
  }
  .bear-space-popup.show {
    opacity: 1;
    pointer-events: auto;
  }
  .bear-space-popup-content {
    position: relative;
    padding: 40px 48px;
    border-radius: 28px;
    background: radial-gradient(600px 300px at 50% 0%, rgba(93, 63, 211, 0.25), transparent 70%),
                radial-gradient(400px 200px at 50% 100%, rgba(237,183,35,0.15), transparent 60%),
                #0b0d0e;
    box-shadow: 0 24px 48px rgba(0,0,0,.65), 0 0 0 1px rgba(255,255,255,.05) inset;
    text-align: center;
    max-width: 420px;
    isolation: isolate;
    transform: scale(0.8) translateY(30px);
    transition: transform .4s var(--ease-spring);
  }
  .bear-space-popup.show .bear-space-popup-content {
    transform: scale(1) translateY(0);
  }
  .bear-space-popup-content::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 28px;
    padding: 4px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: 0;
    opacity: 1;
  }
  .bear-space-icon {
    font-size: 72px;
    line-height: 1;
    margin-bottom: 16px;
    filter: drop-shadow(0 4px 8px rgba(0,0,0,.4));
    animation: floatBear 3s ease-in-out infinite;
  }
  @keyframes floatBear {
    0%, 100% { transform: translateY(0) rotate(0deg); }
    25% { transform: translateY(-8px) rotate(-3deg); }
    50% { transform: translateY(-12px) rotate(0deg); }
    75% { transform: translateY(-8px) rotate(3deg); }
  }

  .bear-space-title {
    font-size: 48px;
    font-weight: 900;
    color: var(--gold);
    text-shadow: 0 4px 0 rgba(0,0,0,.4), 0 0 24px rgba(237,183,35,.5);
    margin-bottom: 8px;
    letter-spacing: 2px;
  }
  .bear-space-subtitle {
    font-size: 24px;
    font-weight: 800;
    color: var(--stripe-purple);
    text-shadow: 0 2px 4px rgba(0,0,0,.6);
    margin-bottom: 20px;
    text-transform: uppercase;
  }
  .bear-space-description {
    font-size: 18px;
    font-weight: 600;
    color: rgba(255,255,255,.85);
    line-height: 1.4;
    text-shadow: 0 2px 4px rgba(0,0,0,.4);
  }

  /* Success Popup - Bubbly and Meme-y */
  .bear-success-popup {
    position: fixed;
    inset: 0;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,.8);
    backdrop-filter: blur(10px);
    opacity: 0;
    pointer-events: none;
    transition: opacity .4s ease;
  }
  .bear-success-popup.show {
    opacity: 1;
    pointer-events: auto;
  }
  .bear-success-popup-content {
    position: relative;
    padding: 48px 56px;
    border-radius: 32px;
    background: radial-gradient(600px 300px at 50% 0%, rgba(237,183,35,0.3), transparent 70%),
                linear-gradient(135deg, #edb723, #f4a623);
    box-shadow: 0 32px 64px rgba(237,183,35,.4), 0 0 0 4px rgba(255,255,255,.2) inset;
    text-align: center;
    max-width: 480px;
    transform: scale(0.5) translateY(50px) rotate(-5deg);
    transition: transform .6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    animation: bounce 0.8s ease infinite alternate;
  }
  .bear-success-popup.show .bear-success-popup-content {
    transform: scale(1) translateY(0) rotate(0deg);
  }
  @keyframes bounce {
    0% { transform: scale(1) translateY(0) rotate(0deg); }
    100% { transform: scale(1.05) translateY(-10px) rotate(1deg); }
  }
  .bear-success-icon {
    font-size: 96px;
    line-height: 1;
    margin-bottom: 20px;
    filter: drop-shadow(0 8px 16px rgba(0,0,0,.5));
    animation: spin-celebrate 1.5s ease-in-out infinite;
  }
  @keyframes spin-celebrate {
    0%, 100% { transform: rotate(0deg) scale(1); }
    25% { transform: rotate(-15deg) scale(1.1); }
    50% { transform: rotate(0deg) scale(1.2); }
    75% { transform: rotate(15deg) scale(1.1); }
  }
  .bear-success-title {
    font-size: 56px;
    font-weight: 900;
    color: #000;
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 16px;
    text-shadow: 3px 3px 0 rgba(255,255,255,.5), -2px -2px 0 rgba(0,0,0,.2);
    line-height: 1.1;
  }
  .bear-success-message {
    font-size: 22px;
    font-weight: 700;
    color: #000;
    margin-bottom: 16px;
    line-height: 1.4;
  }
  .bear-success-sub {
    font-size: 28px;
    font-weight: 900;
    color: #fff;
    text-shadow: 2px 2px 4px rgba(0,0,0,.4);
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .btn.sm{ font-size:26px; padding:1.2rem 1.8rem; border-radius:28px; box-shadow:0 10px 0 #000,0 16px 24px rgba(0,0,0,.35) }

  .price-card{
    position: relative;
    display:grid; gap:12px; padding:28px;
    border-radius:28px;
    background:radial-gradient(500px 200px at 50% -20%, rgba(237,183,35,.1), transparent 60%), #0b0d0e;
    box-shadow:0 12px 22px rgba(0,0,0,.35)
  }
  .price-card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 16px;
    padding: 6px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: -1;
  }
  .price-card .metric{ font-size:52px; font-weight:900; display:flex; align-items:baseline; gap:10px }
  .price-card .metric small{ opacity:.8; font-size:24px }
  .price-card .sub{ opacity:.9; font-size:20px }

  /* Portfolio Card */
  .portfolio-card{
    position: relative;
    padding:32px;
    border-radius:28px;
    background:radial-gradient(500px 200px at 50% -20%, rgba(118,174,255,.12), transparent 60%), #0b0d0e;
    box-shadow:0 12px 22px rgba(0,0,0,.35);
    transition:transform 0.2s ease, box-shadow 0.2s ease;
    isolation: isolate;
  }
  .portfolio-card:hover{
    transform:translateY(-2px);
    box-shadow:0 16px 32px rgba(0,0,0,.45);
  }
  .portfolio-card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 28px;
    padding: 4px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: 0;
    opacity: 1;
  }

  /* LP Card */
  .lp-card{
    position: relative;
    padding:32px;
    border-radius:28px;
    background:radial-gradient(500px 200px at 50% -20%, rgba(76,175,80,.12), transparent 60%), #0b0d0e;
    box-shadow:0 12px 22px rgba(0,0,0,.35);
    transition:transform 0.2s ease, box-shadow 0.2s ease;
    isolation: isolate;
    margin-bottom: 20px;
  }
  .lp-card:hover{
    transform:translateY(-2px);
    box-shadow:0 16px 32px rgba(0,0,0,.45);
  }
  .lp-card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 28px;
    padding: 4px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: 0;
    opacity: 1;
  }

  /* P&L Card */
  .pl-card{
    position: relative;
    padding:32px;
    border-radius:28px;
    background:radial-gradient(500px 200px at 50% -20%, rgba(93, 63, 211,.12), transparent 60%), #0b0d0e;
    box-shadow:0 12px 22px rgba(0,0,0,.35);
    transition:transform 0.2s ease, box-shadow 0.2s ease;
    isolation: isolate;
    margin-bottom: 20px;
  }
  .pl-card:hover{
    transform:translateY(-2px);
    box-shadow:0 16px 32px rgba(0,0,0,.45);
  }
  .pl-card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 28px;
    padding: 4px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: 0;
    opacity: 1;
  }

  /* P&L Toggle Buttons */
  .pl-toggle-group {
    display: flex;
    gap: 8px;
    background: rgba(0,0,0,0.4);
    padding: 4px;
    border-radius: 12px;
    border: 2px solid rgba(255,255,255,0.1);
  }
  .pl-toggle-btn {
    padding: 8px 20px;
    background: transparent;
    color: rgba(255,255,255,0.6);
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 900;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .pl-toggle-btn:hover {
    background: rgba(255,255,255,0.05);
    color: rgba(255,255,255,0.8);
  }
  .pl-toggle-btn.active {
    background: linear-gradient(135deg, var(--gold) 0%, #d4a017 100%);
    color: #000;
    box-shadow: 0 4px 12px rgba(237,183,35,0.4);
  }
  .pl-timeframe-btn {
    padding: 6px 12px;
    background: rgba(0,0,0,0.4);
    color: rgba(255,255,255,0.6);
    border: 2px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    font-size: 12px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    white-space: nowrap;
  }
  .pl-timeframe-btn:hover {
    background: rgba(255,255,255,0.08);
    color: rgba(255,255,255,0.9);
    border-color: rgba(255,255,255,0.2);
    transform: translateY(-2px);
  }
  .pl-timeframe-btn.active {
    background: rgba(237,183,35,0.2);
    color: var(--gold);
    border-color: var(--gold);
    box-shadow: 0 0 12px rgba(237,183,35,0.3);
  }

  /* P&L Stat Boxes */
  .pl-stat-box {
    background: rgba(0,0,0,0.3);
    padding: 14px 16px;
    border-radius: 12px;
    border: 2px solid rgba(255,255,255,0.08);
    text-align: center;
  }
  .pl-stat-label {
    font-size: 12px;
    color: rgba(255,255,255,0.6);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-weight: 700;
    margin-bottom: 6px;
  }
  .pl-stat-value {
    font-size: 20px;
    font-weight: 900;
    color: var(--gold);
  }
  .pl-stat-value.positive {
    color: #4CAF50;
  }
  .pl-stat-value.negative {
    color: #f44336;
  }

  /* Profile Card */
  .profile-card{
    position: relative;
    padding:32px;
    border-radius:28px;
    background:radial-gradient(500px 200px at 50% -20%, rgba(237,183,35,.08), transparent 60%), #0b0d0e;
    box-shadow:0 12px 22px rgba(0,0,0,.35);
    transition:transform 0.2s ease, box-shadow 0.2s ease;
    isolation: isolate;
  }
  .profile-card:hover{
    transform:translateY(-2px);
    box-shadow:0 16px 32px rgba(0,0,0,.45);
  }

  /* Pulsing highlight animation for profile section */
  @keyframes profile-pulse {
    0%, 100% {
      box-shadow: 0 0 0 0 rgba(237,183,35,0.9), 0 12px 22px rgba(0,0,0,.35);
      transform: scale(1);
    }
    50% {
      box-shadow: 0 0 0 15px rgba(237,183,35,0), 0 16px 32px rgba(237,183,35,.4);
      transform: scale(1.02);
    }
  }
  .profile-highlight-pulse {
    animation: profile-pulse 1.5s ease-in-out infinite !important;
    border: 3px solid var(--gold) !important;
  }

  /* Better input field interactions */
  #profileUsername:focus {
    outline: none !important;
    border-color: var(--gold) !important;
    box-shadow: 0 0 0 4px rgba(237,183,35,0.3) !important;
    transform: scale(1.02);
  }
  #profileAvatarSelector {
    transition: all 0.3s ease;
  }
  #profileAvatarSelector:hover {
    border-color: var(--gold);
    transform: translateY(-2px);
  }
  .profile-card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 28px;
    padding: 4px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: 0;
    opacity: 1;
  }

  .portfolio-stats{ display:grid; gap:12px }
  .stat-row{
    display:flex; justify-content:space-between; align-items:center; gap:12px;
    padding:14px 16px; background:rgba(255,255,255,.03); border-radius:12px;
    border:2px solid rgba(255,255,255,.08);
    flex-wrap:wrap;
  }
  .stat-label{ font-size:22px; opacity:.85; flex-shrink:0; }
  .stat-value{ font-size:32px; font-weight:900; color:var(--gold); text-align:right; word-break:break-word; min-width:0; }

  /* Points Card */
  .points-card{
    padding:28px;
  border:4px solid transparent; border-radius:28px;
    background:radial-gradient(500px 200px at 50% -20%, rgba(237,183,35,.08), transparent 60%), #0b0d0e;
    box-shadow:0 12px 22px rgba(0,0,0,.35);
    background-image: radial-gradient(500px 200px at 50% -20%, rgba(237,183,35,.08), transparent 60%), linear-gradient(#0b0d0e, #0b0d0e), var(--tri-gradient);
    background-origin: padding-box, padding-box, border-box;
    background-clip: padding-box, padding-box, border-box;
  }
  .points-card .activity-item{
    padding:16px 18px; background:rgba(255,255,255,.03); border-radius:14px;
    border-left:4px solid var(--gold); margin-bottom:10px; font-size:20px;
    display:flex; justify-content:space-between; align-items:center
  }
  .points-card .activity-item .points{ color:var(--gold); font-weight:900; font-size:24px }

  .links-grid{ display:grid; grid-template-columns:1fr 1fr; gap:14px }
  .links-grid .tile .lbl{ color:var(--gold) }
  @media (max-width:520px){ .links-grid{ grid-template-columns:1fr } }

  /* === User-requested removals === */
  .site-nav{display:none !important}
  .rails::before,.rails::after{display:none !important}

  /* ===== NEW FIXED NAVIGATION BAR ===== */
  .top-nav {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 9999;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
  }

  /* Three-color stripe background */
  .top-nav-stripes {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    z-index: -1;
  }
  .top-nav-stripes .stripe-1 {
    flex: 1;
    background: #680cd9;
  }
  .top-nav-stripes .stripe-2 {
    flex: 1;
    background: #feb501;
  }
  .top-nav-stripes .stripe-3 {
    flex: 1;
    background: #07ae08;
  }

  /* Main nav bar */
  .top-nav-bar {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 24px;
    max-width: 1400px;
    margin: 0 auto;
  }

  /* Menu button with logo */
  .menu-btn {
    display: flex;
    align-items: center;
    position: relative;
    background: none;
    cursor: pointer;
    padding: 0;
    border-radius: 12px;
    transition: all 0.2s;
    border: 4px solid transparent;
    background-image: linear-gradient(#141619, #141619), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.8));
  }

  .menu-btn:hover {
    transform: scale(1.05);
    filter: drop-shadow(3px 3px 6px rgba(0,0,0,0.9));
  }

  .menu-btn img {
    width: 52px;
    height: 52px;
    display: block;
    border-radius: 8px;
  }

  /* Hamburger icon overlay */
  .menu-btn::after {
    content: '';
    position: absolute;
    bottom: -4px;
    right: -4px;
    width: 24px;
    height: 24px;
    background: #edb723;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 6px rgba(0,0,0,0.5);
    background-image:
      linear-gradient(#000 0%, #000 100%),
      linear-gradient(#000 0%, #000 100%),
      linear-gradient(#000 0%, #000 100%);
    background-size: 14px 2px;
    background-position: center calc(50% - 5px), center 50%, center calc(50% + 5px);
    background-repeat: no-repeat;
  }

  /* Nav buttons container */
  .nav-buttons-container {
    position: relative;
    display: flex;
    align-items: center;
    gap: 12px;
  }

  /* Honey points button - compact circular design */
  .honey-points-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
    padding: 8px 12px;
    background: #1a1a1a;
    color: var(--gold);
    border: 3px solid transparent;
    border-radius: 22px;
    font-size: 14px;
    font-weight: 900;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 4px 0 #000, 0 4px 12px rgba(0,0,0,0.8);
    filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.8));
    background-image: linear-gradient(#1a1a1a, #1a1a1a), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    white-space: nowrap;
  }

  .honey-points-btn img {
    height: 1.2em;
    width: auto;
    vertical-align: middle;
  }

  .honey-points-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 0 #000, 0 6px 18px rgba(0,0,0,0.9);
    filter: drop-shadow(3px 3px 6px rgba(0,0,0,0.9));
    background: #252525;
  }

  .honey-points-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 #000, 0 2px 8px rgba(0,0,0,0.6);
  }

  /* Welcome profile button - purple with tri-color border */
  .welcome-profile-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 16px;
    background: #5D3FD3;
    color: #fff;
    border: 3px solid transparent;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 900;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 4px 0 #000, 0 4px 12px rgba(0,0,0,0.8);
    filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.8));
    background-image: linear-gradient(#5D3FD3, #5D3FD3), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
  }

  .welcome-profile-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 0 #000, 0 6px 18px rgba(0,0,0,0.9);
    filter: drop-shadow(3px 3px 6px rgba(0,0,0,0.9));
    background: #6D4FE3;
  }

  .welcome-profile-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 #000, 0 2px 8px rgba(0,0,0,0.6);
  }

  .welcome-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
    margin-left: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.4);
  }

  /* ===== NOTIFICATION BELL ===== */
  .notification-bell-btn {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 44px;
    height: 44px;
    background: #1a1a1a;
    border: 3px solid transparent;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.18, 0.9, 0.2, 1);
    box-shadow: 0 4px 0 #000, 0 4px 12px rgba(0,0,0,0.8);
    filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.8));
    background-image: linear-gradient(#1a1a1a, #1a1a1a), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
  }

  .notification-bell-btn:hover {
    transform: translateY(-2px) scale(1.05);
    box-shadow: 0 6px 0 #000, 0 6px 18px rgba(0,0,0,0.9);
    filter: drop-shadow(3px 3px 6px rgba(0,0,0,0.9));
    background: #252525;
  }

  .notification-bell-btn:active {
    transform: translateY(0) scale(0.95);
    box-shadow: 0 2px 0 #000, 0 2px 8px rgba(0,0,0,0.6);
  }

  .notification-bell-btn.has-notifications {
    animation: bellBounce 0.8s cubic-bezier(0.18, 0.9, 0.2, 1) infinite;
  }

  @keyframes bellBounce {
    0%, 100% {
      transform: translateY(0) rotate(0deg);
    }
    10%, 30% {
      transform: translateY(-4px) rotate(-10deg);
    }
    20%, 40% {
      transform: translateY(-4px) rotate(10deg);
    }
    50% {
      transform: translateY(0) rotate(0deg);
    }
  }

  .notification-badge {
    position: absolute;
    top: -4px;
    right: -4px;
    min-width: 20px;
    height: 20px;
    padding: 0 6px;
    background: linear-gradient(135deg, #ff6b9d 0%, #ff4757 100%);
    color: #fff;
    border-radius: 10px;
    font-size: 11px;
    font-weight: 900;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 2px solid #000;
    box-shadow: 0 2px 6px rgba(255, 71, 87, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.2) inset;
    animation: badgePulse 2s ease-in-out infinite;
  }

  @keyframes badgePulse {
    0%, 100% {
      transform: scale(1);
      box-shadow: 0 2px 6px rgba(255, 71, 87, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.2) inset;
    }
    50% {
      transform: scale(1.1);
      box-shadow: 0 3px 10px rgba(255, 71, 87, 0.8), 0 0 0 1px rgba(255, 255, 255, 0.3) inset;
    }
  }

  /* Notification Panel - Dropdown from bell */
  .notification-panel {
    position: absolute;
    top: 60px;
    right: 0;
    width: 380px;
    max-height: 500px;
    background: linear-gradient(135deg, #1e2226 0%, #141619 100%);
    border: 3px solid transparent;
    border-radius: 16px;
    box-shadow: 0 12px 32px rgba(0,0,0,0.7), 0 0 0 1px rgba(255,255,255,0.05) inset;
    display: none;
    flex-direction: column;
    overflow: hidden;
    z-index: 10000;
    background-image: linear-gradient(135deg, #1e2226 0%, #141619 100%), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    opacity: 0;
    transform: translateY(-10px);
    transition: opacity 0.3s cubic-bezier(0.18, 0.9, 0.2, 1),
                transform 0.3s cubic-bezier(0.18, 0.9, 0.2, 1);
  }

  @keyframes notificationSlideIn {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .notification-panel.visible {
    display: flex;
    animation: notificationSlideIn 0.3s cubic-bezier(0.18, 0.9, 0.2, 1);
    opacity: 1;
    transform: translateY(0);
  }

  .notification-panel-header {
    padding: 16px 20px;
    background: rgba(0,0,0,0.3);
    border-bottom: 2px solid rgba(237, 183, 35, 0.2);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .notification-panel-header h3 {
    margin: 0;
    font-family: 'Luckiest Guy', Arial, sans-serif;
    font-size: 18px;
    color: var(--gold);
    text-shadow: 2px 2px 0 #000;
  }

  .notification-close-btn {
    background: none;
    border: none;
    color: rgba(255,255,255,0.6);
    font-size: 24px;
    cursor: pointer;
    padding: 0;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s;
  }

  .notification-close-btn:hover {
    background: rgba(255,255,255,0.1);
    color: #fff;
  }

  .notification-list {
    flex: 1;
    overflow-y: auto;
    padding: 0;
    margin: 0;
  }

  .notification-item {
    padding: 16px 20px;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    display: flex;
    align-items: flex-start;
    gap: 12px;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    pointer-events: auto; /* Ensure item can receive clicks even with children having pointer-events: none */
  }

  .notification-item:hover {
    background: rgba(237, 183, 35, 0.1);
  }

  .notification-item.unread {
    background: rgba(93, 63, 211, 0.1);
  }

  .notification-item.unread::before {
    content: '';
    position: absolute;
    left: 8px;
    top: 50%;
    transform: translateY(-50%);
    width: 6px;
    height: 6px;
    background: linear-gradient(135deg, #ff6b9d 0%, #ff4757 100%);
    border-radius: 50%;
    box-shadow: 0 0 8px rgba(255, 71, 87, 0.8);
  }

  .notification-icon {
    flex-shrink: 0;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    background: rgba(0,0,0,0.3);
    border-radius: 50%;
    border: 2px solid rgba(237, 183, 35, 0.3);
  }

  .notification-content {
    flex: 1;
    pointer-events: none;
  }

  .notification-text {
    margin: 0 0 4px 0;
    font-size: 14px;
    color: #fff;
    line-height: 1.4;
  }

  .notification-text strong {
    color: var(--gold);
    font-weight: 900;
  }

  .notification-time {
    font-size: 11px;
    color: rgba(255,255,255,0.5);
    margin: 0;
  }

  .notification-reactions {
    display: flex;
    align-items: center;
    gap: 6px;
    flex-wrap: wrap;
    margin-top: 6px;
  }

  .notification-reaction-emoji {
    font-size: 18px;
    padding: 4px 8px;
    background: rgba(0,0,0,0.4);
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.1);
  }

  .notification-preview {
    font-size: 12px;
    color: rgba(255, 255, 255, 0.7);
    font-style: italic;
    margin: 6px 0 0 0;
    line-height: 1.3;
  }

  /* Make sure child elements don't block notification clicks */
  .notification-item img,
  .notification-item .notification-content * {
    pointer-events: none;
  }

  .notification-empty {
    padding: 60px 20px;
    text-align: center;
    color: rgba(255,255,255,0.5);
  }

  .notification-empty-icon {
    font-size: 48px;
    margin-bottom: 12px;
    opacity: 0.3;
  }

  @media (max-width: 640px) {
    .notification-panel {
      left: auto;
      right: 0;
      width: auto;
      max-width: calc(100vw - 20px);
      top: 55px;
      max-height: 70vh;
    }

    .notification-bell-btn {
      width: 40px;
      height: 40px;
      font-size: 18px;
    }

    .notification-badge {
      min-width: 18px;
      height: 18px;
      font-size: 10px;
    }
  }

  /* Hamburger menu overlay */
  .menu-overlay {
    position: fixed;
    top: 0;
    left: -100%;
    width: 100%;
    max-width: 400px;
    height: 100vh;
    background: linear-gradient(180deg, #141619 0%, #0e1013 100%);
    box-shadow: 4px 0 24px rgba(0,0,0,0.5);
    z-index: 10000;
    transition: left 0.3s var(--ease-spring);
    overflow-y: auto;
    border-right: 6px solid;
    border-image: linear-gradient(to bottom, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%) 1;
  }

  .menu-overlay.open {
    left: 0;
  }

  .menu-overlay-header {
    padding: 20px;
    background: #0f1114;
    border-bottom: 4px solid;
    border-image: linear-gradient(to right, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%) 1;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .menu-overlay-header h2 {
    margin: 0;
    color: var(--gold);
    font-size: 24px;
  }

  .menu-close-btn {
    background: none;
    border: none;
    color: var(--gold);
    font-size: 32px;
    cursor: pointer;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    transition: all 0.2s;
  }

  .menu-close-btn:hover {
    background: rgba(237,183,35,0.1);
  }

  .menu-items {
    padding: 16px;
    display: grid;
    gap: 10px;
  }

  .menu-item {
    position: relative;
    display: block;
    padding: 18px 20px;
    background: radial-gradient(500px 200px at 50% -20%, rgba(237,183,35,0.08), transparent 60%), #0b0d0e;
    border-radius: 16px;
    color: var(--gold);
    font-size: 16px;
    font-weight: 900;
    text-transform: uppercase;
    transition: all 0.2s;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0,0,0,0.35);
    text-decoration: none;
    opacity: 0;
    transform: translateX(-20px);
    animation: slideInStagger 0.4s var(--ease-spring) forwards;
  }
  .menu-item:nth-child(1) { animation-delay: 0.05s; }
  .menu-item:nth-child(2) { animation-delay: 0.1s; }
  .menu-item:nth-child(3) { animation-delay: 0.15s; }
  .menu-item:nth-child(4) { animation-delay: 0.2s; }
  .menu-item:nth-child(5) { animation-delay: 0.25s; }
  .menu-item:nth-child(6) { animation-delay: 0.3s; }
  .menu-item:nth-child(7) { animation-delay: 0.35s; }
  .menu-item:nth-child(8) { animation-delay: 0.4s; }

  @keyframes slideInStagger {
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }
  .menu-item::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 16px;
    padding: 6px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: -1;
  }

  .menu-item:hover {
    background: radial-gradient(500px 200px at 50% -20%, rgba(237,183,35,0.15), transparent 60%), #0b0d0e;
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0,0,0,0.45);
  }

  .menu-item-icon {
    margin-right: 12px;
    font-size: 20px;
  }

  /* Scrim for menu */
  .menu-scrim {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    background: rgba(0,0,0,0.7);
    z-index: 9998;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
  }

  .menu-scrim.open {
    opacity: 1;
    pointer-events: all;
  }

  /* Adjust body padding for fixed nav */
  body {
    padding-top: 72px;
  }

  /* ===== PROFILE MODAL STYLES ===== */
  .profile-modal {
    position: fixed;
    inset: 0;
    z-index: 10000;
    display: none;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .profile-modal.visible {
    opacity: 1;
  }

  .profile-modal-overlay {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.85);
    backdrop-filter: blur(8px);
  }

  .profile-modal-content {
    position: relative;
    background: linear-gradient(180deg, #141619 0%, #101215 100%);
    border: 4px solid transparent;
    border-radius: 24px;
    width: 90%;
    max-width: 700px;
    max-height: 90vh;
    overflow: hidden;
    box-shadow: 0 24px 60px rgba(0,0,0,0.6);
    background-image: linear-gradient(180deg, #141619 0%, #101215 100%), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    animation: modalSlideIn 0.4s var(--ease-spring);
  }

  @keyframes modalSlideIn {
    from { transform: translateY(40px) scale(0.95); opacity: 0; }
    to { transform: translateY(0) scale(1); opacity: 1; }
  }

  .profile-modal-header {
    padding: 24px;
    border-bottom: 2px solid rgba(237,183,35,0.2);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: radial-gradient(500px 200px at 50% -20%, rgba(237,183,35,0.08), transparent 60%);
  }

  .profile-close-btn {
    background: none;
    border: none;
    color: var(--gold);
    font-size: 36px;
    cursor: pointer;
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    transition: all 0.2s;
    line-height: 1;
  }

  .profile-close-btn:hover {
    background: rgba(237,183,35,0.15);
    transform: rotate(90deg);
  }

  /* BEAR Search Button */
  .bear-search-btn {
    background: linear-gradient(135deg, rgba(237,183,35,0.2), rgba(237,183,35,0.1));
    border: 2px solid rgba(237,183,35,0.5);
    color: var(--gold);
    width: 44px;
    height: 44px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    position: relative;
  }

  .bear-search-btn:hover {
    background: linear-gradient(135deg, rgba(237,183,35,0.4), rgba(237,183,35,0.2));
    border-color: var(--gold);
    transform: scale(1.1) rotate(15deg);
    box-shadow: 0 0 20px rgba(237,183,35,0.6);
  }

  .bear-search-btn svg {
    filter: drop-shadow(0 0 4px rgba(237,183,35,0.5));
  }

  /* Profile Back Button */
  .profile-back-btn {
    background: linear-gradient(135deg, rgba(104, 12, 217, 0.2), rgba(104, 12, 217, 0.1));
    border: 2px solid rgba(104, 12, 217, 0.5);
    color: rgba(104, 12, 217, 1);
    width: 44px;
    height: 44px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    position: relative;
  }

  .profile-back-btn:hover {
    background: linear-gradient(135deg, rgba(104, 12, 217, 0.4), rgba(104, 12, 217, 0.2));
    border-color: rgba(104, 12, 217, 1);
    transform: scale(1.1) translateX(-3px);
    box-shadow: 0 0 20px rgba(104, 12, 217, 0.6);
  }

  .profile-back-btn svg {
    filter: drop-shadow(0 0 4px rgba(104, 12, 217, 0.5));
  }

  /* BEAR Search Panel */
  .bear-search-panel {
    padding: 24px;
    overflow-y: auto;
    max-height: calc(90vh - 100px);
  }

  .search-input-container {
    margin-bottom: 20px;
  }

  .bear-search-input {
    width: 100%;
    padding: 16px 20px;
    background: rgba(0,0,0,0.4);
    border: 3px solid rgba(237,183,35,0.3);
    border-radius: 16px;
    color: #fff;
    font-size: 16px;
    font-weight: 700;
    font-family: inherit;
    transition: all 0.3s ease;
  }

  .bear-search-input:focus {
    outline: none;
    border-color: var(--gold);
    background: rgba(0,0,0,0.6);
    box-shadow: 0 0 20px rgba(237,183,35,0.3);
  }

  .bear-search-input::placeholder {
    color: rgba(255,255,255,0.7);
  }

  /* BEAR Search Results */
  .bear-search-results {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .bear-user-card {
    background: linear-gradient(135deg, rgba(0,0,0,0.6), rgba(0,0,0,0.4));
    border: 3px solid rgba(237,183,35,0.3);
    border-radius: 20px;
    padding: 16px;
    display: flex;
    align-items: center;
    gap: 16px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
  }

  .bear-user-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, rgba(237,183,35,0.1), transparent);
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .bear-user-card:hover {
    border-color: var(--gold);
    transform: translateX(8px);
    box-shadow: 0 8px 24px rgba(237,183,35,0.3);
  }

  .bear-user-card:hover::before {
    opacity: 1;
  }

  .bear-user-avatar-container {
    position: relative;
    width: 60px;
    height: 60px;
    flex-shrink: 0;
  }

  .bear-user-avatar-border {
    display: none;
  }

  .bear-user-avatar {
    position: relative;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    border: 3px solid rgba(0,0,0,0.9);
    object-fit: cover;
  }

  .bear-user-avatar-placeholder {
    position: relative;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    border: 3px solid rgba(0,0,0,0.9);
    background: rgba(0,0,0,0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
  }

  .bear-user-info {
    flex: 1;
    min-width: 0;
  }

  .bear-user-name {
    color: var(--gold);
    font-size: 18px;
    font-weight: 900;
    margin: 0 0 4px 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .bear-user-friends {
    color: rgba(255,255,255,0.6);
    font-size: 13px;
    margin: 0;
    font-weight: 600;
  }

  .bear-search-empty {
    text-align: center;
    padding: 60px 20px;
    color: rgba(255,255,255,0.8);
    font-size: 16px;
    font-weight: 700;
  }

  .bear-search-empty-icon {
    font-size: 48px;
    margin-bottom: 12px;
    opacity: 0.6;
  }

  /* BEAR Community Section */
  .community-bordered-container {
    max-width: 900px;
    margin: 0 auto;
    padding: 32px 28px;
    background: linear-gradient(135deg, rgba(20, 22, 25, 0.95) 0%, rgba(15, 17, 20, 0.95) 100%);
    border: 4px solid transparent;
    background-image:
      linear-gradient(135deg, rgba(20, 22, 25, 0.95) 0%, rgba(15, 17, 20, 0.95) 100%),
      var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    border-radius: 24px;
    box-shadow:
      0 8px 32px rgba(0,0,0,0.5),
      inset 0 1px 0 rgba(255,255,255,0.05),
      0 0 80px rgba(93,63,211,0.15);
  }

  .community-search-container {
    max-width: 800px;
    margin: 0 auto 32px;
  }

  .community-search-wrapper {
    position: relative;
    margin-bottom: 16px;
  }

  .community-search-icon {
    position: absolute;
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--gold);
    opacity: 0.7;
    pointer-events: none;
  }

  .community-search-input {
    width: 100%;
    padding: 18px 20px 18px 56px;
    background: rgba(0,0,0,0.5);
    border: 2px solid transparent;
    background-image:
      linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)),
      var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    border-radius: 16px;
    color: #fff;
    font-size: 16px;
    font-weight: 600;
    font-family: 'Urbanist', sans-serif;
    transition: all 0.3s ease;
    box-shadow:
      0 2px 8px rgba(0,0,0,0.3),
      inset 0 1px 0 rgba(255,255,255,0.05);
  }

  .community-search-input::placeholder {
    color: rgba(255,255,255,0.45);
    font-weight: 500;
  }

  .community-search-input:focus {
    outline: none;
    background: rgba(0,0,0,0.65);
    background-image:
      linear-gradient(rgba(0,0,0,0.65), rgba(0,0,0,0.65)),
      var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    box-shadow:
      0 4px 20px rgba(237,183,35,0.3),
      0 0 40px rgba(93,63,211,0.2),
      inset 0 1px 0 rgba(255,255,255,0.1);
  }

  .community-count {
    text-align: center;
    background: linear-gradient(135deg, #edb723, #f4c542, #edb723);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    font-size: 18px;
    font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    filter: drop-shadow(0 2px 6px rgba(237,183,35,0.4));
  }

  .community-user-grid {
    max-height: 600px;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 4px;
    margin-top: 24px;
  }

  /* Custom scrollbar for community grid */
  .community-user-grid::-webkit-scrollbar {
    width: 12px;
  }

  .community-user-grid::-webkit-scrollbar-track {
    background: rgba(0,0,0,0.2);
    border-radius: 10px;
  }

  .community-user-grid::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #5d3fd3, #edb723, #22c55e);
    border-radius: 10px;
  }

  .community-user-grid::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #7c5fef, #f4c542, #34d369);
  }

  .community-loading {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 60px 20px;
    gap: 20px;
  }

  .loading-spinner {
    width: 50px;
    height: 50px;
    border: 4px solid rgba(237,183,35,0.2);
    border-top-color: var(--gold);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .community-loading p {
    color: rgba(255,255,255,0.7);
    font-size: 16px;
    margin: 0;
  }

  .community-user-card {
    background: linear-gradient(135deg, #1a1d24 0%, #141619 100%);
    border: 3px solid transparent;
    background-image: linear-gradient(135deg, #1a1d24 0%, #141619 100%), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    border-radius: 16px;
    padding: 20px 24px;
    margin-bottom: 12px;
    cursor: pointer;
    transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex;
    align-items: center;
    gap: 20px;
    box-shadow:
      0 2px 8px rgba(0,0,0,0.4),
      inset 0 1px 0 rgba(255,255,255,0.05);
    position: relative;
    overflow: hidden;
  }

  .community-user-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg,
      transparent,
      rgba(237,183,35,0.1),
      transparent
    );
    transition: left 0.6s ease;
  }

  .community-user-card:hover::before {
    left: 100%;
  }

  .community-user-card:hover {
    transform: translateX(6px) scale(1.01);
    box-shadow:
      0 8px 32px rgba(237,183,35,0.4),
      0 0 60px rgba(93,63,211,0.2),
      inset 0 1px 0 rgba(255,255,255,0.1);
  }

  .community-user-avatar-wrapper {
    width: 64px;
    height: 64px;
    flex-shrink: 0;
    position: relative;
    transition: transform 0.3s ease;
  }

  .community-user-card:hover .community-user-avatar-wrapper {
    transform: scale(1.05) rotate(-2deg);
  }

  .community-user-avatar,
  .community-user-avatar-placeholder {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
    box-shadow:
      0 4px 12px rgba(0,0,0,0.4),
      0 0 20px rgba(237,183,35,0.2);
  }

  .community-user-avatar-placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
    background: linear-gradient(135deg, rgba(93, 63, 211, 0.3), rgba(237, 183, 35, 0.3));
  }

  .community-user-info {
    flex: 1;
    min-width: 0;
    display: flex;
    align-items: center;
    gap: 20px;
  }

  .community-user-name-section {
    flex: 1;
    min-width: 0;
  }

  .community-user-name {
    background: linear-gradient(135deg, #edb723, #f4c542, #edb723);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    font-size: 22px;
    font-weight: 900;
    margin: 0 0 4px 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    text-shadow: 0 2px 12px rgba(237,183,35,0.5);
    filter: drop-shadow(0 2px 8px rgba(237,183,35,0.4));
    letter-spacing: 0.3px;
  }

  .community-user-wallet {
    color: rgba(255,255,255,0.35);
    font-size: 11px;
    font-family: 'Courier New', monospace;
    margin: 0;
    font-weight: 600;
    letter-spacing: 0.5px;
  }

  .community-user-stats {
    display: flex;
    gap: 28px;
    align-items: center;
    flex-shrink: 0;
  }

  .community-user-stat {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    padding: 8px 16px;
    background: rgba(0,0,0,0.3);
    border-radius: 12px;
    border: 1px solid rgba(237,183,35,0.15);
    transition: all 0.3s ease;
  }

  .community-user-stat:hover {
    background: rgba(237,183,35,0.08);
    border-color: rgba(237,183,35,0.3);
    transform: translateY(-2px);
  }

  .community-user-stat-value {
    background: linear-gradient(135deg, #edb723, #f4c542);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    font-size: 24px;
    font-weight: 900;
    margin: 0;
    line-height: 1;
    filter: drop-shadow(0 2px 4px rgba(237,183,35,0.3));
  }

  .community-user-stat-label {
    color: rgba(255,255,255,0.6);
    font-size: 10px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin: 0;
  }

  .community-follow-btn {
    padding: 8px 20px;
    background: linear-gradient(135deg, var(--gold), #c9941a);
    color: #000;
    border: none;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(237,183,35,0.3);
    white-space: nowrap;
  }

  .community-follow-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(237,183,35,0.5);
    background: linear-gradient(135deg, #f4c542, var(--gold));
  }

  .community-follow-btn.following {
    background: linear-gradient(135deg, #28a745, #1e7e34);
    color: #fff;
    box-shadow: 0 2px 8px rgba(40,167,69,0.3);
  }

  .community-follow-btn.following:hover {
    background: linear-gradient(135deg, #34ce57, #28a745);
    box-shadow: 0 4px 12px rgba(40,167,69,0.5);
  }

  .community-follow-btn.following::before {
    content: '✓ ';
  }

  .community-empty {
    grid-column: 1 / -1;
    text-align: center;
    padding: 60px 20px;
  }

  .community-empty-icon {
    font-size: 64px;
    margin-bottom: 16px;
    opacity: 0.5;
  }

  .community-empty p {
    color: rgba(255,255,255,0.6);
    font-size: 18px;
    margin: 0;
  }

  /* Mobile Responsive for Community Section */
  @media (max-width: 768px) {
    .community-bordered-container {
      padding: 24px 20px;
      border-width: 3px;
      border-radius: 20px;
    }

    .community-user-grid {
      max-height: 500px;
    }

    .community-search-input {
      font-size: 14px;
      padding: 16px 18px 16px 52px;
    }

    .community-user-card {
      flex-direction: column;
      align-items: flex-start;
      padding: 16px 18px;
      gap: 14px;
    }

    .community-user-avatar-wrapper {
      width: 56px;
      height: 56px;
    }

    .community-user-info {
      width: 100%;
      flex-direction: column;
      align-items: flex-start;
      gap: 12px;
    }

    .community-user-stats {
      width: 100%;
      justify-content: space-around;
      padding-top: 12px;
      border-top: 1px solid rgba(237,183,35,0.2);
      gap: 12px;
    }

    .community-user-stat {
      flex: 1;
      padding: 10px 12px;
    }

    .community-user-name {
      font-size: 19px;
    }

    .community-user-stat-value {
      font-size: 20px;
    }

    .community-user-stat-label {
      font-size: 9px;
    }
  }

  .profile-modal-body {
    padding: 24px;
    overflow-y: auto;
    max-height: calc(90vh - 100px);
  }

  /* Profile Picture Section */
  .profile-picture-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    margin-bottom: 32px;
    padding: 20px;
    border-radius: 16px;
    background: #141619;
  }

  .profile-picture-container {
    position: relative;
    width: 153px;
    height: 153px;
  }

  .profile-picture,
  .profile-picture-placeholder {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
  }

  .profile-picture-placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, rgba(93, 63, 211, 0.2), rgba(237, 183, 35, 0.2));
  }

  .profile-picture {
    display: none;
  }

  .profile-picture.loaded {
    display: block;
  }

  .profile-info-header {
    text-align: center;
  }

  .profile-name {
    font-size: 26px;
    font-weight: 900;
    color: var(--gold);
    margin: 0 0 8px 0;
    text-shadow: 0 2px 8px rgba(0,0,0,0.4);
  }

  .profile-wallet {
    font-size: 14px;
    color: rgba(255,255,255,0.6);
    margin: 0;
    font-family: monospace;
  }

  /* Follow Section */
  .profile-follow-section {
    background: rgba(0,0,0,0.3);
    border: 2px solid rgba(237,183,35,0.2);
    border-radius: 16px;
    padding: 20px;
    margin: 20px 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 20px;
  }

  .follow-stats {
    display: flex;
    gap: 40px;
    flex: 1;
  }

  .follow-stat-item {
    text-align: center;
    transition: all 0.3s ease;
  }

  .follow-stat-item:hover {
    transform: scale(1.05);
  }

  .follow-stat-item:hover .follow-stat-number {
    color: var(--gold);
    text-shadow: 0 0 12px rgba(237,183,35,0.6);
  }

  .follow-stat-number {
    font-size: 32px;
    font-weight: 900;
    color: rgba(255,255,255,0.9);
    margin: 0;
    transition: all 0.3s ease;
    text-shadow: 0 2px 8px rgba(0,0,0,0.4);
  }

  .follow-stat-label {
    font-size: 14px;
    color: rgba(255,255,255,0.6);
    margin-top: 4px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .follow-btn {
    background: linear-gradient(135deg, rgba(237,183,35,0.3), rgba(237,183,35,0.15));
    border: 2px solid rgba(237,183,35,0.5);
    color: var(--gold);
    padding: 12px 32px;
    font-size: 18px;
    font-weight: 900;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    text-transform: uppercase;
    letter-spacing: 1px;
    animation: followBtnWiggle 2s ease-in-out infinite;
  }

  @keyframes followBtnWiggle {
    0%, 100% { transform: rotate(0deg); }
    25% { transform: rotate(-3deg); }
    75% { transform: rotate(3deg); }
  }

  .follow-btn:hover {
    background: linear-gradient(135deg, rgba(237,183,35,0.5), rgba(237,183,35,0.3));
    border-color: var(--gold);
    box-shadow: 0 0 20px rgba(237,183,35,0.5);
    transform: scale(1.05);
    animation: none;
  }

  .follow-btn.following {
    background: linear-gradient(135deg, rgba(50,205,50,0.2), rgba(50,205,50,0.1));
    border-color: rgba(50,205,50,0.3);
    color: rgba(50,205,50,0.7);
    animation: none;
    padding: 8px 20px;
    font-size: 14px;
    opacity: 0.8;
  }

  .follow-btn.following:hover {
    background: linear-gradient(135deg, rgba(220,20,60,0.15), rgba(220,20,60,0.1));
    border-color: rgba(220,20,60,0.3);
    color: rgba(220,20,60,0.6);
    box-shadow: none;
    transform: scale(0.95);
    opacity: 0.7;
    padding: 6px 16px;
    font-size: 12px;
  }

  .follow-btn.following:hover .follow-btn-text::before {
    content: "Un";
  }

  .follow-btn:disabled {
    opacity: 0.7 !important;
    cursor: not-allowed !important;
    pointer-events: none;
  }

  .follow-btn-icon {
    font-size: 20px;
    transition: transform 0.3s ease;
  }

  .follow-btn-text {
    transition: color 0.3s ease;
  }

  /* Mobile Responsive Follow Section */
  @media (max-width: 768px) {
    .profile-follow-section {
      flex-direction: column;
      align-items: stretch;
      padding: 16px;
    }

    .follow-stats {
      justify-content: space-around;
      gap: 20px;
      width: 100%;
    }

    .follow-stat-number {
      font-size: 28px;
    }

    .follow-stat-label {
      font-size: 12px;
    }

    .follow-btn {
      width: 100%;
      justify-content: center;
      padding: 14px 24px;
      font-size: 16px;
      margin-top: 8px;
    }

    .follow-btn.following {
      padding: 8px 16px;
      font-size: 13px;
    }

    .follow-btn.following:hover {
      padding: 6px 14px;
      font-size: 11px;
    }
  }

  /* Follow List Modal */
  .follow-list-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    backdrop-filter: blur(10px);
  }

  .follow-list-modal {
    background: linear-gradient(135deg, #1a1d24 0%, #141619 100%);
    border: 3px solid rgba(237,183,35,0.3);
    border-radius: 24px;
    width: 90%;
    max-width: 500px;
    max-height: 80vh;
    overflow: hidden;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5), 0 0 40px rgba(237,183,35,0.2);
    animation: followModalSlideIn 0.3s ease-out;
  }

  @keyframes followModalSlideIn {
    from {
      opacity: 0;
      transform: translateY(-30px) scale(0.9);
    }
    to {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }

  .follow-list-header {
    padding: 24px;
    border-bottom: 2px solid rgba(237,183,35,0.2);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .follow-list-header h3 {
    margin: 0;
    color: var(--gold);
    font-size: 24px;
    font-weight: 900;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .follow-list-close {
    background: rgba(237,183,35,0.2);
    border: 2px solid rgba(237,183,35,0.3);
    color: var(--gold);
    font-size: 28px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
  }

  .follow-list-close:hover {
    background: rgba(237,183,35,0.4);
    border-color: var(--gold);
    transform: rotate(90deg);
  }

  .follow-list-body {
    padding: 16px;
    max-height: calc(80vh - 100px);
    overflow-y: auto;
  }

  .follow-list-empty {
    padding: 60px 20px;
    text-align: center;
  }

  .follow-list-empty p {
    color: rgba(255,255,255,0.6);
    font-size: 18px;
    margin: 0;
  }

  .follow-list-item {
    background: rgba(0,0,0,0.3);
    border: 2px solid rgba(237,183,35,0.2);
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 16px;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .follow-list-item:hover {
    background: rgba(0,0,0,0.5);
    border-color: rgba(237,183,35,0.5);
    transform: translateX(5px);
    box-shadow: 0 4px 12px rgba(237,183,35,0.2);
  }

  .follow-list-avatar-container {
    width: 50px;
    height: 50px;
    flex-shrink: 0;
  }

  .follow-list-avatar,
  .follow-list-avatar-placeholder {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
  }

  .follow-list-avatar-placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    background: linear-gradient(135deg, rgba(93, 63, 211, 0.2), rgba(237, 183, 35, 0.2));
  }

  .follow-list-info {
    flex: 1;
  }

  .follow-list-name {
    margin: 0 0 4px 0;
    color: var(--gold);
    font-size: 18px;
    font-weight: 700;
  }

  .follow-list-wallet {
    margin: 0;
    color: rgba(255,255,255,0.5);
    font-size: 13px;
    font-family: monospace;
  }

  /* Profile Sections */
  .profile-section {
    background: rgba(0,0,0,0.3);
    border: 2px solid rgba(237,183,35,0.2);
    border-radius: 16px;
    padding: 20px;
    margin-bottom: 20px;
  }

  .profile-section h4 {
    color: var(--gold);
    font-size: 20px;
    margin: 0 0 16px 0;
    font-weight: 900;
  }

  .profile-section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
  }

  .profile-section-header h4 {
    margin: 0;
  }

  /* Bio Section */
  .edit-bio-btn {
    background: rgba(237,183,35,0.15);
    border: 2px solid var(--gold);
    color: var(--gold);
    padding: 6px 16px;
    border-radius: 8px;
    font-size: 13px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s;
  }

  .edit-bio-btn:hover {
    background: var(--gold);
    color: #000;
    transform: translateY(-2px);
  }

  .edit-profile-picture-btn:hover {
    background: rgba(237,183,35,0.9) !important;
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(237,183,35,0.4);
  }

  .edit-profile-picture-btn:active {
    transform: scale(0.95);
  }

  .bio-display {
    color: rgba(255,255,255,0.85);
    line-height: 1.6;
    font-size: 15px;
    white-space: pre-wrap;
  }

  .bio-editor textarea {
    width: 100%;
    min-height: 100px;
    background: rgba(0,0,0,0.5);
    border: 2px solid rgba(237,183,35,0.3);
    border-radius: 10px;
    padding: 12px;
    color: #fff;
    font-size: 15px;
    font-family: inherit;
    resize: vertical;
  }

  .bio-editor textarea:focus {
    outline: none;
    border-color: var(--gold);
  }

  .bio-editor-actions {
    display: flex;
    gap: 10px;
    margin-top: 12px;
  }

  .btn-save-bio,
  .btn-cancel-bio {
    padding: 10px 20px;
    border-radius: 10px;
    font-size: 14px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s;
    border: 2px solid transparent;
  }

  .btn-save-bio {
    background: var(--gold);
    color: #000;
    border-color: var(--gold);
  }

  .btn-save-bio:hover {
    background: #ffca3a;
    transform: translateY(-2px);
  }

  .btn-cancel-bio {
    background: rgba(255,255,255,0.1);
    color: #fff;
    border-color: rgba(255,255,255,0.2);
  }

  .btn-cancel-bio:hover {
    background: rgba(255,255,255,0.2);
  }

  /* ===== BULLETIN BOARD STYLES ===== */
  /* Bulletin Post Input in Profile Modal */
  .bulletin-post-section {
    background: rgba(237, 183, 35, 0.05);
    border: 2px solid rgba(237, 183, 35, 0.2);
    border-radius: 12px;
    padding: 20px;
  }

  .bulletin-post-input-container {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .bulletin-post-input {
    width: 100%;
    min-height: 80px;
    background: rgba(0, 0, 0, 0.5);
    border: 2px solid rgba(237, 183, 35, 0.3);
    border-radius: 10px;
    padding: 12px;
    color: #fff;
    font-size: 15px;
    font-family: inherit;
    resize: vertical;
    transition: all 0.3s ease;
  }

  .bulletin-post-input:focus {
    outline: none;
    border-color: var(--gold);
    box-shadow: 0 0 0 3px rgba(237, 183, 35, 0.1);
  }

  .bulletin-post-input::placeholder {
    color: rgba(255, 255, 255, 0.4);
  }

  .bulletin-post-actions {
    display: flex;
    justify-content: flex-end;
  }

  .btn-post-bulletin {
    padding: 12px 24px;
    background: var(--gold);
    color: #000;
    border: 2px solid var(--gold);
    border-radius: 10px;
    font-size: 15px;
    font-weight: 800;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .btn-post-bulletin:hover {
    background: #ffca3a;
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(237, 183, 35, 0.3);
  }

  .btn-post-bulletin:active {
    transform: translateY(0);
  }

  .btn-post-bulletin:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* Bulletin Feed Container */
  .post-bulletin-btn {
    display: inline-block;
    background: linear-gradient(135deg, #edb723, #f4d06f);
    color: #000;
    font-weight: 700;
    font-size: 18px;
    padding: 14px 28px;
    border: 3px solid #edb723;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 0 20px rgba(237, 183, 35, 0.6),
                0 0 40px rgba(237, 183, 35, 0.4),
                0 4px 12px rgba(0, 0, 0, 0.3);
    animation: pulseGlow 2s ease-in-out infinite;
  }

  .post-bulletin-btn:hover {
    background: linear-gradient(135deg, #f4d06f, #edb723);
    transform: scale(1.05);
    box-shadow: 0 0 30px rgba(237, 183, 35, 0.8),
                0 0 60px rgba(237, 183, 35, 0.6),
                0 6px 16px rgba(0, 0, 0, 0.4);
  }

  .post-bulletin-btn:active {
    transform: scale(0.98);
  }

  @keyframes pulseGlow {
    0%, 100% {
      box-shadow: 0 0 20px rgba(237, 183, 35, 0.6),
                  0 0 40px rgba(237, 183, 35, 0.4),
                  0 4px 12px rgba(0, 0, 0, 0.3);
    }
    50% {
      box-shadow: 0 0 30px rgba(237, 183, 35, 0.8),
                  0 0 50px rgba(237, 183, 35, 0.5),
                  0 4px 12px rgba(0, 0, 0, 0.3);
    }
  }

  @keyframes highlightPulse {
    0%, 100% {
      box-shadow: 0 0 20px rgba(237, 183, 35, 0.6), 0 0 40px rgba(237, 183, 35, 0.4);
      transform: scale(1);
    }
    50% {
      box-shadow: 0 0 40px rgba(237, 183, 35, 1), 0 0 80px rgba(237, 183, 35, 0.8);
      transform: scale(1.02);
    }
  }

  .bulletin-feed-container {
    max-width: 800px;
    margin: 0 auto;
  }

  .bulletin-feed {
    display: flex;
    flex-direction: column;
    gap: 20px;
    max-height: 600px;
    overflow-y: auto;
    padding: 20px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 16px;
    border: 2px solid rgba(237, 183, 35, 0.2);
  }

  .bulletin-feed::-webkit-scrollbar {
    width: 10px;
  }

  .bulletin-feed::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
  }

  .bulletin-feed::-webkit-scrollbar-thumb {
    background: var(--gold);
    border-radius: 10px;
  }

  .bulletin-feed::-webkit-scrollbar-thumb:hover {
    background: #ffca3a;
  }

  /* Bulletin Post Card */
  .bulletin-post-card {
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid rgba(237, 183, 35, 0.3);
    border-radius: 12px;
    padding: 20px;
    transition: all 0.3s ease;
    cursor: pointer;
  }

  .bulletin-post-card:hover {
    border-color: var(--gold);
    box-shadow: 0 4px 20px rgba(237, 183, 35, 0.2);
    transform: translateY(-2px);
  }

  .bulletin-post-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
  }

  .bulletin-post-avatar {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    border: 2px solid var(--gold);
    object-fit: cover;
  }

  .bulletin-post-info {
    flex: 1;
  }

  .bulletin-post-author {
    font-size: 16px;
    font-weight: 800;
    color: var(--gold);
    margin-bottom: 4px;
  }

  .bulletin-post-time {
    font-size: 13px;
    color: rgba(255, 255, 255, 0.5);
  }

  .bulletin-delete-btn {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: rgba(255, 75, 75, 0.1);
    border: 2px solid rgba(255, 75, 75, 0.3);
    color: #ff4b4b;
    font-size: 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    margin-left: auto;
  }

  .bulletin-delete-btn:hover {
    background: rgba(255, 75, 75, 0.2);
    border-color: #ff4b4b;
    transform: scale(1.1);
  }

  .bulletin-delete-btn:active {
    transform: scale(0.95);
  }

  .bulletin-post-content {
    color: rgba(255, 255, 255, 0.9);
    font-size: 15px;
    line-height: 1.6;
    margin-bottom: 12px;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .bulletin-link {
    color: var(--gold);
    text-decoration: underline;
    transition: all 0.2s ease;
    word-break: break-all;
  }

  .bulletin-link:hover {
    color: #ffd700;
    text-decoration: none;
  }

  /* Link Preview Card - Twitter/X Style */
  .bulletin-post-link-preview {
    margin-top: 16px;
    border: 2px solid rgba(237, 183, 35, 0.4);
    border-radius: 16px;
    overflow: hidden;
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.5) 0%, rgba(20, 20, 20, 0.5) 100%);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }

  .bulletin-post-link-preview:hover {
    border-color: var(--gold);
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(237, 183, 35, 0.3), 0 0 40px rgba(237, 183, 35, 0.1);
  }

  .bulletin-post-link-image-container {
    position: relative;
    width: 100%;
    height: 280px;
    overflow: hidden;
    background: rgba(0, 0, 0, 0.3);
  }

  .bulletin-post-link-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.3s ease;
  }

  .bulletin-post-link-preview:hover .bulletin-post-link-image {
    transform: scale(1.05);
  }

  /* YouTube Play Button Overlay */
  .youtube-play-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 80px;
    height: 80px;
    background: rgba(237, 183, 35, 0.95);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
    color: #000;
    padding-left: 6px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    transition: all 0.3s ease;
    pointer-events: none;
  }

  .bulletin-post-link-preview:hover .youtube-play-overlay {
    transform: translate(-50%, -50%) scale(1.1);
    background: var(--gold);
    box-shadow: 0 6px 30px rgba(237, 183, 35, 0.6);
  }

  .youtube-preview {
    border-color: rgba(255, 0, 0, 0.4) !important;
  }

  .youtube-preview:hover {
    border-color: rgba(255, 0, 0, 0.8) !important;
    box-shadow: 0 8px 24px rgba(255, 0, 0, 0.3), 0 0 40px rgba(255, 0, 0, 0.1) !important;
  }

  .bulletin-post-link-info {
    padding: 16px;
    background: rgba(0, 0, 0, 0.3);
  }

  .bulletin-post-link-title {
    font-size: 17px;
    font-weight: 700;
    color: #fff;
    margin-bottom: 8px;
    line-height: 1.3;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .bulletin-post-link-description {
    font-size: 14px;
    color: rgba(255, 255, 255, 0.75);
    line-height: 1.5;
    margin-bottom: 8px;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .bulletin-post-link-url {
    font-size: 13px;
    color: var(--gold);
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .bulletin-post-footer {
    display: flex;
    align-items: center;
    gap: 20px;
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid rgba(237, 183, 35, 0.2);
  }

  .bulletin-post-stat {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 14px;
    color: rgba(255, 255, 255, 0.6);
  }

  /* Bulletin Post Modal */
  .bulletin-post-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .bulletin-modal-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(4px);
  }

  .bulletin-modal-content {
    position: relative;
    width: 90%;
    max-width: 700px;
    max-height: 90vh;
    background: #1a1a1a;
    border: 3px solid var(--gold);
    border-radius: 16px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
  }

  .bulletin-modal-header {
    padding: 20px;
    background: linear-gradient(135deg, rgba(237, 183, 35, 0.2), rgba(237, 183, 35, 0.1));
    border-bottom: 2px solid rgba(237, 183, 35, 0.3);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .bulletin-modal-title {
    margin: 0;
    color: var(--gold);
    font-size: 24px;
  }

  .bulletin-close-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    color: #fff;
    font-size: 28px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    line-height: 1;
  }

  .bulletin-close-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: rotate(90deg);
  }

  .bulletin-modal-body {
    padding: 20px;
    overflow-y: auto;
    max-height: calc(90vh - 80px);
  }

  .bulletin-modal-body::-webkit-scrollbar {
    width: 8px;
  }

  .bulletin-modal-body::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.3);
  }

  .bulletin-modal-body::-webkit-scrollbar-thumb {
    background: var(--gold);
    border-radius: 4px;
  }

  .bulletin-post-detail {
    margin-bottom: 30px;
  }

  /* Comments Section */
  .bulletin-comments-section {
    margin-top: 20px;
    padding-top: 20px;
    border-top: 2px solid rgba(237, 183, 35, 0.2);
  }

  .comments-title {
    color: var(--gold);
    font-size: 20px;
    margin-bottom: 16px;
  }

  .comment-input-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-bottom: 20px;
  }

  .comment-input {
    width: 100%;
    min-height: 60px;
    background: rgba(0, 0, 0, 0.5);
    border: 2px solid rgba(237, 183, 35, 0.3);
    border-radius: 10px;
    padding: 12px;
    color: #fff;
    font-size: 15px;
    font-family: inherit;
    resize: vertical;
  }

  .comment-input:focus {
    outline: none;
    border-color: var(--gold);
  }

  .btn-post-comment {
    align-self: flex-end;
    padding: 10px 20px;
    background: var(--gold);
    color: #000;
    border: 2px solid var(--gold);
    border-radius: 10px;
    font-size: 14px;
    font-weight: 800;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .btn-post-comment:hover {
    background: #ffca3a;
    transform: translateY(-2px);
  }

  .comments-list {
    display: flex;
    flex-direction: column;
    gap: 16px;
    min-height: 50px;
  }

  .bulletin-comments-section .comment-item {
    background: rgba(0, 0, 0, 0.4);
    border: 1px solid rgba(237, 183, 35, 0.2);
    border-radius: 10px;
    padding: 14px;
    min-height: 80px;
    display: block !important;
  }

  .bulletin-comments-section .comment-header {
    display: flex !important;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
    min-height: 40px;
  }

  .bulletin-comments-section .comment-avatar {
    width: 36px !important;
    height: 36px !important;
    border-radius: 50%;
    border: 2px solid var(--gold);
    object-fit: cover;
    flex-shrink: 0;
  }

  .bulletin-comments-section .comment-author {
    font-size: 14px !important;
    font-weight: 700;
    color: var(--gold);
  }

  .bulletin-comments-section .comment-time {
    font-size: 12px !important;
    color: rgba(255, 255, 255, 0.5);
  }

  .comment-delete-btn {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background: rgba(255, 75, 75, 0.1);
    border: 2px solid rgba(255, 75, 75, 0.3);
    color: #ff4b4b;
    font-size: 14px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    margin-left: auto;
  }

  .comment-delete-btn:hover {
    background: rgba(255, 75, 75, 0.2);
    border-color: #ff4b4b;
    transform: scale(1.1);
  }

  .comment-delete-btn:active {
    transform: scale(0.95);
  }

  .bulletin-comments-section .comment-text {
    color: rgba(255, 255, 255, 0.85);
    font-size: 14px !important;
    line-height: 1.5;
    white-space: pre-wrap;
    word-break: break-word;
    min-height: 20px;
    display: block !important;
  }

  /* Achievements Grid */
  .achievements-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 16px;
  }

  .achievement-placeholder {
    aspect-ratio: 1;
    background: rgba(0,0,0,0.4);
    border: 2px dashed rgba(237,183,35,0.2);
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 12px;
  }

  /* NFT Grid */
  .profile-nft-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 12px;
  }

  .profile-nft-item {
    aspect-ratio: 1;
    border-radius: 12px;
    overflow: hidden;
    border: 3px solid transparent;
    background-image: linear-gradient(#000, #000), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    transition: all 0.2s;
    cursor: pointer;
  }

  .profile-nft-item:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba(237,183,35,0.4);
  }

  .profile-nft-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  /* NFT Collection Sections */
  .nft-collection-section {
    margin-bottom: 16px;
  }

  .nft-collection-toggle {
    width: 100%;
    padding: 20px 24px;
    background: linear-gradient(135deg, rgba(20,20,30,0.8), rgba(30,30,40,0.8));
    border: 3px solid transparent;
    background-image:
      linear-gradient(135deg, rgba(20,20,30,0.8), rgba(30,30,40,0.8)),
      var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    border-radius: 16px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    font-family: 'Luckiest Guy', cursive;
    box-shadow:
      0 4px 12px rgba(0,0,0,0.5),
      inset 0 2px 0 rgba(255,255,255,0.08),
      0 0 20px rgba(237,183,35,0.15);
  }

  .nft-collection-toggle:hover {
    background: linear-gradient(135deg, rgba(30,30,45,0.9), rgba(40,40,50,0.9));
    background-image:
      linear-gradient(135deg, rgba(30,30,45,0.9), rgba(40,40,50,0.9)),
      var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    transform: translateY(-2px);
    box-shadow:
      0 6px 20px rgba(237,183,35,0.4),
      inset 0 2px 0 rgba(255,255,255,0.12),
      0 0 30px rgba(237,183,35,0.3);
  }

  .nft-collection-toggle:active {
    transform: translateY(0);
    box-shadow:
      0 2px 8px rgba(237,183,35,0.3),
      inset 0 1px 0 rgba(255,255,255,0.05);
  }

  .nft-collection-title {
    flex: 1;
    text-align: left;
    font-size: 22px;
    font-weight: 400;
    color: var(--gold);
    text-shadow:
      2px 2px 0px rgba(0,0,0,0.8),
      0 0 15px rgba(237,183,35,0.5);
    letter-spacing: 1px;
  }

  .nft-collection-count {
    background: linear-gradient(135deg, rgba(237,183,35,0.2), rgba(237,183,35,0.1));
    padding: 8px 16px;
    border-radius: 24px;
    font-size: 16px;
    font-weight: 400;
    font-family: 'Luckiest Guy', cursive;
    color: var(--gold);
    border: 2px solid rgba(237,183,35,0.4);
    box-shadow:
      0 2px 8px rgba(0,0,0,0.3),
      inset 0 1px 0 rgba(255,255,255,0.1);
  }

  .nft-collection-arrow {
    font-size: 18px;
    color: var(--gold);
    transition: transform 0.3s ease;
    filter: drop-shadow(2px 2px 0px rgba(0,0,0,0.8));
  }

  .nft-collection-toggle.expanded .nft-collection-arrow {
    transform: rotate(180deg);
  }

  .nft-collection-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    gap: 20px;
    padding: 24px;
    background: rgba(0,0,0,0.3);
    border-radius: 0 0 12px 12px;
    margin-top: 8px;
  }

  .profile-nft-item {
    background: linear-gradient(135deg, rgba(20,20,30,0.9), rgba(30,30,40,0.9));
    border-radius: 12px;
    overflow: hidden;
    border: 2px solid rgba(93,63,211,0.3);
    transition: all 0.3s ease;
    display: flex;
    flex-direction: column;
  }

  .profile-nft-item:hover {
    transform: translateY(-4px);
    border-color: var(--gold);
    box-shadow: 0 8px 24px rgba(237,183,35,0.3);
  }

  .nft-image-container {
    position: relative;
    width: 100%;
    padding-top: 100%; /* 1:1 Aspect ratio */
    background: #000;
    flex-shrink: 0;
  }

  .nft-image-container img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .nft-logo-badge {
    position: absolute;
    top: 8px;
    left: 8px;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: white;
    padding: 3px;
    border: 2px solid transparent;
    background-image:
      linear-gradient(white, white),
      var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    box-shadow: 0 2px 8px rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    z-index: 10;
  }

  .nft-logo-badge:hover {
    transform: scale(1.15);
    box-shadow: 0 4px 12px rgba(0,0,0,0.7);
  }

  .nft-logo-badge img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
  }

  .nft-info {
    padding: 16px 12px;
    text-align: center;
    background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(10,10,15,0.95));
    border-top: 1px solid rgba(93,63,211,0.3);
    min-height: 65px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 6px;
    flex-shrink: 0;
    visibility: visible !important;
    opacity: 1 !important;
  }

  .nft-title {
    font-family: 'Luckiest Guy', 'Arial Black', Impact, sans-serif;
    font-size: 16px;
    font-weight: 400;
    color: var(--gold);
    text-transform: uppercase;
    margin: 0;
    padding: 0;
    line-height: 1.2;
    text-shadow:
      2px 2px 0px rgba(0,0,0,0.8),
      0 0 12px rgba(237,183,35,0.5);
    letter-spacing: 0.5px;
    visibility: visible !important;
    opacity: 1 !important;
    display: block !important;
  }

  .nft-rarity {
    font-family: 'Luckiest Guy', 'Arial Black', Impact, sans-serif;
    font-size: 13px;
    font-weight: 400;
    color: rgba(255,255,255,0.95);
    text-transform: uppercase;
    margin: 0;
    padding: 0;
    line-height: 1.2;
    text-shadow:
      1px 1px 0px rgba(0,0,0,0.8),
      0 0 10px rgba(255,255,255,0.3);
    letter-spacing: 0.5px;
    visibility: visible !important;
    opacity: 1 !important;
    display: block !important;
  }

  .no-nfts-message {
    text-align: center;
    padding: 48px 20px;
    opacity: 0.5;
  }

  .no-nfts-message p {
    margin-top: 12px;
    font-size: 14px;
    color: rgba(255,255,255,0.6);
  }

  /* Comments Section */
  .comment-form {
    margin-bottom: 24px;
  }

  .comment-form textarea {
    width: 100%;
    min-height: 80px;
    background: rgba(0,0,0,0.5);
    border: 2px solid rgba(237,183,35,0.3);
    border-radius: 12px;
    padding: 12px;
    color: #fff;
    font-size: 14px;
    font-family: inherit;
    resize: vertical;
    margin-bottom: 10px;
  }

  .comment-form textarea:focus {
    outline: none;
    border-color: var(--gold);
  }

  .btn-post-comment {
    background: linear-gradient(135deg, #5D3FD3, #7D5FE3);
    border: 3px solid transparent;
    background-image: linear-gradient(135deg, #5D3FD3, #7D5FE3), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    color: #fff;
    padding: 12px 24px;
    border-radius: 12px;
    font-size: 15px;
    font-weight: 900;
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .btn-post-comment:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(93, 63, 211, 0.5);
  }

  .comments-list {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .comments-loading {
    text-align: center;
    padding: 20px;
    color: rgba(255,255,255,0.5);
    font-style: italic;
  }

  /* Reddit-Style Threading */
  .comment-thread {
    position: relative;
    margin-bottom: 8px;
  }

  .comment-thread[data-depth="1"] { margin-left: 12px; }
  .comment-thread[data-depth="2"] { margin-left: 24px; }
  .comment-thread[data-depth="3"] { margin-left: 36px; }
  .comment-thread[data-depth="4"] { margin-left: 48px; }
  .comment-thread[data-depth="5"] { margin-left: 60px; }
  .comment-thread[data-depth="6"] { margin-left: 72px; }
  .comment-thread[data-depth="7"] { margin-left: 84px; }
  .comment-thread[data-depth="8"] { margin-left: 96px; }

  /* Compact styling for deeply nested comments (3+ levels) */
  .comment-thread[data-depth="3"] .comment-item,
  .comment-thread[data-depth="4"] .comment-item,
  .comment-thread[data-depth="5"] .comment-item,
  .comment-thread[data-depth="6"] .comment-item,
  .comment-thread[data-depth="7"] .comment-item,
  .comment-thread[data-depth="8"] .comment-item {
    padding: 8px;
  }

  .comment-thread[data-depth="3"] .comment-actions,
  .comment-thread[data-depth="4"] .comment-actions,
  .comment-thread[data-depth="5"] .comment-actions,
  .comment-thread[data-depth="6"] .comment-actions,
  .comment-thread[data-depth="7"] .comment-actions,
  .comment-thread[data-depth="8"] .comment-actions {
    gap: 4px;
    margin-top: 6px;
  }

  /* Make buttons icon-only at depth 3+ */
  .comment-thread[data-depth="3"] .like-button span:not(.like-emoji),
  .comment-thread[data-depth="4"] .like-button span:not(.like-emoji),
  .comment-thread[data-depth="5"] .like-button span:not(.like-emoji),
  .comment-thread[data-depth="6"] .like-button span:not(.like-emoji),
  .comment-thread[data-depth="7"] .like-button span:not(.like-emoji),
  .comment-thread[data-depth="8"] .like-button span:not(.like-emoji),
  .comment-thread[data-depth="3"] .reply-button span:not(.reply-icon),
  .comment-thread[data-depth="4"] .reply-button span:not(.reply-icon),
  .comment-thread[data-depth="5"] .reply-button span:not(.reply-icon),
  .comment-thread[data-depth="6"] .reply-button span:not(.reply-icon),
  .comment-thread[data-depth="7"] .reply-button span:not(.reply-icon),
  .comment-thread[data-depth="8"] .reply-button span:not(.reply-icon) {
    display: none;
  }

  .comment-thread[data-depth="3"] .like-button,
  .comment-thread[data-depth="3"] .reply-button,
  .comment-thread[data-depth="4"] .like-button,
  .comment-thread[data-depth="4"] .reply-button,
  .comment-thread[data-depth="5"] .like-button,
  .comment-thread[data-depth="5"] .reply-button,
  .comment-thread[data-depth="6"] .like-button,
  .comment-thread[data-depth="6"] .reply-button,
  .comment-thread[data-depth="7"] .like-button,
  .comment-thread[data-depth="7"] .reply-button,
  .comment-thread[data-depth="8"] .like-button,
  .comment-thread[data-depth="8"] .reply-button {
    padding: 4px 6px;
    font-size: 14px;
    min-width: unset;
  }

  .comment-thread[data-depth="3"] .comment-delete-btn,
  .comment-thread[data-depth="4"] .comment-delete-btn,
  .comment-thread[data-depth="5"] .comment-delete-btn,
  .comment-thread[data-depth="6"] .comment-delete-btn,
  .comment-thread[data-depth="7"] .comment-delete-btn,
  .comment-thread[data-depth="8"] .comment-delete-btn {
    padding: 3px 6px;
    font-size: 10px;
  }

  .comment-thread[data-depth="3"] .comment-text,
  .comment-thread[data-depth="4"] .comment-text,
  .comment-thread[data-depth="5"] .comment-text,
  .comment-thread[data-depth="6"] .comment-text,
  .comment-thread[data-depth="7"] .comment-text,
  .comment-thread[data-depth="8"] .comment-text {
    font-size: 12px;
  }

  .comment-thread[data-depth="3"] .comment-author-name,
  .comment-thread[data-depth="4"] .comment-author-name,
  .comment-thread[data-depth="5"] .comment-author-name,
  .comment-thread[data-depth="6"] .comment-author-name,
  .comment-thread[data-depth="7"] .comment-author-name,
  .comment-thread[data-depth="8"] .comment-author-name {
    font-size: 13px;
  }

  /* Threading line visual indicator */
  .comment-thread[data-depth]::before {
    content: '';
    position: absolute;
    left: -12px;
    top: 0;
    bottom: 0;
    width: 2px;
    background: linear-gradient(180deg,
      rgba(237,183,35,0.3) 0%,
      rgba(129,212,250,0.2) 50%,
      rgba(237,183,35,0.3) 100%
    );
    transition: all 0.2s;
  }

  .comment-thread[data-depth]:hover::before {
    background: linear-gradient(180deg,
      rgba(237,183,35,0.6) 0%,
      rgba(129,212,250,0.4) 50%,
      rgba(237,183,35,0.6) 100%
    );
    width: 3px;
  }

  .thread-toggle {
    position: absolute;
    left: -32px;
    top: 16px;
    width: 24px;
    height: 24px;
    background: linear-gradient(135deg, rgba(237,183,35,0.2), rgba(129,212,250,0.2));
    border: 2px solid rgba(237,183,35,0.4);
    border-radius: 4px;
    color: var(--gold);
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
  }

  .thread-toggle:hover {
    background: linear-gradient(135deg, rgba(237,183,35,0.4), rgba(129,212,250,0.4));
    border-color: var(--gold);
    transform: scale(1.1);
  }

  .toggle-icon {
    transition: transform 0.2s;
  }

  .comment-thread.collapsed .toggle-icon {
    transform: rotate(-90deg);
  }

  .thread-spacer {
    width: 24px;
    flex-shrink: 0;
  }

  .comment-replies {
    margin-top: 8px;
    transition: all 0.3s ease-in-out;
  }

  .reply-count {
    font-size: 11px;
    color: rgba(129,212,250,0.8);
    margin-left: 8px;
    font-weight: 700;
  }

  .comment-item {
    background: rgba(0,0,0,0.4);
    border: 2px solid rgba(237,183,35,0.15);
    border-radius: 12px;
    padding: 16px;
    transition: all 0.2s;
    display: flex;
    gap: 12px;
  }

  .comment-content {
    flex: 1;
    min-width: 0;
  }

  /* Reply indicator styling */
  .reply-indicator {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 8px;
    padding: 4px 8px;
    background: linear-gradient(90deg, rgba(129,212,250,0.15), transparent);
    border-left: 3px solid rgba(129,212,250,0.5);
    border-radius: 4px;
  }

  .reply-arrow {
    font-size: 14px;
    color: rgba(129,212,250,0.9);
    animation: replyPulse 2s ease-in-out infinite;
  }

  @keyframes replyPulse {
    0%, 100% { transform: translateX(0); opacity: 1; }
    50% { transform: translateX(-2px); opacity: 0.7; }
  }

  /* Highlight flash animation for notification navigation */
  @keyframes highlight-flash {
    0%, 100% {
      background: transparent;
      box-shadow: none;
    }
    10%, 30%, 50% {
      background: linear-gradient(135deg, rgba(237,183,35,0.3), rgba(237,183,35,0.1));
      box-shadow: 0 0 20px rgba(237,183,35,0.5), inset 0 0 15px rgba(237,183,35,0.2);
    }
    20%, 40%, 60% {
      background: transparent;
      box-shadow: none;
    }
  }

  .reply-to-text {
    font-size: 12px;
    color: rgba(255,255,255,0.6);
    font-weight: 600;
  }

  .reply-to-name {
    color: rgba(129,212,250,0.9);
    font-weight: 900;
  }

  /* Subtle background tint for replies */
  .comment-thread.is-reply .comment-item {
    background: linear-gradient(135deg, rgba(129,212,250,0.05), rgba(0,0,0,0.4));
    border-left: 3px solid rgba(129,212,250,0.3);
  }

  .comment-thread.is-reply .comment-item:hover {
    background: linear-gradient(135deg, rgba(129,212,250,0.1), rgba(0,0,0,0.5));
    border-left-color: rgba(129,212,250,0.6);
  }

  .comment-item:hover {
    border-color: rgba(237,183,35,0.3);
    background: rgba(0,0,0,0.5);
  }

  .comment-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 12px;
  }

  .comment-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid var(--gold);
    object-fit: cover;
  }

  .comment-avatar-placeholder {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid var(--gold);
    background: linear-gradient(135deg, rgba(93, 63, 211, 0.3), rgba(237, 183, 35, 0.3));
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
  }

  .comment-author-info {
    flex: 1;
  }

  .comment-author-clickable {
    transition: all 0.2s ease;
    border-radius: 8px;
    padding: 4px;
    margin: -4px;
  }

  .comment-author-clickable:hover {
    background: rgba(237,183,35,0.1);
    transform: translateX(2px);
  }

  .comment-author-clickable:hover .comment-author-name {
    color: rgba(237,183,35,1);
    text-decoration: underline;
  }

  .comment-author-name {
    font-weight: 900;
    color: var(--gold);
    font-size: 15px;
    margin: 0;
    transition: all 0.2s ease;
  }

  .comment-timestamp {
    font-size: 12px;
    color: rgba(255,255,255,0.5);
    margin: 0;
  }

  .comment-delete-btn {
    background: rgba(255,0,0,0.2);
    border: 2px solid rgba(255,0,0,0.4);
    color: #ff6b6b;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s;
  }

  .comment-delete-btn:hover {
    background: rgba(255,0,0,0.4);
    border-color: #ff6b6b;
  }

  .comment-text {
    color: rgba(255,255,255,0.9);
    line-height: 1.5;
    font-size: 14px;
    white-space: pre-wrap;
    margin: 0;
  }

  .comments-empty {
    text-align: center;
    padding: 40px 20px;
    color: rgba(255,255,255,0.5);
    font-style: italic;
  }

  /* Facebook-Style Reactions */
  .comment-actions {
    display: flex;
    gap: 12px;
    margin-top: 8px;
    align-items: center;
  }

  .like-button {
    position: relative;
    background: none;
    border: none;
    color: rgba(255,255,255,0.6);
    font-size: 14px;
    font-weight: 700;
    cursor: pointer;
    padding: 6px 12px;
    border-radius: 6px;
    transition: all 0.2s;
    user-select: none;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .like-button:hover {
    background: rgba(255,255,255,0.1);
    color: rgba(255,255,255,0.9);
  }

  .like-button.reacted {
    color: var(--gold);
  }

  .like-button .like-emoji {
    font-size: 16px;
  }

  /* Reply Button */
  .reply-button {
    position: relative;
    background: linear-gradient(135deg, rgba(237,183,35,0.15), rgba(129,212,250,0.15));
    border: 2px solid transparent;
    background-image: linear-gradient(rgba(20,22,25,0.9), rgba(20,22,25,0.9)), var(--tri-gradient);
    background-origin: border-box;
    background-clip: padding-box, border-box;
    color: rgba(255,255,255,0.8);
    font-size: 14px;
    font-weight: 700;
    cursor: pointer;
    padding: 6px 14px;
    border-radius: 20px;
    transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    user-select: none;
    display: flex;
    align-items: center;
    gap: 6px;
    animation: wiggle 2s ease-in-out infinite;
    box-shadow: 0 4px 15px rgba(237,183,35,0.2);
  }

  .reply-button:hover {
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 8px 25px rgba(237,183,35,0.4), 0 0 20px rgba(129,212,250,0.3);
    background-image: linear-gradient(rgba(20,22,25,0.7), rgba(20,22,25,0.7)), var(--tri-gradient);
    color: rgba(255,255,255,1);
    animation: none;
  }

  .reply-button .reply-icon {
    font-size: 16px;
    filter: drop-shadow(0 2px 4px rgba(237,183,35,0.4));
  }

  @keyframes wiggle {
    0%, 100% {
      transform: rotate(0deg);
    }
    25% {
      transform: rotate(-3deg);
    }
    75% {
      transform: rotate(3deg);
    }
  }

  /* Reply Box */
  .reply-box {
    margin-top: 12px;
    padding: 12px;
    background: rgba(0,0,0,0.3);
    border: 2px solid transparent;
    background-image: linear-gradient(rgba(20,22,25,0.95), rgba(20,22,25,0.95)), var(--tri-gradient);
    background-origin: border-box;
    background-clip: padding-box, border-box;
    border-radius: 12px;
    display: none;
    animation: slideDown 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  }

  .reply-box.visible {
    display: block;
  }

  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-10px) scale(0.95);
    }
    to {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }

  .reply-box textarea {
    width: 100%;
    min-height: 60px;
    background: rgba(0,0,0,0.4);
    border: 2px solid rgba(237,183,35,0.3);
    border-radius: 8px;
    color: white;
    padding: 8px 12px;
    font-family: inherit;
    font-size: 14px;
    resize: vertical;
    transition: all 0.2s;
  }

  .reply-box textarea:focus {
    outline: none;
    border-color: var(--gold);
    box-shadow: 0 0 15px rgba(237,183,35,0.3);
  }

  .reply-box-actions {
    display: flex;
    gap: 8px;
    margin-top: 8px;
    justify-content: flex-end;
  }

  .reply-box-actions button {
    padding: 6px 16px;
    border-radius: 8px;
    font-weight: 700;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
    border: none;
  }

  .reply-cancel-btn {
    background: rgba(255,255,255,0.1);
    color: rgba(255,255,255,0.7);
  }

  .reply-cancel-btn:hover {
    background: rgba(255,255,255,0.2);
    color: white;
  }

  .reply-submit-btn {
    background: linear-gradient(135deg, var(--gold), #d4a028);
    color: black;
    font-weight: 900;
  }

  .reply-submit-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(237,183,35,0.5);
  }

  /* Reaction Summary (shows counts of reactions) */
  .reaction-summary {
    display: flex;
    gap: 4px;
    align-items: center;
    margin-top: 8px;
    flex-wrap: wrap;
  }

  .reaction-pill {
    background: rgba(0,0,0,0.4);
    border: 2px solid rgba(237,183,35,0.3);
    border-radius: 16px;
    padding: 4px 10px;
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 13px;
    color: rgba(255,255,255,0.8);
    cursor: pointer;
    transition: all 0.2s;
    user-select: none;
  }

  .reaction-pill:hover {
    background: rgba(237,183,35,0.15);
    border-color: var(--gold);
    transform: translateY(-2px) scale(1.05);
  }

  .reaction-pill.user-reacted {
    background: linear-gradient(135deg, rgba(237,183,35,0.3), rgba(237,183,35,0.2));
    border-color: var(--gold);
    box-shadow: 0 0 12px rgba(237,183,35,0.4);
  }

  .reaction-pill.removing {
    animation: bubbleErase 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
  }

  @keyframes bubbleErase {
    0% {
      transform: scale(1);
      opacity: 1;
    }
    50% {
      transform: scale(1.3);
      opacity: 0.8;
    }
    100% {
      transform: scale(0);
      opacity: 0;
    }
  }

  .reaction-pill .pill-emoji {
    font-size: 16px;
    transition: transform 0.2s;
  }

  .reaction-pill:hover .pill-emoji {
    transform: scale(1.2);
  }

  .reaction-pill .pill-count {
    font-weight: 700;
    color: var(--gold);
  }

  /* Facebook-Style Reaction Picker Bubble */
  .reaction-picker {
    position: absolute;
    bottom: 100%;
    left: 0;
    margin-bottom: 8px;
    background: linear-gradient(135deg, rgba(20, 22, 25, 0.98), rgba(16, 18, 21, 0.98));
    border: 3px solid transparent;
    background-image: linear-gradient(135deg, rgba(20, 22, 25, 0.98), rgba(16, 18, 21, 0.98)), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    border-radius: 50px;
    padding: 8px 12px;
    display: none;
    gap: 4px;
    box-shadow: 0 12px 40px rgba(0,0,0,0.8), 0 0 20px rgba(237,183,35,0.3);
    z-index: 1000;
    transform-origin: bottom left;
    animation: pickerBounceIn 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  }

  .reaction-picker.visible {
    display: flex;
  }

  @keyframes pickerBounceIn {
    0% {
      opacity: 0;
      transform: scale(0) translateY(20px);
    }
    50% {
      transform: scale(1.1) translateY(0);
    }
    100% {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
  }

  .reaction-picker-item {
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
    cursor: pointer;
    border-radius: 50%;
    transition: transform 0.1s cubic-bezier(0.34, 1.56, 0.64, 1), filter 0.1s ease;
    position: relative;
    background: transparent;
    transform: scale(1);
    touch-action: none;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    -webkit-user-select: none;
  }

  /* Desktop hover effect */
  @media (hover: hover) and (pointer: fine) {
    .reaction-picker-item:hover {
      transform: scale(1.5) translateY(-8px);
      filter: drop-shadow(0 8px 16px rgba(237,183,35,0.6));
    }

    .reaction-picker-item:active {
      transform: scale(1.3) translateY(-4px);
    }
  }

  /* Reaction label on hover */
  .reaction-picker-item::before {
    content: attr(data-label);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%) translateY(-8px) scale(0);
    background: rgba(0,0,0,0.9);
    color: var(--gold);
    padding: 4px 10px;
    border-radius: 8px;
    font-size: 12px;
    font-weight: 700;
    white-space: nowrap;
    pointer-events: none;
    opacity: 0;
    transition: all 0.2s;
    font-family: 'Luckiest Guy', cursive;
  }

  .reaction-picker-item:hover::before {
    opacity: 1;
    transform: translateX(-50%) translateY(-4px) scale(1);
  }

  /* Stagger animation for picker items */
  .reaction-picker-item:nth-child(1) { animation: itemPop 0.3s 0.05s both; }
  .reaction-picker-item:nth-child(2) { animation: itemPop 0.3s 0.1s both; }
  .reaction-picker-item:nth-child(3) { animation: itemPop 0.3s 0.15s both; }
  .reaction-picker-item:nth-child(4) { animation: itemPop 0.3s 0.2s both; }
  .reaction-picker-item:nth-child(5) { animation: itemPop 0.3s 0.25s both; }
  .reaction-picker-item:nth-child(6) { animation: itemPop 0.3s 0.3s both; }

  @keyframes itemPop {
    0% {
      opacity: 0;
      transform: scale(0) translateY(10px);
    }
    50% {
      transform: scale(1.2) translateY(-4px);
    }
    100% {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
  }

  @media (max-width: 768px) {
    .menu-overlay {
      max-width: 100%;
    }

    .honey-points-btn,
    .welcome-profile-btn {
      padding: 6px 12px;
      font-size: 11px;
      gap: 4px;
    }

    .nav-buttons-container {
      gap: 8px;
    }

    .menu-btn img {
      width: 40px;
      height: 40px;
    }

    .top-nav-bar {
      padding: 8px 16px;
    }

    .welcome-avatar {
      width: 32px;
      height: 32px;
      margin-left: 6px;
    }
  }

  /* Tablet and larger screens - increase header padding for foldables */
  @media (min-width:768px) and (max-width:1024px){
    #buyDrawer .drawer-head{padding-top:calc(env(safe-area-inset-top,0px) + 105px) !important;}
  }

  /* Make the drawer full-screen on phones & foldables so width isn't the limiter */
  @media (max-width:1024px){
    #buyDrawer{
      left:0 !important; right:0 !important; top:0 !important; bottom:0 !important;
      width:100vw !important; height:100vh !important; border-left:0 !important; border-radius:0 !important;
    }
    .drawer-scrim{display:none !important;}
    #buyDrawer .drawer-head{padding-top:calc(env(safe-area-inset-top,0px) + 70px)}
    #buyDrawer .drawer-body{padding-bottom:calc(env(safe-area-inset-bottom,0px) + 200px); overscroll-behavior:contain}
  }

  /* Phone-specific adjustments for smaller devices like iPhone SE */
  @media (max-width:667px){
    #buyDrawer .drawer-body{padding-bottom:calc(env(safe-area-inset-bottom,0px) + 180px) !important;}
  }

  /* Use dynamic viewport height where supported */
  @supports (height: 100dvh){
    #buyDrawer{height:100dvh}
  }

  /* ===== BEAR OVERVIEW SECTION (DexScreener Style) ===== */
  .dex-layout{
    display:grid;
    grid-template-columns:1fr 360px;
    gap:20px;
    margin-top:24px;
  }
  @media(max-width:1100px){
    .dex-layout{grid-template-columns:1fr;}
    .dex-stats-sidebar{order:-1;}
  }

  .dex-chart-container{
    min-height:600px;
  }

  .dex-stats-sidebar{
    display:flex;
    flex-direction:column;
  }

  /* Stats List (DexScreener style) */
  .stats-list{
    display:flex;
    flex-direction:column;
    gap:12px;
  }

  .stat-item{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:12px 14px;
    background:rgba(237,183,35,0.05);
    border-radius:8px;
    border:1px solid rgba(237,183,35,0.15);
    transition:all 0.2s;
  }

  .stat-item:hover{
    background:rgba(237,183,35,0.08);
    border-color:rgba(237,183,35,0.25);
  }

  .stat-label{
    font-size:15px;
    color:#fff;
    opacity:0.7;
    text-transform:uppercase;
    letter-spacing:0.5px;
    font-weight:700;
  }

  .stat-value{
    font-size:20px;
    font-weight:900;
    color:var(--gold);
    text-align:right;
  }

  /* ===== BEAR HONEY POINTS SECTION ===== */
  .honey-points-grid{
    display:grid;
    grid-template-columns:repeat(3, 1fr);
    gap:24px;
    margin-top:24px;
    max-width:1400px;
    margin-left:auto;
    margin-right:auto;
  }
  @media(max-width:1200px){
    .honey-points-grid{grid-template-columns:1fr;}
  }

  .honey-card{
    position: relative;
    background:var(--card);
    border-radius:16px;
    padding:20px;
    box-shadow:var(--elev);
    margin-bottom:20px;
  }
  .honey-card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 16px;
    padding: 6px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: 0;
  }

  .honey-card-title{
    margin:0 0 16px 0;
    font-size:22px;
    font-weight:900;
    color:var(--gold);
    text-transform:uppercase;
    letter-spacing:0.5px;
  }

  /* DEXScreener Style Stats */
  .dex-stats-container {
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid rgba(237,183,35,0.2);
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
  }

  .dex-stat-box {
    background: rgba(0,0,0,0.3);
    border-radius: 8px;
    padding: 12px;
    border: 1px solid rgba(237,183,35,0.15);
  }

  .dex-stat-label {
    font-size: 11px;
    font-weight: 600;
    color: rgba(255,255,255,0.6);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 6px;
  }

  .dex-stat-value {
    font-size: 20px;
    font-weight: 900;
    color: #fff;
    margin-bottom: 8px;
  }

  .dex-stat-subgrid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-bottom: 8px;
  }

  .dex-stat-sub {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .dex-sub-label {
    font-size: 10px;
    font-weight: 600;
    color: rgba(255,255,255,0.5);
    text-transform: uppercase;
    letter-spacing: 0.3px;
  }

  .dex-sub-value {
    font-size: 14px;
    font-weight: 700;
    color: #fff;
  }

  .dex-progress-bar {
    display: flex;
    height: 6px;
    background: rgba(0,0,0,0.4);
    border-radius: 3px;
    overflow: hidden;
    gap: 1px;
  }

  .dex-progress-fill {
    height: 100%;
    transition: width 0.3s ease;
  }

  .dex-progress-buy {
    background: linear-gradient(90deg, #22c55e 0%, #16a34a 100%);
  }

  .dex-progress-sell {
    background: linear-gradient(90deg, #ef4444 0%, #dc2626 100%);
  }

  @media (max-width: 768px) {
    .dex-stats-container {
      grid-template-columns: 1fr;
    }
    .dex-stat-value {
      font-size: 18px;
    }
  }

  /* Price Stats Grid */
  .price-stats-grid{
    display:grid;
    grid-template-columns:repeat(3, 1fr);
    gap:12px;
  }
  @media(max-width:768px){
    .price-stats-grid{grid-template-columns:repeat(2, 1fr);}
  }

  .price-stat{
    background:rgba(237,183,35,0.08);
    padding:14px;
    border-radius:10px;
    border:2px solid rgba(237,183,35,0.2);
  }

  .price-stat-label{
    font-size:12px;
    color:#fff;
    opacity:0.9;
    margin-bottom:6px;
    text-transform:uppercase;
    letter-spacing:0.5px;
  }

  .price-stat-value{
    font-size:20px;
    font-weight:900;
    color:var(--gold);
  }

  /* Chart Container */
  .chart-container{
    background:rgba(0,0,0,0.3);
    border-radius:12px;
    overflow:hidden;
    border:2px solid rgba(0,0,0,0.5);
  }
  .chart-container iframe{
    display:block;
  }

  /* Liquidity Grid */
  .liquidity-grid{
    display:grid;
    gap:12px;
  }

  .liquidity-stat{
    display:flex;
    align-items:center;
    gap:14px;
    background:rgba(237,183,35,0.08);
    padding:16px;
    border-radius:10px;
    border:2px solid rgba(237,183,35,0.2);
  }

  .liquidity-icon{
    font-size:32px;
    line-height:1;
  }

  .liquidity-label{
    font-size:12px;
    color:#fff;
    opacity:0.9;
    margin-bottom:4px;
    text-transform:uppercase;
    letter-spacing:0.5px;
  }

  .liquidity-value{
    font-size:20px;
    font-weight:900;
    color:var(--gold);
  }

  /* My Points Card */
  .my-points-card{
    background:linear-gradient(135deg, rgba(237,183,35,0.15), rgba(215,92,70,0.15));
    border:3px solid var(--gold);
  }

  .points-hero{
    text-align:center;
    padding:24px;
    background:rgba(0,0,0,0.4);
    border-radius:12px;
    margin-bottom:16px;
    border:2px solid rgba(237,183,35,0.3);
  }

  .points-hero-value{
    font-size:56px;
    font-weight:900;
    color:var(--gold);
    line-height:1;
    text-shadow:0 2px 8px rgba(237,183,35,0.5);
  }

  .points-hero-label{
    font-size:14px;
    margin-top:8px;
    opacity:0.8;
    text-transform:uppercase;
    letter-spacing:1px;
  }

  /* Points Breakdown */
  .points-breakdown{
    display:flex;
    flex-direction:column;
    gap:12px;
    margin-bottom:16px;
  }

  .points-breakdown-item{
    display:flex;
    align-items:center;
    gap:16px;
    padding:16px;
    background:rgba(0,0,0,0.3);
    border-radius:12px;
    border:2px solid rgba(237,183,35,0.2);
    transition:all 0.3s ease;
  }

  .points-breakdown-item:hover{
    border-color:rgba(237,183,35,0.4);
    transform:translateX(4px);
  }

  .points-breakdown-icon{
    font-size:32px;
    line-height:1;
  }

  .points-breakdown-content{
    flex:1;
  }

  .points-breakdown-label{
    font-size:14px;
    opacity:0.8;
    margin-bottom:4px;
    text-transform:uppercase;
    letter-spacing:0.5px;
  }

  .points-breakdown-value{
    font-size:24px;
    font-weight:900;
    color:var(--gold);
  }

  /* Daily Game Progress Widget */
  .daily-game-progress{
    background:linear-gradient(135deg, rgba(237,183,35,0.1) 0%, rgba(255,215,0,0.05) 100%);
    border:2px solid rgba(237,183,35,0.3);
    border-radius:16px;
    padding:20px;
    margin:20px 0;
    transition:all 0.3s ease;
  }

  .daily-game-progress:hover{
    border-color:rgba(237,183,35,0.5);
    transform:translateY(-2px);
    box-shadow:0 8px 24px rgba(237,183,35,0.2);
  }

  .daily-progress-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:12px;
  }

  .daily-progress-title{
    font-size:16px;
    font-weight:700;
    color:#fff;
    text-transform:uppercase;
    letter-spacing:0.5px;
  }

  .daily-progress-count{
    font-size:20px;
    font-weight:900;
    color:var(--gold);
    text-shadow:0 0 10px rgba(237,183,35,0.5);
  }

  .daily-progress-bar-container{
    height:12px;
    background:rgba(0,0,0,0.3);
    border-radius:20px;
    overflow:hidden;
    margin-bottom:12px;
    border:1px solid rgba(237,183,35,0.2);
  }

  .daily-progress-bar{
    height:100%;
    background:linear-gradient(90deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%);
    border-radius:20px;
    transition:width 0.6s cubic-bezier(0.65, 0, 0.35, 1);
    box-shadow:0 0 20px rgba(255,215,0,0.6), inset 0 1px 0 rgba(255,255,255,0.3);
    position:relative;
    background-size:200% 100%;
    animation:shimmer 2s infinite;
  }

  @keyframes shimmer{
    0%{ background-position:0% 50%; }
    50%{ background-position:100% 50%; }
    100%{ background-position:0% 50%; }
  }

  /* Shimmer Skeleton Loaders */
  .skeleton {
    background: linear-gradient(90deg, rgba(237,183,35,0.1) 0%, rgba(237,183,35,0.2) 50%, rgba(237,183,35,0.1) 100%);
    background-size: 200% 100%;
    animation: shimmer 2s infinite;
    border-radius: 8px;
    position: relative;
    overflow: hidden;
  }
  .skeleton::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.1) 50%, transparent 100%);
    animation: shimmerSlide 2s infinite;
  }
  @keyframes shimmerSlide {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
  }
  .skeleton-text {
    height: 20px;
    margin-bottom: 10px;
  }
  .skeleton-title {
    height: 32px;
    width: 60%;
    margin-bottom: 16px;
  }
  .skeleton-card {
    height: 200px;
    width: 100%;
  }
  .skeleton-circle {
    width: 50px;
    height: 50px;
    border-radius: 50%;
  }

  .daily-progress-info{
    display:flex;
    justify-content:space-between;
    align-items:center;
    font-size:13px;
  }

  .daily-progress-points{
    color:var(--gold);
    font-weight:700;
    text-shadow:0 0 10px rgba(237,183,35,0.3);
  }

  .daily-progress-remaining{
    color:rgba(255,255,255,0.7);
    font-weight:600;
  }

  .points-rank{
    text-align:center;
    padding:12px;
    background:rgba(0,0,0,0.3);
    border-radius:8px;
    margin-bottom:12px;
    font-size:14px;
  }

  .points-rank strong{
    color:var(--gold);
    font-size:16px;
  }

  .points-twitter{
    display:flex;
    align-items:center;
    justify-content:center;
    gap:8px;
    padding:10px;
    background:rgba(29,155,240,0.1);
    border-radius:8px;
    border:2px solid rgba(29,155,240,0.3);
  }

  .points-cta{
    text-align:center;
    padding:24px;
  }

  /* Leaderboard */
  .leaderboard-card{
    max-height:600px;
    display:flex;
    flex-direction:column;
  }

  .leaderboard{
    flex:1;
    overflow-y:auto;
    margin:-8px;
    padding:8px;
  }

  .leaderboard::-webkit-scrollbar{
    width:8px;
  }

  .leaderboard::-webkit-scrollbar-track{
    background:rgba(0,0,0,0.2);
    border-radius:4px;
  }

  .leaderboard::-webkit-scrollbar-thumb{
    background:var(--gold);
    border-radius:4px;
  }

  .leaderboard-loading{
    text-align:center;
    padding:32px;
    opacity:0.6;
  }

  .leaderboard-item{
    display:flex;
    align-items:center;
    gap:12px;
    padding:12px;
    background:rgba(237,183,35,0.08);
    border-radius:10px;
    border:2px solid rgba(237,183,35,0.2);
    margin-bottom:8px;
    transition:all 0.2s var(--ease-spring);
    opacity: 0;
    transform: translateY(10px);
    animation: fadeInUp 0.4s var(--ease-spring) forwards;
  }
  .leaderboard-item:nth-child(1) { animation-delay: 0.05s; }
  .leaderboard-item:nth-child(2) { animation-delay: 0.1s; }
  .leaderboard-item:nth-child(3) { animation-delay: 0.15s; }
  .leaderboard-item:nth-child(4) { animation-delay: 0.2s; }
  .leaderboard-item:nth-child(5) { animation-delay: 0.25s; }
  .leaderboard-item:nth-child(6) { animation-delay: 0.3s; }
  .leaderboard-item:nth-child(7) { animation-delay: 0.35s; }
  .leaderboard-item:nth-child(8) { animation-delay: 0.4s; }
  .leaderboard-item:nth-child(9) { animation-delay: 0.45s; }
  .leaderboard-item:nth-child(10) { animation-delay: 0.5s; }

  @keyframes fadeInUp {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .leaderboard-item:hover{
    background:rgba(237,183,35,0.15);
    border-color:rgba(237,183,35,0.4);
    transform:translateX(4px);
  }

  .leaderboard-rank{
    font-size:20px;
    font-weight:900;
    color:var(--gold);
    min-width:32px;
    text-align:center;
  }

  .leaderboard-rank.top-3{
    font-size:24px;
  }

  .leaderboard-user{
    flex:1;
    min-width:0;
  }

  .leaderboard-username{
    font-weight:900;
    font-size:14px;
    color:var(--gold);
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  .leaderboard-wallet{
    font-size:11px;
    opacity:0.6;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  .leaderboard-points{
    font-size:16px;
    font-weight:900;
    color:var(--honey);
    white-space:nowrap;
  }

  /* Trophy colors for top 3 */
  .leaderboard-item.rank-1 .leaderboard-rank{color:#FFD700;}
  .leaderboard-item.rank-2 .leaderboard-rank{color:#C0C0C0;}
  .leaderboard-item.rank-3 .leaderboard-rank{color:#CD7F32;}

  .leaderboard-item.rank-1{
    background:linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05));
    border-color:rgba(255,215,0,0.4);
  }

  .leaderboard-item.rank-2{
    background:linear-gradient(135deg, rgba(192,192,192,0.15), rgba(192,192,192,0.05));
    border-color:rgba(192,192,192,0.4);
  }

  .leaderboard-item.rank-3{
    background:linear-gradient(135deg, rgba(205,127,50,0.15), rgba(205,127,50,0.05));
    border-color:rgba(205,127,50,0.4);
  }

  /* Raids Card */
  .raids-card{
    position:relative;
  }

  .admin-raid-btn{
    position:absolute;
    top:-12px;
    left:20px;
    background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color:#fff;
    border:none;
    padding:8px 16px;
    border-radius:8px;
    font-size:12px;
    font-weight:900;
    cursor:pointer;
    text-transform:uppercase;
    letter-spacing:0.5px;
    transition:all 0.3s ease;
    box-shadow:0 4px 12px rgba(102, 126, 234, 0.4);
    z-index:10;
  }
  .admin-raid-btn:hover{
    transform:translateY(-2px) scale(1.05);
    box-shadow:0 6px 20px rgba(102, 126, 234, 0.6);
  }

  .raids-toggle-btn{
    position:absolute;
    top:-12px;
    right:20px;
    background:var(--gold);
    color:#000;
    border:none;
    padding:6px 12px;
    border-radius:6px;
    font-size:11px;
    font-weight:900;
    cursor:pointer;
    text-transform:uppercase;
    letter-spacing:0.5px;
    transition:all 0.2s;
    z-index:10;
  }

  .raids-toggle-btn:hover{
    transform:scale(1.05);
    box-shadow:0 4px 12px rgba(237,183,35,0.4);
  }

  .raids-list{
    display:flex;
    flex-direction:column;
    gap:16px;
    max-height:500px;
    overflow-y:auto;
  }

  .raid-item{
    background:rgba(0,0,0,0.3);
    border:2px solid rgba(237,183,35,0.3);
    border-radius:12px;
    padding:16px;
    transition:all 0.3s;
    display:flex;
    flex-direction:column;
    gap:12px;
  }

  .raid-item:hover{
    border-color:rgba(237,183,35,0.5);
    transform:translateY(-2px);
  }

  .raid-profile-header{
    display:flex;
    align-items:center;
    gap:12px;
    margin-bottom:12px;
  }

  .raid-profile-emoji{
    width:52px;
    height:52px;
    border-radius:50%;
    background:linear-gradient(135deg, rgba(237,183,35,0.15), rgba(237,183,35,0.05));
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:28px;
    flex-shrink:0;
  }

  .raid-profile-pic{
    width:48px;
    height:48px;
    border-radius:50%;
    object-fit:cover;
  }

  .raid-profile-info{
    flex:1;
  }

  .raid-profile-name{
    font-size:15px;
    font-weight:900;
    color:var(--gold);
    margin-bottom:2px;
  }

  .raid-profile-handle{
    font-size:13px;
    opacity:0.7;
  }

  .raid-preview-image{
    width:100%;
    height:200px;
    object-fit:cover;
    border-radius:8px;
    border:2px solid rgba(237,183,35,0.2);
  }

  .raid-tweet-preview{
    margin:16px 0;
    padding:12px;
    background:rgba(0,0,0,0.2);
    border-radius:8px;
    border:1px solid rgba(237,183,35,0.2);
    min-height:100px;
    display:flex;
    align-items:center;
    justify-content:center;
    transition:all 0.3s ease;
  }

  .raid-tweet-preview:hover{
    background:rgba(237,183,35,0.1);
    border-color:rgba(237,183,35,0.4);
    transform:translateY(-2px);
  }

  .raid-preview-loading{
    color:rgba(255,255,255,0.5);
    font-size:13px;
    text-align:center;
  }

  .raid-preview-error{
    color:rgba(255,255,255,0.3);
    font-size:13px;
    text-align:center;
    font-style:italic;
  }

  /* Twitter embed styling */
  .raid-tweet-preview{
    position: relative;
  }

  .raid-tweet-preview blockquote{
    margin:0 !important;
  }

  .raid-tweet-preview .twitter-tweet{
    margin:0 auto !important;
  }

  .raid-tweet-click-overlay{
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    cursor: pointer;
    z-index: 10;
    background: transparent;
  }

  .raid-item.completed{
    opacity:0.6;
    border-color:rgba(0,255,0,0.3);
  }

  .raid-item.missed{
    opacity:0.4;
    border-color:rgba(255,0,0,0.3);
  }

  .raid-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:12px;
  }

  .raid-timer{
    font-size:12px;
    font-weight:900;
    color:var(--gold);
    background:rgba(237,183,35,0.1);
    padding:4px 8px;
    border-radius:6px;
  }

  .raid-timer.expired{
    color:#ff6b6b;
    background:rgba(255,0,0,0.1);
  }

  .raid-description{
    font-size:14px;
    line-height:1.5;
    margin-bottom:12px;
    opacity:0.9;
  }

  .raid-footer{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:12px;
  }

  .raid-reward{
    font-size:13px;
    font-weight:900;
    color:var(--gold);
  }

  .raid-btn{
    background:linear-gradient(135deg, var(--gold), #d4a127);
    color:#000;
    border:none;
    padding:10px 20px;
    border-radius:8px;
    font-size:14px;
    font-weight:900;
    cursor:pointer;
    text-transform:uppercase;
    letter-spacing:0.5px;
    transition:all 0.3s;
    text-decoration:none;
    display:inline-block;
  }

  .raid-btn:hover{
    transform:scale(1.05);
    box-shadow:0 4px 12px rgba(237,183,35,0.4);
  }

  .raid-btn:disabled{
    opacity:0.5;
    cursor:not-allowed;
    transform:none;
  }

  .raids-empty{
    text-align:center;
    padding:32px;
    opacity:0.7;
  }

  /* Completing state */
  .raid-item.completing{
    border-color:rgba(255,215,0,0.6);
    background:rgba(255,215,0,0.05);
  }

  /* Fade out animation */
  .raid-item.fade-out{
    animation:fadeOutSlide 1s ease-out forwards;
  }

  @keyframes fadeOutSlide{
    0%{
      opacity:1;
      transform:translateY(0) scale(1);
      max-height:500px;
    }
    50%{
      opacity:0.5;
      transform:translateY(-10px) scale(0.98);
    }
    100%{
      opacity:0;
      transform:translateY(-20px) scale(0.95);
      max-height:0;
      margin:0;
      padding:0;
      border:none;
    }
  }

  /* Completing button state */
  .raid-btn.completing{
    background:linear-gradient(135deg, #ffd700, #ffa500);
    pointer-events:none;
    animation:pulse 1.5s ease-in-out infinite;
  }

  @keyframes pulse{
    0%, 100%{
      opacity:1;
    }
    50%{
      opacity:0.7;
    }
  }

  /* Image error handling */
  .raid-profile-pic{
    background:rgba(237,183,35,0.1);
  }

  .raid-preview-image{
    background:rgba(0,0,0,0.3);
  }

  @media(max-width:768px){
    .honey-card{
      padding:16px;
    }
    .price-stats-grid{
      grid-template-columns:1fr;
    }
    .points-hero-value{
      font-size:42px;
    }
    .points-breakdown-item{
      flex-direction:row;
      padding:12px;
    }
    .points-breakdown-icon{
      font-size:28px;
    }
    .points-breakdown-label{
      font-size:12px;
    }
    .points-breakdown-value{
      font-size:20px;
    }
    .chart-container iframe{
      height:400px !important;
    }
  }

  /* ===== COSMETICS STORE STYLES ===== */
  .store-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.92);
    backdrop-filter: blur(15px);
    z-index: 10001;
    justify-content: center;
    align-items: center;
  }

  .store-modal.active {
    display: flex;
    animation: modalFadeIn 0.4s cubic-bezier(0.16, 1, 0.3, 1);
  }

  @keyframes modalFadeIn {
    from {
      opacity: 0;
      backdrop-filter: blur(0px);
    }
    to {
      opacity: 1;
      backdrop-filter: blur(15px);
    }
  }

  .store-modal-content {
    background: linear-gradient(135deg, #1a1a2e, #16213e);
    border-radius: 28px;
    border: 5px solid;
    border-image: linear-gradient(135deg, #680cd9, #ffae00, #07ae08) 1;
    max-width: 1100px;
    width: 92%;
    max-height: 92vh;
    overflow: hidden;
    box-shadow: 0 30px 100px rgba(237, 183, 35, 0.4),
                0 0 80px rgba(104, 12, 217, 0.3);
    animation: modalSlideIn 0.6s cubic-bezier(0.16, 1, 0.3, 1);
  }

  @keyframes modalSlideIn {
    0% {
      transform: translateY(-40px) scale(0.95);
      opacity: 0;
    }
    100% {
      transform: translateY(0) scale(1);
      opacity: 1;
    }
  }

  .store-header {
    background: linear-gradient(135deg, rgba(104, 12, 217, 0.4), rgba(237, 183, 35, 0.4), rgba(7, 174, 8, 0.4));
    padding: 28px 36px;
    border-bottom: 4px solid rgba(237, 183, 35, 0.6);
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: relative;
    overflow: hidden;
  }

  .store-header::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255,255,255,0.05), transparent);
    animation: shimmer 3s infinite;
  }

  @keyframes shimmer {
    0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
    100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
  }

  .store-title-section {
    position: relative;
    z-index: 1;
  }

  .store-title {
    font-size: 36px;
    font-weight: 900;
    color: #ffae00;
    text-shadow: 0 3px 12px rgba(237, 183, 35, 0.8),
                 0 0 30px rgba(237, 183, 35, 0.5);
    margin-bottom: 4px;
  }

  .store-subtitle {
    font-size: 14px;
    color: #aaa;
    font-weight: 400;
  }

  .store-balance-container {
    position: relative;
    z-index: 1;
    display: flex;
    gap: 16px;
    align-items: center;
  }

  .store-balance {
    font-size: 28px;
    font-weight: 900;
    color: #ffae00;
    background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,20,30,0.9));
    padding: 14px 24px;
    border-radius: 16px;
    border: 3px solid #ffae00;
    box-shadow: 0 0 20px rgba(255, 174, 0, 0.4),
                inset 0 0 20px rgba(255, 174, 0, 0.1);
    animation: pulseGlow 2s ease-in-out infinite;
  }

  @keyframes pulseGlow {
    0%, 100% { box-shadow: 0 0 20px rgba(255, 174, 0, 0.4), inset 0 0 20px rgba(255, 174, 0, 0.1); }
    50% { box-shadow: 0 0 30px rgba(255, 174, 0, 0.6), inset 0 0 30px rgba(255, 174, 0, 0.2); }
  }

  .store-balance .hp-amount {
    font-size: 32px;
    text-shadow: 0 2px 10px rgba(255, 174, 0, 0.8);
  }

  .store-close-btn {
    background: rgba(255, 0, 0, 0.2);
    border: 3px solid #ff4444;
    color: #ff4444;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    font-size: 28px;
    font-weight: 900;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    z-index: 1;
  }

  .store-close-btn:hover {
    background: rgba(255, 0, 0, 0.5);
    transform: scale(1.15) rotate(90deg);
    box-shadow: 0 0 20px rgba(255, 68, 68, 0.6);
  }

  .store-tabs {
    display: flex;
    gap: 12px;
    padding: 20px 36px;
    background: rgba(0,0,0,0.4);
    border-bottom: 3px solid rgba(237, 183, 35, 0.3);
  }

  .store-tab {
    padding: 14px 28px;
    font-size: 18px;
    font-weight: 900;
    background: rgba(0,0,0,0.6);
    border: 3px solid rgba(237, 183, 35, 0.3);
    border-radius: 14px;
    color: #888;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(.18,.9,.2,1);
    position: relative;
    overflow: hidden;
  }

  .store-tab::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(237, 183, 35, 0.3);
    transform: translate(-50%, -50%);
    transition: width 0.4s, height 0.4s;
  }

  .store-tab:hover::before {
    width: 200%;
    height: 200%;
  }

  .store-tab:hover {
    border-color: rgba(237, 183, 35, 0.7);
    color: #ddd;
    transform: translateY(-2px);
  }

  .store-tab.active {
    background: linear-gradient(135deg, #ffae00, #edb723);
    color: #000;
    border-color: #ffae00;
    box-shadow: 0 4px 15px rgba(255, 174, 0, 0.4);
  }

  .store-tab span {
    position: relative;
    z-index: 1;
  }

  .store-body {
    padding: 36px;
    overflow-y: auto;
    max-height: calc(92vh - 280px);
  }

  .store-body::-webkit-scrollbar {
    width: 12px;
  }

  .store-body::-webkit-scrollbar-track {
    background: rgba(0,0,0,0.3);
    border-radius: 10px;
  }

  .store-body::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #680cd9, #ffae00);
    border-radius: 10px;
  }

  .store-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 24px;
    justify-items: center;
  }

  .store-item {
    background: linear-gradient(135deg, rgba(20,20,30,0.8), rgba(10,10,20,0.9));
    border: 4px solid;
    border-radius: 20px;
    padding: 20px;
    transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
    position: relative;
    overflow: hidden;
    width: 100%;
    max-width: 320px;
    opacity: 0;
    animation: storeItemFadeIn 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  @keyframes storeItemFadeIn {
    0% {
      opacity: 0;
      transform: translateY(20px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .store-item:nth-child(1) { animation-delay: 0.05s; }
  .store-item:nth-child(2) { animation-delay: 0.1s; }
  .store-item:nth-child(3) { animation-delay: 0.15s; }
  .store-item:nth-child(4) { animation-delay: 0.2s; }
  .store-item:nth-child(5) { animation-delay: 0.25s; }
  .store-item:nth-child(6) { animation-delay: 0.3s; }

  .store-item.common { border-color: #22c55e; }
  .store-item.rare { border-color: #3b82f6; }
  .store-item.epic { border-color: #a855f7; }
  .store-item.legendary {
    border-color: #f59e0b;
    background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(239, 68, 68, 0.1));
    animation: legendaryPulse 3s ease-in-out infinite, storeItemFadeIn 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  .store-item.bearableguy123 {
    border-color: #ff0000;
    background: linear-gradient(135deg, rgba(255, 0, 0, 0.2), rgba(139, 0, 0, 0.2));
    animation: bearableguy123Eclipse 3s ease-in-out infinite, storeItemFadeIn 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  @keyframes legendaryPulse {
    0%, 100% {
      box-shadow: 0 4px 20px rgba(245, 158, 11, 0.4), 0 0 30px rgba(239, 68, 68, 0.2);
    }
    50% {
      box-shadow: 0 8px 35px rgba(245, 158, 11, 0.8), 0 0 50px rgba(239, 68, 68, 0.5);
    }
  }

  @keyframes bearableguy123Eclipse {
    0%, 100% {
      box-shadow: 0 6px 30px rgba(255, 0, 0, 0.6),
                  0 0 50px rgba(139, 0, 0, 0.4),
                  0 0 80px rgba(255, 0, 0, 0.3);
      border-color: #ff0000;
    }
    50% {
      box-shadow: 0 10px 50px rgba(255, 0, 0, 1),
                  0 0 80px rgba(139, 0, 0, 0.8),
                  0 0 120px rgba(255, 0, 0, 0.6),
                  0 0 160px rgba(139, 0, 0, 0.4);
      border-color: #ff4444;
    }
  }

  .store-item::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(255,255,255,0.1), transparent 70%);
    opacity: 0;
    transition: opacity 0.4s;
  }

  .store-item:hover::before {
    opacity: 1;
    animation: rotateBg 3s linear infinite;
  }

  @keyframes rotateBg {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  .store-item:hover {
    transform: translateY(-6px) scale(1.02);
  }

  .store-item.common:hover {
    box-shadow: 0 12px 40px rgba(34, 197, 94, 0.4);
  }

  .store-item.rare:hover {
    box-shadow: 0 12px 40px rgba(59, 130, 246, 0.5);
  }

  .store-item.epic:hover {
    box-shadow: 0 12px 40px rgba(168, 85, 247, 0.6);
  }

  .store-item.legendary:hover {
    box-shadow: 0 16px 50px rgba(245, 158, 11, 0.7),
                0 0 60px rgba(239, 68, 68, 0.5);
    transform: translateY(-8px) scale(1.03);
  }

  .store-item.bearableguy123:hover {
    box-shadow: 0 20px 60px rgba(255, 0, 0, 0.9),
                0 0 80px rgba(139, 0, 0, 0.8),
                0 0 120px rgba(255, 0, 0, 0.6);
    transform: translateY(-10px) scale(1.05);
  }

  .store-item-preview {
    width: 100%;
    height: 140px;
    background: rgba(0,0,0,0.7);
    border-radius: 16px;
    margin-bottom: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
  }

  .store-item-badge {
    position: absolute;
    top: 10px;
    right: 10px;
    padding: 6px 14px;
    border-radius: 10px;
    font-size: 13px;
    font-weight: 900;
    text-transform: uppercase;
    box-shadow: 0 3px 10px rgba(0,0,0,0.4);
    z-index: 2;
  }

  .rarity-common {
    background: linear-gradient(135deg, #22c55e, #16a34a);
    color: #fff;
  }

  .rarity-rare {
    background: linear-gradient(135deg, #3b82f6, #2563eb);
    color: #fff;
  }

  .rarity-epic {
    background: linear-gradient(135deg, #a855f7, #9333ea);
    color: #fff;
    animation: epicGlow 2s ease-in-out infinite;
  }

  @keyframes epicGlow {
    0%, 100% { box-shadow: 0 3px 10px rgba(168, 85, 247, 0.4); }
    50% { box-shadow: 0 3px 20px rgba(168, 85, 247, 0.8); }
  }

  .rarity-legendary {
    background: linear-gradient(135deg, #f59e0b, #ef4444);
    color: #fff;
    animation: legendaryShine 2s linear infinite;
    position: relative;
    overflow: hidden;
  }

  .rarity-legendary::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255,255,255,0.6), transparent);
    animation: shineMove 2s infinite;
  }

  .rarity-bearableguy123 {
    background: linear-gradient(135deg, #ff0000, #8b0000);
    color: #fff;
    animation: bearableguy123Shine 1.5s linear infinite;
    position: relative;
    overflow: hidden;
  }

  .rarity-bearableguy123::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255,255,255,0.8), transparent);
    animation: shineMove 1.5s infinite;
  }

  @keyframes shineMove {
    0% { transform: translateX(-100%) rotate(45deg); }
    100% { transform: translateX(100%) rotate(45deg); }
  }

  @keyframes legendaryShine {
    0%, 100% { box-shadow: 0 3px 15px rgba(245, 158, 11, 0.6), 0 0 25px rgba(239, 68, 68, 0.4); }
    50% { box-shadow: 0 3px 25px rgba(245, 158, 11, 1), 0 0 40px rgba(239, 68, 68, 0.7); }
  }

  @keyframes bearableguy123Shine {
    0%, 100% {
      box-shadow: 0 4px 20px rgba(255, 0, 0, 0.8),
                  0 0 35px rgba(139, 0, 0, 0.6),
                  0 0 50px rgba(255, 0, 0, 0.4);
    }
    50% {
      box-shadow: 0 4px 30px rgba(255, 0, 0, 1),
                  0 0 50px rgba(139, 0, 0, 1),
                  0 0 70px rgba(255, 0, 0, 0.8);
    }
  }

  .store-item-name {
    font-size: 20px;
    font-weight: 900;
    margin-bottom: 10px;
  }

  .store-item.common .store-item-name { color: #22c55e; }
  .store-item.rare .store-item-name { color: #3b82f6; }
  .store-item.epic .store-item-name { color: #a855f7; }
  .store-item.legendary .store-item-name {
    background: linear-gradient(135deg, #f59e0b, #ef4444);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .store-item.bearableguy123 .store-item-name {
    background: linear-gradient(135deg, #ff0000, #ff4444, #ff0000);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: redPulse 2s ease-in-out infinite;
  }

  @keyframes redPulse {
    0%, 100% { filter: drop-shadow(0 0 5px rgba(255, 0, 0, 0.6)); }
    50% { filter: drop-shadow(0 0 15px rgba(255, 0, 0, 1)); }
  }

  .store-item-description {
    font-size: 14px;
    color: #aaa;
    margin-bottom: 16px;
    min-height: 42px;
    line-height: 1.4;
  }

  .store-item-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
  }

  .store-item-price {
    font-size: 24px;
    font-weight: 900;
    color: #ffae00;
    text-shadow: 0 2px 8px rgba(255, 174, 0, 0.6);
  }

  .store-item-btn {
    padding: 10px 20px;
    font-size: 16px;
    font-weight: 900;
    background: linear-gradient(135deg, #ffae00, #edb723);
    color: #000;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    box-shadow: 0 4px 12px rgba(237, 183, 35, 0.4);
    font-family: inherit;
    position: relative;
    overflow: hidden;
  }

  .store-item-btn::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.4);
    transform: translate(-50%, -50%);
    transition: width 0.5s cubic-bezier(0.16, 1, 0.3, 1), height 0.5s cubic-bezier(0.16, 1, 0.3, 1);
  }

  .store-item-btn:hover::before {
    width: 300%;
    height: 300%;
  }

  .store-item-btn:hover {
    background: linear-gradient(135deg, #ffc422, #ffae00);
    transform: scale(1.05) translateY(-2px);
    box-shadow: 0 8px 24px rgba(237, 183, 35, 0.6);
  }

  .store-item-btn:active {
    animation: btnBounce 0.5s cubic-bezier(0.16, 1, 0.3, 1);
  }

  @keyframes btnBounce {
    0% { transform: scale(1.05) translateY(-2px); }
    40% { transform: scale(0.92); }
    60% { transform: scale(1.08); }
    80% { transform: scale(0.98); }
    100% { transform: scale(1); }
  }

  /* Owned button state */
  .store-item-btn.owned,
  .store-item-btn:disabled {
    background: linear-gradient(135deg, #6b7280, #9ca3af);
    color: #fff;
    cursor: not-allowed;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  }

  .store-item-btn.owned:hover,
  .store-item-btn:disabled:hover {
    transform: none;
    background: linear-gradient(135deg, #6b7280, #9ca3af);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  }

  .store-item-btn.owned::before,
  .store-item-btn:disabled::before {
    display: none;
  }

  /* Owned badge */
  .store-item-owned-badge {
    position: absolute;
    top: 10px;
    left: 10px;
    padding: 6px 12px;
    background: linear-gradient(135deg, #10b981, #059669);
    color: #fff;
    border-radius: 10px;
    font-size: 13px;
    font-weight: 900;
    text-transform: uppercase;
    box-shadow: 0 3px 10px rgba(16, 185, 129, 0.5);
    z-index: 3;
    animation: ownedPulse 2s ease-in-out infinite;
  }

  @keyframes ownedPulse {
    0%, 100% { box-shadow: 0 3px 10px rgba(16, 185, 129, 0.5); }
    50% { box-shadow: 0 3px 20px rgba(16, 185, 129, 0.8); }
  }

  /* Equipped badge */
  .store-item-equipped-badge {
    position: absolute;
    top: 10px;
    left: 10px;
    padding: 6px 12px;
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
    color: #000;
    border-radius: 10px;
    font-size: 13px;
    font-weight: 900;
    text-transform: uppercase;
    box-shadow: 0 3px 10px rgba(251, 191, 36, 0.5);
    z-index: 3;
    animation: equippedGlow 2s ease-in-out infinite;
  }

  @keyframes equippedGlow {
    0%, 100% { box-shadow: 0 3px 10px rgba(251, 191, 36, 0.5); }
    50% { box-shadow: 0 3px 20px rgba(251, 191, 36, 0.9); }
  }

  /* Equipped button state */
  .store-item-btn.equipped {
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
    color: #000;
    box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
  }

  .store-item-btn.equipped:hover {
    background: linear-gradient(135deg, #fcd34d, #fbbf24);
    transform: scale(1.05) translateY(-2px);
    box-shadow: 0 8px 24px rgba(251, 191, 36, 0.6);
  }

  .owned-badge {
    background: linear-gradient(135deg, #22c55e, #16a34a);
    color: #fff;
    padding: 8px 16px;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 900;
    box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
    animation: ownedBadgeFadeIn 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  @keyframes ownedBadgeFadeIn {
    0% {
      opacity: 0;
      transform: scale(0.8);
    }
    100% {
      opacity: 1;
      transform: scale(1);
    }
  }

  /* Ring preview styles */
  .ring-demo {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    position: relative;
    background: transparent;
  }

  .ring-border {
    position: absolute;
    inset: -6px;
    border-radius: 50%;
  }

  .ring-border.purple { border: 6px solid #680cd9; }
  .ring-border.green { border: 6px solid #07ae08; }
  .ring-border.yellow { border: 6px solid #ffae00; }

  .ring-border.bearableguy123 {
    border: none;
    background: radial-gradient(circle, transparent 40%, rgba(255, 0, 0, 0.3) 60%, transparent 80%);
    animation: eclipseGlow 2s ease-in-out infinite;
  }
  .ring-border.bearableguy123::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 50%;
    border: 6px solid #ff0000;
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.8),
                0 0 40px rgba(139, 0, 0, 0.6);
    animation: eclipseGlow 2s ease-in-out infinite;
  }
  .ring-border.bearableguy123::after {
    content: '';
    position: absolute;
    inset: 6px;
    background: rgba(0,0,0,0.7);
    border-radius: 50%;
    z-index: 1;
  }
  @keyframes eclipseGlow {
    0%, 100% {
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.6),
                  0 0 40px rgba(139, 0, 0, 0.4);
    }
    50% {
      box-shadow: 0 0 20px rgba(255, 0, 0, 1),
                  0 0 40px rgba(139, 0, 0, 0.8);
    }
  }

  .ring-border.tricolor {
    background: conic-gradient(
      #680cd9 0deg 120deg,
      #ffae00 120deg 240deg,
      #07ae08 240deg 360deg
    );
  }

  .ring-border.tricolor::before {
    content: '';
    position: absolute;
    inset: 6px;
    background: rgba(0,0,0,0.7);
    border-radius: 50%;
  }

  .ring-border.animated {
    background: conic-gradient(
      #680cd9 0deg 120deg,
      #ffae00 120deg 240deg,
      #07ae08 240deg 360deg
    );
    animation: spinRing 2s linear infinite;
    transform-origin: center;
  }

  .ring-border.animated::before {
    content: '';
    position: absolute;
    inset: 6px;
    background: rgba(0,0,0,0.7);
    border-radius: 50%;
  }

  @keyframes spinRing {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  .ring-demo img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
  }

  @keyframes spinRingImage {
    from { transform: translate(-50%, -50%) rotate(0deg); }
    to { transform: translate(-50%, -50%) rotate(360deg); }
  }

  .ring-glow-wrapper {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100px;
    height: 100px;
    border-radius: 50%;
    z-index: 0;
  }

  .ring-glow-wrapper.ouroboros {
    box-shadow: 0 0 20px rgba(7, 174, 8, 0.6), 0 0 40px rgba(7, 174, 8, 0.4);
    animation: glowPulse-ouroboros 2s ease-in-out infinite;
  }

  .ring-glow-wrapper.waves {
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.6), 0 0 40px rgba(255, 255, 255, 0.4);
    animation: glowPulse-waves 2s ease-in-out infinite;
  }

  .ring-glow-wrapper.castle {
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.6), 0 0 40px rgba(255, 255, 255, 0.4);
    animation: glowPulse-castle 2s ease-in-out infinite;
  }

  @keyframes glowPulse-ouroboros {
    0%, 100% {
      box-shadow: 0 0 20px rgba(7, 174, 8, 0.6), 0 0 40px rgba(7, 174, 8, 0.4);
    }
    50% {
      box-shadow: 0 0 20px rgba(7, 174, 8, 1), 0 0 40px rgba(7, 174, 8, 0.8);
    }
  }

  @keyframes glowPulse-waves {
    0%, 100% {
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.6), 0 0 40px rgba(255, 255, 255, 0.4);
    }
    50% {
      box-shadow: 0 0 20px rgba(255, 255, 255, 1), 0 0 40px rgba(255, 255, 255, 0.8);
    }
  }

  @keyframes glowPulse-castle {
    0%, 100% {
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.6), 0 0 40px rgba(255, 255, 255, 0.4);
    }
    50% {
      box-shadow: 0 0 20px rgba(255, 255, 255, 1), 0 0 40px rgba(255, 255, 255, 0.8);
    }
  }

  /* Image-based ring sizes for desktop - UPDATED */
  .store-item-preview img.image-ring-ouroboros {
    width: 140px !important;
    height: 140px !important;
    max-width: 140px !important;
    max-height: 140px !important;
  }

  .store-item-preview img.image-ring-castle,
  .store-item-preview img.image-ring-castle-static {
    width: 145px !important;
    height: 145px !important;
    max-width: 145px !important;
    max-height: 145px !important;
  }

  .store-item-preview img.image-ring-waves,
  .store-item-preview img.image-ring-waves-static {
    width: 130px !important;
    height: 130px !important;
    max-width: 130px !important;
    max-height: 130px !important;
  }

  /* Banner demo */
  .banner-demo {
    width: 100%;
    height: 100%;
    border-radius: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
  }

  .banner-profile-preview {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    overflow: hidden;
    border: 4px solid rgba(255,255,255,0.2);
    box-shadow: 0 4px 16px rgba(0,0,0,0.5);
    position: relative;
    z-index: 1;
  }

  .banner-profile-preview img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  /* Celebration overlay */
  .celebration-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 20000;
    pointer-events: none;
  }

  .celebration-overlay.active {
    display: block;
  }

  .celebration-content {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    pointer-events: none;
  }

  .celebration-icon {
    font-size: 120px;
    animation: celebrationBounce 1.5s cubic-bezier(0.16, 1, 0.3, 1),
               iconFadeOut 0.8s cubic-bezier(0.16, 1, 0.3, 1) 4s forwards;
    filter: drop-shadow(0 0 20px rgba(255, 174, 0, 0.6));
  }

  @keyframes celebrationBounce {
    0% {
      transform: scale(0) rotate(-30deg);
      opacity: 0;
      filter: blur(10px) drop-shadow(0 0 20px rgba(255, 174, 0, 0.6));
    }
    50% {
      transform: scale(1.2) rotate(10deg);
      opacity: 1;
      filter: blur(0px) drop-shadow(0 0 30px rgba(255, 174, 0, 0.8));
    }
    70% {
      transform: scale(0.9) rotate(-5deg);
    }
    85% {
      transform: scale(1.05) rotate(2deg);
    }
    100% {
      transform: scale(1) rotate(0deg);
      opacity: 1;
      filter: blur(0px) drop-shadow(0 0 20px rgba(255, 174, 0, 0.6));
    }
  }

  @keyframes iconFadeOut {
    0% {
      opacity: 1;
      transform: scale(1) rotate(0deg);
      filter: blur(0px) drop-shadow(0 0 20px rgba(255, 174, 0, 0.6));
    }
    100% {
      opacity: 0;
      transform: scale(0.8) rotate(15deg);
      filter: blur(10px) drop-shadow(0 0 0px rgba(255, 174, 0, 0));
    }
  }

  .celebration-text {
    font-size: 48px;
    font-weight: 900;
    margin-top: 20px;
    text-shadow: 0 4px 20px rgba(0,0,0,0.8);
    animation: textSlideUp 1.2s cubic-bezier(0.16, 1, 0.3, 1) 0.3s backwards,
               textFadeOut 0.8s cubic-bezier(0.16, 1, 0.3, 1) 4s forwards;
  }

  @keyframes textSlideUp {
    0% {
      transform: translateY(20px);
      opacity: 0;
      filter: blur(5px);
    }
    100% {
      transform: translateY(0);
      opacity: 1;
      filter: blur(0px);
    }
  }

  @keyframes textFadeOut {
    0% {
      opacity: 1;
      filter: blur(0px);
    }
    100% {
      opacity: 0;
      filter: blur(10px);
      transform: translateY(-10px);
    }
  }

  .celebration-subtext {
    font-size: 24px;
    margin-top: 10px;
    opacity: 0.9;
    animation: textSlideUp 1.2s cubic-bezier(0.16, 1, 0.3, 1) 0.4s backwards,
               textFadeOut 0.8s cubic-bezier(0.16, 1, 0.3, 1) 4s forwards;
  }

  .confetti {
    position: absolute;
    width: 10px;
    height: 10px;
    background: #ffae00;
    border-radius: 2px;
    animation: confettiFall 3.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    box-shadow: 0 0 10px rgba(255, 174, 0, 0.6);
    pointer-events: none;
  }

  @keyframes confettiFall {
    0% {
      transform: translateY(0) translateX(0) rotate(0deg) scale(1);
      opacity: 1;
    }
    100% {
      transform: translateY(100vh) translateX(var(--drift, 0)) rotate(1080deg) scale(0.5);
      opacity: 0;
    }
  }

  /* Rarity Section Styles */
  .rarity-section {
    margin-bottom: 48px;
    position: relative;
    background: linear-gradient(135deg, rgba(20,20,30,0.6), rgba(10,10,20,0.8));
    border-radius: 24px;
    padding: 24px;
    border: 4px solid;
  }

  .common-section {
    border-color: #22c55e;
    box-shadow: 0 4px 20px rgba(34, 197, 94, 0.2);
  }

  .rare-section {
    border-color: #3b82f6;
    box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
  }

  .epic-section {
    border-color: #a855f7;
    box-shadow: 0 6px 30px rgba(168, 85, 247, 0.4);
  }

  .legendary-section {
    border-color: #f59e0b;
    box-shadow: 0 8px 40px rgba(245, 158, 11, 0.5),
                0 0 60px rgba(239, 68, 68, 0.3);
  }

  .bearableguy123-section {
    border-color: #ff0000;
    box-shadow: 0 10px 50px rgba(255, 0, 0, 0.7),
                0 0 80px rgba(139, 0, 0, 0.5),
                0 0 120px rgba(255, 0, 0, 0.3);
    animation: sectionEclipse 3s ease-in-out infinite;
  }

  @keyframes sectionEclipse {
    0%, 100% {
      box-shadow: 0 10px 50px rgba(255, 0, 0, 0.7),
                  0 0 80px rgba(139, 0, 0, 0.5),
                  0 0 120px rgba(255, 0, 0, 0.3);
    }
    50% {
      box-shadow: 0 15px 70px rgba(255, 0, 0, 1),
                  0 0 120px rgba(139, 0, 0, 0.8),
                  0 0 180px rgba(255, 0, 0, 0.6);
    }
  }

  .rarity-header {
    font-size: 28px;
    font-weight: 900;
    padding: 20px 32px;
    border-radius: 16px;
    margin-bottom: 24px;
    text-align: center;
    position: relative;
    overflow: hidden;
    border: 4px solid;
    text-shadow: 0 2px 10px rgba(0,0,0,0.5);
    z-index: 1;
  }

  .rarity-header::before,
  .rarity-header::after {
    z-index: -1;
  }

  .rarity-header > * {
    position: relative;
    z-index: 2;
  }

  .common-header {
    background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(22, 163, 74, 0.2));
    border-color: #22c55e;
    color: #22c55e;
  }

  .rare-header {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.2));
    border-color: #3b82f6;
    color: #3b82f6;
    box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
  }

  .epic-header {
    background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(147, 51, 234, 0.2));
    border-color: #a855f7;
    color: #a855f7;
    animation: epicHeaderGlow 2s ease-in-out infinite;
  }

  @keyframes epicHeaderGlow {
    0%, 100% {
      box-shadow: 0 4px 20px rgba(168, 85, 247, 0.4), 0 0 30px rgba(168, 85, 247, 0.2);
    }
    50% {
      box-shadow: 0 6px 30px rgba(168, 85, 247, 0.7), 0 0 50px rgba(168, 85, 247, 0.4);
    }
  }

  .legendary-header {
    background: linear-gradient(135deg, rgba(245, 158, 11, 0.3), rgba(239, 68, 68, 0.3));
    border-color: #f59e0b;
    color: #f59e0b;
    animation: legendaryHeaderGlow 2s ease-in-out infinite;
    position: relative;
  }

  .legendary-header::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(245, 158, 11, 0.3), transparent);
    animation: shineMove 3s infinite;
  }

  @keyframes legendaryHeaderGlow {
    0%, 100% {
      box-shadow: 0 6px 30px rgba(245, 158, 11, 0.5), 0 0 40px rgba(239, 68, 68, 0.3);
    }
    50% {
      box-shadow: 0 8px 50px rgba(245, 158, 11, 0.8), 0 0 70px rgba(239, 68, 68, 0.6);
    }
  }

  .bearableguy123-header {
    background: linear-gradient(135deg, rgba(255, 0, 0, 0.4), rgba(139, 0, 0, 0.4));
    border-color: #ff0000;
    color: #ff0000;
    animation: bearableguy123HeaderGlow 2s ease-in-out infinite;
    position: relative;
    font-size: 32px;
  }

  .bearableguy123-header::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(255, 0, 0, 0.3), transparent 70%);
    animation: rotateBg 4s linear infinite;
  }

  .bearableguy123-header::after {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255, 0, 0, 0.5), transparent);
    animation: shineMove 2s infinite;
  }

  @keyframes bearableguy123HeaderGlow {
    0%, 100% {
      box-shadow: 0 8px 40px rgba(255, 0, 0, 0.7),
                  0 0 60px rgba(139, 0, 0, 0.5),
                  0 0 100px rgba(255, 0, 0, 0.3);
      border-color: #ff0000;
    }
    50% {
      box-shadow: 0 12px 60px rgba(255, 0, 0, 1),
                  0 0 100px rgba(139, 0, 0, 0.9),
                  0 0 150px rgba(255, 0, 0, 0.7),
                  0 0 200px rgba(139, 0, 0, 0.5);
      border-color: #ff4444;
    }
  }

  /* Shake animations */
  @keyframes shake {
    0%, 100% {
      transform: translateX(0) rotate(0deg);
    }
    10% {
      transform: translateX(-6px) rotate(-1deg);
    }
    20% {
      transform: translateX(6px) rotate(1deg);
    }
    30% {
      transform: translateX(-6px) rotate(-1deg);
    }
    40% {
      transform: translateX(6px) rotate(1deg);
    }
    50% {
      transform: translateX(-4px) rotate(-0.5deg);
    }
    60% {
      transform: translateX(4px) rotate(0.5deg);
    }
    70% {
      transform: translateX(-2px) rotate(-0.25deg);
    }
    80% {
      transform: translateX(2px) rotate(0.25deg);
    }
    90% {
      transform: translateX(-1px) rotate(0deg);
    }
  }

  @keyframes shake-medium {
    0%, 100% {
      transform: translate(0, 0) rotate(0deg);
    }
    10% {
      transform: translate(-10px, -5px) rotate(-2deg);
    }
    20% {
      transform: translate(10px, 5px) rotate(2deg);
    }
    30% {
      transform: translate(-10px, 3px) rotate(-1.5deg);
    }
    40% {
      transform: translate(10px, -3px) rotate(1.5deg);
    }
    50% {
      transform: translate(-8px, 2px) rotate(-1deg);
    }
    60% {
      transform: translate(8px, -2px) rotate(1deg);
    }
    70% {
      transform: translate(-5px, 1px) rotate(-0.5deg);
    }
    80% {
      transform: translate(5px, -1px) rotate(0.5deg);
    }
    90% {
      transform: translate(-2px, 0) rotate(0deg);
    }
  }

  @keyframes shake-heavy {
    0%, 100% {
      transform: translate(0, 0) rotate(0deg) scale(1);
    }
    10% {
      transform: translate(-15px, -8px) rotate(-3deg) scale(1.02);
    }
    20% {
      transform: translate(15px, 8px) rotate(3deg) scale(0.98);
    }
    30% {
      transform: translate(-15px, 5px) rotate(-2.5deg) scale(1.02);
    }
    40% {
      transform: translate(15px, -5px) rotate(2.5deg) scale(0.98);
    }
    50% {
      transform: translate(-12px, 3px) rotate(-2deg) scale(1.01);
    }
    60% {
      transform: translate(12px, -3px) rotate(2deg) scale(0.99);
    }
    70% {
      transform: translate(-8px, 2px) rotate(-1deg) scale(1.01);
    }
    80% {
      transform: translate(8px, -2px) rotate(1deg) scale(0.99);
    }
    90% {
      transform: translate(-3px, 0) rotate(0deg) scale(1);
    }
  }

  @keyframes shake-legendary {
    0%, 100% {
      transform: translate(0, 0) rotate(0deg) scale(1);
    }
    5% {
      transform: translate(-20px, -12px) rotate(-5deg) scale(1.05);
    }
    10% {
      transform: translate(20px, 12px) rotate(5deg) scale(0.95);
    }
    15% {
      transform: translate(-20px, 8px) rotate(-4deg) scale(1.05);
    }
    20% {
      transform: translate(20px, -8px) rotate(4deg) scale(0.95);
    }
    25% {
      transform: translate(-18px, 10px) rotate(-4deg) scale(1.04);
    }
    30% {
      transform: translate(18px, -10px) rotate(4deg) scale(0.96);
    }
    35% {
      transform: translate(-15px, 5px) rotate(-3deg) scale(1.03);
    }
    40% {
      transform: translate(15px, -5px) rotate(3deg) scale(0.97);
    }
    45% {
      transform: translate(-15px, 3px) rotate(-3deg) scale(1.03);
    }
    50% {
      transform: translate(15px, -3px) rotate(3deg) scale(0.97);
    }
    55% {
      transform: translate(-12px, 2px) rotate(-2deg) scale(1.02);
    }
    60% {
      transform: translate(12px, -2px) rotate(2deg) scale(0.98);
    }
    65% {
      transform: translate(-10px, 2px) rotate(-2deg) scale(1.02);
    }
    70% {
      transform: translate(10px, -2px) rotate(2deg) scale(0.98);
    }
    75% {
      transform: translate(-8px, 1px) rotate(-1deg) scale(1.01);
    }
    80% {
      transform: translate(8px, -1px) rotate(1deg) scale(0.99);
    }
    85% {
      transform: translate(-5px, 0) rotate(-0.5deg) scale(1.01);
    }
    90% {
      transform: translate(5px, 0) rotate(0.5deg) scale(0.99);
    }
    95% {
      transform: translate(-2px, 0) rotate(0deg) scale(1);
    }
  }

  @keyframes shake-bearableguy123 {
    0%, 100% {
      transform: translate(0, 0) rotate(0deg) scale(1);
    }
    3% {
      transform: translate(-30px, -18px) rotate(-8deg) scale(1.08);
    }
    6% {
      transform: translate(30px, 18px) rotate(8deg) scale(0.92);
    }
    9% {
      transform: translate(-28px, 15px) rotate(-7deg) scale(1.07);
    }
    12% {
      transform: translate(28px, -15px) rotate(7deg) scale(0.93);
    }
    15% {
      transform: translate(-26px, 12px) rotate(-6deg) scale(1.06);
    }
    18% {
      transform: translate(26px, -12px) rotate(6deg) scale(0.94);
    }
    21% {
      transform: translate(-24px, 10px) rotate(-6deg) scale(1.06);
    }
    24% {
      transform: translate(24px, -10px) rotate(6deg) scale(0.94);
    }
    27% {
      transform: translate(-22px, 8px) rotate(-5deg) scale(1.05);
    }
    30% {
      transform: translate(22px, -8px) rotate(5deg) scale(0.95);
    }
    33% {
      transform: translate(-20px, 6px) rotate(-4deg) scale(1.04);
    }
    36% {
      transform: translate(20px, -6px) rotate(4deg) scale(0.96);
    }
    39% {
      transform: translate(-18px, 5px) rotate(-4deg) scale(1.04);
    }
    42% {
      transform: translate(18px, -5px) rotate(4deg) scale(0.96);
    }
    45% {
      transform: translate(-16px, 4px) rotate(-3deg) scale(1.03);
    }
    48% {
      transform: translate(16px, -4px) rotate(3deg) scale(0.97);
    }
    51% {
      transform: translate(-14px, 3px) rotate(-3deg) scale(1.03);
    }
    54% {
      transform: translate(14px, -3px) rotate(3deg) scale(0.97);
    }
    57% {
      transform: translate(-12px, 2px) rotate(-2deg) scale(1.02);
    }
    60% {
      transform: translate(12px, -2px) rotate(2deg) scale(0.98);
    }
    63% {
      transform: translate(-10px, 2px) rotate(-2deg) scale(1.02);
    }
    66% {
      transform: translate(10px, -2px) rotate(2deg) scale(0.98);
    }
    69% {
      transform: translate(-8px, 1px) rotate(-1deg) scale(1.01);
    }
    72% {
      transform: translate(8px, -1px) rotate(1deg) scale(0.99);
    }
    75% {
      transform: translate(-6px, 1px) rotate(-1deg) scale(1.01);
    }
    78% {
      transform: translate(6px, -1px) rotate(1deg) scale(0.99);
    }
    81% {
      transform: translate(-4px, 0) rotate(-0.5deg) scale(1.005);
    }
    84% {
      transform: translate(4px, 0) rotate(0.5deg) scale(0.995);
    }
    87% {
      transform: translate(-3px, 0) rotate(-0.5deg) scale(1.005);
    }
    90% {
      transform: translate(3px, 0) rotate(0.5deg) scale(0.995);
    }
    93% {
      transform: translate(-2px, 0) rotate(0deg) scale(1.002);
    }
    96% {
      transform: translate(2px, 0) rotate(0deg) scale(0.998);
    }
  }

  /* Mobile responsive styles for cosmetics store */
  @media (max-width: 768px) {
    .store-modal-content {
      width: 98%;
      max-height: 95vh;
    }

    .store-header {
      padding: 12px 16px;
      flex-direction: column;
      gap: 8px;
    }

    .store-title {
      font-size: 20px;
    }

    .store-subtitle {
      font-size: 11px;
    }

    .store-balance-container {
      width: 100%;
      justify-content: space-between;
    }

    .store-balance {
      font-size: 18px;
      padding: 8px 14px;
    }

    .store-balance .hp-amount {
      font-size: 22px;
    }

    .store-close-btn {
      width: 32px;
      height: 32px;
      font-size: 22px;
    }

    .store-tabs {
      padding: 8px 12px;
      gap: 6px;
    }

    .store-tab {
      padding: 8px 14px;
      font-size: 13px;
      flex: 1;
    }

    .store-body {
      padding: 12px;
      max-height: calc(95vh - 180px);
    }

    .store-grid {
      grid-template-columns: 1fr;
      gap: 16px;
    }

    .store-item {
      padding: 14px;
    }

    .store-item-preview {
      height: 120px;
      margin-bottom: 12px;
    }

    .store-item-badge {
      font-size: 10px;
      padding: 5px 10px;
      top: 8px;
      right: 8px;
    }

    .store-item-name {
      font-size: 16px;
      margin-bottom: 8px;
    }

    .store-item-description {
      font-size: 12px;
      margin-bottom: 12px;
      min-height: auto;
      line-height: 1.4;
    }

    .store-item-footer {
      flex-direction: row;
      align-items: center;
      gap: 10px;
    }

    .store-item-price {
      font-size: 20px;
    }

    .store-item-btn {
      padding: 10px 18px;
      font-size: 14px;
      white-space: nowrap;
    }

    .ring-demo {
      width: 100px !important;
      height: 100px !important;
    }

    .celebration-icon {
      font-size: 80px;
    }

    .celebration-text {
      font-size: 32px;
    }

    .celebration-subtext {
      font-size: 18px;
    }

    .rarity-section {
      margin-bottom: 28px;
      padding: 16px;
      border-width: 3px;
    }

    .rarity-header {
      font-size: 20px;
      padding: 14px 18px;
      margin-bottom: 16px;
      border-width: 3px;
    }

    .bearableguy123-header {
      font-size: 22px;
    }
  }
  /* ===== END COSMETICS STORE STYLES ===== */

  </style>

  <!-- Twitter Widgets Script for Embedded Tweets -->
  <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

  <!-- PWA Push Notifications -->
  <script src="/frontend/push-notifications.js"></script>
</head>
<body>
  <!-- Fixed Top Navigation -->
  <div class="top-nav">
    <div class="top-nav-stripes">
      <div class="stripe-1"></div>
      <div class="stripe-2"></div>
      <div class="stripe-3"></div>
    </div>
    <div class="top-nav-bar">
      <button class="menu-btn" onclick="toggleMenu()" aria-label="Open menu">
        <img src="https://files.catbox.moe/1z14d9.jpg" alt="BEAR Park" width="52" height="52">
      </button>
      <div class="nav-buttons-container">
        <button class="notification-bell-btn" id="notificationBellBtn" onclick="toggleNotificationPanel()" aria-label="Notifications">
          <span id="bellIcon">🔔</span>
          <span class="notification-badge" id="notificationBadge" style="display: none;">0</span>
        </button>
        <button class="honey-points-btn" onclick="window.scrollTo({top: document.getElementById('honey-points').offsetTop - 80, behavior: 'smooth'})" title="Honey Points">
          <img src="https://files.catbox.moe/wyfjtc.png" alt="honey">
          <span id="welcomePoints">0</span>
        </button>
        <button class="welcome-profile-btn" id="welcomeBtn">
          <span id="welcomeUsername">WELCOME BEAR (click me!)</span>
          <img class="welcome-avatar" id="welcomeAvatar" style="display: none;" alt="Profile Avatar" width="40" height="40">
        </button>

        <!-- Notification Panel -->
        <div class="notification-panel" id="notificationPanel">
          <div class="notification-panel-header">
            <h3>🔔 NOTIFICATIONS</h3>
            <button class="notification-close-btn" onclick="toggleNotificationPanel()" aria-label="Close notifications">&times;</button>
          </div>
          <div class="notification-list" id="notificationList">
            <div class="notification-empty">
              <div class="notification-empty-icon">🔕</div>
              <p>No notifications yet!</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Menu Overlay -->
  <div class="menu-scrim" id="menuScrim" onclick="toggleMenu()"></div>
  <div class="menu-overlay" id="menuOverlay">
    <div class="menu-overlay-header">
      <h2><img src="https://files.catbox.moe/1z14d9.jpg" alt="BEAR PARK" style="height:2.5em; width:auto; border-radius:12px; display:inline-block;"></h2>
      <button class="menu-close-btn" onclick="toggleMenu()" aria-label="Close menu">&times;</button>
    </div>
    <div class="menu-items">
      <a href="#bear-overview" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">📊</span>BEAR OVERVIEW
      </a>
      <a href="#honey-points" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon"><img src="https://files.catbox.moe/wyfjtc.png" alt="honey" style="height:1.2em; width:auto; display:inline-block;"></span>BEAR HONEY POINTS
      </a>
      <a href="#cosmetics-store" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">🛍️</span>COSMETICS STORE
      </a>
      <a href="#bearcade" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">🎮</span>BEARCADE
      </a>
      <a href="#leaderboards" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">🏆</span>LEADERBOARDS
      </a>
      <a href="#community" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">🐻</span>BEAR COMMUNITY
      </a>
      <a href="#bg123" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">📖</span>BG123 LORE
      </a>
      <a href="#nfts" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">🖼️</span>NFT COLLECTIONS
      </a>
      <a href="#community" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">👥</span>COMMUNITY
      </a>
      <a href="#memes" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">🎭</span>5D MEMES
      </a>
      <a href="#network" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon"><img src="https://files.catbox.moe/esp426.png" alt="BEAR" style="height:1.2em; width:auto; display:inline-block;"></span>BUY $BEAR
      </a>
    </div>
  </div>

  <a class="skip-link" href="#bearcade">Skip to BEARcade</a>

  <!-- Sticky nav -->
  <div class="site-nav" role="navigation" aria-label="Primary">
    <div class="progress" id="progress"></div>
    <div class="bar">
      <a class="brand" href="#top" aria-label="BEAR Park Home">
        <img src="https://files.catbox.moe/25ekkd.png" width="72" height="72" alt="BEAR Park logo" loading="eager" decoding="sync" />
        <span>BEAR Park</span>
      </a>
      <nav class="links" aria-label="Sections">
        <a href="#honey-points"><img src="https://files.catbox.moe/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"> Honey Points</a>
        <a href="#cosmetics-store">🛍️ Store</a>
        <a href="#bearcade">BEARcade</a>
        <a href="#leaderboards">🏆 Leaderboards</a>
        <a href="#bg123">BG123</a>
        <a href="#nfts">NFTs</a>
        <a href="#community">Community</a>
        <a href="#memes">5D Memes</a>
        <a href="#network">Network</a>
      </nav>
      <div class="nav-cta">
        <a class="btn gold" href="#network">Buy $BEAR</a>
      </div>
    </div>
  </div>

  <!-- HERO -->
  <header class="hero" role="banner" style="position: relative; overflow: hidden;">
    <!-- 🎨💥 EPIC 3D LAYERED PARALLAX SIGN 💥🎨 -->
    <div id="woodenSignContainer" style="position: absolute; top: 38%; left: 50%; transform: translate(-50%, -50%); z-index: 10; perspective: 1000px;">
      <div id="signParallaxWrapper" style="position: relative; transform-style: preserve-3d; width: 430px;">
        <!-- Deep shadow layer (moves slowest) - INVISIBLE until mouse near -->
        <img class="sign-layer sign-depth-layer" data-depth="0.2" src="https://files.catbox.moe/25ekkd.png" alt="" style="position: absolute; width: 100%; height: auto; opacity: 0; filter: blur(20px) brightness(0); transform: translateZ(-100px) scale(1.2); pointer-events: none;">

        <!-- Mid shadow layer - INVISIBLE until mouse near -->
        <img class="sign-layer sign-depth-layer" data-depth="0.4" src="https://files.catbox.moe/25ekkd.png" alt="" style="position: absolute; width: 100%; height: auto; opacity: 0; filter: blur(10px) brightness(0.3); transform: translateZ(-50px) scale(1.1); pointer-events: none;">

        <!-- Main sign layer (NO glow/highlight layers) -->
        <img id="woodenSign" class="sign-layer" data-depth="1" src="https://files.catbox.moe/25ekkd.png" alt="BEAR PARK wooden sign" style="position: relative; width: 100%; height: auto; transform: translateZ(0px);">
      </div>
    </div>

    <!-- 🎯 FLOATING NAVIGATION BUTTONS 🎯 -->
    <!-- RAIDS Button (Left) -->
    <div class="floating-nav-btn" id="raidsNavBtn" data-depth="0.8" style="position: absolute; top: 55%; left: 23%; z-index: 11; perspective: 1000px; cursor: pointer;">
      <div class="floating-nav-text" data-section="honey-points">RAIDS</div>
    </div>

    <!-- Honey Points Button (Center-Bottom) -->
    <div class="floating-nav-btn" id="honeyNavBtn" data-depth="0.8" style="position: absolute; top: 72%; left: 50%; transform: translateX(-50%); z-index: 11; perspective: 1000px; cursor: pointer;">
      <div class="floating-nav-text" data-section="honey-points">HONEY POINTS</div>
    </div>

    <!-- GAMES Button (Right) -->
    <div class="floating-nav-btn" id="gamesNavBtn" data-depth="0.8" style="position: absolute; top: 55%; right: 18%; z-index: 11; perspective: 1000px; cursor: pointer;">
      <div class="floating-nav-text" data-section="bearcade">GAMES</div>
    </div>

    <!-- 🐻🏙️ BEAR CITY INHABITANTS 🏙️🐻 -->
    <div id="bearCityContainer" aria-hidden="true"></div>
  </header>

  <!-- BEAR OVERVIEW -->
  <section class="alt" id="bear-overview" style="padding-top:2px;">
    <div class="wrap reveal">
      <div style="text-align:center; margin-bottom:16px; margin-top:-60px;">
        <img src="https://files.catbox.moe/20lxak.png" alt="BEAR" style="width:100%; max-width:400px; height:auto; display:block; margin:0 auto 8px;">
        <h2 class="h2" style="font-size:clamp(42px, 5vw, 64px); margin:0;">OVERVIEW</h2>
      </div>
      <p style="text-align:center;margin:0 0 20px;opacity:0.9;font-size:clamp(18px, 2.5vw, 22px);font-weight:700;">Live $BEAR price, market stats, chart, and liquidity pool.</p>

      <!-- Main Chart Area -->
      <div class="honey-card" style="margin-bottom:20px; padding:20px 20px 0 20px; overflow:hidden;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
          <h3 class="honey-card-title" style="margin:0;">📈 Live Chart</h3>
          <a href="https://dexscreener.com/xrpl/4245415200000000000000000000000000000000.rbearguasyu7tuw53rufqzfdwmjhpjeqfw_xrp"
             target="_blank"
             rel="noopener noreferrer"
             style="display:inline-flex; align-items:center; gap:6px; padding:8px 16px; background:var(--gold); color:#000; border-radius:8px; font-size:12px; font-weight:900; text-transform:uppercase; transition:all 0.2s; border:2px solid transparent; border-image: var(--tri-gradient) 1;"
             onmouseover="this.style.background='#ffca3a'"
             onmouseout="this.style.background='var(--gold)'">
            <span>📊 View Transactions</span>
          </a>
        </div>
        <div class="chart-container">
          <div id="chart-error" style="display:none;">
            <div style="padding:40px; text-align:center; color:var(--gold); background:rgba(0,0,0,0.5); border-radius:12px; height:800px; display:flex; flex-direction:column; align-items:center; justify-content:center;">
              <div style="font-size:48px; margin-bottom:16px;">📊</div>
              <div style="font-size:18px; font-weight:900; margin-bottom:12px;">Chart Loading Issue</div>
              <div style="opacity:0.8; margin-bottom:20px;">The embedded chart may be blocked by your browser settings.</div>
              <a href="https://dexscreener.com/xrpl/4245415200000000000000000000000000000000.rbearguasyu7tuw53rufqzfdwmjhpjeqfw_xrp"
                 target="_blank"
                 rel="noopener noreferrer"
                 class="btn gold">
                View Full Chart on DexScreener
              </a>
            </div>
          </div>
          <iframe
            id="dexscreener-embed"
            src="https://dexscreener.com/xrpl/4245415200000000000000000000000000000000.rbearguasyu7tuw53rufqzfdwmjhpjeqfw_xrp?embed=1&theme=dark&trades=0&info=0"
            style="width:100%; height:590px; border:0; border-radius:12px; background:#000; display:block;"
            title="DexScreener Chart"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowfullscreen
          ></iframe>
        </div>
      </div>

      <!-- Stats Grid Below Chart -->
      <div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:20px;" class="stats-grid-bottom">
        <!-- Stats Sidebar -->
          <!-- USD Metrics Card -->
          <div class="honey-card" style="margin-bottom:20px;">
            <h3 class="honey-card-title">💵 USD METRICS</h3>
            <div class="stats-list">
              <div class="stat-item">
                <div class="stat-label" style="white-space: nowrap; display: inline-flex; align-items: center; gap: 4px;"><img src="https://files.catbox.moe/esp426.png" alt="BEAR" style="height:0.9em; width:auto; display:inline-block;">BEAR / 💵 USD</div>
                <div class="stat-value" id="honeyPriceUsd">—</div>
              </div>
              <div class="stat-item">
                <div class="stat-label">24H CHANGE</div>
                <div class="stat-value" id="honeyChange24h">—</div>
              </div>
              <div class="stat-item">
                <div class="stat-label">💵 24H VOLUME</div>
                <div class="stat-value" id="honeyVolume">—</div>
              </div>
              <div class="stat-item">
                <div class="stat-label">💵 MARKET CAP</div>
                <div class="stat-value" id="honeyMcap">—</div>
              </div>
            </div>
          </div>

          <!-- XRP Metrics Card -->
          <div class="honey-card" style="margin-bottom:20px;">
            <h3 class="honey-card-title" style="display:inline-flex; align-items:center; gap:6px;"><img src="https://files.catbox.moe/lufprf.png" alt="XRP" style="height:1em; width:auto; display:inline-block;">XRP METRICS</h3>
            <div class="stats-list">
              <div class="stat-item">
                <div class="stat-label" style="white-space: nowrap; display: inline-flex; align-items: center; gap: 4px;"><img src="https://files.catbox.moe/esp426.png" alt="BEAR" style="height:0.9em; width:auto; display:inline-block;">BEAR / <img src="https://files.catbox.moe/lufprf.png" alt="XRP" style="height:0.9em; width:auto; display:inline-block;">XRP</div>
                <div class="stat-value" id="honeyPriceXrp">—</div>
              </div>
              <div class="stat-item">
                <div class="stat-label">24H CHANGE</div>
                <div class="stat-value" id="honeyChange24hXrp">—</div>
              </div>
              <div class="stat-item">
                <div class="stat-label" style="white-space: nowrap; display: inline-flex; align-items: center; gap: 4px;"><img src="https://files.catbox.moe/lufprf.png" alt="XRP" style="height:0.9em; width:auto; display:inline-block;">XRP 24H VOLUME</div>
                <div class="stat-value" id="honeyVolumeXrp">—</div>
              </div>
              <div class="stat-item">
                <div class="stat-label" style="white-space: nowrap; display: inline-flex; align-items: center; gap: 4px;"><img src="https://files.catbox.moe/lufprf.png" alt="XRP" style="height:0.9em; width:auto; display:inline-block;">XRP MARKET CAP</div>
                <div class="stat-value" id="honeyMcapXrp">—</div>
              </div>
            </div>
          </div>

          <!-- Liquidity Pool -->
          <div class="honey-card">
            <h3 class="honey-card-title">💧 Liquidity Pool</h3>
            <div class="stats-list">
              <div class="stat-item">
                <div class="stat-label" style="white-space: nowrap; display: inline-flex; align-items: center; gap: 4px;"><img src="https://files.catbox.moe/esp426.png" alt="BEAR" style="height:0.9em; width:auto; display:inline-block;">BEAR Liquidity</div>
                <div class="stat-value" id="liquidityBear">—</div>
              </div>
              <div class="stat-item">
                <div class="stat-label" style="white-space: nowrap; display: inline-flex; align-items: center; gap: 4px;"><img src="https://files.catbox.moe/lufprf.png" alt="XRP" style="height:0.9em; width:auto; display:inline-block;">XRP Liquidity</div>
                <div class="stat-value" id="liquidityXrp">—</div>
              </div>
              <div class="stat-item">
                <div class="stat-label" style="white-space: nowrap;">💵 USD Value</div>
                <div class="stat-value" id="liquidityUsd">—</div>
              </div>
              <div class="stat-item">
                <div class="stat-label" style="white-space: nowrap;">📊 Liq/MCap Ratio</div>
                <div class="stat-value" id="liquidityMcapRatio">—</div>
              </div>
            </div>
          </div>
      </div>

      <style>
        @media (max-width: 1024px) {
          .stats-grid-bottom {
            grid-template-columns: 1fr !important;
          }
        }
        @media (max-width: 768px) {
          .stats-grid-bottom {
            grid-template-columns: 1fr !important;
          }
        }
      </style>
    </div>
  </section>

  <!-- BEAR HONEY POINTS -->
  <section class="dark" id="honey-points">
    <div class="wrap reveal">
      <h2 class="h2"><img src="https://files.catbox.moe/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"> BEAR HONEY POINTS</h2>
      <p style="text-align:center;margin:-6px 0 32px;opacity:0.9;">earn honey points by raiding, playing games, having your meme voted as the "meme of the week" and other fun giveaways!</p>

      <div class="honey-points-grid">
        <!-- My Points Card -->
        <div class="honey-card my-points-card">
            <h3 class="honey-card-title"><img src="https://files.catbox.moe/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"> My Honey Points</h3>
            <div id="myPointsContent">
              <!-- Total Points Hero -->
              <div class="points-hero">
                <div class="points-hero-value" id="totalHoneyPoints">0</div>
                <div class="points-hero-label">TOTAL HONEY POINTS EARNED</div>
              </div>

              <!-- Points Breakdown -->
              <div class="points-breakdown">
                <div class="points-breakdown-item">
                  <div class="points-breakdown-icon">🪖</div>
                  <div class="points-breakdown-content">
                    <div class="points-breakdown-label">Honey Earned from Raiding</div>
                    <div class="points-breakdown-value" id="raidingPoints">0 PTS</div>
                  </div>
                </div>

                <div class="points-breakdown-item">
                  <div class="points-breakdown-icon">🎮</div>
                  <div class="points-breakdown-content">
                    <div class="points-breakdown-label">Honey Earned from Games</div>
                    <div class="points-breakdown-value" id="gamesPoints">0 PTS</div>
                  </div>
                </div>
              </div>

              <!-- Daily Game Progress -->
              <div class="daily-game-progress">
                <div class="daily-progress-header">
                  <span class="daily-progress-title">🕹️🃏 Today's Game Progress</span>
                  <span class="daily-progress-count" id="dailyGameCount">0/20</span>
                </div>
                <div class="daily-progress-bar-container">
                  <div class="daily-progress-bar" id="dailyProgressBar" style="width: 0%"></div>
                </div>
                <div class="daily-progress-info">
                  <span class="daily-progress-points" id="dailyGamePoints">0 pts earned today</span>
                  <span class="daily-progress-remaining" id="dailyGamesRemaining">20 mins left</span>
                </div>
              </div>

              <!-- Your Rank -->
              <div class="points-rank">
                <span>Your Rank: <strong id="myRank">—</strong></span>
              </div>
            </div>
          </div>

        <!-- Leaderboard -->
        <div class="honey-card leaderboard-card">
          <h3 class="honey-card-title">🏆 Top Honey Earners</h3>
          <div class="leaderboard" id="honeyLeaderboard">
            <div class="leaderboard-loading">Loading leaderboard...</div>
          </div>
        </div>

        <!-- Current Raids -->
        <div class="honey-card raids-card">
          <button class="admin-raid-btn" id="adminRaidBtn" style="display:none;" onclick="window.location.href='/admin-raids.html'">🎯 START RAID</button>
          <button class="raids-toggle-btn" id="raidsToggleBtn">Show Previous Raids</button>
          <h3 class="honey-card-title" id="raidsTitle">🐻 🪖 Current Raids</h3>
          <div id="raidsContent">
            <div class="raids-list" id="currentRaidsList">
              <div class="raids-empty">Loading raids...</div>
            </div>
            <div class="raids-list" id="previousRaidsList" style="display:none;">
              <div class="raids-empty">Loading previous raids...</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- COSMETICS STORE -->
  <section class="dark" id="cosmetics-store">
    <div class="wrap reveal">
      <h2 class="h2">🛍️ COSMETICS STORE</h2>
      <p style="text-align:center;margin:-6px 0 32px;opacity:0.9;">Customize your profile with legendary rings and banners using your Honey Points!</p>

      <div style="text-align:center; margin-bottom:32px; display:flex; gap:16px; justify-content:center; flex-wrap:wrap;">
        <button id="openStoreBtn" class="btn gold" onclick="openStoreModal()">
          🍯 OPEN STORE
        </button>
        <button id="openInventoryBtn" class="btn" onclick="openInventoryModal()" style="background:linear-gradient(135deg, #8b5cf6, #7c3aed); color:#fff;">
          🎒 MY INVENTORY
        </button>
      </div>
    </div>
  </section>

  <!-- BEARCADE -->
  <section class="alt" id="bearcade">
    <div class="wrap reveal">
      <h2 class="h2">BEARCADE</h2>
      <p style="text-align:center;margin:-6px 0 32px;">PLAY GAMES AND EARN HONEY POINTS! PLAY ANY OF THE 4 BELOW <img src="https://files.catbox.moe/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"> 🎮</p>

      <div class="grid-3" style="gap:24px;">
        <!-- Flappy Bear -->
        <div class="game-card">
          <a href="https://www.bearpark.xyz/flappybear" target="_blank" rel="noopener noreferrer" style="text-decoration:none;">
            <div style="border:4px solid transparent; border-radius:16px; overflow:hidden; box-shadow:0 8px 24px rgba(0,0,0,0.4); background-image: linear-gradient(#1a1a1a, #1a1a1a), linear-gradient(135deg, #680cd9, #feb501, #00ff88); background-origin: border-box; background-clip: padding-box, border-box; transition: transform 0.3s ease, box-shadow 0.3s ease;">
              <img src="https://files.catbox.moe/8k133u.png" alt="Flappy Bear" style="width:100%; height:auto; display:block;">
              <div style="padding:20px; background:#1a1a1a;">
                <h3 style="color:var(--gold); font-size:24px; font-weight:900; margin:0 0 12px 0; text-align:center;">FLAPPY BEAR</h3>
                <p style="color:rgba(255,255,255,0.85); font-size:15px; line-height:1.5; margin:0; text-align:center;">Tap to flap and dodge obstacles! Test your reflexes in this addictive arcade classic.</p>
              </div>
            </div>
          </a>
        </div>

        <!-- Bear Ninja -->
        <div class="game-card">
          <a href="https://www.bearpark.xyz/bear-ninja" target="_blank" rel="noopener noreferrer" style="text-decoration:none;">
            <div style="border:4px solid transparent; border-radius:16px; overflow:hidden; box-shadow:0 8px 24px rgba(0,0,0,0.4); background-image: linear-gradient(#1a1a1a, #1a1a1a), linear-gradient(135deg, #680cd9, #feb501, #00ff88); background-origin: border-box; background-clip: padding-box, border-box; transition: transform 0.3s ease, box-shadow 0.3s ease;">
              <img src="https://files.catbox.moe/478y6f.png" alt="Bear Ninja" style="width:100%; height:auto; display:block;">
              <div style="padding:20px; background:#1a1a1a;">
                <h3 style="color:var(--gold); font-size:24px; font-weight:900; margin:0 0 12px 0; text-align:center;">BEAR NINJA</h3>
                <p style="color:rgba(255,255,255,0.85); font-size:15px; line-height:1.5; margin:0; text-align:center;">Slice and dice your way through waves! Master the art of the ninja blade.</p>
              </div>
            </div>
          </a>
        </div>

        <!-- Bear Jumpventure -->
        <div class="game-card">
          <a href="https://www.bearpark.xyz/bear-jumpventure" target="_blank" rel="noopener noreferrer" style="text-decoration:none;">
            <div style="border:4px solid transparent; border-radius:16px; overflow:hidden; box-shadow:0 8px 24px rgba(0,0,0,0.4); background-image: linear-gradient(#1a1a1a, #1a1a1a), linear-gradient(135deg, #680cd9, #feb501, #00ff88); background-origin: border-box; background-clip: padding-box, border-box; transition: transform 0.3s ease, box-shadow 0.3s ease;">
              <img src="https://files.catbox.moe/njsz8n.png" alt="Bear Jumpventure" style="width:100%; height:auto; display:block;">
              <div style="padding:20px; background:#1a1a1a;">
                <h3 style="color:var(--gold); font-size:24px; font-weight:900; margin:0 0 12px 0; text-align:center;">BEAR JUMPVENTURE</h3>
                <p style="color:rgba(255,255,255,0.85); font-size:15px; line-height:1.5; margin:0; text-align:center;">Jump across platforms and collect coins! Explore challenging levels in this platformer.</p>
              </div>
            </div>
          </a>
        </div>

        <!-- Bear Pong -->
        <div class="game-card">
          <a href="https://www.bearpark.xyz/bearpong" target="_blank" rel="noopener noreferrer" style="text-decoration:none;">
            <div style="border:4px solid transparent; border-radius:16px; overflow:hidden; box-shadow:0 8px 24px rgba(0,0,0,0.4); background-image: linear-gradient(#1a1a1a, #1a1a1a), linear-gradient(135deg, #680cd9, #feb501, #00ff88); background-origin: border-box; background-clip: padding-box, border-box; transition: transform 0.3s ease, box-shadow 0.3s ease;">
              <img src="https://files.catbox.moe/bs753i.png" alt="Bear Pong" style="width:100%; height:auto; display:block;">
              <div style="padding:20px; background:#1a1a1a;">
                <h3 style="color:var(--gold); font-size:24px; font-weight:900; margin:0 0 12px 0; text-align:center;">BEAR PONG</h3>
                <p style="color:rgba(255,255,255,0.85); font-size:15px; line-height:1.5; margin:0; text-align:center;">Battle it out in classic pong action! Compete head-to-head in this timeless arcade showdown.</p>
              </div>
            </div>
          </a>
        </div>
      </div>
    </div>
  </section>

  <!-- LEADERBOARDS -->
  <section class="dark" id="leaderboards">
    <div class="wrap reveal">
      <h2 class="h2">🏆 LEADERBOARDS 🏆</h2>
      <p style="text-align:center;margin:-6px 0 32px;">Top players across all BEAR games — wallet-verified high scores!</p>

      <div class="grid-3" style="gap:24px;">

        <!-- Flappy BEAR Leaderboard -->
        <div class="leaderboard-card">
          <h3 class="h3" style="text-align:center; margin-bottom:16px;">
            <span style="color:var(--gold);">FLAPPY</span> BEAR
          </h3>
          <div id="leaderboard-flappy" class="leaderboard-list">
            <div class="loading">Loading scores...</div>
          </div>
        </div>

        <!-- BEAR Ninja Leaderboard -->
        <div class="leaderboard-card">
          <h3 class="h3" style="text-align:center; margin-bottom:16px;">
            BEAR <span style="color:var(--gold);">NINJA</span>
          </h3>
          <div id="leaderboard-slice" class="leaderboard-list">
            <div class="loading">Loading scores...</div>
          </div>
        </div>

        <!-- BEAR Jump Leaderboard -->
        <div class="leaderboard-card">
          <h3 class="h3" style="text-align:center; margin-bottom:16px;">
            BEAR <span style="color:var(--gold);">JUMP</span>
          </h3>
          <div id="leaderboard-jumpventure" class="leaderboard-list">
            <div class="loading">Loading scores...</div>
          </div>
        </div>

        <!-- BEAR Pong Leaderboard -->
        <div class="leaderboard-card">
          <h3 class="h3" style="text-align:center; margin-bottom:16px;">
            BEAR <span style="color:var(--gold);">PONG</span>
          </h3>
          <div id="leaderboard-pong" class="leaderboard-list">
            <div class="loading">Loading scores...</div>
          </div>
        </div>

      </div>
    </div>
  </section>

  <!-- BEAR BULLETIN BOARD -->
  <section class="dark" id="bulletin-board">
    <div class="wrap reveal">
      <h2 class="h2">📋 BEAR BULLETIN BOARD 📋</h2>
      <p style="text-align:center;margin:-6px 0 20px;">What are other BEARS up to?</p>

      <!-- Post Bulletin Button -->
      <div style="text-align:center; margin-bottom:32px;">
        <button id="postBulletinBtn" class="post-bulletin-btn" onclick="openPostBulletinHighlight()">
          ✨ Post Bulletin
        </button>
      </div>

      <!-- Bulletin Feed -->
      <div class="bulletin-feed-container">
        <div id="bulletinFeed" class="bulletin-feed">
          <div class="loading">Loading bulletin posts...</div>
        </div>
      </div>
    </div>
  </section>

  <!-- BEAR COMMUNITY -->
  <section class="alt" id="community">
    <div class="wrap reveal">
      <h2 class="h2">🐻 BEAR COMMUNITY 🐻</h2>
      <p style="text-align:center;margin:-6px 0 32px;">Discover all the BEARs in the park! Search and explore the growing community.</p>

      <!-- Community Container with Border -->
      <div class="community-bordered-container">
        <!-- Search Bar -->
        <div class="community-search-container">
          <div class="community-search-wrapper">
            <svg class="community-search-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
              <circle cx="11" cy="11" r="8"></circle>
              <path d="m21 21-4.35-4.35"></path>
            </svg>
            <input
              type="text"
              id="communitySearchInput"
              placeholder="Search for a BEAR by name..."
              class="community-search-input"
            >
          </div>
          <div class="community-count">
            <span id="communityUserCount">0</span> BEARs
          </div>
        </div>

        <!-- User Grid -->
        <div id="communityUserGrid" class="community-user-grid">
          <div class="community-loading">
            <div class="loading-spinner"></div>
            <p>Loading BEARs...</p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- BEARABLEGUY123 -->
  <section class="dark" id="bg123">
    <div class="wrap reveal">
      <h2 class="h2">BEARABLEGUY123</h2>
      <p class="center on-dark" style="opacity:.9;margin:-6px 0 20px;">Since 2018, Bearableguy posted riddles in images with a red masked bear. The community uncovered hints like “589.”</p>

      <div class="card" role="region" aria-roledescription="carousel" aria-label="Bearableguy image gallery" aria-live="polite">
        <div class="carousel" id="carousel">
          <!-- LEFT ARROW -->
          <button class="carousel-arrow carousel-arrow-left" id="carouselPrev" aria-label="Previous slide">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M15 18L9 12L15 6" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>

          <!-- RIGHT ARROW -->
          <button class="carousel-arrow carousel-arrow-right" id="carouselNext" aria-label="Next slide">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M9 18L15 12L9 6" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>

          <div class="viewport" id="viewport" tabindex="0" aria-label="Carousel viewport (use left and right arrow keys)">
            <div class="slides" id="slides">
              <img src="https://files.catbox.moe/f6k3b1.jpg" alt="BG123 poster 1" width="1600" height="900" loading="lazy" decoding="async">
              <img src="https://files.catbox.moe/18vwoq.jpg" alt="BG123 poster 2" width="1600" height="900" loading="lazy" decoding="async">
              <img src="https://files.catbox.moe/ruozs3.jpg" alt="BG123 poster 3" width="1600" height="900" loading="lazy" decoding="async">
              <img src="https://files.catbox.moe/ha4uwj.jpg" alt="BG123 poster 4" width="1600" height="900" loading="lazy" decoding="async">
              <img src="https://files.catbox.moe/n0le0t.jpg" alt="BG123 poster 5" width="1600" height="900" loading="lazy" decoding="async">
              <img src="https://files.catbox.moe/wbin3t.jpg" alt="BG123 poster 6" width="1600" height="900" loading="lazy" decoding="async">
              <img src="https://files.catbox.moe/lrtbxe.png" alt="BG123 poster 7" width="1600" height="900" loading="lazy" decoding="async">
            </div>
          </div>
        </div>
        <div class="dots" id="dots" role="tablist" aria-label="Choose slide"></div>
      </div>
    </div>
  </section>

  <!-- NFTs -->
  <section class="alt" id="nfts">
    <div class="wrap reveal">
      <h2 class="h2">BEAR NFTs</h2>
      <p style="text-align:center;margin:-6px 0 24px;">The BEAR community has collectible NFTs for profile pictures — the <strong>Ultra Rare Collection</strong> and the <strong>Pixel Collection</strong>.</p>

      <div class="grid-2">
        <div class="card">
          <h3 class="h3">ULTRA RARE BEARS</h3>
          <p style="text-align:center;opacity:.95;">The BEAR Ultra Rare collection was the first mint and consists of 667 NFTs.</p>
          <div class="spacer"></div>
          <a class="nft-media" href="https://xrp.cafe/collection/bearxrpl" target="_blank" rel="noopener">
            <img src="https://cdn.xrp.cafe/362e53289fd2-49f8-b070-4a3a6f95617272729975700c-46ba-a056-0aaf34028496f5a507b1d5a4-4adc-ad01-8d8b6ecd631d.webp" alt="Ultra Rare Bear preview" width="1200" height="1200" loading="lazy" decoding="async">
          </a>
          <div class="center" style="margin-top:16px;">
            <a class="btn gold" href="https://xrp.cafe/collection/bearxrpl" target="_blank" rel="noopener">Ultra Collection</a>
          </div>
        </div>

        <div class="card">
          <h3 class="h3">PIXEL BEARS</h3>
          <p style="text-align:center;opacity:.95;">There are 5880 Pixel BEARS to provide a profile picture for every $BEAR maxi.</p>
          <div class="spacer"></div>
          <a class="nft-media" href="https://xrp.cafe/collection/bear-pixel-collection" target="_blank" rel="noopener">
            <video src="https://files.catbox.moe/babbn1.mp4" playsinline muted autoplay loop poster="https://files.catbox.moe/babbn1.jpg"></video>
          </a>
          <div class="center" style="margin-top:16px;">
            <a class="btn gold" href="https://xrp.cafe/collection/bear-pixel-collection" target="_blank" rel="noopener">Pixel Collection</a>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- COMMUNITY -->
  <section class="dark" id="community">
    <div class="wrap reveal">
      <h2 class="h2">COMMUNITY</h2>

    <div class="community-banner" id="communityBanner" role="img" aria-label="$BEAR community montage with honey lighting">
        <img class="bg" id="communityBannerBg" src="https://files.catbox.moe/kgs8as.jpg" alt="" width="2000" height="1000" loading="lazy" decoding="async">

        <!-- Animated bear paw prints -->
        <div class="paw-prints">
          <span class="paw">🐾</span>
          <span class="paw">🐾</span>
          <span class="paw">🐾</span>
          <span class="paw">🐾</span>
        </div>

        <div class="overlay">
          <div class="community-content">
            <div class="community-badge">
              <img src="https://files.catbox.moe/98rugn.png" alt="BEAR Community" style="width:100%; height:100%; object-fit:cover; border-radius:50%;">
            </div>
            <h3 style="font-family:'Luckiest Guy',cursive; font-size:clamp(24px, 5vw, 36px); color:var(--gold); text-shadow:3px 3px 0 #000, 0 0 20px rgba(237,183,35,0.4); margin:16px 0 8px; text-align:center;">OFFICIAL COMMUNITIES!</h3>
            <p class="on-dark" style="text-align:center; font-size:clamp(15px, 3vw, 18px); margin:0 0 24px; max-width:500px; line-height:1.4;">Come meet the $BEAR fam and join the most vibrant community in crypto!</p>
            <div class="community-buttons">
              <a class="btn gold community-btn" href="https://x.com/bearxrpl" target="_blank" rel="noopener">
                <span class="btn-icon">𝕏</span>
                <span class="btn-text">Join us on X</span>
              </a>
              <a class="btn gold community-btn" href="https://discord.com/invite/atGTNuzqH6" target="_blank" rel="noopener">
                <span class="btn-icon">💬</span>
                <span class="btn-text">Join Discord</span>
              </a>
            </div>
            <div class="community-stats">
              <div class="stat-item">
                <span class="stat-emoji">💬</span>
                <span class="stat-text">Discord Daily</span>
              </div>
              <div class="stat-item">
                <span class="stat-emoji">🎙️</span>
                <span class="stat-text">Spaces Daily</span>
              </div>
              <div class="stat-item">
                <span class="stat-emoji">🪖</span>
                <span class="stat-text">Raiding Daily</span>
              </div>
              <div class="stat-item">
                <span class="stat-emoji">🎉</span>
                <span class="stat-text">Having Fun Daily</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- 5D MEMES -->
  <section class="alt" id="memes">
    <div class="wrap reveal">
      <h2 class="h2">5D MEMES</h2>
      <p style="text-align:center;margin:-6px 0 18px;color:var(--gold-ink)">Live stream from Kick</p>

      <div class="card">
        <div class="square" id="kickWrap">
          <!-- Lazy-loaded Kick embed with placeholder -->
          <button class="placeholder btn ghost" id="kickPlaceholder" aria-label="Load live Kick stream">
            ▶ Load live Kick stream
          </button>
        </div>
        <div class="center" style="margin-top:14px;">
          <a class="btn ghost" href="https://kick.com/bearxrpl" target="_blank" rel="noopener">Open on Kick</a>
        </div>
      </div>
    </div>
  </section>

  <!-- NETWORK -->
  <section class="dark" id="network">
    <div class="wrap reveal">
      <h2 class="h2">NETWORK</h2>
      <p class="on-dark" style="text-align:center;margin:-6px 0 24px;">Buy $BEAR here</p>

      <div class="grid-2">
        <a class="tile" href="https://firstledger.net/token/rBEARGUAsyu7tUw53rufQzFdWmJHpJEqFW/4245415200000000000000000000000000000000" target="_blank" rel="noopener">
          <div class="face"><img src="https://files.catbox.moe/du61x3.jpg" alt="First Ledger" width="300" height="64" loading="lazy" decoding="async"></div>
          <span class="lbl">First Ledger</span>
        </a>
        <a class="tile" href="https://xmagnetic.org/dex/BEAR+rBEARGUAsyu7tUw53rufQzFdWmJHpJEqFW_XRP+XRP?network=mainnet" target="_blank" rel="noopener">
          <div class="face"><img src="https://files.catbox.moe/m9ck1m.png" alt="Magnetic DEX" width="300" height="64" loading="lazy" decoding="async"></div>
          <span class="lbl">Magnetic DEX</span>
        </a>
        <a class="tile" href="https://xpmarket.com/token/BEAR-rBEARGUAsyu7tUw53rufQzFdWmJHpJEqFW" target="_blank" rel="noopener">
          <div class="face"><img src="https://files.catbox.moe/1dw0sy.png" alt="XPMarket" width="220" height="64" loading="lazy" decoding="async"></div>
          <span class="lbl">XPMarket</span>
        </a>
      </div>
    </div>
  </section>

  <!-- PWA Install & Notifications Controls -->
  <div id="pwaControls" style="display:none;position:fixed;bottom:100px;right:20px;z-index:9999;max-width:300px;">
    <button id="installAppBtn" style="display:none;width:100%;padding:14px 20px;margin-bottom:10px;background:linear-gradient(135deg,#8b5cf6,#ec4899);color:#fff;border:none;border-radius:12px;font-size:16px;font-weight:900;cursor:pointer;box-shadow:0 4px 12px rgba(139,92,246,0.5);text-shadow:0 1px 2px rgba(0,0,0,0.3);transition:all 0.2s;">
      📱 Install BEAR Park App
    </button>
    <button id="enableNotificationsBtn" style="width:100%;padding:14px 20px;background:linear-gradient(135deg,#680cd9,#feb501);color:#fff;border:none;border-radius:12px;font-size:16px;font-weight:900;cursor:pointer;box-shadow:0 4px 12px rgba(104,12,217,0.5);text-shadow:0 1px 2px rgba(0,0,0,0.3);transition:all 0.2s;">
      🔔 Enable Raid Alerts
    </button>
  </div>

  <style>
    #pwaControls button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(139,92,246,0.7);
    }
    #pwaControls button:active:not(:disabled) {
      transform: translateY(0);
    }
    #pwaControls button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    @media (max-width: 768px) {
      #pwaControls {
        left: 20px;
        right: 20px;
        max-width: none;
        bottom: 80px;
      }
    }
  </style>

  <footer class="dark">
    <div class="wrap center" style="gap:14px;flex-wrap:wrap;">
      <span class="on-dark" style="opacity:.9;">© BEAR Park — Defend the castle 🏰</span>
      <a class="btn ghost" href="#top">Back to Top</a>
    </div>
  </footer>

  <!-- Buy Drawer -->
  <aside id="buyDrawer" class="drawer" aria-hidden="true">
    <div class="drawer-head">
      <h3 class="h3" style="margin:0;"><span style="color:var(--gold);">BEAR</span> <span style="color:#fff;">HUB</span></h3>
      <button class="drawer-close-btn" data-close-drawer aria-label="Close BEAR HUB">
        &times;
      </button>
    </div>
    <div class="drawer-body">
      <!-- MY $BEAR PORTFOLIO -->
      <div id="portfolioSection" class="portfolio-card" style="display:none;">
        <h4 style="margin:0 0 16px 0; font-size:18px; font-weight:900; color:var(--gold); text-transform:uppercase; letter-spacing:0.5px;">💼 My $BEAR Portfolio</h4>
        <div class="portfolio-stats">
          <div class="stat-row" style="margin-bottom:16px;">
            <span class="stat-label" style="font-size:15px; display:inline-flex; align-items:center; gap:6px; white-space:nowrap;">
              <img src="https://files.catbox.moe/esp426.png" alt="BEAR" width="18" height="18" style="display:inline-block;"> Total BEAR:
            </span>
            <span id="portfolioBearAmount" class="stat-value" style="font-size:24px; font-weight:900;">—</span>
          </div>
          <div class="stat-row" style="margin-bottom:12px;">
            <span class="stat-label" style="font-size:15px; white-space:nowrap;">💵 USD Value:</span>
            <span id="portfolioUsdValue" class="stat-value" style="font-size:20px; font-weight:900;">—</span>
          </div>
          <div class="stat-row">
            <span class="stat-label" style="font-size:15px; display:inline-flex; align-items:center; gap:4px; white-space:nowrap;"><img src="https://files.catbox.moe/lufprf.png" alt="XRP" width="18" height="18" style="display:inline-block;">XRP Value:</span>
            <span id="portfolioXrpValue" class="stat-value" style="font-size:20px; font-weight:900;">—</span>
          </div>
        </div>
        <div class="wallet-address" style="margin-top:16px; padding:10px; background:rgba(0,0,0,0.4); border-radius:8px; border:1px solid rgba(237,183,35,0.2); font-size:13px; font-family:monospace; word-break:break-all; text-align:center; color:rgba(255,255,255,0.8);">
          <span id="connectedWalletAddress">—</span>
        </div>
      </div>

      <!-- LIQUIDITY POOL POSITION -->
      <div id="lpSection" class="lp-card" style="display:none;">
        <h4 style="margin:0 0 16px 0; font-size:18px; font-weight:900; color:var(--gold); text-transform:uppercase; letter-spacing:0.5px;">💧 My Liquidity Position</h4>
        <div class="lp-stats">
          <div class="stat-row" style="margin-bottom:16px;">
            <span class="stat-label" style="font-size:14px; display:inline-flex; align-items:center; gap:6px; white-space:nowrap;">
              🪙 LP Tokens:
            </span>
            <span id="lpTokenAmount" class="stat-value" style="font-size:18px; font-weight:900; word-break:break-all;">—</span>
          </div>
          <div class="stat-row" style="margin-bottom:12px;">
            <span class="stat-label" style="font-size:15px; white-space:nowrap;">📊 Pool Ownership:</span>
            <span id="lpPoolPercentage" class="stat-value" style="font-size:20px; font-weight:900; color:#5D3FD3;">—</span>
          </div>
          <div class="stat-row" style="margin-bottom:12px;">
            <span class="stat-label" style="font-size:15px; display:inline-flex; align-items:center; gap:4px; white-space:nowrap;">
              <img src="https://files.catbox.moe/esp426.png" alt="BEAR" width="18" height="18" style="display:inline-block;"> BEAR Share:
            </span>
            <span id="lpBearAmount" class="stat-value" style="font-size:20px; font-weight:900;">—</span>
          </div>
          <div class="stat-row" style="margin-bottom:12px;">
            <span class="stat-label" style="font-size:15px; display:inline-flex; align-items:center; gap:4px; white-space:nowrap;">
              <img src="https://files.catbox.moe/lufprf.png" alt="XRP" width="18" height="18" style="display:inline-block;"> XRP Share:
            </span>
            <span id="lpXrpAmount" class="stat-value" style="font-size:20px; font-weight:900;">—</span>
          </div>
          <div class="stat-row" style="padding-top:12px; border-top:2px solid rgba(237,183,35,0.3);">
            <span class="stat-label" style="font-size:15px; white-space:nowrap;">💰 Total USD Value:</span>
            <span id="lpUsdValue" class="stat-value" style="font-size:24px; font-weight:900; color:#4CAF50;">—</span>
          </div>
        </div>
      </div>

      <!-- PROFIT & LOSS CHART -->
      <div id="plSection" class="pl-card" style="display:none;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px; flex-wrap:wrap; gap:12px;">
          <h4 style="margin:0; font-size:18px; font-weight:900; color:var(--gold); text-transform:uppercase; letter-spacing:0.5px;">📈 Profit & Loss</h4>
          <div class="pl-toggle-group">
            <button id="plToggleXRP" class="pl-toggle-btn active" onclick="switchPLCurrency('XRP')">XRP</button>
            <button id="plToggleUSD" class="pl-toggle-btn" onclick="switchPLCurrency('USD')">USD</button>
          </div>
        </div>


        <!-- Summary Stats -->
        <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(140px, 1fr)); gap:12px; margin-bottom:20px;">
          <div class="pl-stat-box">
            <div class="pl-stat-label">Total P&L</div>
            <div id="plTotalValue" class="pl-stat-value">—</div>
          </div>
          <div class="pl-stat-box">
            <div class="pl-stat-label">Unrealized</div>
            <div id="plUnrealizedValue" class="pl-stat-value">—</div>
          </div>
          <div class="pl-stat-box">
            <div class="pl-stat-label">Realized</div>
            <div id="plRealizedValue" class="pl-stat-value">—</div>
          </div>
          <div class="pl-stat-box">
            <div class="pl-stat-label">ROI</div>
            <div id="plROIValue" class="pl-stat-value">—</div>
          </div>
        </div>

        <!-- Chart Canvas -->
        <div style="position:relative; height:300px; background:rgba(0,0,0,0.3); border-radius:12px; padding:16px;">
          <div id="plLoadingIndicator" style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); text-align:center; display:none;">
            <div style="font-size:40px; margin-bottom:10px;">📊</div>
            <div style="font-size:16px; font-weight:700; color:var(--gold); margin-bottom:8px;">Analyzing Transactions...</div>
            <div id="plLoadingProgress" style="font-size:13px; color:rgba(255,255,255,0.6);">Fetching data...</div>
          </div>
          <div id="plNoDataIndicator" style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); text-align:center; display:none;">
            <div style="font-size:40px; margin-bottom:10px;">📭</div>
            <div style="font-size:16px; font-weight:700; color:rgba(255,255,255,0.6); margin-bottom:8px;">Insufficient Data</div>
            <div style="font-size:13px; color:rgba(255,255,255,0.4);">No transactions in this timeframe. Try a longer period.</div>
          </div>
          <canvas id="plChart"></canvas>
        </div>

      </div>

      <!-- USER PROFILE CUSTOMIZATION -->
      <div id="profileSection" class="profile-card" style="display:none;">
        <div id="profileSetupSection">
          <h4 style="margin:0 0 16px 0; font-size:18px; font-weight:900; color:var(--gold); text-transform:uppercase; letter-spacing:0.5px;">👤 Your Profile</h4>

          <!-- Helpful instruction banner -->
          <div id="profileInstructions" style="background:linear-gradient(135deg, rgba(237,183,35,0.2), rgba(237,183,35,0.1)); padding:16px; border-radius:12px; border:2px solid var(--gold); margin-bottom:20px; text-align:center; transition:all 0.5s ease;">
            <div style="font-size:16px; font-weight:900; color:var(--gold); margin-bottom:8px;">👋 SET UP YOUR PROFILE!</div>
            <div style="font-size:14px; line-height:1.6; color:rgba(255,255,255,0.9);">
              1️⃣ Enter your username below<br>
              2️⃣ Scroll down and pick an NFT from your collection<br>
              3️⃣ Click "Save Profile" when done!
            </div>
          </div>

        <div style="background:rgba(0,0,0,0.3); padding:20px; border-radius:12px; border:2px solid rgba(237,183,35,0.2); margin-bottom:16px;">
          <div style="margin-bottom:20px;">
            <label style="display:block; font-size:16px; font-weight:900; margin-bottom:10px; color:var(--gold);">✏️ Display Name</label>
            <input type="text" id="profileUsername" placeholder="Enter your username here..." maxlength="20" style="width:100%; padding:16px; background:rgba(0,0,0,0.5); border:3px solid rgba(237,183,35,0.5); border-radius:12px; color:#fff; font-size:18px; font-family:inherit; font-weight:700; transition:all 0.3s;">
          </div>

          <div>
            <label style="display:block; font-size:16px; font-weight:900; margin-bottom:10px; color:var(--gold);">🖼️ Profile Avatar</label>
            <div id="profileAvatarSelector" style="background:rgba(0,0,0,0.5); padding:16px; border-radius:12px; border:3px solid rgba(237,183,35,0.5); min-height:90px; display:flex; align-items:center; justify-content:center;">
              <div style="text-align:center; font-size:15px; font-weight:700; color:rgba(237,183,35,0.8);">
                👇 Scroll down and click an NFT to select it 👇
              </div>
            </div>
            <input type="hidden" id="profileAvatarNFT" value="">
          </div>
        </div>

        <button id="saveProfileBtn" class="btn gold" style="width:100%; font-size:20px; padding:20px; font-weight:900; letter-spacing:1px; background:linear-gradient(135deg, #edb723, #f4a623); box-shadow:0 6px 20px rgba(237,183,35,0.5);">💾 SAVE PROFILE</button>
        </div>
      </div>

      <!-- NFT VIEWING SECTION -->
      <div id="nftSection" style="display:none; flex-shrink:0; display:flex; flex-direction:column;">
        <h4 style="margin:0 0 16px 0; font-size:18px; font-weight:900; color:var(--gold); text-transform:uppercase; letter-spacing:0.5px;">🖼️ Your NFTs</h4>

        <!-- Helpful instruction for NFT selection -->
        <div id="nftInstructions" style="background:linear-gradient(135deg, rgba(237,183,35,0.15), rgba(237,183,35,0.05)); padding:14px; border-radius:10px; border:2px solid rgba(237,183,35,0.4); margin-bottom:16px; text-align:center; transition:all 0.5s ease;">
          <div style="font-size:15px; font-weight:900; color:var(--gold);">
            👆 SCROLL UP to see your selected avatar<br>
            👇 CLICK any NFT below to use it as your profile picture!
          </div>
        </div>

        <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-bottom:18px;">
          <button id="viewPixelBearsBtn" class="btn gold" style="font-size:15px; padding:14px; font-weight:900;">🐻 Pixel Bears</button>
          <button id="viewUltraRaresBtn" class="btn gold" style="font-size:15px; padding:14px; font-weight:900;">💎 Ultra Rares</button>
        </div>

        <div id="nftGrid" style="display:none; max-height:600px; overflow-y:auto; background:rgba(0,0,0,0.3); padding:10px; border-radius:10px; border:2px solid rgba(237,183,35,0.2); margin-bottom:20px;">
          <div id="nftGridContent" style="display:grid; grid-template-columns:repeat(2, 1fr); gap:10px;">
            <!-- NFTs will be loaded here -->
          </div>
        </div>

        <div id="nftLoading" style="display:none; text-align:center; padding:20px; opacity:0.6;">
          Loading NFTs...
        </div>

        <div id="nftEmpty" style="display:none; text-align:center; padding:20px; opacity:0.6; font-size:12px;">
          No NFTs found in your wallet
        </div>
      </div>

      <!-- Disconnect button at bottom of drawer -->
      <div id="drawerDisconnectContainer"></div>
    </div>
  </aside>

  <!-- Profile Page Modal -->
  <div id="profileModal" class="profile-modal" aria-hidden="true">
    <div class="profile-modal-overlay" onclick="closeProfileModal()"></div>
    <div class="profile-modal-content">
      <!-- Header -->
      <div id="profileModalHeader" class="profile-modal-header">
        <h2 id="profileModalTitle" style="margin:0; color:var(--gold); font-size:28px;">MY PROFILE</h2>
        <div style="display: flex; align-items: center; gap: 12px;">
          <button id="profileBackBtn" class="profile-back-btn" onclick="goBackInProfile()" aria-label="Go back" style="display:none;">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
              <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
          </button>
          <button class="bear-search-btn" onclick="toggleBearSearch()" aria-label="BEAR Search">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="11" cy="11" r="8"></circle>
              <path d="m21 21-4.35-4.35"></path>
            </svg>
          </button>
          <button class="profile-close-btn" onclick="closeProfileModal()" aria-label="Close profile">&times;</button>
        </div>
      </div>

      <!-- BEAR Search Panel -->
      <div id="bearSearchPanel" class="bear-search-panel" style="display:none;">
        <div class="search-input-container">
          <input type="text" id="bearSearchInput" placeholder="🔍 Search for a BEAR..." class="bear-search-input">
        </div>
        <div id="bearSearchResults" class="bear-search-results"></div>
      </div>

      <!-- Profile Body -->
      <div class="profile-modal-body">
        <!-- Profile Picture Section -->
        <div id="profilePictureSection" class="profile-picture-section">
          <div id="profilePictureContainer" class="profile-picture-container" style="position: relative;">
            <img id="profilePictureDisplay" src="" alt="Profile Picture" class="profile-picture">
            <div class="profile-picture-placeholder" id="profilePicturePlaceholder">
              <span style="font-size:48px;">🐻</span>
            </div>
            <button id="editProfilePictureBtn" class="edit-profile-picture-btn" onclick="editProfileFromModal()" style="position: absolute; bottom: 8px; right: 8px; width: 40px; height: 40px; border-radius: 50%; background: var(--gold); border: 3px solid #000; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease;">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#000" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
              </svg>
            </button>
          </div>
          <div class="profile-info-header">
            <h3 id="profileDisplayName" class="profile-name">Loading...</h3>
            <p id="profileWalletAddress" class="profile-wallet">Loading...</p>
          </div>
        </div>

        <!-- Follow Stats & Button -->
        <div class="profile-follow-section">
          <div class="follow-stats">
            <div class="follow-stat-item" onclick="showFollowersList(event)" style="cursor: pointer;">
              <div class="follow-stat-number" id="followersCount">0</div>
              <div class="follow-stat-label">Followers</div>
            </div>
            <div class="follow-stat-item" onclick="showFollowingList(event)" style="cursor: pointer;">
              <div class="follow-stat-number" id="followingCount">0</div>
              <div class="follow-stat-label">Following</div>
            </div>
          </div>
          <button id="followBtn" class="follow-btn" onclick="toggleFollow()" style="display:none;">
            <span class="follow-btn-text">Follow</span>
            <span class="follow-btn-icon">+</span>
          </button>
        </div>

        <!-- Bear Bulletin Post Section -->
        <div class="profile-section bulletin-post-section">
          <div class="bulletin-post-input-container">
            <textarea
              id="bulletinPostInput"
              class="bulletin-post-input"
              placeholder="What would you like to share with the BEARS?"
              maxlength="1000"
              rows="3"
            ></textarea>
            <div class="bulletin-post-actions">
              <button id="postToBulletinBtn" class="btn-post-bulletin" onclick="postToBulletin()">
                📢 Post to Bulletin Board
              </button>
            </div>
          </div>
        </div>

        <!-- Bio Section -->
        <div class="profile-section">
          <div class="profile-section-header">
            <h4>📝 Bio</h4>
            <button id="editBioBtn" class="edit-bio-btn">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
              </svg>
            </button>
          </div>
          <div id="bioDisplay" class="bio-display">No bio yet. Click Edit to add one!</div>
          <div id="bioEditor" class="bio-editor" style="display:none;">
            <textarea id="bioTextarea" maxlength="500" placeholder="Tell other BEARs about yourself..."></textarea>
            <div class="bio-editor-actions">
              <button id="saveBioBtn" class="btn-save-bio">Save</button>
              <button id="cancelBioBtn" class="btn-cancel-bio">Cancel</button>
            </div>
          </div>
        </div>

        <!-- Achievements Section -->
        <div class="profile-section">
          <h4>🏆 Achievements</h4>
          <div id="achievementsDisplay" class="achievements-grid">
            <div class="achievement-placeholder">
              <span style="font-size:32px; opacity:0.3;">🔒</span>
              <p style="opacity:0.5; font-size:12px; margin-top:8px;">Coming Soon!</p>
            </div>
            <div class="achievement-placeholder">
              <span style="font-size:32px; opacity:0.3;">🔒</span>
              <p style="opacity:0.5; font-size:12px; margin-top:8px;">Coming Soon!</p>
            </div>
            <div class="achievement-placeholder">
              <span style="font-size:32px; opacity:0.3;">🔒</span>
              <p style="opacity:0.5; font-size:12px; margin-top:8px;">Coming Soon!</p>
            </div>
          </div>
        </div>

        <!-- NFT Collection Section (conditional) -->
        <div class="profile-section">
          <h4 id="nftCollectionHeader">🖼️ My NFT Collection</h4>

          <!-- Pixel BEARS Collection -->
          <div id="pixelBearsSection" class="nft-collection-section" style="display:none;">
            <button class="nft-collection-toggle" onclick="toggleNFTCollection('pixelBears')">
              <span class="nft-collection-title">🎨 PIXEL BEARS</span>
              <span class="nft-collection-count" id="pixelBearsCount">0</span>
              <span class="nft-collection-arrow" id="pixelBearsArrow">▼</span>
            </button>
            <div id="pixelBearsGrid" class="nft-collection-grid" style="display:none;"></div>
          </div>

          <!-- Ultra Rare BEARS Collection -->
          <div id="ultraRareBearsSection" class="nft-collection-section" style="display:none;">
            <button class="nft-collection-toggle" onclick="toggleNFTCollection('ultraRareBears')">
              <span class="nft-collection-title">💎 ULTRA RARE BEARS</span>
              <span class="nft-collection-count" id="ultraRareBearsCount">0</span>
              <span class="nft-collection-arrow" id="ultraRareBearsArrow">▼</span>
            </button>
            <div id="ultraRareBearsGrid" class="nft-collection-grid" style="display:none;"></div>
          </div>

          <!-- No NFTs Message -->
          <div id="noNFTsMessage" class="no-nfts-message">
            <span style="font-size:48px; opacity:0.3;">🐻</span>
            <p>No BEAR NFTs found in this wallet</p>
          </div>
        </div>

        <!-- Comments Section -->
        <div class="profile-section">
          <h4>💬 Comments (<span id="commentsCount">0</span>)</h4>

          <!-- Add Comment Form -->
          <div class="comment-form">
            <textarea id="commentTextarea" placeholder="Leave a comment on this profile..." maxlength="500"></textarea>
            <button id="postCommentBtn" class="btn-post-comment">Post Comment</button>
          </div>

          <!-- Comments List -->
          <div id="commentsList" class="comments-list">
            <div class="comments-loading">Loading comments...</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <style>
    /* 🐻🏙️ BEAR CITY INHABITANTS SYSTEM 🏙️🐻 */
    #bearCityContainer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1; /* Behind UI but visible */
      overflow: visible;
    }

    .city-bear {
      position: absolute;
      width: 60px;
      height: auto;
      opacity: 1;
      filter: drop-shadow(2px 3px 6px rgba(0, 0, 0, 0.3));
      will-change: transform;
      transition: transform 0.1s linear;
      pointer-events: auto;
      cursor: pointer;
      z-index: 1;
    }

    .city-bear:hover {
      filter: drop-shadow(0 0 15px rgba(237, 183, 35, 0.8));
      transform: scale(1.15) !important;
    }

    .city-bear.walking-left {
      transform: scaleX(-1);
    }

    .city-bear.jumping {
      animation: bearJump 0.6s ease-out;
    }

    .city-bear.dancing {
      animation: bearDance 1s ease-in-out infinite;
    }

    .city-bear.waving {
      animation: bearWave 1.5s ease-in-out infinite;
    }

    @keyframes bearJump {
      0%, 100% { transform: translateY(0) scale(1); }
      50% { transform: translateY(-80px) scale(1.1) rotate(10deg); }
    }

    @keyframes bearDance {
      0%, 100% { transform: rotate(0deg) scale(1); }
      25% { transform: rotate(-15deg) scale(1.1); }
      50% { transform: rotate(0deg) scale(1.15); }
      75% { transform: rotate(15deg) scale(1.1); }
    }

    @keyframes bearWave {
      0%, 100% { transform: rotate(0deg); }
      25% { transform: rotate(-20deg); }
      75% { transform: rotate(20deg); }
    }

    @keyframes bearBounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-20px); }
    }

    /* MOBILE OPTIMIZATIONS */
    @media (max-width: 768px) {
      .city-bear {
        width: 40px;
      }
    }
  </style>

  <script>
    // Console logging enabled for debugging

    // 🐻🏙️💥 BEAR CITY INHABITANTS - LIVING ECOSYSTEM 💥🏙️🐻
    (function() {
      const bearImages = [
        'https://files.catbox.moe/a8yk6m.png',
        'https://files.catbox.moe/k3yx6x.png',
        'https://files.catbox.moe/2la74d.png',
        'https://files.catbox.moe/zkxfrs.png',
        'https://files.catbox.moe/sv9big.png',
        'https://files.catbox.moe/scs5nr.png',
        'https://files.catbox.moe/su97n8.png',
        'https://files.catbox.moe/rbz4k3.png',
        'https://files.catbox.moe/mglkoj.png',
        'https://files.catbox.moe/un18dl.png',
        'https://files.catbox.moe/0ftro9.png',
        'https://files.catbox.moe/s5w7wg.png',
        'https://files.catbox.moe/a2pgvw.png',
        'https://files.catbox.moe/ecqtzu.png',
        'https://files.catbox.moe/ku1n1u.png',
        'https://files.catbox.moe/yrf4b7.png',
        'https://files.catbox.moe/dj9a9s.png',
        'https://files.catbox.moe/l5xrps.png',
        'https://files.catbox.moe/r6myzr.png',
        'https://files.catbox.moe/kbjcbv.png',
        'https://files.catbox.moe/2weeov.png',
        'https://files.catbox.moe/ijhbbj.png',
        'https://files.catbox.moe/6t4s3b.png',
        'https://files.catbox.moe/09oxkp.png',
        'https://files.catbox.moe/y72z5w.png',
        'https://files.catbox.moe/6a7p84.png',
        'https://files.catbox.moe/qwh0mg.png'
      ];

      const container = document.getElementById('bearCityContainer');
      if (!container) return;

      const hero = document.querySelector('.hero');
      if (!hero) return;

      let cityBears = [];
      let containerWidth = hero.offsetWidth;
      let containerHeight = hero.offsetHeight;

      // Ground level - bears stay in bottom 60% (40% from top to 100%)
      const groundStart = containerHeight * 0.4;
      const groundEnd = containerHeight * 0.95;

      // 🏠💧 NO-WALK ZONES - Bears avoid water only!
      const noWalkZones = [
        // 💧💧💧 WATER ZONE - Bottom portion only
        {
          left: 0,
          right: containerWidth * 0.35,  // 35% from left
          top: containerHeight * 0.60,   // Start at 60% from top (increased by 5%)
          bottom: containerHeight,       // To the bottom
          name: 'WATER ZONE - ABSOLUTE NO ENTRY'
        }
      ];

      // Check if position is in any no-walk zone
      function isInNoWalkZone(x, y) {
        for (let zone of noWalkZones) {
          if (x >= zone.left && x <= zone.right && y >= zone.top && y <= zone.bottom) {
            return zone;
          }
        }
        return null;
      }

      // BEAR CLASS - Each bear is a living entity
      class CityBear {
        constructor(imageSrc, index) {
          this.element = document.createElement('img');
          this.element.src = imageSrc;
          this.element.className = 'city-bear';
          this.element.loading = 'lazy';

          // Random starting position on the ground (NOT in water!)
          do {
            this.x = Math.random() * (containerWidth - 80);
            this.y = groundStart + Math.random() * (groundEnd - groundStart);
          } while (isInNoWalkZone(this.x, this.y));

          this.speed = (0.3 + Math.random() * 1.2) * 0.75; // pixels per frame (25% slower)
          this.direction = Math.random() > 0.5 ? 1 : -1; // 1 = right, -1 = left
          this.state = 'walking'; // walking, standing, dancing, jumping
          this.stateTimer = Math.random() * 300;
          this.isActive = true;
          this.imageSrc = imageSrc;

          // Position the bear
          this.element.style.left = this.x + 'px';
          this.element.style.top = this.y + 'px';

          if (this.direction < 0) {
            this.element.classList.add('walking-left');
          }

          // Handle broken images - remove them
          this.element.onerror = () => {
            console.warn('🐻 ❌ Broken bear image removed: ' + imageSrc);
            this.element.remove();
            this.isActive = false;
          };

          // Click interaction
          this.element.addEventListener('click', () => this.onClick());

          container.appendChild(this.element);
        }

        onClick() {
          const actions = ['jumping', 'dancing', 'waving'];
          const action = actions[Math.floor(Math.random() * actions.length)];

          this.element.classList.remove('jumping', 'dancing', 'waving');
          this.element.classList.add(action);

          setTimeout(() => {
            this.element.classList.remove(action);
          }, action === 'dancing' ? 3000 : action === 'waving' ? 4500 : 600);

          console.log('🐻 Bear is ' + action + '!');
        }

        update() {
          if (!this.isActive) return; // Skip if bear is removed

          this.stateTimer--;

          // Randomly change states
          if (this.stateTimer <= 0) {
            const rand = Math.random();
            if (rand > 0.7) {
              this.state = 'standing';
              this.stateTimer = 60 + Math.random() * 120;
            } else if (rand > 0.5) {
              this.state = 'dancing';
              this.element.classList.add('dancing');
              this.stateTimer = 180 + Math.random() * 120;
              setTimeout(() => this.element.classList.remove('dancing'), this.stateTimer * 16);
            } else {
              this.state = 'walking';
              this.stateTimer = 180 + Math.random() * 300;
              // Randomly change direction
              if (Math.random() > 0.7) {
                this.direction *= -1;
                if (this.direction < 0) {
                  this.element.classList.add('walking-left');
                } else {
                  this.element.classList.remove('walking-left');
                }
              }
            }
          }

          // Move if walking
          if (this.state === 'walking') {
            this.move();
          }
        }

        move() {
          const nextX = this.x + this.speed * this.direction;

          // Check if next position would be in a no-walk zone
          const blockedZone = isInNoWalkZone(nextX, this.y);
          if (blockedZone) {
            // Don't walk into buildings or water! Turn around!
            this.direction *= -1;
            if (this.direction < 0) {
              this.element.classList.add('walking-left');
            } else {
              this.element.classList.remove('walking-left');
            }
            console.log('🐻🏠 Bear avoided ' + blockedZone.name + '!');
          } else {
            this.x = nextX;
          }

          // Screen boundaries - mostly bounce, but 10% chance to walk off and despawn
          if (this.x < 0) {
            if (Math.random() < 0.1) {
              // 10% chance - let them walk off to despawn
              if (this.x < -100) {
                console.log('🐻👋 Bear walked off LEFT - despawning...');
                this.despawn();
                return;
              }
            } else {
              // 90% chance - bounce back
              this.x = 10;
              this.direction = 1;
              this.element.classList.remove('walking-left');
            }
          } else if (this.x >= containerWidth - 80) {
            if (Math.random() < 0.1) {
              // 10% chance - let them walk off to despawn
              if (this.x > containerWidth + 100) {
                console.log('🐻👋 Bear walked off RIGHT - despawning...');
                this.despawn();
                return;
              }
            } else {
              // 90% chance - bounce back
              this.x = containerWidth - 80;
              this.direction = -1;
              this.element.classList.add('walking-left');
            }
          }

          // Update position
          this.element.style.left = this.x + 'px';
        }

        despawn() {
          if (this.element && this.element.parentNode) {
            this.element.remove();
          }
          this.isActive = false;

          // Remove from cityBears array
          const index = cityBears.indexOf(this);
          if (index > -1) {
            cityBears.splice(index, 1);
          }

          // Return image to available pool
          availableBearImages.push(this.imageSrc);
        }
      }

      // Available bear images pool
      let availableBearImages = [...bearImages];

      // Get max bears based on screen size
      function getMaxBears() {
        const width = window.innerWidth;
        if (width < 768) return 5;        // Mobile: 5 bears
        if (width < 1024) return 10;      // Tablet: 10 bears
        if (width < 1440) return 15;      // Small desktop: 15 bears
        if (width < 1920) return 20;      // Desktop: 20 bears
        return 27;                        // Ultrawide: all 27 bears
      }

      // Spawn a new bear from off-screen
      function spawnRandomBear() {
        if (cityBears.length >= getMaxBears()) return;
        if (availableBearImages.length === 0) {
          availableBearImages = [...bearImages]; // Refill pool
        }

        // Pick random bear image
        const randomIndex = Math.floor(Math.random() * availableBearImages.length);
        const imageSrc = availableBearImages[randomIndex];
        availableBearImages.splice(randomIndex, 1);

        const bear = new CityBear(imageSrc, cityBears.length);

        // Pick safe Y position that's NOT in water zone
        // Spawn across the full ground area (40% to 95%) but avoid water zone
        const groundStart = containerHeight * 0.4;
        const groundEnd = containerHeight * 0.95;

        // Try to find a safe Y position (not in water zone)
        let attempts = 0;
        do {
          bear.y = groundStart + Math.random() * (groundEnd - groundStart);
          attempts++;
        } while (isInNoWalkZone(containerWidth * 0.5, bear.y) && attempts < 20);

        bear.element.style.top = bear.y + 'px';

        // Spawn off-screen (left or right)
        // IMPORTANT: Don't spawn from left if it would make them walk through water zone
        const waterZoneEnd = containerWidth * 0.35; // Water zone ends at 35%
        const canSpawnFromLeft = bear.y < (containerHeight * 0.60); // Only if Y is above water zone

        const spawnFromLeft = canSpawnFromLeft && (Math.random() > 0.5);
        if (spawnFromLeft) {
          bear.x = -80;
          bear.direction = 1; // Walk right
          bear.element.classList.remove('walking-left');
        } else {
          bear.x = containerWidth + 80;
          bear.direction = -1; // Walk left
          bear.element.classList.add('walking-left');
        }
        bear.state = 'walking';
        bear.element.style.left = bear.x + 'px';

        cityBears.push(bear);
        console.log('🐻✨ New bear spawned from ' + (spawnFromLeft ? 'LEFT' : 'RIGHT') + ' at safe Y position! Total: ' + cityBears.length);
      }

      // Initialize with responsive number of bears
      function initializeBears() {
        const maxBears = getMaxBears();
        console.log('🐻🏙️ Initializing BEAR CITY with ' + maxBears + ' inhabitants for screen size ' + window.innerWidth + 'px');

        for (let i = 0; i < maxBears; i++) {
          setTimeout(() => {
            spawnRandomBear();
          }, i * 300); // Stagger initial spawning
        }

        console.log('🐻✨ BEAR CITY is spawning!');
      }

      // Spawn new bears periodically
      setInterval(() => {
        if (cityBears.length < getMaxBears()) {
          spawnRandomBear();
        }
      }, 8000); // Try to spawn every 8 seconds

      // ANIMATION LOOP
      function animate() {
        cityBears.forEach(bear => bear.update());
        requestAnimationFrame(animate);
      }

      // HANDLE RESIZE
      function handleResize() {
        containerWidth = hero.offsetWidth;
        containerHeight = hero.offsetHeight;

        // Update water zone boundary only
        noWalkZones[0] = { // 💧💧💧 WATER ZONE - Bottom portion only
          left: 0,
          right: containerWidth * 0.35,
          top: containerHeight * 0.60,   // Start at 60% from top (increased by 5%)
          bottom: containerHeight,
          name: 'WATER ZONE - ABSOLUTE NO ENTRY'
        };

        // Adjust bear count based on new screen size
        const maxBears = getMaxBears();
        if (cityBears.length > maxBears) {
          // Too many bears - remove excess
          const excess = cityBears.length - maxBears;
          console.log('🐻📉 Screen got smaller - removing ' + excess + ' bears');
          for (let i = 0; i < excess; i++) {
            if (cityBears.length > 0) {
              const bear = cityBears[cityBears.length - 1];
              bear.despawn();
            }
          }
        }

      }

      window.addEventListener('resize', handleResize);

      // START THE CITY
      handleResize(); // Initialize zones
      initializeBears();
      animate();

      console.log('🐻🏙️💥 BEAR CITY IS ALIVE! 💥🏙️🐻');
    })();
  </script>

  <script>
    // 🎨💥🔥 EPIC 3D LAYERED PARALLAX SIGN WITH JESTER BEAR 🔥💥🎨
    (function() {
      const woodenSign = document.getElementById('woodenSign');
      const woodenSignContainer = document.getElementById('woodenSignContainer');
      const signParallaxWrapper = document.getElementById('signParallaxWrapper');
      const signLayers = document.querySelectorAll('.sign-layer');

      if (!woodenSign || !woodenSignContainer || !signParallaxWrapper) return;

      let time = 0;
      let clickCount = 0;
      let clickTimer = null;

      // Spring physics for smooth movement
      let currentX = 0, currentY = 0;
      let velocityX = 0, velocityY = 0;
      let targetX = 0, targetY = 0;

      // 3D rotation
      let currentRotX = 0, currentRotY = 0, currentRotZ = 0;
      let targetRotX = 0, targetRotY = 0, targetRotZ = 0;

      // Scale and intensity
      let currentScale = 1;
      let targetScale = 1;
      let mouseDistance = 1;
      let isNearMouse = false;

      // EPIC SPRING PHYSICS ANIMATION
      function animate() {
        time += 0.003;

        // Idle floating when not interacting
        const idleFloatY = Math.sin(time) * 8;
        const idleFloatX = Math.cos(time * 0.6) * 6;
        const idleRotZ = Math.sin(time * 0.5) * 2;

        // Spring physics for smooth magnetic following
        const springStrength = 0.05;
        const damping = 0.85;

        velocityX += (targetX - currentX) * springStrength;
        velocityY += (targetY - currentY) * springStrength;
        velocityX *= damping;
        velocityY *= damping;
        currentX += velocityX;
        currentY += velocityY;

        // Smooth rotation interpolation
        currentRotX += (targetRotX - currentRotX) * 0.15;
        currentRotY += (targetRotY - currentRotY) * 0.15;
        currentRotZ += (targetRotZ - currentRotZ) * 0.15;

        // Smooth scale
        currentScale += (targetScale - currentScale) * 0.1;

        // Apply transforms to wrapper with combined idle + interactive movement
        const finalX = currentX + idleFloatX;
        const finalY = currentY + idleFloatY;
        const finalRotZ = currentRotZ + idleRotZ;

        signParallaxWrapper.style.transform = `
          translate(${finalX}px, ${finalY}px)
          rotateX(${currentRotX}deg)
          rotateY(${currentRotY}deg)
          rotateZ(${finalRotZ}deg)
          scale(${currentScale})
        `;

        // Apply layered parallax to each layer based on depth
        signLayers.forEach((layer) => {
          const depth = parseFloat(layer.getAttribute('data-depth')) || 1;
          const isDepthLayer = layer.classList.contains('sign-depth-layer');

          // Each layer moves at different speed/intensity
          const layerX = currentX * depth;
          const layerY = currentY * depth;
          const layerRotY = currentRotY * depth * 0.5;
          const layerRotX = currentRotX * depth * 0.5;

          // SUBTLE glow intensity based on mouse proximity
          const glowIntensity = 8 + (1 - mouseDistance) * 12; // Much more subtle
          const brightness = 1 + (1 - mouseDistance) * 0.1 * depth; // Very subtle brightness

          // FADE IN depth layers ONLY when mouse is near
          if (isDepthLayer) {
            const maxOpacity = depth === 0.2 ? 0.2 : depth === 0.4 ? 0.3 : 0;
            const targetOpacity = isNearMouse ? maxOpacity * (1 - mouseDistance) : 0;
            layer.style.opacity = targetOpacity;
          }

          // Add SUBTLE dynamic lighting to main sign
          if (layer === woodenSign) {
            layer.style.filter = `
              drop-shadow(0 ${glowIntensity}px ${glowIntensity * 2}px rgba(0, 0, 0, 0.5))
              drop-shadow(0 0 ${glowIntensity}px rgba(139, 69, 19, ${0.2 + (1 - mouseDistance) * 0.1}))
              brightness(${brightness})
            `;
          }
        });

        requestAnimationFrame(animate);
      }

      // MAGNETIC MOUSE TRACKING WITH EXTREME PARALLAX
      let mouseUpdateTicking = false;
      document.addEventListener('mousemove', (e) => {
        if (mouseUpdateTicking) return;
        mouseUpdateTicking = true;

        requestAnimationFrame(() => {
          const rect = signParallaxWrapper.getBoundingClientRect();
          const signCenterX = rect.left + rect.width / 2;
          const signCenterY = rect.top + rect.height / 2;

          // Calculate distance from mouse to sign center
          const deltaX = e.clientX - signCenterX;
          const deltaY = e.clientY - signCenterY;
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          const maxDistance = 800; // Magnetic attraction radius

          // Normalize distance (0 = at center, 1 = far away)
          mouseDistance = Math.min(distance / maxDistance, 1);
          isNearMouse = distance < maxDistance;

          if (isNearMouse) {
            // MAGNETIC PULL - sign follows mouse
            const pullStrength = (1 - mouseDistance) * 60; // Stronger when closer
            targetX = (deltaX / maxDistance) * pullStrength;
            targetY = (deltaY / maxDistance) * pullStrength;

            // EXTREME 3D ROTATION based on mouse position
            targetRotY = (deltaX / rect.width) * 25; // More extreme tilt
            targetRotX = -(deltaY / rect.height) * 25;
            targetRotZ = (deltaX / rect.width) * 8; // Add Z rotation for more depth

            // SCALE UP when mouse is near
            targetScale = 1 + (1 - mouseDistance) * 0.15;
          } else {
            // Return to idle state
            targetX = 0;
            targetY = 0;
            targetRotX = 0;
            targetRotY = 0;
            targetRotZ = 0;
            targetScale = 1;
          }

          mouseUpdateTicking = false;
        });
      });

      // JESTER BEAR EASTER EGG - Click 5 times with PLAYFUL animations!
      woodenSign.addEventListener('click', () => {
        clickCount++;

        // Reset timer
        if (clickTimer) clearTimeout(clickTimer);
        clickTimer = setTimeout(() => {
          clickCount = 0;
        }, 2000);

        // PLAYFUL BUBBLY CLICK ANIMATIONS - each click gets progressively more excited!
        const bounceAmount = 1.05 + (clickCount * 0.02); // Grows slightly with each click
        const rotateAmount = 3 + (clickCount * 2); // Wiggles more with each click

        // Quick bubble bounce
        targetScale = bounceAmount;
        setTimeout(() => targetScale = isNearMouse ? 1.05 : 1, 150);

        // Playful wiggle alternating directions
        targetRotZ = clickCount % 2 === 0 ? rotateAmount : -rotateAmount;
        setTimeout(() => targetRotZ = 0, 200);

        // Subtle Y bounce
        targetY = targetY - 10;
        setTimeout(() => targetY = 0, 200);

        // JESTER BEAR APPEARS ON 5th CLICK!
        if (clickCount === 5) {
          spawnJesterBear();
          clickCount = 0;
          // BIG CELEBRATION BOUNCE
          targetScale = 1.2;
          targetRotZ = 15;
          setTimeout(() => {
            targetScale = 1;
            targetRotZ = -15;
          }, 150);
          setTimeout(() => {
            targetRotZ = 0;
          }, 300);
          console.log('🤡🐻 JESTER BEAR HAS BEEN SUMMONED! 🐻🤡');
        }
      });

      // SPAWN JESTER BEAR RUNNING ACROSS SCREEN
      function spawnJesterBear() {
        const jester = document.createElement('img');
        jester.src = 'https://files.catbox.moe/sv9big.png';
        jester.style.position = 'fixed';
        jester.style.bottom = '20%';
        jester.style.left = '-150px';
        jester.style.width = '120px';
        jester.style.height = 'auto';
        jester.style.zIndex = '99999';
        jester.style.pointerEvents = 'none';
        jester.style.filter = 'drop-shadow(0 10px 30px rgba(0,0,0,0.5))';
        jester.style.transition = 'left 3s linear, transform 3s ease-in-out';
        jester.style.animation = 'jesterRun 3s linear';

        document.body.appendChild(jester);

        // Animate across screen with bounce
        setTimeout(() => {
          jester.style.left = window.innerWidth + 'px';
          jester.style.transform = 'scaleX(-1)'; // Flip to face right
        }, 50);

        // Remove after animation
        setTimeout(() => {
          jester.remove();
        }, 3200);
      }

      // SCROLL PARALLAX
      let scrollTicking = false;
      window.addEventListener('scroll', () => {
        if (scrollTicking) return;
        scrollTicking = true;

        requestAnimationFrame(() => {
          const scrollY = window.scrollY || window.pageYOffset;
          const maxScroll = 1600;
          const scrollProgress = Math.min(scrollY / maxScroll, 1);

          const moveY = scrollProgress * -100;
          const moveX = Math.sin(scrollProgress * Math.PI * 2) * 50;
          const rotateAmount = scrollProgress * 360;
          const scaleAmount = 1 + scrollProgress * 1;
          const opacity = Math.max(0, 1 - scrollProgress * 1.2);

          woodenSignContainer.style.transform = `translate(-50%, calc(-50% + ${moveY}px)) translateX(${moveX}px) rotate(${rotateAmount}deg) scale(${scaleAmount})`;
          woodenSignContainer.style.opacity = opacity;

          scrollTicking = false;
        });
      });

      // START ANIMATION
      animate();

      console.log('🎨💥 EPIC 3D PARALLAX SIGN IS ALIVE! Move your mouse near it! Click 5 times for JESTER BEAR! 💥🎨');
    })();
  </script>

  <script>
    // 🎯 FLOATING NAVIGATION BUTTONS WITH PARALLAX 🎯
    (function() {
      const floatingBtns = document.querySelectorAll('.floating-nav-btn');

      if (!floatingBtns.length) return;

      let mouseX = 0;
      let mouseY = 0;
      let mouseUpdateTicking = false;

      // Track mouse position
      document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;

        if (mouseUpdateTicking) return;
        mouseUpdateTicking = true;

        requestAnimationFrame(() => {
          const centerX = window.innerWidth / 2;
          const centerY = window.innerHeight / 2;

          // Calculate mouse offset from center
          const offsetX = (mouseX - centerX) / centerX;
          const offsetY = (mouseY - centerY) / centerY;

          floatingBtns.forEach(btn => {
            const depth = parseFloat(btn.getAttribute('data-depth')) || 0.8;

            // Apply parallax movement
            const moveX = offsetX * 20 * depth;
            const moveY = offsetY * 20 * depth;

            // Preserve centering for honey points button
            if (btn.id === 'honeyNavBtn') {
              btn.style.transform = `translateX(-50%) translate(${moveX}px, ${moveY}px)`;
            } else {
              btn.style.transform = `translate(${moveX}px, ${moveY}px)`;
            }
          });

          mouseUpdateTicking = false;
        });
      });

      // Add click handlers for smooth scrolling
      floatingBtns.forEach(btn => {
        const textElement = btn.querySelector('.floating-nav-text');
        if (!textElement) return;

        const sectionId = textElement.getAttribute('data-section');

        btn.addEventListener('click', () => {
          const targetSection = document.getElementById(sectionId);
          if (targetSection) {
            targetSection.scrollIntoView({
              behavior: 'smooth',
              block: 'start'
            });
          }
        });
      });

      // Scroll parallax - fade out as user scrolls
      let scrollTicking = false;
      window.addEventListener('scroll', () => {
        if (scrollTicking) return;
        scrollTicking = true;

        requestAnimationFrame(() => {
          const scrollY = window.scrollY || window.pageYOffset;
          const maxScroll = 800;
          const scrollProgress = Math.min(scrollY / maxScroll, 1);

          const opacity = Math.max(0, 1 - scrollProgress * 1.5);

          floatingBtns.forEach(btn => {
            btn.style.opacity = opacity;
          });

          scrollTicking = false;
        });
      });

      console.log('🎯 FLOATING NAV BUTTONS ACTIVE! Click to navigate! 🎯');
    })();
  </script>

  <style>
    @keyframes signGoNuts {
      0% { transform: scale(1) rotate(0deg); }
      10% { transform: scale(1.25) rotate(10deg); }
      20% { transform: scale(0.9) rotate(-10deg); }
      30% { transform: scale(1.15) rotate(8deg); }
      40% { transform: scale(0.95) rotate(-8deg); }
      50% { transform: scale(1.2) rotate(12deg); }
      60% { transform: scale(0.92) rotate(-5deg); }
      70% { transform: scale(1.1) rotate(5deg); }
      80% { transform: scale(0.97) rotate(-3deg); }
      90% { transform: scale(1.05) rotate(2deg); }
      100% { transform: scale(1) rotate(0deg); }
    }

    #woodenSign {
      cursor: pointer;
      transition: filter 0.3s ease, transform 0.3s ease;
      will-change: transform, filter;
    }

    #woodenSignContainer {
      will-change: transform, opacity;
      pointer-events: auto;
    }

    /* Responsive sizing */
    @media (max-width: 768px) {
      #signParallaxWrapper {
        width: 280px !important;
      }
      #woodenSignContainer {
        top: 35% !important;
      }
    }

    /* 🎯 FLOATING NAVIGATION BUTTONS 🎯 */
    .floating-nav-btn {
      will-change: transform, opacity;
      pointer-events: auto;
      transition: all 0.3s ease;
    }

    .floating-nav-text {
      font-family: 'Luckiest Guy', 'Arial Black', Impact, sans-serif;
      font-size: clamp(24px, 3vw, 42px);
      color: #fff;
      text-shadow:
        4px 4px 0 #000,
        -2px -2px 0 #000,
        2px -2px 0 #000,
        -2px 2px 0 #000,
        0 0 20px rgba(237, 183, 35, 0.6),
        0 0 40px rgba(237, 183, 35, 0.4);
      cursor: pointer;
      transition: all 0.3s ease;
      user-select: none;
      white-space: nowrap;
      text-align: center;
    }

    .floating-nav-text:hover {
      color: var(--gold);
      text-shadow:
        4px 4px 0 #000,
        -2px -2px 0 #000,
        2px -2px 0 #000,
        -2px 2px 0 #000,
        0 0 30px rgba(237, 183, 35, 0.8),
        0 0 50px rgba(237, 183, 35, 0.6);
      transform: scale(1.1);
    }

    .floating-nav-text:active {
      transform: scale(0.95);
    }

    /* Responsive adjustments for floating nav buttons */
    @media (max-width: 768px) {
      .floating-nav-btn {
        display: none !important;
      }
    }

    @media (max-width: 1200px) {
      #raidsNavBtn {
        left: 13% !important;
      }
      #gamesNavBtn {
        right: 8% !important;
      }
    }
  </style>

  <!-- Structured data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "name": "BEAR Park",
    "url": "https://bearpark.xyz/",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "https://bearpark.xyz/?q={search_term_string}",
      "query-input": "required name=search_term_string"
    }
  }
  </script>

  <script>
  // === VERSION CHECK - Force cache refresh ===
  (function checkVersion() {
    const CURRENT_VERSION = '2025-01-10-v2';
    const STORED_VERSION = localStorage.getItem('bearpark_site_version');

    if (STORED_VERSION !== CURRENT_VERSION) {
      console.log('🔄 New version detected! Forcing cache refresh...');
      localStorage.setItem('bearpark_site_version', CURRENT_VERSION);

      // Force a hard reload if this is not the first visit
      if (STORED_VERSION !== null && !sessionStorage.getItem('bearpark_just_refreshed')) {
        sessionStorage.setItem('bearpark_just_refreshed', 'true');
        window.location.reload(true);
      }
    }
  })();

  // === API CONFIGURATION ===
  const API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
    ? 'http://localhost:3000'
    : '';

  // === INTERVAL MANAGER - Prevent memory leaks ===
  const IntervalManager = {
    intervals: new Map(),
    set(key, fn, ms) {
      // Clear existing interval with same key
      this.clear(key);
      // Set new interval and store reference
      const id = setInterval(fn, ms);
      this.intervals.set(key, id);
      return id;
    },
    clear(key) {
      if (this.intervals.has(key)) {
        clearInterval(this.intervals.get(key));
        this.intervals.delete(key);
      }
    },
    clearAll() {
      this.intervals.forEach(id => clearInterval(id));
      this.intervals.clear();
    }
  };

  // Clear all intervals when page unloads or user navigates away
  window.addEventListener('beforeunload', () => IntervalManager.clearAll());
  window.addEventListener('pagehide', () => IntervalManager.clearAll());

  // === AUTHENTICATION CHECK - Prevent bypass ===
  (function checkAuth(){
    const isAuthenticated = localStorage.getItem('bearpark_auth');
    const authenticatedWallet = localStorage.getItem('bearpark_wallet');

    // If not authenticated, redirect to login page
    if(isAuthenticated !== 'true' || !authenticatedWallet){
      window.location.href = 'index.html';
      return;
    }

    // Optional: Display wallet address in console for debugging
    console.log('Authenticated wallet:', authenticatedWallet);

    // Add logout button inside drawer
    const logoutBtn = document.createElement('button');
    logoutBtn.className = 'drawer-disconnect-btn';
    logoutBtn.innerHTML = '<span>disconnect</span>';
    logoutBtn.setAttribute('aria-label', 'Disconnect wallet and logout');
    logoutBtn.addEventListener('click', function(){
      if(confirm('Are you sure you want to disconnect your wallet?')){
        localStorage.removeItem('bearpark_auth');
        localStorage.removeItem('bearpark_wallet');
        window.location.href = 'index.html';
      }
    });
    const disconnectContainer = document.getElementById('drawerDisconnectContainer');
    if(disconnectContainer){
      disconnectContainer.appendChild(logoutBtn);
    }
  })();

  document.documentElement.classList.remove('no-js');

  /* Input modality hint */
  document.addEventListener('mousedown',()=>document.body.classList.add('using-mouse'));
  document.addEventListener('keydown',()=>document.body.classList.remove('using-mouse'));

  /* ===== Scroll reveal ===== */
  const io=new IntersectionObserver((entries)=>entries.forEach(e=>{
    if(e.isIntersecting){
      e.target.classList.add('in'); io.unobserve(e.target);
    }
  }),{threshold:.15});
  document.querySelectorAll('.reveal').forEach(el=>io.observe(el));

  /* ===== Sticky nav scroll progress + scrollspy ===== */
  (function(){
    const progress = document.getElementById('progress');
    const links = Array.from(document.querySelectorAll('.links a'));
    const sections = links.map(a => document.querySelector(a.getAttribute('href'))).filter(Boolean);

    function spy(){
      const de=document.documentElement;
      const scrollTop = de.scrollTop || document.body.scrollTop;
      const scrollHeight = de.scrollHeight - de.clientHeight;
      const pct = scrollHeight ? scrollTop / scrollHeight : 0;
      if(progress) progress.style.transform = `scaleX(${pct})`;

      let activeIndex = sections.findIndex((sec, i) => {
        const next = sections[i+1];
        const top = sec.offsetTop - 120;
        const bottom = next ? next.offsetTop - 120 : Infinity;
        return scrollTop >= top && scrollTop < bottom;
      });
      links.forEach((a,i)=> a.setAttribute('aria-current', i===activeIndex ? 'true' : 'false'));
    }
    document.addEventListener('scroll', spy, {passive:true});
    window.addEventListener('resize', spy);
    spy();
  })();

  /* ===== Hero parallax ===== */
  (function(){
    const plate=document.getElementById('heroPlate');
    if(!plate) return;
    if (matchMedia('(prefers-reduced-motion: reduce)').matches) return;

    function tilt(x,y){
      const rX = (y-0.5)*10;
      const rY = (x-0.5)*-10;
      plate.style.transform = `perspective(800px) rotateX(${rX}deg) rotateY(${rY}deg) translateZ(0)`;
    }
    function reset(){ plate.style.transform='perspective(800px) rotateX(0) rotateY(0)'; }

    window.addEventListener('mousemove',e=>{
      const r=plate.getBoundingClientRect();
      tilt((e.clientX-r.left)/r.width,(e.clientY-r.top)/r.height);
    });
    window.addEventListener('mouseleave',reset);
  })();

  /* ===== Magnetic buttons (skip on touch) ===== */
  (function(){
    if (matchMedia('(pointer: coarse)').matches) return;
    const strength = 14;
    const maxShift = 10;

    document.querySelectorAll('.btn').forEach(btn=>{
      let raf = null;
      function onMove(e){
        if (raf) cancelAnimationFrame(raf);
        raf = requestAnimationFrame(()=>{
          const rect = btn.getBoundingClientRect();
          const cx = rect.left + rect.width/2;
          const cy = rect.top + rect.height/2;
          const dx = Math.max(-maxShift, Math.min(maxShift, (e.clientX - cx)/strength));
          const dy = Math.max(-maxShift, Math.min(maxShift, (e.clientY - cy)/strength));
          btn.style.transform = `translate(${dx}px, ${dy}px)`;
        });
      }
      btn.addEventListener('mousemove', onMove);
      btn.addEventListener('mouseleave', ()=>{
        if (raf) cancelAnimationFrame(raf);
        btn.style.transform = 'translate(0,0)';
      });
    });
  })();

  /* ===== Carousel: a11y + keys + swipe + zoom/pan ===== */
  (function(){
    const slides = document.getElementById('slides');
    const viewport = document.getElementById('viewport');
    const prevBtn = document.getElementById('carouselPrev');
    const nextBtn = document.getElementById('carouselNext');
    if(!slides || !viewport) return;

    const imgs = slides.querySelectorAll('img');
    const dotsWrap = document.getElementById('dots');

    const Z_MIN = 1, Z_MAX = 4;
    let idx=0, n=imgs.length, timer=null, userPaused=false;
    let isDrag=false, startX=0, deltaX=0, dragged=false;
    let scale=1, panX=0, panY=0, pinchStartDist=0, startScale=1, lastX=0, lastY=0;
    let zoomGesture=false;

    imgs.forEach((_,i)=>{
      const b=document.createElement('button');
      b.type='button';
      b.className='dot'+(i===0?' active':'');
      b.setAttribute('role','tab');
      b.setAttribute('aria-selected', i===0 ? 'true' : 'false');
      b.setAttribute('aria-label', `Show slide ${i+1} of ${n}`);
      b.addEventListener('click', ()=>go(i,true));
      dotsWrap.appendChild(b);
    });
    const dots=[...dotsWrap.children];

    function applyZoom(){ imgs[idx].style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`; }
    function resetZoom(all=false){
      scale=1; panX=0; panY=0;
      (all?imgs:[imgs[idx]]).forEach(i=>{
        i.style.transition='transform .2s ease';
        i.style.transform='scale(1)';
        setTimeout(()=>i.style.transition='',200);
      });
    }
    function clampPan(){
      const vw=viewport.clientWidth, vh=viewport.clientHeight;
      const maxX=(vw*(scale-1))/2, maxY=(vh*(scale-1))/2;
      panX=Math.max(-maxX,Math.min(maxX,panX));
      panY=Math.max(-maxY,Math.min(maxY,panY));
    }
    function go(i, user){
      resetZoom(true);
      idx=(i+n)%n;
      slides.style.transition='transform .7s var(--ease-spring)';
      slides.style.transform=`translateX(-${idx*100}%)`;
      dots.forEach((d,k)=>{
        const active = k===idx;
        d.classList.toggle('active',active);
        d.setAttribute('aria-selected', active ? 'true' : 'false');
      });
      viewport.setAttribute('aria-label', `Carousel viewport — slide ${idx+1} of ${n}`);
      if(user && !userPaused) restart();
    }
    function next(){ go(idx+1,false) }
    function restart(){
      clearInterval(timer);
      timer=setInterval(()=>{ if(!userPaused && scale===1) next(); },4000);
    }

    // Arrow button navigation
    if(prevBtn) {
      prevBtn.addEventListener('click', (e)=>{
        e.stopPropagation();
        go(idx-1, true);
      });
    }
    if(nextBtn) {
      nextBtn.addEventListener('click', (e)=>{
        e.stopPropagation();
        go(idx+1, true);
      });
    }

    viewport.addEventListener('mousedown',e=>{
      isDrag=true; dragged=false; startX=e.clientX; lastX=e.clientX; lastY=e.clientY;
      viewport.classList.add('grabbing'); clearInterval(timer);
    });
    window.addEventListener('mousemove',e=>{
      if(!isDrag) return;
      if(scale>1){
        const dx=e.clientX-lastX, dy=e.clientY-lastY;
        lastX=e.clientX; lastY=e.clientY; panX+=dx; panY+=dy; clampPan(); applyZoom(); dragged=true; return;
      }
      deltaX=e.clientX-startX;
      slides.style.transition='none';
      slides.style.transform=`translateX(${ -idx*100 + (deltaX/viewport.clientWidth)*100 }%)`;
      if(Math.abs(deltaX)>3) dragged=true;
    });
    window.addEventListener('mouseup',()=>{
      if(!isDrag) return;
      isDrag=false; viewport.classList.remove('grabbing');
      if(scale>1){ if(!userPaused) restart(); return; }
      const threshold = viewport.clientWidth*0.12;
      if(Math.abs(deltaX)>threshold){ go(idx + (deltaX<0?1:-1), true); } else { go(idx,false); }
      if(!userPaused) restart();
    });

    viewport.addEventListener('click',()=>{
      if(dragged || scale>1 || zoomGesture) return;
      userPaused=!userPaused;
      if(userPaused) clearInterval(timer); else restart();
    });
    viewport.addEventListener('keydown',e=>{
      if(e.key==='ArrowRight'){ go(idx+1,true); }
      else if(e.key==='ArrowLeft'){ go(idx-1,true); }
      else if(e.key===' '){ userPaused=!userPaused; if(userPaused) clearInterval(timer); else restart(); e.preventDefault(); }
    });

    viewport.addEventListener('touchstart',e=>{
      if(e.touches.length===2){
        zoomGesture=true; clearInterval(timer);
        const [a,b]=e.touches; pinchStartDist=Math.hypot(a.clientX-b.clientX,a.clientY-b.clientY); startScale=scale;
      } else if(e.touches.length===1){
        dragged=false; startX=e.touches[0].clientX; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY;
      }
    },{passive:false});

    viewport.addEventListener('touchmove',e=>{
      if(zoomGesture && e.touches.length===2){
        e.preventDefault();
        const [a,b]=e.touches; const dist=Math.hypot(a.clientX-b.clientX,a.clientY-b.clientY);
        scale=Math.max(Z_MIN,Math.min(Z_MAX, startScale * (dist/pinchStartDist)));
        clampPan(); applyZoom();
      } else if(scale>1 && e.touches.length===1){
        e.preventDefault();
        const t=e.touches[0]; const dx=t.clientX-lastX, dy=t.clientY-lastY;
        lastX=t.clientX; lastY=t.clientY; panX+=dx; panY+=dy; clampPan(); applyZoom(); dragged=true;
      } else if(scale===1 && e.touches.length===1){
        const x=e.touches[0].clientX; deltaX=x-startX;
        slides.style.transition='none';
        slides.style.transform=`translateX(${ -idx*100 + (deltaX/viewport.clientWidth)*100 }%)`;
      }
    },{passive:false});

    viewport.addEventListener('touchend',e=>{
      if(zoomGesture && e.touches.length<2){
        zoomGesture=false;
        if(scale<=1.01){ scale=1; panX=0; panY=0; applyZoom(); }
        restart(); return;
      }
      if(scale>1){ restart(); return; }
      const threshold = viewport.clientWidth*0.12;
      if(Math.abs(deltaX)>threshold){ go(idx + (deltaX<0?1:-1), true); } else { go(idx,false); }
    });

    viewport.addEventListener('wheel',e=>{
      e.preventDefault(); clearInterval(timer);
      const rect=viewport.getBoundingClientRect();
      const cx=e.clientX-rect.left - rect.width/2;
      const cy=e.clientY-rect.top - rect.height/2;
      const prevScale=scale;
      scale = Math.max(Z_MIN, Math.min(Z_MAX, scale * (e.deltaY>0 ? 0.9 : 1.1)));
      panX = (panX + cx) * (scale/prevScale) - cx;
      panY = (panY + cy) * (scale/prevScale) - cy;
      clampPan(); applyZoom();
    },{passive:false});

    go(0,false);
    restart();
    window.addEventListener('visibilitychange',()=>document.hidden?clearInterval(timer):(!userPaused&&restart()));
  })();

  /* ===== Lazy load Kick iframe ===== */
  function loadKick(){
    const wrap=document.getElementById('kickWrap');
    if(!wrap || wrap.dataset.loaded) return;
    const iframe=document.createElement('iframe');
    iframe.src='https://player.kick.com/bearxrpl?autoplay=true&muted=true';
    iframe.allow='autoplay; encrypted-media; picture-in-picture';
    iframe.title='Kick Stream';
    wrap.innerHTML='';
    wrap.appendChild(iframe);
    wrap.dataset.loaded='1';
  }
  const kickBtn=document.getElementById('kickPlaceholder');
  if(kickBtn){
    kickBtn.addEventListener('click', loadKick);
    const obs=new IntersectionObserver((es,o)=>{
      es.forEach(e=>{ if(e.isIntersecting){ loadKick(); o.disconnect(); } });
    },{rootMargin:'200px'});
    obs.observe(kickBtn);
  }

  /* ===== Ensure all imgs lazy/async if not set ===== */
  document.querySelectorAll('img:not([loading])').forEach(img=>{ img.loading='lazy'; img.decoding='async'; });

  /* ===== Drawer + Prices (consolidated) ===== */
  (function(){
    const PAIR_ID = '4245415200000000000000000000000000000000.rbearguasyu7tuw53rufqzfdwmjhpjeqfw_xrp';
    const DS_URL = `https://api.dexscreener.com/latest/dex/pairs/xrpl/${PAIR_ID}`;

    /* FAB + drawer wiring */
    const fab=document.createElement('button');
    fab.className='fab-buy';
    fab.innerHTML='<span class="txt">BEAR HUB</span>';
    fab.setAttribute('aria-controls','buyDrawer');
    fab.setAttribute('aria-expanded','false');
    fab.setAttribute('aria-label','Open BEAR HUB panel');
    document.body.appendChild(fab);

    const scrim=document.createElement('div');
    scrim.className='drawer-scrim';
    scrim.hidden=true;
    document.body.appendChild(scrim);

    const drawer=document.getElementById('buyDrawer');
    const closeBtn=drawer.querySelector('[data-close-drawer]');

    function openDrawer(){
      drawer.classList.add('open'); scrim.hidden=false;
      fab.setAttribute('aria-expanded','true'); drawer.setAttribute('aria-hidden','false');
      document.body.style.overflow='hidden';
      loadPortfolioData(); // Load wallet portfolio data
      initializeProfileAndNFTs(); // Load profile data and NFTs

      // Hide instruction boxes if user has completed first-time setup OR already has a profile
      const setupComplete = localStorage.getItem('bearpark_profile_setup_complete') === 'true';

      // Check if user already has a profile
      const walletAddress = localStorage.getItem('bearpark_wallet');
      let hasProfile = false;
      if (walletAddress) {
        const profileKey = `bearpark_profile_${walletAddress}`;
        const localProfile = localStorage.getItem(profileKey);
        if (localProfile) {
          try {
            const profile = JSON.parse(localProfile);
            hasProfile = profile.display_name && (profile.avatar_nft || profile.avatar_url);
          } catch (e) {
            hasProfile = false;
          }
        }
      }

      if (setupComplete || hasProfile) {
        setTimeout(() => {
          const profileInstructionsBanner = document.getElementById('profileInstructions');
          const nftInstructionsBanner = document.getElementById('nftInstructions');
          if (profileInstructionsBanner) {
            profileInstructionsBanner.style.display = 'none';
          }
          if (nftInstructionsBanner) {
            nftInstructionsBanner.style.display = 'none';
          }
        }, 100); // Small delay to ensure elements are rendered
      }
    }
    function closeDrawer(){
      drawer.classList.remove('open'); scrim.hidden=true;
      fab.setAttribute('aria-expanded','false'); drawer.setAttribute('aria-hidden','true');
      document.body.style.overflow='';
    }

    function openProfileSetup(){
      console.log('🔥 [openProfileSetup] Function called!');
      const walletAddress = localStorage.getItem('bearpark_wallet');
      console.log('🔥 [openProfileSetup] Wallet:', walletAddress);
      if (!walletAddress) {
        console.log('🔥 [openProfileSetup] No wallet, opening drawer');
        openDrawer();
        return;
      }

      // Check if profile is already set
      const profileKey = `bearpark_profile_${walletAddress}`;
      const localProfile = localStorage.getItem(profileKey);

      let hasProfile = false;
      if (localProfile) {
        try {
          const profile = JSON.parse(localProfile);
          // Profile is considered "set" if it has both display_name and avatar
          hasProfile = profile.display_name && (profile.avatar_nft || profile.avatar_url);
        } catch (e) {
          hasProfile = false;
        }
      }

      // Check if user has completed first-time setup OR already has a profile (hide instruction boxes)
      const setupComplete = localStorage.getItem('bearpark_profile_setup_complete') === 'true';
      if (setupComplete || hasProfile) {
        // Hide instruction boxes immediately for returning users
        const profileInstructionsBanner = document.getElementById('profileInstructions');
        const nftInstructionsBanner = document.getElementById('nftInstructions');
        if (profileInstructionsBanner) {
          profileInstructionsBanner.style.display = 'none';
        }
        if (nftInstructionsBanner) {
          nftInstructionsBanner.style.display = 'none';
        }
      }

      if (!hasProfile) {
        console.log('🐻 Opening profile setup for new user...');
        // Open drawer and scroll to profile section
        openDrawer();
        setTimeout(() => {
          const profileSection = document.getElementById('profileSection');
          const drawerBody = drawer.querySelector('.drawer-body');

          console.log('🐻 Drawer opened, scrolling to profile section...', { profileSection, drawerBody });

          if (profileSection && drawerBody) {
            drawerBody.scrollTo({
              top: profileSection.offsetTop - 20,
              behavior: 'smooth'
            });

            // Add pulsing highlight effect to make it obvious
            profileSection.classList.add('profile-highlight-pulse');

            // Remove highlight after 5 seconds
            setTimeout(() => {
              profileSection.classList.remove('profile-highlight-pulse');
            }, 5000);

            console.log('✅ Profile section highlighted and scrolled into view!');
          } else {
            console.error('❌ Could not find profileSection or drawerBody elements!');
          }
        }, 600); // Wait longer for drawer to fully open and render
      } else {
        // Wallet not connected - do nothing
        console.log('⚠️ Wallet not connected. Please connect wallet to access profile.');
      }
    }

    // Make function globally accessible for inline onclick handler
    window.openProfileSetup = openProfileSetup;

    function showBearSpaceTeaser(){
      // Create popup element
      const popup = document.createElement('div');
      popup.className = 'bear-space-popup';
      popup.innerHTML = `
        <div class="bear-space-popup-content">
          <div class="bear-space-icon">🐻🚀</div>
          <div class="bear-space-title">BEAR SPACE</div>
          <div class="bear-space-subtitle">Coming Soon</div>
          <div class="bear-space-description">Your personal BEAR universe is being prepared...</div>
        </div>
      `;

      // Add to body
      document.body.appendChild(popup);

      // Trigger animation
      setTimeout(() => popup.classList.add('show'), 10);

      // Auto-remove after 3 seconds
      setTimeout(() => {
        popup.classList.remove('show');
        setTimeout(() => popup.remove(), 300);
      }, 3000);

      // Click to dismiss
      popup.addEventListener('click', () => {
        popup.classList.remove('show');
        setTimeout(() => popup.remove(), 300);
      });
    }

    function showSuccessPopup(message, emoji = '🎉') {
      // Create bubbly success popup
      const popup = document.createElement('div');
      popup.className = 'bear-success-popup';
      popup.innerHTML = `
        <div class="bear-success-popup-content">
          <div class="bear-success-icon">${emoji}</div>
          <div class="bear-success-title">BEARISH SUCCESS!</div>
          <div class="bear-success-message">${message}</div>
          <div class="bear-success-sub">TO THE MOON! 🚀🐻</div>
        </div>
      `;

      // Add to body
      document.body.appendChild(popup);

      // Trigger animation
      setTimeout(() => popup.classList.add('show'), 10);

      // Auto-remove after 4 seconds
      setTimeout(() => {
        popup.classList.remove('show');
        setTimeout(() => popup.remove(), 500);
      }, 4000);

      // Click to dismiss
      popup.addEventListener('click', () => {
        popup.classList.remove('show');
        setTimeout(() => popup.remove(), 500);
      });
    }

    // ===== CONFETTI CELEBRATION SYSTEM 🎉 =====
    function createConfetti(options = {}) {
      const {
        x = window.innerWidth / 2,
        y = window.innerHeight / 2,
        count = 50,
        spread = 360,
        colors = ['#edb723', '#680cd9', '#feb501', '#07ae08', '#d75c46', '#fff']
      } = options;

      const confettiContainer = document.createElement('div');
      confettiContainer.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 9999;
      `;
      document.body.appendChild(confettiContainer);

      for (let i = 0; i < count; i++) {
        const confetti = document.createElement('div');
        const color = colors[Math.floor(Math.random() * colors.length)];
        const size = Math.random() * 10 + 5;
        const angle = (spread / count) * i + (Math.random() - 0.5) * 30;
        const velocity = Math.random() * 300 + 200;
        const rotation = Math.random() * 360;
        const rotationSpeed = (Math.random() - 0.5) * 720;

        confetti.style.cssText = `
          position: absolute;
          left: ${x}px;
          top: ${y}px;
          width: ${size}px;
          height: ${size}px;
          background: ${color};
          opacity: 1;
          transform: rotate(${rotation}deg);
          border-radius: ${Math.random() > 0.5 ? '50%' : '2px'};
        `;

        confettiContainer.appendChild(confetti);

        const rad = (angle * Math.PI) / 180;
        const vx = Math.cos(rad) * velocity;
        const vy = Math.sin(rad) * velocity - 100;

        let posX = x;
        let posY = y;
        let velX = vx;
        let velY = vy;
        let rot = rotation;
        let opacity = 1;
        let startTime = Date.now();

        function animate() {
          const elapsed = (Date.now() - startTime) / 1000;
          if (elapsed > 3 || opacity <= 0) {
            confetti.remove();
            return;
          }

          velY += 500 * 0.016; // gravity
          velX *= 0.99; // air resistance
          posX += velX * 0.016;
          posY += velY * 0.016;
          rot += rotationSpeed * 0.016;
          opacity = Math.max(0, 1 - elapsed / 3);

          confetti.style.transform = `translate(${posX - x}px, ${posY - y}px) rotate(${rot}deg)`;
          confetti.style.opacity = opacity;

          requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);
      }

      setTimeout(() => confettiContainer.remove(), 3500);
    }

    // Confetti presets
    window.celebrateRaidWin = function() {
      createConfetti({ count: 100, spread: 360, y: window.innerHeight * 0.4 });
      setTimeout(() => createConfetti({ count: 50, spread: 180, y: window.innerHeight * 0.3 }), 200);
    };

    window.celebrateGameWin = function() {
      createConfetti({ count: 80, spread: 120, y: window.innerHeight * 0.5 });
    };

    window.celebrateAchievement = function() {
      createConfetti({ count: 60, spread: 90 });
    };

    window.celebrateProfileSave = function() {
      createConfetti({ count: 40, spread: 60, colors: ['#edb723', '#fff', '#680cd9'] });
    };

    // ===== ANIMATED COUNTER SYSTEM 🔢 =====
    function animateCounter(element, start, end, duration = 1000, suffix = '') {
      if (!element) return;

      const startTime = Date.now();
      const range = end - start;

      function update() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Ease out cubic
        const easeProgress = 1 - Math.pow(1 - progress, 3);
        const current = Math.floor(start + range * easeProgress);

        element.textContent = current.toLocaleString() + suffix;
        element.style.transform = `scale(${1 + (1 - progress) * 0.2})`;

        if (progress < 1) {
          requestAnimationFrame(update);
        } else {
          element.style.transform = 'scale(1)';
        }
      }

      element.style.transition = 'transform 0.3s ease';
      requestAnimationFrame(update);
    }

    window.animateCounter = animateCounter;

    // Expose functions to global scope for onclick handlers
    window.openProfileSetup = openProfileSetup;
    window.showBearSpaceTeaser = showBearSpaceTeaser;

    fab.addEventListener('click', openDrawer);
    closeBtn.addEventListener('click', closeDrawer);
    scrim.addEventListener('click', closeDrawer);
    window.addEventListener('keydown', e=>{ if(e.key==='Escape') closeDrawer(); });

    const navBuy=document.querySelector('.nav-cta a[href="#network"]');
    if(navBuy){
      navBuy.addEventListener('click', (e)=>{ e.preventDefault(); openDrawer(); });
    }

    /* Build big duo metric lines (XRP first) */
    const priceCard = document.querySelector('.price-card');
    const metric = priceCard?.querySelector('.metric');
    const legacyUsdEl = document.getElementById('priceUsd');
    const volUsdEl = document.getElementById('vol24');
    const mcapUsdEl = document.getElementById('mcapUsd'); // NEW

    if (metric && !document.getElementById('bearXrpBig')) {
      metric.classList.add('duo');
      if (legacyUsdEl) legacyUsdEl.style.display='none';
      const usdSmall = legacyUsdEl && legacyUsdEl.nextElementSibling?.tagName==='SMALL' ? legacyUsdEl.nextElementSibling : null;
      if (usdSmall) usdSmall.style.display='none';

      const wrap=document.createElement('div');
      wrap.innerHTML =
        `<div class="line"><span class="label" style="white-space: nowrap; display: inline-flex; align-items: center; gap: 4px;"><img src="https://files.catbox.moe/esp426.png" alt="BEAR" style="height:0.9em; width:auto; display:inline-block;">BEAR / <img src="https://files.catbox.moe/lufprf.png" alt="XRP" style="height:0.9em; width:auto; display:inline-block;">XRP</span><span id="bearXrpBig" class="price">—</span></div>
         <div class="line"><span class="label" style="white-space: nowrap; display: inline-flex; align-items: center; gap: 4px;"><img src="https://files.catbox.moe/esp426.png" alt="BEAR" style="height:0.9em; width:auto; display:inline-block;">BEAR / 💵 USD</span><span id="bearUsdBig" class="price">—</span></div>`;
      metric.prepend(wrap);

      const st=document.createElement('style');
      st.textContent=
        `.price-card .metric.duo{flex-direction:column;align-items:flex-start;gap:.4rem}
         .price-card .metric .line{display:flex;align-items:baseline;gap:.6rem;flex-wrap:wrap}
         .price-card .metric .label{color:var(--gold);font-weight:900;letter-spacing:.3px}
         .price-card .metric .price{color:#fff;font-weight:900}`;
      document.head.appendChild(st);
    }

    function $id(id){ return document.getElementById(id); }
    const fmt = (n, min=2, max=8) => Number(n).toLocaleString(undefined,{minimumFractionDigits:min, maximumFractionDigits:max});
    const fmt0 = (n) => Number(n).toLocaleString(undefined,{maximumFractionDigits:0});

    async function fetchDex(){
      const r=await fetch(DS_URL,{cache:'no-store'});
      if(!r.ok) throw new Error('Price API HTTP '+r.status);
      const j=await r.json();
      const p=j?.pairs?.[0];
      if(!p) throw new Error('Pair not found');
      return {
        priceNative: Number(p.priceNative),
        priceUsd: p.priceUsd!=null?Number(p.priceUsd):NaN,
        vol24Usd: Number(p.volume?.h24 ?? p.volume24h ?? 0),
        // NEW: Prefer marketCap; fallback to fdv
        mcapUsd: Number((p.marketCap ?? p.fdv) ?? NaN),
        // Add liquidity data
        liquidityUsd: Number(p.liquidity?.usd ?? 0),
        // Add 24h price change
        priceChange24h: Number(p.priceChange?.h24 ?? 0),
        // Add transaction data
        txns: p.txns || {}
      };
    }

    // XRP/USD price - using static value (removed CoinGecko to eliminate console spam)
    async function fetchXrpPrice(){
      return 2.5; // Static price - update manually if needed
    }

    async function updatePrices(){
      try{
        const {priceNative, priceUsd, vol24Usd, mcapUsd, liquidityUsd, priceChange24h, txns} = await fetchDex();
        const xrpPrice = await fetchXrpPrice();
        const xrpLine = $id('bearXrpBig');
        const usdLine = $id('bearUsdBig');

        if (Number.isFinite(priceNative) && xrpLine){
          const d = priceNative >= 1 ? {min:3,max:6} : {min:4,max:8};
          xrpLine.textContent = fmt(priceNative, d.min, d.max);
        }
        const usdVal = Number.isFinite(priceUsd) ? priceUsd : NaN;
        if (Number.isFinite(usdVal) && usdLine){
          usdLine.textContent = fmt(usdVal, 5, 8);
        }
        if (volUsdEl){
          const vol = Number.isFinite(vol24Usd) ? vol24Usd : NaN;
          if (Number.isFinite(vol)) volUsdEl.textContent = '$' + fmt0(vol);
        }
        // NEW: Market Cap update
        if (mcapUsdEl && Number.isFinite(mcapUsd)){
          mcapUsdEl.textContent = '$' + fmt0(mcapUsd);
        }

        if (legacyUsdEl && legacyUsdEl.textContent.trim()==='—' && Number.isFinite(usdVal)){
          legacyUsdEl.textContent = fmt(usdVal, 5, 8);
        }

        // Update Honey Points section
        updateHoneyPrices(priceNative, priceUsd, vol24Usd, mcapUsd, liquidityUsd, priceChange24h, xrpPrice, txns);
      }catch(err){
        console.debug('Price update failed', err);
      }
    }

    function updateHoneyPrices(priceNative, priceUsd, vol24Usd, mcapUsd, liquidityUsd, priceChange24h, xrpPrice, txns){
      // Update price stats
      const honeyPriceXrp = $id('honeyPriceXrp');
      const honeyPriceUsd = $id('honeyPriceUsd');
      const honeyVolume = $id('honeyVolume');
      const honeyVolumeXrp = $id('honeyVolumeXrp');
      const honeyMcap = $id('honeyMcap');
      const honeyMcapXrp = $id('honeyMcapXrp');
      const honeyChange24h = $id('honeyChange24h');
      const honeyChange24hXrp = $id('honeyChange24hXrp');
      const liquidityBear = $id('liquidityBear');
      const liquidityXrp = $id('liquidityXrp');
      const liquidityUsdEl = $id('liquidityUsd');
      const liquidityMcapRatio = $id('liquidityMcapRatio');

      if (honeyPriceXrp && Number.isFinite(priceNative)){
        const d = priceNative >= 1 ? {min:3,max:6} : {min:4,max:8};
        honeyPriceXrp.textContent = fmt(priceNative, d.min, d.max) + ' XRP';
      }

      if (honeyPriceUsd && Number.isFinite(priceUsd)){
        honeyPriceUsd.textContent = '$' + fmt(priceUsd, 5, 8);
      }

      if (honeyVolume && Number.isFinite(vol24Usd)){
        honeyVolume.textContent = '$' + fmt0(vol24Usd);

        // Update USD DEXScreener volume total to match
        const usdVolumeTotal = $id('usdVolumeTotal');
        if (usdVolumeTotal) {
          usdVolumeTotal.textContent = '$' + fmt0(vol24Usd);
        }
      }

      // Calculate XRP 24h volume
      if (honeyVolumeXrp && Number.isFinite(vol24Usd) && Number.isFinite(xrpPrice)){
        const vol24Xrp = vol24Usd / xrpPrice;
        honeyVolumeXrp.textContent = fmt0(vol24Xrp) + ' XRP';

        // Update XRP DEXScreener volume total to match
        const xrpVolumeTotal = $id('xrpVolumeTotal');
        if (xrpVolumeTotal) {
          xrpVolumeTotal.textContent = fmt0(vol24Xrp) + ' XRP';
        }
      }

      if (honeyMcap && Number.isFinite(mcapUsd)){
        honeyMcap.textContent = '$' + fmt0(mcapUsd);
      }

      // Calculate XRP market cap
      if (honeyMcapXrp && Number.isFinite(mcapUsd) && Number.isFinite(xrpPrice)){
        const mcapXrp = mcapUsd / xrpPrice;
        honeyMcapXrp.textContent = fmt0(mcapXrp) + ' XRP';
      }

      // Update 24h change with color coding (same for both USD and XRP)
      if (honeyChange24h && Number.isFinite(priceChange24h)){
        const sign = priceChange24h >= 0 ? '+' : '';
        honeyChange24h.textContent = sign + priceChange24h.toFixed(2) + '%';
        honeyChange24h.style.color = priceChange24h >= 0 ? '#4ade80' : '#f87171';
      }

      // Update XRP 24h change (same percentage as USD)
      if (honeyChange24hXrp && Number.isFinite(priceChange24h)){
        const sign = priceChange24h >= 0 ? '+' : '';
        honeyChange24hXrp.textContent = sign + priceChange24h.toFixed(2) + '%';
        honeyChange24hXrp.style.color = priceChange24h >= 0 ? '#4ade80' : '#f87171';
      }

      // Calculate liquidity values
      if (liquidityUsdEl && Number.isFinite(liquidityUsd)){
        liquidityUsdEl.textContent = '$' + fmt0(liquidityUsd);
      }

      // Calculate BEAR liquidity (half of total liquidity USD / BEAR price)
      if (liquidityBear && Number.isFinite(liquidityUsd) && Number.isFinite(priceUsd)){
        const bearLiq = (liquidityUsd / 2) / priceUsd;
        liquidityBear.textContent = fmt0(bearLiq) + ' BEAR';
      }

      // Calculate XRP liquidity using real XRP price
      if (liquidityXrp && Number.isFinite(liquidityUsd) && Number.isFinite(xrpPrice)){
        // Assume roughly half of liquidity is in XRP
        const xrpLiq = (liquidityUsd / 2) / xrpPrice;
        liquidityXrp.textContent = fmt0(xrpLiq) + ' XRP';
      }

      // Calculate Liquidity to Market Cap Ratio
      if (liquidityMcapRatio && Number.isFinite(liquidityUsd) && Number.isFinite(mcapUsd) && mcapUsd > 0){
        const ratio = (liquidityUsd / mcapUsd) * 100;
        liquidityMcapRatio.textContent = ratio.toFixed(2) + '%';
      }

      // Update DEXScreener-style stats with real transaction data
      if (txns && txns.h24) {
        const h24 = txns.h24;
        const buys = Number(h24.buys || 0);
        const sells = Number(h24.sells || 0);
        const totalTxns = buys + sells;

        // Calculate volume split based on transaction ratio
        const buyRatio = totalTxns > 0 ? buys / totalTxns : 0.5;
        const sellRatio = totalTxns > 0 ? sells / totalTxns : 0.5;

        // Update TXNS for both USD and XRP (same transaction count)
        if (totalTxns > 0) {
          // USD TXNS
          const usdTxnsTotal = $id('usdTxnsTotal');
          const usdBuys = $id('usdBuys');
          const usdSells = $id('usdSells');
          const usdBuysBar = $id('usdBuysBar');
          const usdSellsBar = $id('usdSellsBar');

          if (usdTxnsTotal) usdTxnsTotal.textContent = totalTxns;
          if (usdBuys) usdBuys.textContent = buys;
          if (usdSells) usdSells.textContent = sells;
          if (usdBuysBar && usdSellsBar) {
            const buyPct = (buys / totalTxns) * 100;
            const sellPct = (sells / totalTxns) * 100;
            usdBuysBar.style.width = buyPct + '%';
            usdSellsBar.style.width = sellPct + '%';
          }

          // XRP TXNS (same as USD)
          const xrpTxnsTotal = $id('xrpTxnsTotal');
          const xrpBuys = $id('xrpBuys');
          const xrpSells = $id('xrpSells');
          const xrpBuysBar = $id('xrpBuysBar');
          const xrpSellsBar = $id('xrpSellsBar');

          if (xrpTxnsTotal) xrpTxnsTotal.textContent = totalTxns;
          if (xrpBuys) xrpBuys.textContent = buys;
          if (xrpSells) xrpSells.textContent = sells;
          if (xrpBuysBar && xrpSellsBar) {
            const buyPct = (buys / totalTxns) * 100;
            const sellPct = (sells / totalTxns) * 100;
            xrpBuysBar.style.width = buyPct + '%';
            xrpSellsBar.style.width = sellPct + '%';
          }
        }

        // Update MAKERS (unique buyers/sellers)
        const buyers = Number(h24.buyers || 0);
        const sellers = Number(h24.sellers || 0);
        const totalMakers = buyers + sellers;

        if (totalMakers > 0) {
          // USD MAKERS
          const usdMakersTotal = $id('usdMakersTotal');
          const usdBuyers = $id('usdBuyers');
          const usdSellers = $id('usdSellers');
          const usdBuyersBar = $id('usdBuyersBar');
          const usdSellersBar = $id('usdSellersBar');

          if (usdMakersTotal) usdMakersTotal.textContent = totalMakers;
          if (usdBuyers) usdBuyers.textContent = buyers;
          if (usdSellers) usdSellers.textContent = sellers;
          if (usdBuyersBar && usdSellersBar) {
            const buyersPct = (buyers / totalMakers) * 100;
            const sellersPct = (sellers / totalMakers) * 100;
            usdBuyersBar.style.width = buyersPct + '%';
            usdSellersBar.style.width = sellersPct + '%';
          }

          // XRP MAKERS (same as USD)
          const xrpMakersTotal = $id('xrpMakersTotal');
          const xrpBuyers = $id('xrpBuyers');
          const xrpSellers = $id('xrpSellers');
          const xrpBuyersBar = $id('xrpBuyersBar');
          const xrpSellersBar = $id('xrpSellersBar');

          if (xrpMakersTotal) xrpMakersTotal.textContent = totalMakers;
          if (xrpBuyers) xrpBuyers.textContent = buyers;
          if (xrpSellers) xrpSellers.textContent = sellers;
          if (xrpBuyersBar && xrpSellersBar) {
            const buyersPct = (buyers / totalMakers) * 100;
            const sellersPct = (sellers / totalMakers) * 100;
            xrpBuyersBar.style.width = buyersPct + '%';
            xrpSellersBar.style.width = sellersPct + '%';
          }
        }
      }
    }
    updatePrices();
    IntervalManager.set('updatePrices', updatePrices, 60000); // Use IntervalManager to prevent memory leaks
    document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) updatePrices(); });

    /* ===== Chart Loading Detection ===== */
    const chartIframe = document.getElementById('dexscreener-embed');
    const chartError = document.getElementById('chart-error');

    if (chartIframe && chartError) {
      // Check if iframe loaded after 10 seconds
      setTimeout(() => {
        try {
          // Try to access iframe - if it fails, it might be blocked
          const iframeDoc = chartIframe.contentDocument || chartIframe.contentWindow.document;
          if (!iframeDoc || iframeDoc.readyState !== 'complete') {
            console.warn('Chart iframe may not have loaded properly');
          }
        } catch (e) {
          // CORS error is expected and means it's loading from external source (good)
          // Do nothing - this is normal for cross-origin iframes
        }
      }, 10000);

      // Handle iframe errors
      chartIframe.onerror = () => {
        console.error('Chart iframe failed to load');
        chartIframe.style.display = 'none';
        chartError.style.display = 'flex';
      };
    }

    /* ===== Portfolio & Points Functions ===== */
    async function loadPortfolioData() {
      console.log('🔥 loadPortfolioData() CALLED!');
      const walletAddress = localStorage.getItem('bearpark_wallet');
      const isAuthenticated = localStorage.getItem('bearpark_auth') === 'true';
      console.log('🔥 Wallet:', walletAddress, 'Auth:', isAuthenticated);

      const portfolioSection = document.getElementById('portfolioSection');
      const connectedWalletAddress = document.getElementById('connectedWalletAddress');

      if (!isAuthenticated || !walletAddress) {
        portfolioSection.style.display = 'none';
        return;
      }

      // Show portfolio section
      portfolioSection.style.display = 'block';
      connectedWalletAddress.textContent = walletAddress;

      // Check if xrpl library is loaded
      if (typeof xrpl === 'undefined') {
        console.error('[Portfolio] XRPL library not loaded!');
        document.getElementById('portfolioBearAmount').textContent = 'Error: Library not loaded';
        return;
      }

      try {
        // Set loading states
        document.getElementById('portfolioBearAmount').textContent = 'Loading...';
        document.getElementById('portfolioUsdValue').textContent = 'Loading...';
        document.getElementById('portfolioXrpValue').textContent = 'Loading...';

        // Connect to XRPL with fallback nodes
        const xrplNodes = [
          'wss://xrplcluster.com',
          'wss://s1.ripple.com',
          'wss://s2.ripple.com'
        ];

        let client = null;
        let lastError = null;

        for (const node of xrplNodes) {
          try {
            client = new xrpl.Client(node);
            await client.connect();
            break;
          } catch (err) {
            lastError = err;
            if (client) {
              try { await client.disconnect(); } catch(e) {}
            }
            client = null;
          }
        }

        if (!client) {
          console.error('[Portfolio] Unable to connect to any XRPL node');
          throw new Error('Unable to connect to XRPL nodes');
        }

        // Get $BEAR balance
        const accountLines = await client.request({
          command: 'account_lines',
          account: walletAddress,
          ledger_index: 'validated'
        });

        const BEAR_ISSUER = 'rBEARGUAsyu7tUw53rufQzFdWmJHpJEqFW';
        const BEAR_CURRENCY = 'BEAR';
        const BEAR_CURRENCY_HEX = '4245415200000000000000000000000000000000'; // "BEAR" in hex

        const bearLine = accountLines.result.lines.find(line =>
          line.account === BEAR_ISSUER &&
          (line.currency === BEAR_CURRENCY || line.currency === BEAR_CURRENCY_HEX)
        );

        const bearBalance = bearLine ? parseFloat(bearLine.balance) : 0;

        // Update BEAR amount immediately
        document.getElementById('portfolioBearAmount').textContent = bearBalance.toLocaleString('en-US', { maximumFractionDigits: 2 });

        // Fetch fresh price data from API
        try {
          const {priceNative, priceUsd} = await fetchDex();

          // Calculate values
          const usdValue = bearBalance * priceUsd;
          const xrpValue = bearBalance * priceNative;

          // Update UI with calculated values
          if (priceUsd > 0) {
            document.getElementById('portfolioUsdValue').textContent = '$' + usdValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
          } else {
            document.getElementById('portfolioUsdValue').textContent = 'Loading...';
          }

          if (priceNative > 0) {
            document.getElementById('portfolioXrpValue').textContent = xrpValue.toLocaleString('en-US', { maximumFractionDigits: 4 }) + ' XRP';
          } else {
            document.getElementById('portfolioXrpValue').textContent = 'Loading...';
          }
        } catch (priceErr) {
          console.error('[Portfolio] Error fetching prices:', priceErr);
          document.getElementById('portfolioUsdValue').textContent = 'N/A';
          document.getElementById('portfolioXrpValue').textContent = 'N/A';
        }

        await client.disconnect();

      } catch (err) {
        console.error('[Portfolio] ERROR loading portfolio:', err);
        console.error('[Portfolio] Error stack:', err.stack);
        document.getElementById('portfolioBearAmount').textContent = 'Error: ' + err.message;
        document.getElementById('portfolioUsdValue').textContent = 'Error';
        document.getElementById('portfolioXrpValue').textContent = 'Error';
      }

      // Load points data (will be implemented with backend)
      loadPointsData(walletAddress);

      // Load LP position data
      loadLPData(walletAddress);

      // Load P&L chart
      loadPLChart(walletAddress);
    }

    async function loadLPData(walletAddress) {
      const lpSection = document.getElementById('lpSection');
      if (!lpSection) return;

      const LP_TOKEN_ISSUER = 'rKkkYMCvC63HEgxjQHmayKADaxYqnsMUkT'; // Your BEAR token address (AMM LP issuer)

      try {
        // Set loading states
        document.getElementById('lpTokenAmount').textContent = 'Loading...';
        document.getElementById('lpPoolPercentage').textContent = 'Loading...';
        document.getElementById('lpBearAmount').textContent = 'Loading...';
        document.getElementById('lpXrpAmount').textContent = 'Loading...';
        document.getElementById('lpUsdValue').textContent = 'Loading...';

        // Connect to XRPL
        const client = new xrpl.Client('wss://xrplcluster.com');
        await client.connect();

        // Get account lines to find LP tokens
        const accountLines = await client.request({
          command: 'account_lines',
          account: walletAddress,
          ledger_index: 'validated'
        });

        // Look for LP token (AMM pool tokens have special format)
        // For XRPL AMM, we need to check for the AMM account's LP tokens
        const ammInfoRequest = await client.request({
          command: 'amm_info',
          asset: {
            currency: '4245415200000000000000000000000000000000', // BEAR in hex
            issuer: LP_TOKEN_ISSUER
          },
          asset2: {
            currency: 'XRP'
          }
        });

        if (!ammInfoRequest || !ammInfoRequest.result || !ammInfoRequest.result.amm) {
          console.log('[LP] No AMM pool found');
          lpSection.style.display = 'none';
          await client.disconnect();
          return;
        }

        const ammData = ammInfoRequest.result.amm;
        const ammAccount = ammData.account;

        // Find user's LP tokens
        const lpLine = accountLines.result.lines.find(line =>
          line.account === ammAccount && line.currency.length === 40 // LP tokens have 40-char hex
        );

        if (!lpLine || parseFloat(lpLine.balance) === 0) {
          console.log('[LP] User has no LP tokens');
          lpSection.style.display = 'none';
          await client.disconnect();
          return;
        }

        // Show LP section
        lpSection.style.display = 'block';

        const userLPTokens = parseFloat(lpLine.balance);
        const totalLPTokens = parseFloat(ammData.lp_token.value);
        const poolOwnershipPercent = (userLPTokens / totalLPTokens) * 100;

        // Get pool reserves
        const bearReserve = parseFloat(ammData.amount.value);
        const xrpReserve = parseFloat(ammData.amount2.value) / 1000000; // Convert drops to XRP

        // Calculate user's share
        const userBearShare = bearReserve * (userLPTokens / totalLPTokens);
        const userXrpShare = xrpReserve * (userLPTokens / totalLPTokens);

        // Get prices
        const {priceNative, priceUsd} = await fetchDex();

        // Calculate USD value
        const bearUsdValue = userBearShare * priceUsd;
        const xrpUsdValue = userXrpShare * 2.50; // Approximate XRP price, should fetch real price
        const totalUsdValue = bearUsdValue + xrpUsdValue;

        // Update UI
        document.getElementById('lpTokenAmount').textContent = userLPTokens.toLocaleString('en-US', { maximumFractionDigits: 6 });
        document.getElementById('lpPoolPercentage').textContent = poolOwnershipPercent.toFixed(4) + '%';
        document.getElementById('lpBearAmount').textContent = userBearShare.toLocaleString('en-US', { maximumFractionDigits: 2 });
        document.getElementById('lpXrpAmount').textContent = userXrpShare.toLocaleString('en-US', { maximumFractionDigits: 2 }) + ' XRP';
        document.getElementById('lpUsdValue').textContent = '$' + totalUsdValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

        await client.disconnect();

      } catch (err) {
        console.error('[LP] Error loading LP data:', err);
        lpSection.style.display = 'none';
      }
    }

    // Global P&L state
    let plChartInstance = null;
    let plData = null;
    let plFullData = null; // Store full unfiltered data
    let currentPLCurrency = 'XRP';

    // Switch P&L currency display
    window.switchPLCurrency = function(currency) {
      currentPLCurrency = currency;
      document.getElementById('plToggleXRP').classList.toggle('active', currency === 'XRP');
      document.getElementById('plToggleUSD').classList.toggle('active', currency === 'USD');
      if (plData) {
        updatePLDisplay(plData);
      }
    };



    async function loadPLChart(walletAddress) {
      const plSection = document.getElementById('plSection');
      if (!plSection) {
        console.error('📊 [P&L] ERROR: plSection element not found!');
        return;
      }

      // Demo mode for testing
      const FORCE_DEMO = false; // Set to true for demo data
      if (FORCE_DEMO) {
        console.log('📊 [P&L] DEMO MODE ACTIVATED');
        plSection.style.display = 'block';

        // Generate fake data points
        const demoDataPoints = [];
        const startDate = new Date('2024-04-13').getTime();
        const now = Date.now();
        let currentPL = -500;

        for (let i = 0; i < 30; i++) {
          const timestamp = startDate + (i * (now - startDate) / 30);
          currentPL += Math.random() * 200 - 50; // Random walk
          demoDataPoints.push({
            timestamp: timestamp,
            date: new Date(timestamp),
            totalPLXRP: currentPL,
            totalPLUSD: currentPL * 2.50,
            unrealizedXRP: currentPL * 0.7,
            unrealizedUSD: currentPL * 0.7 * 2.50,
            realizedXRP: currentPL * 0.3,
            realizedUSD: currentPL * 0.3 * 2.50
          });
        }

        plFullData = {
          dataPoints: demoDataPoints,
          totalPLXRP: currentPL,
          totalPLUSD: currentPL * 2.50,
          unrealizedXRP: currentPL * 0.7,
          unrealizedUSD: currentPL * 0.7 * 2.50,
          realizedXRP: currentPL * 0.3,
          realizedUSD: currentPL * 0.3 * 2.50,
          roiPercent: 25.5,
          totalBought: 1500000,
          totalSold: 300000
        };

        plData = plFullData;
        updatePLDisplay(plData);
        createPLChart(demoDataPoints);
        console.log('📊 [P&L] DEMO chart created!');
        return;
      }

      const BEAR_ISSUER = 'rKkkYMCvC63HEgxjQHmayKADaxYqnsMUkT';
      const BEAR_CURRENCY = '4245415200000000000000000000000000000000';

      try {
        console.log('📊 [P&L] Starting genius-level P&L analysis...');
        plSection.style.display = 'block';

        // Show loading indicator
        const loadingIndicator = document.getElementById('plLoadingIndicator');
        const loadingProgress = document.getElementById('plLoadingProgress');
        if (loadingIndicator) loadingIndicator.style.display = 'block';

        // Connect to XRPL
        const client = new xrpl.Client('wss://xrplcluster.com');
        await client.connect();
        console.log('📊 [P&L] Connected to XRPL');
        if (loadingProgress) loadingProgress.textContent = 'Connected to XRPL...';

        // Fetch ALL account transactions
        console.log('📊 [P&L] Fetching account transactions...');
        const allTransactions = [];
        let marker = undefined;
        let pageCount = 0;
        const maxPages = 20; // Limit for performance (20 pages = ~4000 transactions)

        while (pageCount < maxPages) {
          try {
            const txRequest = {
              command: 'account_tx',
              account: walletAddress,
              ledger_index_min: -1,
              ledger_index_max: -1,
              limit: 200
            };
            if (marker) txRequest.marker = marker;

            console.log(`📊 [P&L] Fetching page ${pageCount + 1}...`);
            if (loadingProgress) loadingProgress.textContent = `Fetching page ${pageCount + 1}/${maxPages}...`;
            const txResponse = await client.request(txRequest);
            allTransactions.push(...txResponse.result.transactions);

            marker = txResponse.result.marker;
            pageCount++;

            if (!marker) break;
          } catch (pageErr) {
            console.error(`📊 [P&L] Error fetching page ${pageCount + 1}:`, pageErr);
            break; // Stop pagination on error
          }
        }

        console.log(`📊 [P&L] Fetched ${allTransactions.length} total transactions across ${pageCount} pages`);
        if (loadingProgress) loadingProgress.textContent = `Analyzing ${allTransactions.length} transactions...`;

        // Filter for BEAR token transactions
        const bearTxs = allTransactions.filter(item => {
          const tx = item.tx;
          const meta = item.meta;

          // Check if transaction involves BEAR token
          if (tx.TransactionType === 'Payment') {
            const amount = tx.Amount;
            if (typeof amount === 'object' &&
                amount.currency === BEAR_CURRENCY &&
                amount.issuer === BEAR_ISSUER) {
              return true;
            }
          }

          // Check balance changes in metadata
          if (meta && meta.AffectedNodes) {
            for (const node of meta.AffectedNodes) {
              const fields = node.ModifiedNode?.FinalFields || node.CreatedNode?.NewFields;
              if (fields && fields.Balance && typeof fields.Balance === 'object' &&
                  fields.Balance.currency === BEAR_CURRENCY) {
                return true;
              }
            }
          }

          return false;
        });

        console.log(`📊 [P&L] Found ${bearTxs.length} BEAR transactions`);

        if (bearTxs.length === 0) {
          console.log('📊 [P&L] No BEAR transactions found - hiding P&L section');
          plSection.style.display = 'none';
          await client.disconnect();
          return;
        }

        // Sort transactions by date FIRST so we can debug
        bearTxs.sort((a, b) => a.tx.date - b.tx.date);

        // DEBUG: Log first and last transaction dates to find the timestamp issue
        const firstTx = bearTxs[0];
        const lastTx = bearTxs[bearTxs.length - 1];
        console.log('🔍 [DEBUG] First TX raw XRPL date:', firstTx.tx.date);
        console.log('🔍 [DEBUG] First TX converted:', new Date((firstTx.tx.date + 946684800) * 1000).toISOString());
        console.log('🔍 [DEBUG] Last TX raw XRPL date:', lastTx.tx.date);
        console.log('🔍 [DEBUG] Last TX converted:', new Date((lastTx.tx.date + 946684800) * 1000).toISOString());
        console.log('🔍 [DEBUG] Current time:', new Date().toISOString());

        console.log('📊 [P&L] Showing P&L section and starting analysis...');

        // Show section
        plSection.style.display = 'block';

        // Get current prices
        console.log('📊 [P&L] Fetching current BEAR price...');
        const {priceNative, priceUsd} = await fetchDex();
        console.log('📊 [P&L] Current BEAR price:', priceNative, 'XRP,', priceUsd, 'USD');
        const xrpUsdPrice = 2.50; // Should fetch real XRP price
        console.log('📊 [P&L] Starting FIFO analysis...');

        // Analyze transactions with FIFO cost basis
        const costBasis = []; // Queue for FIFO
        const dataPoints = [];
        let totalBought = 0;
        let totalSold = 0;
        let realizedGainXRP = 0;
        let realizedGainUSD = 0;

        // Transactions already sorted above, start FIFO loop
        for (const item of bearTxs) {
          const tx = item.tx;
          const meta = item.meta;
          const timestamp = (tx.date + 946684800) * 1000; // Ripple epoch to Unix
          const date = new Date(timestamp);

          // Determine if this is a buy or sell
          let bearAmount = 0;
          let xrpCost = 0;
          let isBuy = false;

          if (tx.TransactionType === 'Payment') {
            const amount = tx.Amount;
            const deliveredAmount = meta.delivered_amount || amount;

            if (typeof deliveredAmount === 'object' && deliveredAmount.currency === BEAR_CURRENCY) {
              // Received BEAR (BUY)
              if (tx.Destination === walletAddress) {
                bearAmount = parseFloat(deliveredAmount.value);
                isBuy = true;

                // Calculate XRP cost (from SendMax or Amount)
                if (typeof tx.SendMax === 'string') {
                  xrpCost = parseInt(tx.SendMax) / 1000000;
                } else if (typeof tx.Amount === 'string') {
                  xrpCost = parseInt(tx.Amount) / 1000000;
                }
              }
              // Sent BEAR (SELL)
              else if (tx.Account === walletAddress) {
                bearAmount = parseFloat(deliveredAmount.value);
                isBuy = false;

                // Calculate XRP received
                if (typeof meta.delivered_amount === 'string') {
                  xrpCost = parseInt(meta.delivered_amount) / 1000000;
                } else if (typeof tx.SendMax === 'object' && !tx.SendMax.currency) {
                  xrpCost = parseInt(tx.SendMax) / 1000000;
                }
              }
            }
          }

          if (bearAmount === 0) continue;

          const costPerToken = xrpCost / bearAmount;

          if (isBuy) {
            // Add to cost basis queue
            costBasis.push({
              amount: bearAmount,
              costPerToken: costPerToken,
              timestamp: timestamp
            });
            totalBought += bearAmount;
          } else {
            // SELL - Calculate realized gain using FIFO
            let remainingToSell = bearAmount;
            let sellGainXRP = 0;

            while (remainingToSell > 0 && costBasis.length > 0) {
              const lot = costBasis[0];
              const sellFromThisLot = Math.min(remainingToSell, lot.amount);

              const soldForXRP = sellFromThisLot * costPerToken;
              const boughtForXRP = sellFromThisLot * lot.costPerToken;
              sellGainXRP += (soldForXRP - boughtForXRP);

              lot.amount -= sellFromThisLot;
              remainingToSell -= sellFromThisLot;

              if (lot.amount <= 0.0001) {
                costBasis.shift();
              }
            }

            realizedGainXRP += sellGainXRP;
            realizedGainUSD += sellGainXRP * xrpUsdPrice;
            totalSold += bearAmount;
          }

          // Calculate unrealized gain on remaining tokens
          const currentHoldings = costBasis.reduce((sum, lot) => sum + lot.amount, 0);
          const avgCostBasis = costBasis.length > 0
            ? costBasis.reduce((sum, lot) => sum + (lot.amount * lot.costPerToken), 0) / currentHoldings
            : 0;

          const unrealizedXRP = currentHoldings * (priceNative - avgCostBasis);
          const unrealizedUSD = unrealizedXRP * xrpUsdPrice;

          const totalPLXRP = realizedGainXRP + unrealizedXRP;
          const totalPLUSD = realizedGainUSD + unrealizedUSD;

          dataPoints.push({
            date: date,
            timestamp: timestamp,
            totalPLXRP: totalPLXRP,
            totalPLUSD: totalPLUSD,
            unrealizedXRP: unrealizedXRP,
            unrealizedUSD: unrealizedUSD,
            realizedXRP: realizedGainXRP,
            realizedUSD: realizedGainUSD,
            holdings: currentHoldings
          });
        }

        await client.disconnect();

        // Calculate final stats
        const currentHoldings = costBasis.reduce((sum, lot) => sum + lot.amount, 0);
        const avgCostBasis = costBasis.length > 0
          ? costBasis.reduce((sum, lot) => sum + (lot.amount * lot.costPerToken), 0) / currentHoldings
          : 0;

        const unrealizedXRP = currentHoldings * (priceNative - avgCostBasis);
        const unrealizedUSD = unrealizedXRP * xrpUsdPrice;
        const totalPLXRP = realizedGainXRP + unrealizedXRP;
        const totalPLUSD = realizedGainUSD + unrealizedUSD;
        const totalInvestedXRP = costBasis.reduce((sum, lot) => sum + (lot.amount * lot.costPerToken), 0);
        const roiPercent = totalInvestedXRP > 0 ? (totalPLXRP / totalInvestedXRP) * 100 : 0;

        plFullData = {
          dataPoints,
          totalPLXRP,
          totalPLUSD,
          unrealizedXRP,
          unrealizedUSD,
          realizedXRP: realizedGainXRP,
          realizedUSD: realizedGainUSD,
          roiPercent,
          totalBought,
          totalSold
        };

        plData = plFullData;

        console.log('📊 [P&L] FIFO analysis complete! Data points:', dataPoints.length);
        console.log('📊 [P&L] Total P&L:', totalPLXRP, 'XRP');

        if (loadingProgress) loadingProgress.textContent = 'Creating chart...';

        // Use all data (no timeframe filtering)
        plData = plFullData;

        // Update display
        console.log('📊 [P&L] Updating display...');
        updatePLDisplay(plFullData);

        // Create chart
        console.log('📊 [P&L] Creating chart with', plFullData.dataPoints.length, 'data points...');
        createPLChart(plFullData.dataPoints);

        // Hide loading indicator
        if (loadingIndicator) loadingIndicator.style.display = 'none';

        console.log('📊 [P&L] ✅ Chart created successfully!');

      } catch (err) {
        console.error('[P&L] Error loading P&L chart:', err);
        console.error('[P&L] Error stack:', err.stack);
        plSection.style.display = 'none';
      }
    }

    function updatePLDisplay(data) {
      const isXRP = currentPLCurrency === 'XRP';
      const symbol = isXRP ? ' XRP' : ' USD';
      const prefix = isXRP ? '' : '$';

      const total = isXRP ? data.totalPLXRP : data.totalPLUSD;
      const unrealized = isXRP ? data.unrealizedXRP : data.unrealizedUSD;
      const realized = isXRP ? data.realizedXRP : data.realizedUSD;

      // Update stat boxes
      const totalEl = document.getElementById('plTotalValue');
      const unrealizedEl = document.getElementById('plUnrealizedValue');
      const realizedEl = document.getElementById('plRealizedValue');
      const roiEl = document.getElementById('plROIValue');

      totalEl.textContent = prefix + total.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + symbol;
      totalEl.className = 'pl-stat-value ' + (total >= 0 ? 'positive' : 'negative');

      unrealizedEl.textContent = prefix + unrealized.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + symbol;
      unrealizedEl.className = 'pl-stat-value ' + (unrealized >= 0 ? 'positive' : 'negative');

      realizedEl.textContent = prefix + realized.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + symbol;
      realizedEl.className = 'pl-stat-value ' + (realized >= 0 ? 'positive' : 'negative');

      roiEl.textContent = (data.roiPercent >= 0 ? '+' : '') + data.roiPercent.toFixed(2) + '%';
      roiEl.className = 'pl-stat-value ' + (data.roiPercent >= 0 ? 'positive' : 'negative');


      // Update chart if it exists
      if (plChartInstance) {
        plChartInstance.data.datasets[0].data = data.dataPoints.map(d => ({
          x: d.date,
          y: isXRP ? d.totalPLXRP : d.totalPLUSD
        }));
        plChartInstance.options.plugins.tooltip.callbacks.label = function(context) {
          const value = context.parsed.y;
          return prefix + value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + symbol;
        };
        plChartInstance.update();
      }
    }

    function createPLChart(dataPoints) {
      console.log('📊 [CHART] createPLChart() called with', dataPoints.length, 'data points');
      const canvas = document.getElementById('plChart');
      const noDataIndicator = document.getElementById('plNoDataIndicator');

      console.log('📊 [CHART] Canvas element:', canvas);
      if (!canvas) {
        console.error('📊 [CHART] ERROR: Canvas not found!');
        return;
      }

      // Check if we have enough data points to draw a line chart
      if (dataPoints.length < 2) {
        console.warn('📊 [CHART] Insufficient data points (<2), showing no-data message');
        const loadingIndicator = document.getElementById('plLoadingIndicator');
        if (loadingIndicator) loadingIndicator.style.display = 'none';
        if (noDataIndicator) noDataIndicator.style.display = 'block';
        canvas.style.display = 'none';

        // Destroy existing chart instance if it exists
        if (plChartInstance) {
          plChartInstance.destroy();
          plChartInstance = null;
        }
        return;
      }

      // Hide no-data indicator and loading indicator, show canvas
      const loadingIndicator = document.getElementById('plLoadingIndicator');
      if (loadingIndicator) loadingIndicator.style.display = 'none';
      if (noDataIndicator) noDataIndicator.style.display = 'none';
      canvas.style.display = 'block';

      // Destroy existing chart instance if it exists
      if (plChartInstance) {
        console.log('📊 [CHART] Destroying existing chart instance');
        plChartInstance.destroy();
        plChartInstance = null;
      }

      // Get a fresh context
      const ctx = canvas.getContext('2d');
      console.log('📊 [CHART] Canvas context:', ctx);
      if (!ctx) {
        console.error('📊 [CHART] ERROR: Could not get canvas context!');
        return;
      }

      const isXRP = currentPLCurrency === 'XRP';
      console.log('📊 [CHART] Creating Chart.js instance... Currency:', isXRP ? 'XRP' : 'USD');

      try {
        plChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [{
            label: 'P&L Over Time',
            data: dataPoints.map(d => ({
              x: d.timestamp,
              y: isXRP ? d.totalPLXRP : d.totalPLUSD
            })),
            segment: {
              borderColor: ctx => {
                // Use segment styling to color based on y value
                const p0 = ctx.p0;
                const p1 = ctx.p1;
                if (!p0 || !p1) return '#4CAF50';
                const avg = (p0.parsed.y + p1.parsed.y) / 2;
                return avg >= 0 ? '#4CAF50' : '#f44336';
              }
            },
            borderColor: '#4CAF50', // Default color
            backgroundColor: function(context) {
              const chart = context.chart;
              const {ctx, chartArea} = chart;
              if (!chartArea) return 'rgba(76, 175, 80, 0.1)';

              const gradient = ctx.createLinearGradient(0, chartArea.top, 0, chartArea.bottom);
              gradient.addColorStop(0, 'rgba(76, 175, 80, 0.3)');
              gradient.addColorStop(1, 'rgba(76, 175, 80, 0.0)');
              return gradient;
            },
            borderWidth: 3,
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            pointHoverRadius: 6,
            pointHoverBackgroundColor: '#edb723',
            pointHoverBorderColor: '#fff',
            pointHoverBorderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(0,0,0,0.8)',
              titleColor: '#edb723',
              bodyColor: '#fff',
              borderColor: '#edb723',
              borderWidth: 2,
              padding: 12,
              displayColors: false,
              callbacks: {
                title: function(context) {
                  return new Date(context[0].parsed.x).toLocaleDateString();
                },
                label: function(context) {
                  const value = context.parsed.y;
                  const prefix = isXRP ? '' : '$';
                  const symbol = isXRP ? ' XRP' : '';
                  return 'P&L: ' + prefix + value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + symbol;
                }
              }
            }
          },
          scales: {
            x: {
              type: 'linear',
              grid: {
                color: 'rgba(255,255,255,0.05)',
                drawBorder: false
              },
              ticks: {
                color: 'rgba(255,255,255,0.6)',
                maxRotation: 0,
                callback: function(value, index, ticks) {
                  // Convert timestamp back to date for display
                  const date = new Date(value);
                  const month = date.toLocaleDateString('en-US', { month: 'short' });
                  const day = date.getDate();
                  return month + ' ' + day;
                },
                maxTicksLimit: 8
              }
            },
            y: {
              grid: {
                color: 'rgba(255,255,255,0.05)',
                drawBorder: false
              },
              ticks: {
                color: 'rgba(255,255,255,0.6)',
                callback: function(value) {
                  const prefix = isXRP ? '' : '$';
                  return prefix + value.toFixed(0);
                }
              }
            }
          },
          interaction: {
            intersect: false,
            mode: 'index'
          }
        }
      });
      console.log('📊 [CHART] ✅ Chart.js instance created successfully!', plChartInstance);
    } catch (error) {
      console.error('📊 [CHART] ❌ ERROR creating Chart.js instance:', error);
      console.error('📊 [CHART] Error stack:', error.stack);
    }
  }

    async function loadPointsData(walletAddress) {
      try {
        const response = await fetch(`${API_BASE_URL}/api/points/${walletAddress}`);
        if (!response.ok) {
          console.debug('Points API not available');
          return;
        }
        const data = await response.json();

        if (data.twitter_connected) {
          // Show connected state (with defensive checks)
          const pointsConnected = document.getElementById('pointsConnected');
          const pointsNotConnected = document.getElementById('pointsNotConnected');
          const totalPoints = document.getElementById('totalPoints');
          const connectedTwitter = document.getElementById('connectedTwitter');

          if (pointsConnected) pointsConnected.style.display = 'block';
          if (pointsNotConnected) pointsNotConnected.style.display = 'none';
          if (totalPoints) totalPoints.textContent = data.total_points;
          if (connectedTwitter) connectedTwitter.textContent = data.twitter_username;

          // Load activity (with defensive checks)
          const activityList = document.getElementById('activityList');
          if (activityList) {
            if (data.recent_activity && data.recent_activity.length > 0) {
              activityList.innerHTML = data.recent_activity.map(activity => {
                const date = new Date(activity.created_at);
                const timeAgo = getTimeAgo(date);
                const points = activity.points_change > 0 ? `+${activity.points_change}` : activity.points_change;
                return `
                  <div style="display:flex; justify-content:space-between; padding:8px; background:rgba(255,255,255,0.05); border-radius:6px; margin-bottom:6px;">
                    <span style="font-size:12px;">${activity.description || activity.transaction_type}</span>
                    <span style="color:var(--gold); font-weight:900; font-size:12px;">${points} pts</span>
                  </div>
                `;
              }).join('');
            } else {
              activityList.innerHTML = '<div style="opacity:0.6; padding:12px; text-align:center;">No recent activity</div>';
            }
          }

          // Load active raids
          loadActiveRaids();
        } else {
          // Show not connected state (with defensive checks)
          const pointsConnected = document.getElementById('pointsConnected');
          const pointsNotConnected = document.getElementById('pointsNotConnected');
          if (pointsConnected) pointsConnected.style.display = 'none';
          if (pointsNotConnected) pointsNotConnected.style.display = 'block';
        }
      } catch (err) {
        console.error('Error loading points:', err);
        // Show not connected state on error (with defensive checks)
        const pointsConnected = document.getElementById('pointsConnected');
        const pointsNotConnected = document.getElementById('pointsNotConnected');
        if (pointsConnected) pointsConnected.style.display = 'none';
        if (pointsNotConnected) pointsNotConnected.style.display = 'block';
      }
    }

    async function loadActiveRaids() {
      try {
        const response = await fetch('/api/raids/active');
        const data = await response.json();

        const activeRaidsSection = document.getElementById('activeRaids');
        const raidInfo = document.getElementById('raidInfo');
        const viewRaidBtn = document.getElementById('viewRaidBtn');

        if (data.success && data.raids && data.raids.length > 0) {
          const raid = data.raids[0]; // Show first active raid
          activeRaidsSection.style.display = 'block';

          raidInfo.innerHTML = `
            <div style="font-weight:900; margin-bottom:4px;">${raid.raid_title}</div>
            <div style="opacity:0.8; font-size:12px;">Target: ${raid.target_account}</div>
            <div style="opacity:0.8; font-size:12px;">Reward: ${raid.points_per_participation} points</div>
          `;

          viewRaidBtn.onclick = () => {
            window.open(raid.raid_url, '_blank');
          };
        } else {
          activeRaidsSection.style.display = 'none';
        }
      } catch (err) {
        console.error('Error loading raids:', err);
        document.getElementById('activeRaids').style.display = 'none';
      }
    }

    /* ===== Honey Points Section Functions ===== */
    async function loadHoneyPoints() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      const isAuthenticated = localStorage.getItem('bearpark_auth') === 'true';

      // Load from localStorage first
      const pointsKey = `honey_points_${walletAddress}`;
      const localPoints = JSON.parse(localStorage.getItem(pointsKey) || '{"total":0,"raiding":0,"games":0}');

      // Update display with local points immediately
      updatePointsDisplay(localPoints.total, localPoints.raiding, localPoints.games);

      // Update nav bar
      const navHoneyPoints = document.getElementById('navHoneyPoints');
      if (navHoneyPoints) {
        navHoneyPoints.textContent = localPoints.total.toFixed(1) + ' PTS';
      }

      // Update compact honey button
      const welcomePoints = document.getElementById('welcomePoints');
      if (welcomePoints) {
        welcomePoints.textContent = localPoints.total.toFixed(1);
      }

      // Try to sync with backend
      try {
        // Add cache-busting timestamp to force fresh data
        const response = await fetch(`${API_BASE_URL}/api/points/${walletAddress}?_t=${Date.now()}`, {
          cache: 'no-store',
          headers: {
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache'
          }
        });
        if (response.ok) {
          const data = await response.json();

          const backendTotal = data.total_points || 0;
          const backendRaiding = data.raiding_points || 0;
          const backendGames = data.games_points || 0;

          // If local points are higher than backend, sync local TO backend
          if (localPoints.total > backendTotal) {
            console.log('📤 Syncing local points to backend...', localPoints);
            const syncResponse = await fetch(`${API_BASE_URL}/api/points`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                wallet_address: walletAddress,
                total_points: localPoints.total,
                raiding_points: localPoints.raiding,
                games_points: localPoints.games
              })
            });

            if (syncResponse.ok) {
              console.log('✅ Local points synced to backend successfully!');
            }

            // Keep local points displayed
            updatePointsDisplay(localPoints.total, localPoints.raiding, localPoints.games);
            if (navHoneyPoints) navHoneyPoints.textContent = localPoints.total.toFixed(1) + ' PTS';
            const welcomePointsLocal = document.getElementById('welcomePoints');
            if (welcomePointsLocal) welcomePointsLocal.textContent = localPoints.total.toFixed(1);
          } else {
            // Backend has more points, use backend data
            updatePointsDisplay(backendTotal, backendRaiding, backendGames);
            if (navHoneyPoints) navHoneyPoints.textContent = backendTotal.toFixed(1) + ' PTS';

            // Update compact honey button
            const welcomePoints = document.getElementById('welcomePoints');
            if (welcomePoints) {
              welcomePoints.textContent = backendTotal.toFixed(1);
            }

            // Sync localStorage with backend data
            localStorage.setItem(pointsKey, JSON.stringify({
              total: backendTotal,
              raiding: backendRaiding,
              games: backendGames
            }));
          }
        }

        // Load leaderboard to get rank
        loadHoneyLeaderboard(walletAddress);
      } catch (err) {
        console.debug('Backend not available - using local points');
      }
    }

    /* ===== Daily Game Progress ===== */
    async function loadDailyGameProgress() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) return;

      try {
        // Fetch daily game status from ALL games and sum them up
        const response = await fetch(`${API_BASE_URL}/api/games/daily-status/${walletAddress}/all-games`);

        if (!response.ok) {
          console.debug('Daily game status not available');
          return;
        }

        const data = await response.json();

        if (data.success) {
          const minutesToday = data.minutes_today || 0;
          const maxMinutes = data.max_minutes || 20;
          const remainingMinutes = typeof data.remaining_minutes === 'number' ? data.remaining_minutes : 20;
          const pointsToday = data.points_earned_today || 0;

          // Update UI
          document.getElementById('dailyGameCount').textContent = `${minutesToday.toFixed(1)}/${maxMinutes}`;
          document.getElementById('dailyGamePoints').textContent = `${pointsToday.toFixed(1)} pts earned today`;

          // Show countdown timer when limit reached
          if (remainingMinutes === 0) {
            updateGameResetCountdown();
            startGameResetCountdown(); // Start the interval to update every second
          } else {
            document.getElementById('dailyGamesRemaining').textContent = `${remainingMinutes.toFixed(1)} mins left`;
            document.getElementById('dailyGamesRemaining').style.color = '#ffffff';
          }

          // Update progress bar
          const progressPercent = (minutesToday / maxMinutes) * 100;
          const progressBar = document.getElementById('dailyProgressBar');
          progressBar.style.width = progressPercent + '%';

          // Change color when limit reached
          if (remainingMinutes === 0) {
            progressBar.style.background = 'linear-gradient(90deg, #ff6b6b 0%, #ee5a6f 50%, #ff6b6b 100%)';
            document.getElementById('dailyGamesRemaining').style.color = '#ff6b6b';
          }
        }
      } catch (err) {
        console.debug('Error loading daily game progress:', err);
      }
    }

    // TEST MODE: Set to true to simulate 10 seconds before reset
    window.TEST_COUNTDOWN_MODE = false;

    // Update countdown timer to next UTC midnight
    function updateGameResetCountdown() {
      const now = new Date();
      const tomorrow = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + 1, 0, 0, 0));

      // TEST MODE: Simulate being 10 seconds before midnight
      let diff = window.TEST_COUNTDOWN_MODE ? 10000 : (tomorrow - now);

      // Decrease test countdown each second
      if (window.TEST_COUNTDOWN_MODE && window.testCountdownSeconds !== undefined) {
        window.testCountdownSeconds--;
        if (window.testCountdownSeconds <= 0) {
          // Reset happened! Clear daily games in database
          console.log('🔄 TEST: Countdown reached 0! Resetting daily games...');
          window.TEST_COUNTDOWN_MODE = false;

          // Clear today's game plays from database
          const walletAddress = localStorage.getItem('bearpark_wallet');
          if (walletAddress) {
            fetch(`${API_BASE_URL}/api/games/reset-daily/${walletAddress}`, {
              method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
              console.log('✅ Daily games reset:', data);
              // Reload game progress and points to show reset
              loadDailyGameProgress();
              loadHoneyPoints();
              const wallet = localStorage.getItem('bearpark_wallet');
              if (wallet) loadHoneyLeaderboard(wallet);
            })
            .catch(err => console.error('Error resetting daily games:', err));
          }
          return;
        }
        diff = window.testCountdownSeconds * 1000;
      } else if (window.TEST_COUNTDOWN_MODE) {
        window.testCountdownSeconds = 10;
        diff = 10000;
      }

      const hours = Math.floor(diff / (1000 * 60 * 60));
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((diff % (1000 * 60)) / 1000);

      const remainingEl = document.getElementById('dailyGamesRemaining');
      if (remainingEl) {
        remainingEl.textContent = `Resets in ${hours}h ${minutes}m ${seconds}s`;

        // Dynamic color based on time remaining
        const totalHours = diff / (1000 * 60 * 60);
        let color;

        if (totalHours > 18) {
          color = '#50fa7b'; // Green - lots of time
        } else if (totalHours > 12) {
          color = '#9aff6e'; // Yellow-green
        } else if (totalHours > 6) {
          color = '#f1fa8c'; // Yellow
        } else if (totalHours > 3) {
          color = '#ffb86c'; // Orange
        } else if (totalHours > 1) {
          color = '#ff8c42'; // Dark orange
        } else {
          color = '#ff6b6b'; // Red - almost reset!
        }

        remainingEl.style.color = color;
        remainingEl.style.textShadow = `0 0 10px ${color}`;
      }
    }

    // Start countdown interval when page loads
    let countdownInterval;
    function startGameResetCountdown() {
      if (countdownInterval) clearInterval(countdownInterval);
      countdownInterval = setInterval(() => {
        const remainingEl = document.getElementById('dailyGamesRemaining');
        if (remainingEl && remainingEl.textContent.includes('Resets in')) {
          updateGameResetCountdown();
        }
      }, 1000);
    }

    function updatePointsDisplay(total, raiding, games, animate = false) {
      const totalEl = document.getElementById('totalHoneyPoints');
      const raidingEl = document.getElementById('raidingPoints');
      const gamesEl = document.getElementById('gamesPoints');

      if (totalEl) {
        if (animate) {
          const oldValue = parseFloat(totalEl.textContent) || 0;
          animateCounter(totalEl, oldValue, total, 800, '');
        } else {
          totalEl.textContent = total.toFixed(1);
        }
      }
      if (raidingEl) raidingEl.textContent = raiding.toFixed(1) + ' PTS';
      if (gamesEl) gamesEl.textContent = games.toFixed(1) + ' PTS';
    }

    async function loadHoneyLeaderboard(currentWallet = null) {
      const leaderboardEl = document.getElementById('honeyLeaderboard');
      if (!leaderboardEl) return;

      try {
        // Include wallet address in request to get rank
        const url = currentWallet
          ? `${API_BASE_URL}/api/leaderboard?limit=15&wallet=${currentWallet}`
          : `${API_BASE_URL}/api/leaderboard?limit=15`;

        const response = await fetch(url);
        if (!response.ok) {
          console.debug('Leaderboard API not available');
          leaderboardEl.innerHTML = '<div class="leaderboard-empty">Leaderboard coming soon!</div>';
          return;
        }
        const data = await response.json();

        // Update user's rank from backend response
        if (currentWallet && data.userRank) {
          const myRankEl = document.getElementById('myRank');
          if (myRankEl) myRankEl.textContent = `#${data.userRank}`;
        }

        if (data.success && data.leaderboard && data.leaderboard.length > 0) {
          leaderboardEl.innerHTML = data.leaderboard.map((entry, index) => {
            const rank = index + 1;
            const isCurrentUser = currentWallet && entry.wallet_address === currentWallet;
            const rankClass = rank <= 3 ? `rank-${rank}` : '';
            const trophy = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : rank;

            // Use custom display name or show abbreviated wallet
            const displayName = entry.display_name || `${entry.wallet_address.substring(0, 6)}...${entry.wallet_address.substring(entry.wallet_address.length - 4)}`;

            // Show avatar if available, or default bear avatar
            let avatarHTML = '';
            if (entry.avatar_nft) {
              try {
                const avatarData = JSON.parse(entry.avatar_nft);
                const avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl;
                if (avatarUrl) {
                  avatarHTML = `<img src="${avatarUrl}"
                       style="width:40px; height:40px; border-radius:50%; object-fit:cover; margin-right:8px;"
                       alt="${displayName} avatar"
                       onerror="this.src='https://files.catbox.moe/ugu1kl.png'">`;
                }
              } catch (e) {
                // If not JSON, try using it directly as NFT ID
                avatarHTML = `<img src="https://nft.xrpl-labs.com/${entry.avatar_nft}"
                     style="width:40px; height:40px; border-radius:50%; object-fit:cover; margin-right:8px;"
                     alt="${displayName} avatar"
                     onerror="this.src='https://files.catbox.moe/ugu1kl.png'">`;
              }
            }

            // If no avatar_nft, show default bear avatar
            if (!avatarHTML) {
              avatarHTML = `<img src="https://files.catbox.moe/ugu1kl.png"
                   style="width:40px; height:40px; border-radius:50%; object-fit:cover; margin-right:8px;"
                   alt="${displayName} avatar">`;
            }

            return `
              <div class="leaderboard-item ${rankClass}" onclick="openProfileModal('${entry.wallet_address}')" style="display:flex; align-items:center; gap:12px; cursor:pointer;">
                <div class="leaderboard-rank ${rank <= 3 ? 'top-3' : ''}">${trophy}</div>
                ${avatarHTML}
                <div class="leaderboard-user" style="flex:1; min-width:0;">
                  <div class="leaderboard-username">${displayName}</div>
                  <div class="leaderboard-wallet">${entry.wallet_address.substring(0, 8)}...${entry.wallet_address.substring(entry.wallet_address.length - 6)}</div>
                </div>
                <div class="leaderboard-points">${entry.total_points.toLocaleString()} <img src="https://files.catbox.moe/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"></div>
              </div>
            `;
          }).join('');
        } else {
          leaderboardEl.innerHTML = '<div class="leaderboard-loading">No leaderboard data yet. Start playing to earn points!</div>';
        }
      } catch (err) {
        console.error('Error loading leaderboard:', err);
        leaderboardEl.innerHTML = '<div class="leaderboard-loading">Failed to load leaderboard</div>';
      }
    }

    // Initialize honey points section
    loadHoneyPoints();
    loadDailyGameProgress();
    const walletAddress = localStorage.getItem('bearpark_wallet');
    loadHoneyLeaderboard(walletAddress);
    loadRaids();
    startGameResetCountdown();

    // Listen for game points being awarded to refresh progress widget
    window.addEventListener('gamePointsAwarded', () => {
      loadDailyGameProgress();
      loadHoneyPoints(); // Also refresh total points
    });

    // Refresh data when page becomes visible (e.g., returning from game page)
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        console.log('Page became visible - refreshing honey points data');
        loadDailyGameProgress();
        loadHoneyPoints();
        const wallet = localStorage.getItem('bearpark_wallet');
        if (wallet) loadHoneyLeaderboard(wallet);
      }
    });

    // Also refresh when window gains focus
    window.addEventListener('focus', () => {
      console.log('Window gained focus - refreshing honey points data');
      loadDailyGameProgress();
      loadHoneyPoints();
    });

    // Show admin button if user is admin
    const ADMIN_WALLET = 'rKkkYMCvC63HEgxjQHmayKADaxYqnsMUkT';
    if (walletAddress === ADMIN_WALLET) {
      const adminBtn = document.getElementById('adminRaidBtn');
      if (adminBtn) {
        adminBtn.style.display = 'block';
      }
    }

    // Refresh leaderboard and raids every 30 seconds
    setInterval(() => {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      loadHoneyLeaderboard(walletAddress);
      if (!showingPreviousRaids) {
        loadRaids(); // Only refresh if showing current raids
      }
    }, 30000);

    function getTimeAgo(date) {
      const seconds = Math.floor((new Date() - date) / 1000);
      if (seconds < 60) return 'just now';
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m ago`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h ago`;
      const days = Math.floor(hours / 24);
      return `${days}d ago`;
    }

    // Twitter integration removed - points now earned through games and raids only

    /* ===== Raids System ===== */
    let raidTimerIntervals = [];
    let showingPreviousRaids = false;
    let currentRaidsData = {}; // Store raid data by ID for easy access
    let processingRaids = new Set(); // Track which raids are currently being processed

    async function loadRaids() {
      const walletAddress = localStorage.getItem('bearpark_wallet');

      try {
        // Fetch current raids and user's completed raids in parallel
        const [raidsResponse, completedResponse] = await Promise.all([
          fetch(`${API_BASE_URL}/api/raids/current`),
          walletAddress ? fetch(`${API_BASE_URL}/api/raids/completed/${walletAddress}`).catch(() => null) : Promise.resolve(null)
        ]);

        if (!raidsResponse.ok) {
          console.debug('Raids API not available');
          displayMockRaids(); // Show mock data for now
          return;
        }

        const raidsData = await raidsResponse.json();

        if (raidsData.success && raidsData.raids) {
          // Get server-side completed raids if available
          let serverCompletedRaids = [];
          if (completedResponse && completedResponse.ok) {
            const completedData = await completedResponse.json();
            if (completedData.success && completedData.completedRaids) {
              serverCompletedRaids = completedData.completedRaids.map(r => r.raid_id);
              console.log('🔵 [Raids] Server-side completed raids:', serverCompletedRaids);
            }
          }

          // Merge server-side completed raids with localStorage
          const localCompleted = JSON.parse(localStorage.getItem(`completed_raids_${walletAddress}`) || '[]');
          const allCompletedRaids = [...new Set([...serverCompletedRaids, ...localCompleted])];

          // Update localStorage with merged data
          if (walletAddress && allCompletedRaids.length > 0) {
            localStorage.setItem(`completed_raids_${walletAddress}`, JSON.stringify(allCompletedRaids));
          }

          // Filter out completed raids entirely
          const activeRaids = raidsData.raids.filter(raid => !allCompletedRaids.includes(raid.id));
          console.log('🔵 [Raids] Total raids:', raidsData.raids.length, 'Active:', activeRaids.length, 'Completed:', allCompletedRaids.length);

          displayCurrentRaids(activeRaids, walletAddress);
        }
      } catch (err) {
        console.error('Error loading raids:', err);
        displayMockRaids(); // Show mock data on error
      }
    }

    function displayMockRaids() {
      // Mock raid data for demonstration
      const mockRaids = [
        {
          id: 101,
          description: "Like and retweet the latest @BearXRPL announcement about the new BEAR SLICE game! 🎮<img src='https://files.catbox.moe/wyfjtc.png' alt='honey' style='height:1em; width:auto; vertical-align:middle; display:inline-block;'>",
          twitter_url: "https://x.com/BearXRPL/status/1986706939775181224",
          reward: 20,
          expires_at: new Date(Date.now() + 18 * 60 * 60 * 1000).toISOString(), // 18 hours from now
          profile_name: "BearXRPL",
          profile_handle: "@BearXRPL",
          profile_emoji: "🐻"
        },
        {
          id: 102,
          description: "Join the BEAR community space happening NOW! Come discuss the future of BEARpark 🐻",
          twitter_url: "https://twitter.com/i/spaces/1234567890",
          reward: 20,
          expires_at: new Date(Date.now() + 3 * 60 * 60 * 1000).toISOString(), // 3 hours from now
          profile_name: "BearXRPL",
          profile_handle: "@BearXRPL",
          profile_emoji: "🐻"
        }
      ];

      displayCurrentRaids(mockRaids, localStorage.getItem('bearpark_wallet'));
    }

    function displayCurrentRaids(raids, walletAddress) {
      const currentList = document.getElementById('currentRaidsList');
      if (!currentList) return;

      // Clear existing timers
      raidTimerIntervals.forEach(interval => clearInterval(interval));
      raidTimerIntervals = [];

      if (!raids || raids.length === 0) {
        currentList.innerHTML = '<div class="raids-empty">No active raids right now. Check back soon! <img src="https://files.catbox.moe/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"></div>';
        return;
      }

      // Store raids data for later use
      raids.forEach(raid => {
        currentRaidsData[raid.id] = raid;
      });

      // Get completed raids from localStorage
      const completedRaids = JSON.parse(localStorage.getItem(`completed_raids_${walletAddress}`) || '[]');

      // SECURITY: Save processing raid cards BEFORE rebuilding to preserve countdown state
      // We save the actual DOM elements (not clones) to preserve event handlers and intervals
      const processingCards = [];
      processingRaids.forEach(raidId => {
        const card = currentList.querySelector(`.raid-item[data-raid-id="${raidId}"]`);
        if (card) {
          card.remove(); // Remove from DOM temporarily
          processingCards.push(card); // Save reference to actual element
        }
      });

      // OPTIMIZATION: Save existing raid cards with loaded tweets to prevent reload
      const existingCards = {};
      Array.from(currentList.querySelectorAll('.raid-item')).forEach(card => {
        const raidId = parseInt(card.getAttribute('data-raid-id'));
        const preview = card.querySelector('.raid-tweet-preview');
        // Only save cards that have loaded tweet previews
        if (preview && (preview.querySelector('.twitter-tweet') || preview.querySelector('.raid-tweet-click-overlay'))) {
          card.remove(); // Remove from DOM temporarily
          existingCards[raidId] = card;
        }
      });

      currentList.innerHTML = raids.map(raid => {
        const isCompleted = completedRaids.includes(raid.id);
        const isProcessing = processingRaids.has(raid.id); // Check if currently processing
        const expiresAt = new Date(raid.expires_at);
        const now = new Date();
        const isExpired = expiresAt < now;

        // SECURITY: Don't re-render raids that are completed OR currently processing
        // Re-rendering processing raids would destroy the countdown state and UI references
        if (isCompleted || isProcessing) {
          return ''; // Don't render these raids
        }

        // OPTIMIZATION: Don't re-render raids with loaded tweet previews
        if (existingCards[raid.id]) {
          return ''; // Will be restored from saved element
        }

        return `
          <div class="raid-item ${isExpired ? 'expired' : ''}" data-raid-id="${raid.id}">
            ${raid.profile_name ? `
              <div class="raid-profile-header">
                <div class="raid-profile-emoji">${raid.profile_emoji || '🐻'}</div>
                <div class="raid-profile-info">
                  <div class="raid-profile-name">${raid.profile_name}</div>
                  <div class="raid-profile-handle">${raid.profile_handle || ''}</div>
                </div>
              </div>
            ` : ''}
            <div class="raid-header">
              <span class="raid-timer ${isExpired ? 'expired' : ''}" id="timer-${raid.id}">
                ${isExpired ? 'EXPIRED' : 'Calculating...'}
              </span>
            </div>
            <div class="raid-description">${raid.description}</div>
            <div class="raid-tweet-preview" id="tweet-preview-${raid.id}">
              <div class="raid-preview-loading">Loading tweet preview...</div>
            </div>
            <div class="raid-footer">
              <span class="raid-reward"><img src="https://files.catbox.moe/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"> HONEY EARNED FROM RAID: ${raid.reward}</span>
              <a href="javascript:void(0)"
                 class="raid-btn"
                 data-twitter-url="${raid.twitter_url}"
                 onclick="trackRaidClick(${raid.id}, event)"
                 ${isExpired ? 'style="pointer-events:none;opacity:0.5;"' : ''}>
                ${isExpired ? 'EXPIRED' : 'RAID NOW'}
              </a>
            </div>
          </div>
        `;
      }).join('');

      // OPTIMIZATION: Restore existing cards with loaded previews (appended at the end)
      raids.forEach(raid => {
        if (existingCards[raid.id]) {
          currentList.appendChild(existingCards[raid.id]);
          // Restart timer for this existing card
          if (new Date(raid.expires_at) > new Date()) {
            startRaidTimer(raid.id, raid.expires_at);
          }
        }
      });

      // Start countdown timers and load tweet previews for NEW raids only
      raids.forEach(raid => {
        // Skip if this is an existing card we just restored
        if (existingCards[raid.id]) {
          return; // Already has timer and preview
        }

        if (new Date(raid.expires_at) > new Date()) {
          startRaidTimer(raid.id, raid.expires_at);
        }
        // Load tweet preview only for new raids
        if (!completedRaids.includes(raid.id) && !processingRaids.has(raid.id)) {
          loadTweetPreview(raid.id, raid.twitter_url);
        }
      });

      // SECURITY: Re-append saved processing cards to preserve countdown state
      processingCards.forEach(card => {
        currentList.prepend(card); // Add at the beginning to keep them visible
      });
    }

    async function loadTweetPreview(raidId, twitterUrl) {
      const previewEl = document.getElementById(`tweet-preview-${raidId}`);
      if (!previewEl) return;

      // Check if preview is already loaded (not just the loading message)
      if (previewEl.querySelector('.twitter-tweet') || previewEl.querySelector('.raid-tweet-click-overlay')) {
        console.log(`Tweet preview already loaded for raid ${raidId}, skipping reload`);
        return;
      }

      try {
        const response = await fetch(`${API_BASE_URL}/api/twitter/oembed?url=${encodeURIComponent(twitterUrl)}`);
        const data = await response.json();

        if (data.success && data.embed && data.embed.html) {
          // Just display the full Twitter embed HTML
          previewEl.innerHTML = data.embed.html;

          // Add click overlay on top of the embed
          const overlay = document.createElement('div');
          overlay.className = 'raid-tweet-click-overlay';
          overlay.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            // Find the raid button and click it
            const raidBtn = document.querySelector(`.raid-item[data-raid-id="${raidId}"] .raid-btn`);
            if (raidBtn && !raidBtn.disabled) {
              console.log('Tweet preview clicked, triggering raid button');
              raidBtn.click();
            }
          };
          previewEl.appendChild(overlay);

          // Load Twitter widgets script if not already loaded
          if (!window.twttr) {
            const script = document.createElement('script');
            script.src = 'https://platform.twitter.com/widgets.js';
            script.async = true;
            document.body.appendChild(script);
          } else {
            // Reload widgets for this element
            window.twttr.widgets.load(previewEl);
          }
        } else {
          previewEl.innerHTML = '<div class="raid-preview-error">Preview unavailable</div>';
        }
      } catch (error) {
        console.error('Error loading tweet preview:', error);
        previewEl.innerHTML = '<div class="raid-preview-error">Preview unavailable</div>';
      }
    }

    function startRaidTimer(raidId, expiresAt) {
      const timerEl = document.getElementById(`timer-${raidId}`);
      if (!timerEl) return;

      const updateTimer = () => {
        const now = new Date().getTime();
        const end = new Date(expiresAt).getTime();
        const distance = end - now;

        if (distance < 0) {
          timerEl.textContent = 'EXPIRED';
          timerEl.classList.add('expired');
          return;
        }

        const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((distance % (1000 * 60)) / 1000);

        timerEl.textContent = `⏰ ${hours}h ${minutes}m ${seconds}s left`;
      };

      updateTimer(); // Update immediately
      const interval = setInterval(updateTimer, 1000);
      raidTimerIntervals.push(interval);
    }

    // Make function globally accessible
    window.trackRaidClick = function(raidId, event) {
      console.log('trackRaidClick called with raidId:', raidId);

      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) {
        console.log('No wallet address found');
        return true; // Allow link to open
      }

      // SECURITY: Check if already completed in localStorage (fast check)
      const completedRaids = JSON.parse(localStorage.getItem(`completed_raids_${walletAddress}`) || '[]');
      if (completedRaids.includes(raidId)) {
        console.log('❌ SECURITY: Raid already completed in localStorage!');
        return false; // Don't allow reopening
      }

      // SECURITY: Check if already being processed on THIS device
      if (processingRaids.has(raidId)) {
        console.log('❌ SECURITY: Raid already being processed on this device!');
        return false; // Prevent duplicate processing
      }

      // SECURITY: Mark as being processed IMMEDIATELY on this device
      processingRaids.add(raidId);

      // CRITICAL SECURITY: Check backend BEFORE starting countdown
      // This prevents race condition exploit across multiple devices
      console.log('🔒 SECURITY: Checking backend for existing completion...');

      // Show checking state
      const raidCard = document.querySelector(`.raid-item[data-raid-id="${raidId}"]`);
      const raidBtn = event ? event.currentTarget : document.querySelector(`.raid-item[data-raid-id="${raidId}"] .raid-btn`);

      if (!raidCard || !raidBtn) {
        console.error('Could not find raid card or button');
        processingRaids.delete(raidId);
        return true;
      }

      // Disable button immediately while checking
      raidBtn.style.pointerEvents = 'none';
      raidBtn.style.opacity = '0.5';
      const originalText = raidBtn.textContent;
      raidBtn.textContent = 'CHECKING...';

      // Check backend for existing completion
      fetch(`${API_BASE_URL}/api/raids/check-completion`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          wallet_address: walletAddress,
          raid_id: raidId
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.alreadyCompleted) {
          console.log('❌ SECURITY: Backend says raid already completed! Blocking exploit attempt.');
          raidBtn.textContent = 'ALREADY COMPLETED';
          raidBtn.style.backgroundColor = '#ff0000';

          // Mark as completed locally
          completedRaids.push(raidId);
          localStorage.setItem(`completed_raids_${walletAddress}`, JSON.stringify(completedRaids));

          processingRaids.delete(raidId);

          // Remove raid from view after 2 seconds
          setTimeout(() => {
            raidCard.classList.add('fade-out');
            setTimeout(() => raidCard.remove(), 500);
          }, 2000);

          return;
        }

        // Backend approved - proceed with raid
        console.log('✅ SECURITY: Backend approved raid completion');
        startRaidCompletion(raidId, walletAddress, raidCard, raidBtn, event);
      })
      .catch(err => {
        console.error('❌ SECURITY: Backend check failed:', err);
        raidBtn.textContent = 'ERROR - TRY AGAIN';
        raidBtn.style.pointerEvents = '';
        raidBtn.style.opacity = '';
        processingRaids.delete(raidId);
      });

      return false; // Prevent default link behavior
    };

    // Separate function for the actual raid completion flow
    function startRaidCompletion(raidId, walletAddress, raidCard, raidBtn, event) {

      // SECURITY: Capture raid reward IMMEDIATELY before any async operations
      // This ensures we have the correct reward value even if raids refresh during countdown
      const raidData = currentRaidsData[raidId];
      const pointsAwarded = raidData?.reward || 20;
      console.log(`🎯 Raid reward captured: ${pointsAwarded} points for raid ${raidId}`);

      // Open Twitter URL in browser (bypass Windows X app handler)
      let twitterUrl = raidBtn.getAttribute('data-twitter-url') || raidData?.twitter_url;
      if (twitterUrl) {
        twitterUrl = twitterUrl.replace('https://x.com/', 'https://twitter.com/');

        // Workaround for Windows opening X app: open blank tab first, then navigate
        const newTab = window.open('about:blank', '_blank');
        if (newTab) {
          // Small delay to ensure tab is ready, then navigate
          setTimeout(() => {
            newTab.location.href = twitterUrl;
          }, 100);
        }
      }

      // SECURITY: Prevent ANY re-rendering of this raid
      raidCard.setAttribute('data-processing', 'true');
      raidCard.style.pointerEvents = 'none'; // Disable entire card

      // SECURITY: Disable button immediately and make changes PERMANENT
      raidBtn.style.pointerEvents = 'none';
      raidBtn.style.opacity = '0.5';
      raidBtn.style.cursor = 'not-allowed';
      raidBtn.onclick = null; // Remove click handler entirely

      // Add completing state
      raidCard.classList.add('completing');
      raidBtn.classList.add('completing');

      // Start 60-second countdown
      let secondsLeft = 60;
      raidBtn.textContent = `COMPLETING... ⏳ ${secondsLeft}s`;

      // Store original button content to prevent overwrites
      const processingText = `COMPLETING... ⏳`;

      const countdownInterval = setInterval(() => {
        secondsLeft--;
        if (secondsLeft > 0) {
          // SECURITY: Force button text to stay as countdown - CANNOT be overwritten
          raidBtn.textContent = `COMPLETING... ⏳ ${secondsLeft}s`;
          raidBtn.style.pointerEvents = 'none'; // Re-enforce every second
          raidBtn.onclick = null; // Re-enforce every second
        } else {
          // Countdown finished - mark as completed and fade out
          clearInterval(countdownInterval);

          // SECURITY: Double-check not already completed
          const currentCompleted = JSON.parse(localStorage.getItem(`completed_raids_${walletAddress}`) || '[]');
          if (currentCompleted.includes(raidId)) {
            console.log('❌ SECURITY: Raid was already completed during countdown!');
            processingRaids.delete(raidId);
            return;
          }

          // Mark raid as completed in localStorage
          currentCompleted.push(raidId);
          localStorage.setItem(`completed_raids_${walletAddress}`, JSON.stringify(currentCompleted));

          // Save full raid data for previous raids section
          const completedRaidsData = JSON.parse(localStorage.getItem(`completed_raids_data_${walletAddress}`) || '[]');

          // Use the raidData and pointsAwarded we captured at the start
          if (raidData && !completedRaidsData.find(r => r.id === raidId)) {
            completedRaidsData.push({
              ...raidData,
              completed_at: new Date().toISOString()
            });
            localStorage.setItem(`completed_raids_data_${walletAddress}`, JSON.stringify(completedRaidsData));
          }

          // CRITICAL SECURITY: Send to backend FIRST and ONLY award points if backend approves
          // This prevents the double-reward exploit
          raidBtn.textContent = 'SYNCING WITH SERVER...';

          fetch(`${API_BASE_URL}/api/raids/complete`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              wallet_address: walletAddress,
              raid_id: raidId,
              completed_at: new Date().toISOString(),
              points_awarded: pointsAwarded
            })
          })
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
          })
          .then(data => {
            console.log('🔒 SECURITY: Backend response:', data);

            // CRITICAL: Only award points if backend says success AND not already completed
            if (data.success && !data.alreadyCompleted) {
              console.log('✅ SECURITY: Backend approved points award');

              // Award points locally
              const pointsKey = `honey_points_${walletAddress}`;
              const currentPoints = JSON.parse(localStorage.getItem(pointsKey) || '{"total":0,"raiding":0,"games":0}');

              currentPoints.total += pointsAwarded;
              currentPoints.raiding += pointsAwarded;
              localStorage.setItem(pointsKey, JSON.stringify(currentPoints));

              console.log(`✅ Points awarded! +${pointsAwarded} New balance:`, currentPoints);

              // Update all points displays immediately
              updatePointsDisplay(currentPoints.total, currentPoints.raiding, currentPoints.games);
              updateWelcomeButton();

              const navHoneyPoints = document.getElementById('navHoneyPoints');
              if (navHoneyPoints) {
                navHoneyPoints.textContent = currentPoints.total.toFixed(1) + ' PTS';
              }

              const welcomePoints = document.getElementById('welcomePoints');
              if (welcomePoints) {
                welcomePoints.textContent = currentPoints.total.toFixed(1);
              }

              // Reload to sync with backend
              loadHoneyPoints();
              loadDailyGameProgress();
              loadHoneyLeaderboard(walletAddress);

              raidBtn.textContent = `✓ COMPLETED +${pointsAwarded} PTS`;
            } else if (data.alreadyCompleted) {
              console.log('❌ SECURITY: Backend rejected - raid already completed! EXPLOIT BLOCKED!');
              raidBtn.textContent = 'ALREADY COMPLETED - NO POINTS';
              raidBtn.style.backgroundColor = '#ff0000';
            } else {
              console.warn('⚠️ SECURITY: Backend returned unexpected response');
              raidBtn.textContent = 'ERROR - NO POINTS AWARDED';
              raidBtn.style.backgroundColor = '#ff6600';
            }
          })
          .catch(err => {
            console.error('❌ SECURITY: Backend sync FAILED - NO POINTS AWARDED:', err);
            raidBtn.textContent = 'ERROR - TRY AGAIN LATER';
            raidBtn.style.backgroundColor = '#ff0000';
            processingRaids.delete(raidId);
            return; // Don't continue if backend fails
          })
          .finally(() => {
            // Clean up UI regardless of success or failure
            raidBtn.classList.remove('completing');
            raidCard.classList.remove('completing');
            raidCard.classList.add('completed');

            // SECURITY: Remove from processing set
            processingRaids.delete(raidId);

            // Fade out and remove after animation
            setTimeout(() => {
              raidCard.classList.add('fade-out');

              // Remove from DOM after animation completes
              setTimeout(() => {
                raidCard.remove();

                // Check if there are no more raids
                const currentList = document.getElementById('currentRaidsList');
                if (currentList && currentList.children.length === 0) {
                  currentList.innerHTML = '<div class="raids-empty">No active raids right now. Check back soon! <img src="https://files.catbox.moe/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"></div>';
                }
              }, 1000);
            }, 1500);
          });
        }
      }, 1000);

      return true; // Allow link to open in new tab
    };

    async function loadPreviousRaids() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      const previousList = document.getElementById('previousRaidsList');
      if (!previousList) return;

      // Load from localStorage
      const completedRaidsData = JSON.parse(localStorage.getItem(`completed_raids_data_${walletAddress}`) || '[]');

      if (completedRaidsData.length > 0) {
        previousList.innerHTML = completedRaidsData.map(raid => {
          return `
            <div class="raid-item completed">
              ${raid.profile_name ? `
                <div class="raid-profile-header">
                  <div class="raid-profile-emoji">${raid.profile_emoji || '🐻'}</div>
                  <div class="raid-profile-info">
                    <div class="raid-profile-name">${raid.profile_name}</div>
                    <div class="raid-profile-handle">${raid.profile_handle || ''}</div>
                  </div>
                </div>
              ` : ''}
              <div class="raid-header">
                <span class="raid-timer expired">✓ COMPLETED</span>
              </div>
              <div class="raid-description">${raid.description}</div>
              <div class="raid-footer">
                <span class="raid-reward">✓ Earned ${raid.reward} PTS <img src="https://files.catbox.moe/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"></span>
                <a href="${raid.twitter_url}" target="_blank" rel="noopener noreferrer" class="raid-btn" style="pointer-events:all;opacity:1;">
                  VIEW POST
                </a>
              </div>
            </div>
          `;
        }).join('');
      } else {
        previousList.innerHTML = '<div class="raids-empty">No previous raids yet! Complete some raids to see them here. <img src="https://files.catbox.moe/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"></div>';
      }

      // Try to sync with backend (optional)
      try {
        const response = await fetch(`/api/raids/previous?wallet=${walletAddress}`);
        if (response.ok) {
          const data = await response.json();
          // Could merge backend data here if needed
        }
      } catch (err) {
        console.debug('Backend not available - using local data');
      }
    }

    // Toggle between current and previous raids
    document.getElementById('raidsToggleBtn')?.addEventListener('click', function() {
      const currentList = document.getElementById('currentRaidsList');
      const previousList = document.getElementById('previousRaidsList');
      const raidsTitle = document.getElementById('raidsTitle');

      showingPreviousRaids = !showingPreviousRaids;

      if (showingPreviousRaids) {
        currentList.style.display = 'none';
        previousList.style.display = 'flex';
        this.textContent = 'Show Current Raids';
        if (raidsTitle) raidsTitle.textContent = '📜 Previous Raids';
        loadPreviousRaids();
      } else {
        currentList.style.display = 'flex';
        previousList.style.display = 'none';
        this.textContent = 'Show Previous Raids';
        if (raidsTitle) raidsTitle.textContent = '🐻 🪖 Current Raids';
      }
    });

    /* ===== NFT & Profile Management ===== */
    const PIXEL_BEARS_ISSUER = 'rBEARbo4Prn33894evmvYcAf9yAQjp4VJF';
    const PIXEL_BEARS_TAXON = 1;
    const ULTRA_RARES_ISSUER = 'rBEARbo4Prn33894evmvYcAf9yAQjp4VJF';
    const ULTRA_RARES_TAXON = 2;

    let currentNFTs = [];
    let selectedAvatarNFT = null;
    let nftImageCache = {}; // Store NFT images and metadata

    // Helper function to convert hex string to regular string
    function hexToString(hex) {
      const hexString = hex.startsWith('0x') ? hex.slice(2) : hex;
      let str = '';
      for (let i = 0; i < hexString.length; i += 2) {
        const charCode = parseInt(hexString.substr(i, 2), 16);
        if (charCode) str += String.fromCharCode(charCode);
      }
      return str;
    }

    // Show profile and NFT sections when authenticated
    async function initializeProfileAndNFTs() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      const isAuthenticated = localStorage.getItem('bearpark_auth') === 'true';

      if (!isAuthenticated || !walletAddress) {
        document.getElementById('profileSection').style.display = 'none';
        document.getElementById('nftSection').style.display = 'none';
        return;
      }

      // Show sections
      document.getElementById('profileSection').style.display = 'block';
      document.getElementById('nftSection').style.display = 'block';

      // Load existing profile data
      let profileLoaded = false;

      // Try to load from backend first
      try {
        const response = await fetch(`${API_BASE_URL}/api/profile/${walletAddress}`);
        if (response.ok) {
          const data = await response.json();

          if (data.success && data.profile) {
            document.getElementById('profileUsername').value = data.profile.display_name || '';
            if (data.profile.avatar_nft) {
              selectedAvatarNFT = data.profile.avatar_nft;
              document.getElementById('profileAvatarNFT').value = data.profile.avatar_nft;
              // Display selected avatar
              displaySelectedAvatar(data.profile.avatar_nft);
            }
            profileLoaded = true;
          }
        }
      } catch (err) {
        console.debug('Backend profile not available, checking localStorage:', err.message);
      }

      // Fallback to localStorage if backend didn't load
      if (!profileLoaded) {
        const profileKey = `bearpark_profile_${walletAddress}`;
        const localProfile = localStorage.getItem(profileKey);
        if (localProfile) {
          try {
            const profile = JSON.parse(localProfile);
            document.getElementById('profileUsername').value = profile.display_name || '';
            if (profile.avatar_nft) {
              selectedAvatarNFT = profile.avatar_nft;
              document.getElementById('profileAvatarNFT').value = profile.avatar_nft;
              // Display selected avatar
              displaySelectedAvatar(profile.avatar_nft);
            }
            console.log('✅ Loaded profile from localStorage');
          } catch (e) {
            console.error('Error parsing local profile:', e);
          }
        }
      }
    }

    function displaySelectedAvatar(nftIdOrData) {
      const selector = document.getElementById('profileAvatarSelector');
      let imageData;

      // Handle both NFT ID string and JSON avatar data
      if (typeof nftIdOrData === 'string') {
        // Try to parse as JSON first (from database)
        try {
          imageData = JSON.parse(nftIdOrData);
        } catch (e) {
          // If not JSON, it's an NFT ID - look it up in cache
          imageData = nftImageCache[nftIdOrData];
        }
      } else {
        // Already an object
        imageData = nftIdOrData;
      }

      if (imageData && imageData.imageUrl) {
        // Build fallback chain: animated -> fallback image -> error placeholder
        const fallbackSrc = imageData.fallbackImageUrl || 'data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27100%27 height=%27100%27%3E%3Crect fill=%27%23333%27 width=%27100%27 height=%27100%27/%3E%3Ctext fill=%27%23edb723%27 x=%2750%25%27 y=%2750%25%27 text-anchor=%27middle%27 dy=%27.3em%27%3ENFT%3C/text%3E%3C/svg%3E';

        // Use img element for all content types
        // Browsers handle GIFs natively, and can show video thumbnails
        selector.innerHTML = `
          <img src="${imageData.imageUrl}"
               style="width:100%; max-width:120px; border-radius:8px;"
               alt="Selected avatar"
               crossorigin="anonymous"
               onerror="if(this.src!=='${fallbackSrc.replace(/'/g, "\\'")}'){console.log('[Avatar] Trying fallback image');this.src='${fallbackSrc.replace(/'/g, "\\'")}';}">
        `;
      } else {
        selector.innerHTML = `
          <div style="width:100%; max-width:120px; aspect-ratio:1; background:rgba(237,183,35,0.1); border-radius:8px; display:flex; align-items:center; justify-content:center; color:var(--gold);">
            Loading...
          </div>
        `;
      }
    }

    // Load NFTs from wallet
    async function loadNFTs(taxon, type) {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) return;

      const nftLoading = document.getElementById('nftLoading');
      const nftGrid = document.getElementById('nftGrid');
      const nftEmpty = document.getElementById('nftEmpty');
      const nftGridContent = document.getElementById('nftGridContent');

      // Show loading
      nftLoading.style.display = 'block';
      nftGrid.style.display = 'none';
      nftEmpty.style.display = 'none';

      try {
        // Connect to XRPL
        if (typeof xrpl === 'undefined') {
          console.error('XRPL library not loaded');
          alert('Error: XRPL library not loaded');
          nftLoading.style.display = 'none';
          return;
        }

        const client = new xrpl.Client('wss://xrplcluster.com');
        await client.connect();

        // Get ALL account NFTs with pagination
        let allNFTs = [];
        let marker = undefined;
        let pageCount = 0;
        const maxPages = 20; // Safety limit

        console.log('[NFT] Fetching all NFTs from wallet (with pagination)...');

        do {
          const nftRequest = {
            command: 'account_nfts',
            account: walletAddress,
            ledger_index: 'validated',
            limit: 400 // Maximum per page
          };

          if (marker) {
            nftRequest.marker = marker;
          }

          const nfts = await client.request(nftRequest);

          if (nfts.result.account_nfts && nfts.result.account_nfts.length > 0) {
            allNFTs = allNFTs.concat(nfts.result.account_nfts);
            console.log(`[NFT] Page ${pageCount + 1}: Found ${nfts.result.account_nfts.length} NFTs`);
          }

          marker = nfts.result.marker;
          pageCount++;

        } while (marker && pageCount < maxPages);

        console.log(`[NFT] Total NFTs found across ${pageCount} page(s):`, allNFTs.length);

        // Log each NFT for debugging
        allNFTs.forEach((nft, i) => {
          const nftTaxon = parseInt(nft.NFTokenID.substring(48, 56), 16);
          console.log(`[NFT ${i}] Issuer:`, nft.Issuer, 'Taxon:', nftTaxon, 'ID:', nft.NFTokenID);
        });

        // Filter NFTs by issuer AND URI pattern
        const targetIssuer = 'rBEARbo4Prn33894evmvYcAf9yAQjp4VJF';
        const filteredNFTs = allNFTs.filter(nft => {
          const issuerMatch = nft.Issuer === targetIssuer;
          if (!issuerMatch) return false;

          // Check URI to distinguish Pixel Bears from Ultra Rares
          if (nft.URI) {
            const uriString = hexToString(nft.URI);
            const isPixelBear = uriString.includes('Pixel BEAR') || uriString.includes('Pixel%20BEAR');

            // If looking for Pixel Bears (taxon 1), include Pixel Bears
            // If looking for Ultra Rares (taxon 2), exclude Pixel Bears
            const typeMatch = (taxon === PIXEL_BEARS_TAXON) ? isPixelBear : !isPixelBear;

            console.log('[NFT Filter]', nft.NFTokenID, 'Issuer:', issuerMatch, 'Type:', isPixelBear ? 'Pixel BEAR' : 'Ultra Rare', 'Match:', typeMatch);
            return typeMatch;
          }

          return false;
        });

        console.log('[NFT] Filtered NFTs:', filteredNFTs.length);

        currentNFTs = filteredNFTs;

        if (filteredNFTs.length === 0) {
          nftLoading.style.display = 'none';
          nftEmpty.style.display = 'block';
          nftEmpty.textContent = `No ${type} found in your wallet. Total NFTs: ${allNFTs.length}`;
          return;
        }

        // Display NFTs with loading placeholders
        nftGridContent.innerHTML = filteredNFTs.map(nft => `
          <div class="nft-item" data-nft-id="${nft.NFTokenID}"
               style="position:relative; border-radius:12px; overflow:hidden; border:3px solid rgba(237,183,35,0.3); background:linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,20,20,0.9)); transition:all 0.3s ease; box-shadow:0 4px 15px rgba(0,0,0,0.5);"
               onmouseover="this.style.transform='translateY(-5px) scale(1.02)'; this.style.borderColor='var(--gold)'; this.style.boxShadow='0 8px 25px rgba(237,183,35,0.4)';"
               onmouseout="this.style.transform=''; this.style.borderColor='rgba(237,183,35,0.3)'; this.style.boxShadow='0 4px 15px rgba(0,0,0,0.5)';">
            <div style="width:100%; aspect-ratio:1; position:relative; background:rgba(237,183,35,0.05);">
              <img src="" data-nft-id="${nft.NFTokenID}" class="nft-image-loading"
                   style="width:100%; height:100%; display:block; object-fit:contain; image-rendering:pixelated;"
                   loading="lazy"
                   alt="${type} NFT">
              <a href="https://xrp.cafe/nft/${nft.NFTokenID}" target="_blank" rel="noopener noreferrer"
                 style="position:absolute; top:8px; left:8px; width:32px; height:32px; border-radius:50%; background:#fff; display:flex; align-items:center; justify-content:center; box-shadow:0 2px 8px rgba(0,0,0,0.3); transition:all 0.2s; z-index:10; border:3px solid transparent; background-image: linear-gradient(#fff, #fff), var(--tri-gradient); background-origin: padding-box, border-box; background-clip: padding-box, border-box;"
                 onmouseover="this.style.transform='scale(1.15)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.5)';"
                 onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.3)';"
                 title="View on XRP.cafe">
                <img src="https://avatars.githubusercontent.com/u/109316848?s=280&v=4"
                     alt="XRP.cafe"
                     style="width:20px; height:20px; border-radius:50%; object-fit:cover;">
              </a>
              <div class="loading-overlay" data-nft-id="${nft.NFTokenID}" style="position:absolute; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); display:flex; align-items:center; justify-content:center; color:var(--gold); font-size:14px; font-weight:900; backdrop-filter:blur(4px);">
                Loading...
              </div>
            </div>
            <div class="nft-info" data-nft-id="${nft.NFTokenID}" style="padding:12px; background:rgba(0,0,0,0.6); backdrop-filter:blur(10px); display:none;">
              <div style="text-align:center; margin-bottom:8px;">
                <div style="color:var(--gold); font-weight:900; font-size:14px; margin-bottom:4px;">Loading...</div>
                <div style="color:rgba(255,255,255,0.7); font-size:11px;">Please wait...</div>
              </div>
            </div>
            <div style="padding:8px; background:rgba(0,0,0,0.8); backdrop-filter:blur(10px);">
              <button class="nft-select-btn" data-nft-id="${nft.NFTokenID}"
                      style="font-size:12px; padding:10px; background:#5D3FD3; color:#fff; border:3px solid transparent; border-radius:20px; font-weight:900; cursor:pointer; width:100%; transition:all 0.2s; text-transform:uppercase; letter-spacing:1px; box-shadow:0 4px 0 #000,0 4px 12px rgba(0,0,0,0.8); background-image:linear-gradient(#5D3FD3, #5D3FD3), var(--tri-gradient); background-origin:padding-box, border-box; background-clip:padding-box, border-box;"
                      onmouseover="this.style.backgroundImage='linear-gradient(#6D4FE3, #6D4FE3), var(--tri-gradient)'; this.style.transform='translateY(-2px)';"
                      onmouseout="this.style.backgroundImage='linear-gradient(#5D3FD3, #5D3FD3), var(--tri-gradient)'; this.style.transform='translateY(0)';">
                Select Avatar
              </button>
              <button class="nft-save-btn" data-nft-id="${nft.NFTokenID}"
                      style="font-size:11px; padding:8px; background:#07ae08; color:#fff; border:3px solid transparent; border-radius:20px; font-weight:900; cursor:pointer; margin-top:6px; width:100%; transition:all 0.2s; text-transform:uppercase; letter-spacing:0.5px; box-shadow:0 4px 0 #000,0 4px 12px rgba(0,0,0,0.8); background-image:linear-gradient(#07ae08, #07ae08), var(--tri-gradient); background-origin:padding-box, border-box; background-clip:padding-box, border-box;"
                      onmouseover="this.style.backgroundImage='linear-gradient(#08d509, #08d509), var(--tri-gradient)'; this.style.transform='translateY(-2px)';"
                      onmouseout="this.style.backgroundImage='linear-gradient(#07ae08, #07ae08), var(--tri-gradient)'; this.style.transform='translateY(0)';">
                Save Image
              </button>
            </div>
          </div>
        `).join('');

        // Disconnect client - we have all the data we need
        await client.disconnect();
        console.log('[NFT] Client disconnected');

        // Load NFT images from metadata JSON files
        const imageLoadPromises = filteredNFTs.map(async (nft) => {
          try {
            // Check if NFT has a URI field (hex-encoded)
            if (!nft.URI) {
              console.log('[NFT Image] No URI found for', nft.NFTokenID);
              return;
            }

            // Convert hex URI to string
            const uriString = hexToString(nft.URI);
            console.log('[NFT Image] NFT:', nft.NFTokenID, 'URI:', uriString);

            // Convert IPFS URI to HTTP gateway URL
            let metadataUrl = '';
            if (uriString.startsWith('ipfs://')) {
              const ipfsPath = uriString.replace('ipfs://', '');
              // Split path and encode each component to handle spaces and special chars
              const pathParts = ipfsPath.split('/');
              const encodedPath = pathParts.map(part => encodeURIComponent(part)).join('/');
              metadataUrl = `https://ipfs.io/ipfs/${encodedPath}`;
            } else if (uriString.startsWith('http')) {
              metadataUrl = uriString;
            } else if (uriString.length > 0) {
              // Might be just the IPFS hash without prefix
              const pathParts = uriString.split('/');
              const encodedPath = pathParts.map(part => encodeURIComponent(part)).join('/');
              metadataUrl = `https://ipfs.io/ipfs/${encodedPath}`;
            }

            if (!metadataUrl) {
              console.log('[NFT Image] Could not construct metadata URL for', nft.NFTokenID);
              return;
            }

            // Fetch the metadata JSON
            console.log('[NFT Image] Fetching metadata from:', metadataUrl);
            const metadataResponse = await fetch(metadataUrl);

            if (!metadataResponse.ok) {
              throw new Error(`Failed to fetch metadata: ${metadataResponse.status} ${metadataResponse.statusText}`);
            }

            const metadata = await metadataResponse.json();

            if (!metadata) {
              throw new Error('Metadata is empty or invalid');
            }

            // Extract image URL from metadata (check image, animation, or image_url fields)
            // Ultra Rare Bears use the "animation" field for their animated images
            // Store both animation and static image if available for fallback
            const isAnimated = !!metadata.animation;
            let imageUrl = metadata.animation || metadata.image || metadata.image_url || '';
            let fallbackImageUrl = null;

            // If there's an animation, also get the static image as fallback
            if (metadata.animation && metadata.image) {
              fallbackImageUrl = metadata.image;
            }

            // Helper to convert IPFS URL to HTTP gateway with multiple fallback gateways
            const convertIpfsUrl = (url, gatewayIndex = 0) => {
              if (url && url.startsWith('ipfs://')) {
                const ipfsPath = url.replace('ipfs://', '');
                const pathParts = ipfsPath.split('/');
                const encodedPath = pathParts.map(part => encodeURIComponent(part)).join('/');

                // Multiple IPFS gateways for redundancy (using working gateways only)
                const gateways = [
                  'https://ipfs.io/ipfs/',
                  'https://gateway.ipfs.io/ipfs/',
                  'https://gateway.pinata.cloud/ipfs/',
                  'https://dweb.link/ipfs/'
                ];

                return `${gateways[gatewayIndex % gateways.length]}${encodedPath}`;
              }
              return url;
            };

            imageUrl = convertIpfsUrl(imageUrl);
            fallbackImageUrl = convertIpfsUrl(fallbackImageUrl);

            console.log('[NFT Image]', isAnimated ? 'Animation' : 'Image', 'URL for', nft.NFTokenID, ':', imageUrl);
            if (fallbackImageUrl) {
              console.log('[NFT Image] Fallback URL:', fallbackImageUrl);
            }

            // Extract BEAR number and rarity from metadata
            const bearName = metadata.name || 'Unknown BEAR';

            // Extract bear number from name (e.g., "BEAR #36" -> 36)
            const bearNumberMatch = bearName.match(/#(\d+)/);
            const bearNumber = bearNumberMatch ? parseInt(bearNumberMatch[1]) : null;

            // Hardcoded rarity mapping for Ultra Rare Bears
            // This data is not stored in the NFT metadata
            const ultraRareRarityMap = {
              9: 10,
              12: 12,
              14: 14,
              18: 18,
              36: 37,
              451: 273
            };

            let rarityNumber = '';
            if (bearNumber && ultraRareRarityMap[bearNumber]) {
              rarityNumber = `#${ultraRareRarityMap[bearNumber]}`;
              console.log('[NFT Image] Mapped rarity for', bearName, ':', rarityNumber);
            } else {
              console.log('[NFT Image] No rarity mapping found for', bearName);
              rarityNumber = '';
            }

            console.log('[NFT Image] Extracted:', bearName, 'Rarity:', rarityNumber);

            // Store in cache
            nftImageCache[nft.NFTokenID] = {
              imageUrl,
              fallbackImageUrl,
              metadata,
              bearName,
              rarityNumber,
              isAnimated
            };

            // Update media element (use img for all content types for reliability)
            const imgElement = document.querySelector(`img.nft-image-loading[data-nft-id="${nft.NFTokenID}"]`);
            if (imgElement && imageUrl) {
              // Set up timeout for slow-loading animated content
              let loadTimeout = null;
              let hasLoaded = false;

              // Set up error handler to try fallback image if animated content fails
              if (fallbackImageUrl && isAnimated) {
                // Timeout after 8 seconds for animated content
                loadTimeout = setTimeout(() => {
                  if (!hasLoaded && imgElement.src !== fallbackImageUrl) {
                    console.log('[NFT Image] Animated content loading too slow, using static fallback for', nft.NFTokenID);
                    imgElement.src = fallbackImageUrl;
                  }
                }, 8000);

                imgElement.onerror = function() {
                  clearTimeout(loadTimeout);
                  if (this.src !== fallbackImageUrl) {
                    console.log('[NFT Image] Animated content failed, trying static fallback for', nft.NFTokenID);
                    this.src = fallbackImageUrl;
                  }
                };

                imgElement.onload = function() {
                  hasLoaded = true;
                  clearTimeout(loadTimeout);
                  console.log('[NFT Image] Successfully loaded image for', nft.NFTokenID);
                };
              }

              imgElement.src = imageUrl;
              imgElement.classList.remove('nft-image-loading');
              console.log('[NFT Image] Successfully set image URL:', imageUrl);

              // Remove loading overlay after image loads
              const loadingOverlay = document.querySelector(`.loading-overlay[data-nft-id="${nft.NFTokenID}"]`);
              if (loadingOverlay) {
                // Wait for image to load before removing overlay
                if (imgElement.complete) {
                  loadingOverlay.remove();
                } else {
                  const removeOverlay = () => {
                    loadingOverlay.remove();
                    imgElement.removeEventListener('load', removeOverlay);
                    imgElement.removeEventListener('error', removeOverlay);
                  };
                  imgElement.addEventListener('load', removeOverlay);
                  imgElement.addEventListener('error', removeOverlay);
                }
              }

              // Update NFT info section
              const infoSection = document.querySelector(`.nft-info[data-nft-id="${nft.NFTokenID}"]`);
              if (infoSection) {
                infoSection.style.display = 'block';
                infoSection.innerHTML = `
                  <div style="text-align:center; margin-bottom:0;">
                    <div style="color:var(--gold); font-weight:900; font-size:14px; margin-bottom:2px; text-shadow:0 2px 4px rgba(0,0,0,0.5);">${bearName}</div>
                    <div style="color:rgba(255,255,255,0.8); font-size:12px; font-weight:700;">Rarity ${rarityNumber}</div>
                  </div>
                `;
              }
            }
          } catch (err) {
            console.error('[NFT Image] Failed to load image for', nft.NFTokenID, err);
            // Show error state
            const loadingOverlay = document.querySelector(`.loading-overlay[data-nft-id="${nft.NFTokenID}"]`);
            if (loadingOverlay) {
              loadingOverlay.innerHTML = '<div style="text-align:center;"><div style="font-size:20px; margin-bottom:4px;">⚠️</div><div>Failed to load</div></div>';
            }
          }
        });

        // Wait for all images to load
        await Promise.all(imageLoadPromises);
        console.log('[NFT] All images loaded');

        // Wire up NFT buttons
        document.querySelectorAll('.nft-select-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const nftId = btn.getAttribute('data-nft-id');
            selectNFTAsAvatar(nftId);
          });
        });

        document.querySelectorAll('.nft-save-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const nftId = btn.getAttribute('data-nft-id');
            saveNFTImage(nftId);
          });
        });

        nftLoading.style.display = 'none';
        nftGrid.style.display = 'block';

        // Auto-scroll to NFT grid after loading
        setTimeout(() => {
          nftGrid.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }, 100);

      } catch (err) {
        console.error('Error loading NFTs:', err);
        nftLoading.style.display = 'none';
        nftEmpty.style.display = 'block';
        nftEmpty.textContent = 'Failed to load NFTs. Please try again.';
      }
    }

    function selectNFTAsAvatar(nftId) {
      selectedAvatarNFT = nftId;
      document.getElementById('profileAvatarNFT').value = nftId;
      displaySelectedAvatar(nftId);
      // Scroll to profile setup section to see avatar
      const profileSection = document.getElementById('profileSetupSection');
      if (profileSection) {
        profileSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    function saveNFTImage(nftId) {
      const imageData = nftImageCache[nftId];
      if (imageData && imageData.imageUrl) {
        const link = document.createElement('a');
        link.href = imageData.imageUrl;
        link.download = `${imageData.bearName || 'BEAR-NFT'}-${nftId.substring(0, 8)}.png`;
        link.target = '_blank';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      } else {
        alert('Image not yet loaded. Please wait a moment and try again.');
      }
    }

    // Save profile
    document.getElementById('saveProfileBtn')?.addEventListener('click', async () => {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) return;

      const username = document.getElementById('profileUsername').value.trim();
      const avatarNFT = document.getElementById('profileAvatarNFT').value;

      if (!username) {
        showSuccessPopup('Please enter a display name first!', '⚠️');
        return;
      }

      // Get the full image data from cache
      let avatarData = null;
      let avatarUrl = null;
      if (avatarNFT && nftImageCache[avatarNFT]) {
        // Store the full image data as JSON
        avatarData = JSON.stringify({
          nftId: avatarNFT,
          imageUrl: nftImageCache[avatarNFT].imageUrl,
          fallbackImageUrl: nftImageCache[avatarNFT].fallbackImageUrl,
          bearName: nftImageCache[avatarNFT].bearName,
          isAnimated: nftImageCache[avatarNFT].isAnimated
        });
        avatarUrl = nftImageCache[avatarNFT].imageUrl;
      }

      // IMMEDIATELY save to localStorage (works without backend)
      const profileKey = `bearpark_profile_${walletAddress}`;
      const localProfile = {
        display_name: username,
        avatar_nft: avatarData,
        avatar_url: avatarUrl,
        updated_at: new Date().toISOString()
      };
      localStorage.setItem(profileKey, JSON.stringify(localProfile));
      console.log('✅ Profile saved locally!', localProfile);

      // Mark that user has completed first-time profile setup
      localStorage.setItem('bearpark_profile_setup_complete', 'true');

      // Hide BOTH instruction banners with fade out effect
      const profileInstructionsBanner = document.getElementById('profileInstructions');
      const nftInstructionsBanner = document.getElementById('nftInstructions');

      if (profileInstructionsBanner) {
        profileInstructionsBanner.style.opacity = '0';
        profileInstructionsBanner.style.transform = 'scale(0.8)';
        setTimeout(() => {
          profileInstructionsBanner.style.display = 'none';
        }, 500);
      }

      if (nftInstructionsBanner) {
        nftInstructionsBanner.style.opacity = '0';
        nftInstructionsBanner.style.transform = 'scale(0.8)';
        setTimeout(() => {
          nftInstructionsBanner.style.display = 'none';
        }, 500);
      }

      // Update welcome button immediately with local data
      updateWelcomeButton();

      // Try to sync with backend (optional)
      try {
        const response = await fetch(`${API_BASE_URL}/api/profile`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            wallet_address: walletAddress,
            display_name: username,
            avatar_nft: avatarData
          })
        });

        if (response.ok) {
          const data = await response.json();
          if (data.success) {
            console.log('✅ Profile synced with backend!');
            celebrateProfileSave();
            showSuccessPopup('Your profile is looking BEARISH! 🐻✨ Your custom username and avatar will appear on the leaderboard!', '🎉');
            // Refresh leaderboard to show new profile
            loadHoneyLeaderboard(walletAddress);
          } else {
            celebrateProfileSave();
            showSuccessPopup('Profile saved to the moon! 🚀 (Backend sync pending but you\'re good to go!)', '✅');
          }
        } else {
          console.log('Backend not available - profile saved locally only');
          celebrateProfileSave();
          showSuccessPopup('You\'re officially a BEAR now! 🐻💪 Your profile is saved and ready to roar!', '🎊');
        }
      } catch (error) {
        console.log('Backend not available - profile saved locally only');
        celebrateProfileSave();
        showSuccessPopup('You\'re officially a BEAR now! 🐻💪 Your profile is saved and ready to roar!', '🎊');
      }
    });

    // View Pixel Bears button
    document.getElementById('viewPixelBearsBtn')?.addEventListener('click', () => {
      loadNFTs(PIXEL_BEARS_TAXON, 'Pixel Bears');
    });

    // View Ultra Rares button
    document.getElementById('viewUltraRaresBtn')?.addEventListener('click', () => {
      loadNFTs(ULTRA_RARES_TAXON, 'Ultra Rares');
    });

    // Initialize on load
    initializeProfileAndNFTs();

    // ===== TOP NAVIGATION FUNCTIONS =====

    // Toggle hamburger menu
    window.toggleMenu = function() {
      const menuOverlay = document.getElementById('menuOverlay');
      const menuScrim = document.getElementById('menuScrim');

      menuOverlay.classList.toggle('open');
      menuScrim.classList.toggle('open');

      // Prevent body scroll when menu is open
      if (menuOverlay.classList.contains('open')) {
        document.body.style.overflow = 'hidden';
      } else {
        document.body.style.overflow = '';
      }
    };

    // Open profile setup - opens drawer and scrolls to profile section
    window.openProfileSetup = function() {
      console.log('🔥 [openProfileSetup] Function called!');
      const walletAddress = localStorage.getItem('bearpark_wallet');
      console.log('🔥 [openProfileSetup] Wallet:', walletAddress);

      if (!walletAddress) {
        console.log('🔥 [openProfileSetup] No wallet, opening drawer');
        // Use the correct openDrawer function
        if (typeof openDrawer === 'function') {
          openDrawer();
        } else {
          // Fallback to direct DOM manipulation
          const drawer = document.getElementById('buyDrawer');
          if (drawer) {
            drawer.style.display = 'flex';
            setTimeout(() => drawer.classList.add('visible'), 10);
          }
        }
        return;
      }

      console.log('🐻 Opening profile setup for new user...');
      // Use the correct openDrawer function
      if (typeof openDrawer === 'function') {
        openDrawer();
      } else {
        // Fallback to direct DOM manipulation
        const drawer = document.getElementById('buyDrawer');
        if (drawer) {
          drawer.style.display = 'flex';
          setTimeout(() => drawer.classList.add('visible'), 10);
        }
      }

      // Wait for drawer to open and PNL content to load, then scroll to profile section
      setTimeout(() => {
        const profileSection = document.getElementById('profileSection');
        const drawer = document.getElementById('buyDrawer');
        const drawerBody = drawer ? drawer.querySelector('.drawer-body') : null;

        console.log('🐻 Drawer opened, scrolling to profile section...', { profileSection, drawerBody });

        if (profileSection && drawerBody) {
          drawerBody.scrollTo({
            top: profileSection.offsetTop - 20,
            behavior: 'smooth'
          });

          // Add pulsing highlight effect to make it obvious
          profileSection.classList.add('profile-highlight-pulse');

          // Remove highlight after 5 seconds
          setTimeout(() => {
            profileSection.classList.remove('profile-highlight-pulse');
          }, 5000);

          console.log('✅ Profile section highlighted and scrolled into view!');
        } else {
          console.error('❌ Could not find profileSection or drawerBody elements!', { profileSection, drawerBody });
        }
      }, 1500);
    };

    // Update welcome button with points and username
    async function updateWelcomeButton() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      const welcomePoints = document.getElementById('welcomePoints');
      const welcomeUsername = document.getElementById('welcomeUsername');
      const navHoneyPoints = document.getElementById('navHoneyPoints');

      if (!walletAddress) {
        welcomePoints.textContent = '0.0';
        welcomeUsername.textContent = 'WELCOME BEAR (click me!)';
        if (navHoneyPoints) navHoneyPoints.textContent = '0.0 PTS';
        return;
      }

      // Load points from localStorage first (instant)
      const pointsKey = `honey_points_${walletAddress}`;
      const localPoints = JSON.parse(localStorage.getItem(pointsKey) || '{"total":0,"raiding":0,"games":0}');
      welcomePoints.textContent = localPoints.total.toFixed(1);
      if (navHoneyPoints) navHoneyPoints.textContent = `${localPoints.total.toFixed(1)} PTS`;

      // Load username from localStorage
      const profileKey = `bear_profile_${walletAddress}`;
      const localProfile = JSON.parse(localStorage.getItem(profileKey) || '{}');

      if (localProfile.display_name) {
        welcomeUsername.textContent = `WELCOME ${localProfile.display_name.toUpperCase()}`;
      } else {
        welcomeUsername.textContent = 'WELCOME BEAR (click me!)';
      }

      // Update avatar if available, or show default bear avatar
      const welcomeAvatar = document.getElementById('welcomeAvatar');
      if (localProfile.avatar_url) {
        welcomeAvatar.src = localProfile.avatar_url;
        welcomeAvatar.style.display = 'block';
        welcomeAvatar.onerror = function() {
          this.src = 'https://files.catbox.moe/ugu1kl.png';
        };
      } else {
        // Show default bear avatar if no avatar is set
        welcomeAvatar.src = 'https://files.catbox.moe/ugu1kl.png';
        welcomeAvatar.style.display = 'block';
      }

      // Try to sync with backend (optional)
      try {
        const pointsResponse = await fetch(`${API_BASE_URL}/api/points/${walletAddress}`);
        if (pointsResponse.ok) {
          const pointsData = await pointsResponse.json();
          const totalPoints = pointsData.total_points || 0;
          const raidingPoints = pointsData.raiding_points || 0;
          const gamesPoints = pointsData.games_points || 0;

          welcomePoints.textContent = totalPoints.toFixed(1);
          if (navHoneyPoints) navHoneyPoints.textContent = `${totalPoints.toFixed(1)} PTS`;

          // Update honey points section if it exists
          const totalEl = document.getElementById('totalHoneyPoints');
          const raidingEl = document.getElementById('raidingPoints');
          const gamesEl = document.getElementById('gamesPoints');
          if (totalEl) totalEl.textContent = totalPoints.toFixed(1);
          if (raidingEl) raidingEl.textContent = raidingPoints.toFixed(1) + ' PTS';
          if (gamesEl) gamesEl.textContent = gamesPoints.toFixed(1) + ' PTS';

          // Sync localStorage with backend data
          localStorage.setItem(pointsKey, JSON.stringify({
            total: totalPoints,
            raiding: raidingPoints,
            games: gamesPoints
          }));
        }
      } catch (error) {
        console.log('[Welcome] Backend not available - using local points');
      }

      // Try to load profile from backend
      try {
        const profileResponse = await fetch(`${API_BASE_URL}/api/profile/${walletAddress}`);
        if (profileResponse.ok) {
          const profileData = await profileResponse.json();
          if (profileData.success && profileData.profile) {
            const profile = profileData.profile;

            // Update username from backend
            if (profile.display_name) {
              welcomeUsername.textContent = `WELCOME ${profile.display_name.toUpperCase()}`;
              // Save to localStorage
              localProfile.display_name = profile.display_name;
              localStorage.setItem(profileKey, JSON.stringify(localProfile));
            }

            // Update avatar from backend
            if (profile.avatar_nft) {
              try {
                const avatarData = JSON.parse(profile.avatar_nft);
                if (avatarData.imageUrl) {
                  welcomeAvatar.src = avatarData.imageUrl;
                  welcomeAvatar.style.display = 'block';
                  localProfile.avatar_url = avatarData.imageUrl;
                  localStorage.setItem(profileKey, JSON.stringify(localProfile));

                  welcomeAvatar.onerror = function() {
                    if (avatarData.fallbackImageUrl && this.src !== avatarData.fallbackImageUrl) {
                      this.src = avatarData.fallbackImageUrl;
                    } else {
                      this.src = 'https://files.catbox.moe/ugu1kl.png';
                    }
                  };
                }
              } catch (e) {
                console.log('[Welcome] Could not parse avatar data');
              }
            }
          }
        }
      } catch (error) {
        console.log('[Welcome] Backend not available - using local profile');
      }
    }

    // Update welcome button when profile is loaded
    updateWelcomeButton();

    // Refresh welcome button when wallet connects
    window.addEventListener('storage', (e) => {
      if (e.key === 'bearpark_wallet') {
        updateWelcomeButton();
      }
    });

    // ===== LEADERBOARDS =====
    async function loadLeaderboards() {
      const games = [
        { id: 'flappy-bear', elementId: 'leaderboard-flappy' },
        { id: 'bear-slice', elementId: 'leaderboard-slice' },
        { id: 'bear-jumpventure', elementId: 'leaderboard-jumpventure' },
        { id: 'bear-pong', elementId: 'leaderboard-pong' }
      ];

      for (const game of games) {
        try {
          const response = await fetch(`${API_BASE_URL}/api/leaderboard/${game.id}?limit=100`);
          const data = await response.json();

          const container = document.getElementById(game.elementId);
          if (!container) continue;

          if (data.success && data.leaderboard && data.leaderboard.length > 0) {
            container.innerHTML = data.leaderboard.map((entry, index) => {
              const medal = index === 0 ? '🥇' : (index === 1 ? '🥈' : (index === 2 ? '🥉' : ''));
              const rankClass = index === 0 ? 'rank-1' : (index === 1 ? 'rank-2' : (index === 2 ? 'rank-3' : ''));
              const displayName = entry.display_name || 'Anonymous';

              // Show avatar if available, or default bear avatar
              let avatarHTML = '';
              if (entry.avatar_nft) {
                try {
                  const avatarData = JSON.parse(entry.avatar_nft);
                  const avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl;
                  if (avatarUrl) {
                    avatarHTML = `<img src="${avatarUrl}"
                         style="width:40px; height:40px; border-radius:50%; object-fit:cover; margin-right:8px;"
                         alt="${displayName} avatar"
                         onerror="this.src='https://files.catbox.moe/ugu1kl.png'">`;
                  }
                } catch (e) {
                  // If not JSON, try using it directly as NFT ID
                  avatarHTML = `<img src="https://nft.xrpl-labs.com/${entry.avatar_nft}"
                       style="width:40px; height:40px; border-radius:50%; object-fit:cover; margin-right:8px;"
                       alt="${displayName} avatar"
                       onerror="this.src='https://files.catbox.moe/ugu1kl.png'">`;
                }
              }

              // If no avatar_nft, show default bear avatar
              if (!avatarHTML) {
                avatarHTML = `<img src="https://files.catbox.moe/ugu1kl.png"
                     style="width:40px; height:40px; border-radius:50%; object-fit:cover; margin-right:8px;"
                     alt="${displayName} avatar">`;
              }

              // For BEAR PONG, show weighted score + W/L stats
              let scoreDisplay;
              if (game.id === 'bear-pong') {
                const wins = entry.wins || entry.score || 0;
                const losses = entry.losses || 0;
                const weightedScore = entry.weighted_score || entry.score || 0;
                const winRate = entry.win_rate ? (entry.win_rate * 100).toFixed(0) : '0';

                scoreDisplay = `
                  <div style="text-align:right;">
                    <div style="font-size:16px; font-weight:700; color:var(--gold);">${weightedScore}</div>
                    <div style="font-size:12px; color:#888; margin-top:2px;">${wins}W ${losses}L (${winRate}%)</div>
                  </div>
                `;
              } else {
                scoreDisplay = `${entry.score.toLocaleString()}`;
              }

              return `
                <div class="leaderboard-entry ${rankClass}" onclick="openProfileModal('${entry.wallet_address}')" style="cursor:pointer;">
                  <div class="leaderboard-rank">${medal || `#${index + 1}`}</div>
                  <div class="leaderboard-name" style="display:flex; align-items:center;">
                    ${avatarHTML}
                    <div>
                      ${displayName}
                      ${entry.wallet_address ? `<div class="leaderboard-wallet">${entry.wallet_address.substring(0, 8)}...</div>` : ''}
                    </div>
                  </div>
                  <div class="leaderboard-score">${scoreDisplay}</div>
                </div>
              `;
            }).join('');
          } else {
            container.innerHTML = '<div class="loading">No scores yet! Be the first!</div>';
          }
        } catch (error) {
          console.error(`Error loading ${game.id} leaderboard:`, error);
          const container = document.getElementById(game.elementId);
          if (container) {
            container.innerHTML = '<div class="loading">Unable to load scores</div>';
          }
        }
      }
    }

    // Load leaderboards on page load
    loadLeaderboards();

    // Refresh leaderboards every 30 seconds
    IntervalManager.set('loadLeaderboards', loadLeaderboards, 30000); // Use IntervalManager to prevent memory leaks

    // ===== COMMUNITY BANNER PARALLAX =====
    (function initCommunityParallax() {
      const banner = document.getElementById('communityBanner');
      const bg = document.getElementById('communityBannerBg');

      if (!banner || !bg) return;

      let mouseX = 0;
      let mouseY = 0;
      let currentX = 0;
      let currentY = 0;

      // Mouse parallax
      banner.addEventListener('mousemove', (e) => {
        const rect = banner.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        // Calculate offset from center (-1 to 1)
        mouseX = (e.clientX - centerX) / (rect.width / 2);
        mouseY = (e.clientY - centerY) / (rect.height / 2);
      });

      banner.addEventListener('mouseleave', () => {
        mouseX = 0;
        mouseY = 0;
      });

      // Touch parallax
      let touchActive = false;
      banner.addEventListener('touchmove', (e) => {
        touchActive = true;
        const rect = banner.getBoundingClientRect();
        const touch = e.touches[0];
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        mouseX = (touch.clientX - centerX) / (rect.width / 2);
        mouseY = (touch.clientY - centerY) / (rect.height / 2);
      });

      banner.addEventListener('touchend', () => {
        touchActive = false;
        mouseX = 0;
        mouseY = 0;
      });

      // Smooth animation loop
      function animate() {
        // Smoothly interpolate towards target
        currentX += (mouseX - currentX) * 0.05;
        currentY += (mouseY - currentY) * 0.05;

        // Apply parallax transform (subtle movement)
        const offsetX = currentX * 20; // Max 20px movement
        const offsetY = currentY * 15; // Max 15px movement

        // Maintain center positioning with parallax offset
        bg.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px))`;

        requestAnimationFrame(animate);
      }

      animate();
    })();

    // ===== BEAR COMMUNITY =====
    let allCommunityUsers = [];

    async function loadCommunityUsers() {
      const communityUserGrid = document.getElementById('communityUserGrid');
      const communityUserCount = document.getElementById('communityUserCount');

      try {
        const response = await fetch(`${API_BASE_URL}/api/users`);
        if (response.ok) {
          const data = await response.json();
          if (data.success && data.users) {
            // Sort users alphabetically by display_name
            allCommunityUsers = data.users.sort((a, b) => {
              const nameA = (a.display_name || 'Anonymous BEAR').toLowerCase();
              const nameB = (b.display_name || 'Anonymous BEAR').toLowerCase();
              return nameA.localeCompare(nameB);
            });

            communityUserCount.textContent = allCommunityUsers.length;
            renderCommunityUsers(allCommunityUsers);
          }
        }
      } catch (error) {
        console.error('Error loading community users:', error);
        communityUserGrid.innerHTML = `
          <div class="community-empty">
            <div class="community-empty-icon">😔</div>
            <p>Failed to load community. Please try again later.</p>
          </div>
        `;
      }
    }

    async function renderCommunityUsers(users) {
      const communityUserGrid = document.getElementById('communityUserGrid');
      const currentWallet = localStorage.getItem('bearpark_wallet');

      if (users.length === 0) {
        communityUserGrid.innerHTML = `
          <div class="community-empty">
            <div class="community-empty-icon">🐻</div>
            <p>No BEARs found matching your search.</p>
          </div>
        `;
        return;
      }

      // Fetch follower counts and follow status for each user
      const usersWithCounts = await Promise.all(users.map(async (user) => {
        try {
          // Get follower/following counts
          const countsResponse = await fetch(`${API_BASE_URL}/api/follow/counts/${user.wallet_address}`);
          let followers = 0, following = 0;
          if (countsResponse.ok) {
            const countsData = await countsResponse.json();
            followers = countsData.success ? countsData.followers : 0;
            following = countsData.success ? countsData.following : 0;
          }

          // Get follow status (are we following this user?)
          let isFollowing = false;
          if (currentWallet && currentWallet !== user.wallet_address) {
            const statusResponse = await fetch(`${API_BASE_URL}/api/follow/status?follower_wallet=${currentWallet}&following_wallet=${user.wallet_address}`);
            if (statusResponse.ok) {
              const statusData = await statusResponse.json();
              isFollowing = statusData.success ? statusData.isFollowing : false;
            }
          }

          return { ...user, followers, following, isFollowing };
        } catch (error) {
          console.error('Error fetching data for user:', error);
          return { ...user, followers: 0, following: 0, isFollowing: false };
        }
      }));

      const userCards = usersWithCounts.map(user => {
        const displayName = user.display_name || 'Anonymous BEAR';
        const walletShort = `${user.wallet_address.substring(0, 6)}...${user.wallet_address.substring(user.wallet_address.length - 4)}`;
        const isSelf = currentWallet === user.wallet_address;

        let avatarHTML = '';
        if (user.avatar_nft) {
          try {
            const avatarData = JSON.parse(user.avatar_nft);
            const avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl;
            avatarHTML = `<img src="${avatarUrl}" class="community-user-avatar" alt="${displayName}" onerror="this.src='https://files.catbox.moe/ugu1kl.png'">`;
          } catch (e) {
            avatarHTML = `<img src="https://files.catbox.moe/ugu1kl.png" class="community-user-avatar" alt="${displayName}">`;
          }
        } else {
          avatarHTML = `<img src="https://files.catbox.moe/ugu1kl.png" class="community-user-avatar" alt="${displayName}">`;
        }

        // Follow button (only show if not viewing own profile and user is logged in)
        let followButtonHTML = '';
        if (!isSelf && currentWallet) {
          const buttonClass = user.isFollowing ? 'community-follow-btn following' : 'community-follow-btn';
          const buttonText = user.isFollowing ? 'Following' : 'Follow';
          followButtonHTML = `<button class="${buttonClass}" data-wallet="${user.wallet_address}" onclick="event.stopPropagation(); toggleCommunityFollow('${user.wallet_address}')">${buttonText}</button>`;
        }

        return `
          <div class="community-user-card" onclick="viewUserProfileFromCommunity('${user.wallet_address}')">
            <div class="community-user-avatar-wrapper">
              ${avatarHTML}
            </div>
            <div class="community-user-info">
              <div class="community-user-name-section">
                <h3 class="community-user-name">${displayName}</h3>
                <p class="community-user-wallet">${walletShort}</p>
              </div>
              <div class="community-user-stats">
                <div class="community-user-stat">
                  <div class="community-user-stat-value" data-wallet="${user.wallet_address}" data-type="followers">${user.followers}</div>
                  <div class="community-user-stat-label">Followers</div>
                </div>
                <div class="community-user-stat">
                  <div class="community-user-stat-value" data-wallet="${user.wallet_address}" data-type="following">${user.following}</div>
                  <div class="community-user-stat-label">Following</div>
                </div>
              </div>
              ${followButtonHTML}
            </div>
          </div>
        `;
      }).join('');

      communityUserGrid.innerHTML = userCards;
    }

    // Toggle follow/unfollow in community view
    let isTogglingCommunityFollow = false; // Guard against multiple simultaneous clicks

    window.toggleCommunityFollow = async function(targetWallet) {
      console.log('🔵 [Community Follow] toggleCommunityFollow called for:', targetWallet);

      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        console.log('❌ [Community Follow] No wallet connected');
        alert('Please connect your wallet first!');
        return;
      }

      // Prevent multiple simultaneous operations
      if (isTogglingCommunityFollow) {
        console.log('⏸️ [Community Follow] Already processing a follow/unfollow action');
        return;
      }

      isTogglingCommunityFollow = true;
      console.log('🔵 [Community Follow] Starting follow toggle operation');

      try {
        const response = await fetch(`${API_BASE_URL}/api/follow`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            follower_wallet: currentWallet,
            following_wallet: targetWallet
          })
        });

        console.log('🔵 [Community Follow] Response status:', response.status);

        if (response.ok) {
          const data = await response.json();
          console.log('🔵 [Community Follow] Response data:', data);
          const action = data.action; // 'followed' or 'unfollowed'
          console.log('🔵 [Community Follow] Action:', action);

          // Update the follow button
          const btn = document.querySelector(`.community-follow-btn[data-wallet="${targetWallet}"]`);
          console.log('🔵 [Community Follow] Found button:', btn);
          if (btn) {
            console.log('🔵 [Community Follow] Button classes before:', btn.classList.toString());
            if (action === 'followed') {
              btn.classList.add('following');
              btn.textContent = 'Following';
              console.log('✅ [Community Follow] Updated button to: Following');
            } else {
              btn.classList.remove('following');
              btn.textContent = 'Follow';
              console.log('✅ [Community Follow] Updated button to: Follow');
            }
            console.log('🔵 [Community Follow] Button classes after:', btn.classList.toString());
          } else {
            console.error('❌ [Community Follow] Button not found for wallet:', targetWallet);
          }

          // Update the follower count for the target user
          const followerCountEl = document.querySelector(`.community-user-stat-value[data-wallet="${targetWallet}"][data-type="followers"]`);
          if (followerCountEl) {
            let currentCount = parseInt(followerCountEl.textContent) || 0;
            if (action === 'followed') {
              followerCountEl.textContent = currentCount + 1;
            } else {
              followerCountEl.textContent = Math.max(0, currentCount - 1);
            }
          }

          // Update the following count for the current user (if their card is visible)
          const followingCountEl = document.querySelector(`.community-user-stat-value[data-wallet="${currentWallet}"][data-type="following"]`);
          if (followingCountEl) {
            let currentCount = parseInt(followingCountEl.textContent) || 0;
            if (action === 'followed') {
              followingCountEl.textContent = currentCount + 1;
            } else {
              followingCountEl.textContent = Math.max(0, currentCount - 1);
            }
          }

          // SYNC: Also update the profile modal follow button if it's open for this user
          console.log('🔵 [Community Follow Sync] Checking profile modal sync...');
          console.log('🔵 [Community Follow Sync] window.currentProfileWallet:', window.currentProfileWallet);
          console.log('🔵 [Community Follow Sync] targetWallet:', targetWallet);

          const profileFollowBtn = document.getElementById('followBtn');
          console.log('🔵 [Community Follow Sync] Found profile follow button:', !!profileFollowBtn);

          if (profileFollowBtn && window.currentProfileWallet === targetWallet) {
            console.log('🔵 [Community Follow Sync] Wallets match! Syncing profile modal...');
            console.log('🔵 [Community Follow Sync] Button classes before:', profileFollowBtn.className);
            console.log('🔵 [Community Follow Sync] Button text before:', profileFollowBtn.querySelector('.follow-btn-text')?.textContent);

            if (action === 'followed') {
              profileFollowBtn.classList.add('following');
              profileFollowBtn.querySelector('.follow-btn-text').textContent = 'Following';
              profileFollowBtn.querySelector('.follow-btn-icon').textContent = '✓';
              console.log('✅ [Community Follow Sync] Set profile button to: Following');
            } else {
              profileFollowBtn.classList.remove('following');
              profileFollowBtn.querySelector('.follow-btn-text').textContent = 'Follow';
              profileFollowBtn.querySelector('.follow-btn-icon').textContent = '+';
              console.log('✅ [Community Follow Sync] Set profile button to: Follow');
            }

            // Mark that we just synced, so loadFollowData doesn't overwrite this
            lastFollowSyncTimestamp = Date.now();
            console.log('🔵 [Community Follow Sync] Set lastFollowSyncTimestamp to prevent database overwrite');

            console.log('🔵 [Community Follow Sync] Button classes after:', profileFollowBtn.className);
            console.log('🔵 [Community Follow Sync] Button text after:', profileFollowBtn.querySelector('.follow-btn-text')?.textContent);

            // Also update the profile modal follower count
            const profileFollowersCount = document.getElementById('followersCount');
            console.log('🔵 [Community Follow Sync] Looking for followersCount element:', !!profileFollowersCount);
            if (profileFollowersCount) {
              let currentCount = parseInt(profileFollowersCount.textContent) || 0;
              console.log('🔵 [Community Follow Sync] Current count:', currentCount, 'Action:', action);
              if (action === 'followed') {
                profileFollowersCount.textContent = currentCount + 1;
              } else {
                profileFollowersCount.textContent = Math.max(0, currentCount - 1);
              }
              console.log('✅ [Community Follow Sync] Updated follower count to:', profileFollowersCount.textContent);
              // Add animation for visual feedback
              profileFollowersCount.style.transform = action === 'followed' ? 'scale(1.3)' : 'scale(0.9)';
              profileFollowersCount.style.color = action === 'followed' ? 'var(--gold)' : '';
              setTimeout(() => {
                profileFollowersCount.style.transform = '';
                profileFollowersCount.style.color = '';
              }, 300);
            } else {
              console.log('⚠️ [Community Follow Sync] followersCount element not found - profile modal may not be open');
            }
          } else {
            console.log('⏸️ [Community Follow Sync] Not syncing - profile modal not open for this user or button not found');
          }
          console.log('✅ [Community Follow] Profile modal sync completed');
        } else {
          console.error('❌ [Community Follow] Response not OK:', response.status, response.statusText);
          alert('Failed to update follow status. Please try again.');
        }
      } catch (error) {
        console.error('❌ [Community Follow] Error toggling follow:', error);
        alert('Failed to update follow status. Please try again.');
      } finally {
        isTogglingCommunityFollow = false;
        console.log('🔵 [Community Follow] Operation complete, unlocked');
      }
    };

    // Search functionality
    const communitySearchInput = document.getElementById('communitySearchInput');
    if (communitySearchInput) {
      communitySearchInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase().trim();

        if (searchTerm === '') {
          renderCommunityUsers(allCommunityUsers);
        } else {
          const filtered = allCommunityUsers.filter(user => {
            const displayName = (user.display_name || 'Anonymous BEAR').toLowerCase();
            const walletAddress = user.wallet_address.toLowerCase();
            return displayName.includes(searchTerm) || walletAddress.includes(searchTerm);
          });
          renderCommunityUsers(filtered);
        }
      });
    }

    // Function to view user profile from community (opens profile modal)
    window.viewUserProfileFromCommunity = function(wallet) {
      // Open the profile modal with the user's wallet
      if (typeof openProfileModal === 'function') {
        openProfileModal(wallet);
      } else if (typeof window.openProfileModal === 'function') {
        window.openProfileModal(wallet);
      }
    };

    // Load community users on page load
    loadCommunityUsers();

  })();
  </script>

  <!-- Emergency FAB Button Fix -->
  <script>
  (function() {
    // Check if FAB already exists
    if (document.querySelector('.fab-buy')) return;

    console.log('Creating emergency FAB button...');

    // Create FAB button
    const fab = document.createElement('button');
    fab.className = 'fab-buy';
    fab.innerHTML = '<span class="txt">BEAR HUB</span>';
    fab.setAttribute('aria-controls', 'buyDrawer');
    fab.setAttribute('aria-expanded', 'false');
    fab.setAttribute('aria-label', 'Open BEAR HUB panel');
    document.body.appendChild(fab);

    // Create scrim
    const scrim = document.createElement('div');
    scrim.className = 'drawer-scrim';
    scrim.hidden = true;
    document.body.appendChild(scrim);

    const drawer = document.getElementById('buyDrawer');
    const closeBtn = drawer ? drawer.querySelector('[data-close-drawer]') : null;

    if (!drawer) {
      console.error('buyDrawer not found!');
      return;
    }

    function openDrawer() {
      drawer.classList.add('open');
      scrim.hidden = false;
      fab.setAttribute('aria-expanded', 'true');
      drawer.setAttribute('aria-hidden', 'false');
      document.body.style.overflow = 'hidden';
    }

    function closeDrawer() {
      drawer.classList.remove('open');
      scrim.hidden = true;
      fab.setAttribute('aria-expanded', 'false');
      drawer.setAttribute('aria-hidden', 'true');
      document.body.style.overflow = '';
    }

    fab.addEventListener('click', openDrawer);
    if (closeBtn) closeBtn.addEventListener('click', closeDrawer);
    scrim.addEventListener('click', closeDrawer);

    console.log('Emergency FAB button created successfully!');
  })();

  // ===== PROFILE MODAL SYSTEM =====
  (function initProfileModal() {
    const profileModal = document.getElementById('profileModal');
    const profilePictureDisplay = document.getElementById('profilePictureDisplay');
    const profilePicturePlaceholder = document.getElementById('profilePicturePlaceholder');
    const profileDisplayName = document.getElementById('profileDisplayName');
    const profileWalletAddress = document.getElementById('profileWalletAddress');
    const bioDisplay = document.getElementById('bioDisplay');
    const bioEditor = document.getElementById('bioEditor');
    const bioTextarea = document.getElementById('bioTextarea');
    const editBioBtn = document.getElementById('editBioBtn');
    const saveBioBtn = document.getElementById('saveBioBtn');
    const cancelBioBtn = document.getElementById('cancelBioBtn');
    const commentsList = document.getElementById('commentsList');
    const commentTextarea = document.getElementById('commentTextarea');
    const postCommentBtn = document.getElementById('postCommentBtn');
    const commentsCount = document.getElementById('commentsCount');
    const bearSearchPanel = document.getElementById('bearSearchPanel');
    const bearSearchInput = document.getElementById('bearSearchInput');
    const bearSearchResults = document.getElementById('bearSearchResults');
    const profileModalTitle = document.getElementById('profileModalTitle');
    const profileModalBody = document.querySelector('.profile-modal-body');

    window.currentProfileWallet = null; // Make it global so community follow can access it
    let currentUserWallet = null;
    let allUsers = [];
    let isSearchMode = false;
    let profileNavigationHistory = []; // Track navigation history for back button
    let lastFollowSyncTimestamp = 0; // Track when we last manually synced the follow button

    // Open Profile Modal
    window.openProfileModal = async function(walletAddress = null, addToHistory = true, options = {}) {
      currentUserWallet = localStorage.getItem('bearpark_wallet');
      if (!currentUserWallet) {
        alert('Please connect your wallet first!');
        return;
      }

      // Add current profile to history before navigating (if there is one and we're adding to history)
      if (addToHistory && window.currentProfileWallet && window.currentProfileWallet !== walletAddress) {
        profileNavigationHistory.push(window.currentProfileWallet);
        updateBackButton();
      }

      // If a wallet address is provided, view that profile; otherwise view own profile
      window.currentProfileWallet = walletAddress || currentUserWallet;
      profileModal.style.display = 'flex';
      setTimeout(() => profileModal.classList.add('visible'), 10);

      // Scroll to top of profile modal (unless we're scrolling to a specific comment)
      if (profileModalBody && !options.scrollToCommentId) {
        profileModalBody.scrollTop = 0;
      }

      await loadProfileData();
      await loadComments();
      await loadProfileNFTs();

      // Update back button visibility
      updateBackButton();

      // If a specific comment should be scrolled to, do it after everything loads
      if (options.scrollToCommentId) {
        scrollToComment(options.scrollToCommentId);
      }
    };

    // Close Profile Modal
    window.closeProfileModal = function() {
      profileModal.classList.remove('visible');
      setTimeout(() => {
        profileModal.style.display = 'none';
        // Reset to profile view when closing
        if (isSearchMode) {
          toggleBearSearch();
        }
        // Clear navigation history
        profileNavigationHistory = [];
        updateBackButton();
      }, 300);
    };

    // Scroll to a specific comment
    function scrollToComment(commentId) {
      console.log('📍 Attempting to scroll to comment:', commentId);
      // Give a small delay to ensure DOM is fully rendered
      setTimeout(() => {
        const commentElement = document.querySelector(`.comment-thread[data-comment-id="${commentId}"]`);
        console.log('📍 Comment element found:', !!commentElement);
        if (commentElement) {
          // Scroll the profile modal body to the comment
          const modalBody = document.querySelector('.profile-modal-body');
          console.log('📍 Modal body found:', !!modalBody);
          if (modalBody) {
            // Calculate position relative to modal body
            const commentPosition = commentElement.offsetTop;
            console.log('📍 Scrolling to position:', commentPosition);
            modalBody.scrollTo({
              top: commentPosition - 100, // Offset for better visibility
              behavior: 'smooth'
            });
          }

          // Add gold glow highlight effect (same as bulletin board)
          commentElement.style.backgroundColor = 'rgba(237, 183, 35, 0.3)';
          commentElement.style.boxShadow = '0 0 20px rgba(237, 183, 35, 0.5)';
          commentElement.style.transition = 'all 0.3s ease';
          setTimeout(() => {
            commentElement.style.backgroundColor = '';
            commentElement.style.boxShadow = '';
          }, 2500);
        } else {
          console.warn('❌ Comment not found:', commentId);
          // Log all comment IDs to help debug
          const allComments = document.querySelectorAll('.comment-thread[data-comment-id]');
          console.log('Available comment IDs:', Array.from(allComments).map(c => c.getAttribute('data-comment-id')));
        }
      }, 300);
    }

    // Go Back in Profile Navigation
    window.goBackInProfile = function() {
      if (profileNavigationHistory.length > 0) {
        const previousWallet = profileNavigationHistory.pop();
        // Open previous profile without adding to history
        openProfileModal(previousWallet, false);
      }
    };

    // Update Back Button Visibility
    function updateBackButton() {
      const backBtn = document.getElementById('profileBackBtn');
      if (backBtn) {
        if (profileNavigationHistory.length > 0) {
          backBtn.style.display = 'flex';
        } else {
          backBtn.style.display = 'none';
        }
      }
    }

    // Edit profile from modal - close modal and open BEAR HUB to profile section
    window.editProfileFromModal = function() {
      console.log('🎨 Edit profile button clicked!');

      // Close the profile modal
      closeProfileModal();

      // Wait for modal to close, then open profile setup
      setTimeout(() => {
        if (typeof window.openProfileSetup === 'function') {
          console.log('🎨 Opening profile setup...');
          window.openProfileSetup();
        } else {
          console.error('❌ openProfileSetup function not found');
        }
      }, 350);
    };

    // Toggle BEAR Search
    window.toggleBearSearch = async function() {
      isSearchMode = !isSearchMode;

      if (isSearchMode) {
        // Switch to search mode
        profileModalTitle.textContent = 'BEAR SEARCH';
        profileModalBody.style.display = 'none';
        bearSearchPanel.style.display = 'block';
        bearSearchInput.value = '';

        // Load all users
        await loadAllUsers();
        renderUserList(allUsers);
      } else {
        // Switch back to profile mode - restore proper title
        const currentDisplayName = profileDisplayName.textContent;
        if (window.currentProfileWallet === currentUserWallet) {
          profileModalTitle.textContent = 'MY PROFILE';
        } else {
          profileModalTitle.textContent = `${currentDisplayName.toUpperCase()}'S PROFILE`;
        }
        profileModalBody.style.display = 'block';
        bearSearchPanel.style.display = 'none';
      }
    };

    // Load All Users
    async function loadAllUsers() {
      try {
        const response = await fetch(`${API_BASE_URL}/api/users`);
        if (!response.ok) throw new Error('Failed to load users');

        const data = await response.json();
        allUsers = data.users || [];
      } catch (error) {
        console.error('Error loading users:', error);
        allUsers = [];
      }
    }

    // Render User List
    function renderUserList(users) {
      if (users.length === 0) {
        bearSearchResults.innerHTML = `
          <div class="bear-search-empty">
            <div class="bear-search-empty-icon">🐻</div>
            <p>No BEARs found in the park yet!</p>
          </div>
        `;
        return;
      }

      const userCards = users.map(user => {
        const displayName = user.display_name || 'Anonymous BEAR';
        const friendCount = 0; // Placeholder for now

        let avatarHTML = '';
        if (user.avatar_nft) {
          try {
            const avatarData = JSON.parse(user.avatar_nft);
            const avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl;
            avatarHTML = `<img src="${avatarUrl}" class="bear-user-avatar" alt="${displayName}" onerror="this.src='https://files.catbox.moe/ugu1kl.png'">`;
          } catch (e) {
            avatarHTML = `<img src="https://files.catbox.moe/ugu1kl.png" class="bear-user-avatar" alt="${displayName}">`;
          }
        } else {
          avatarHTML = `<img src="https://files.catbox.moe/ugu1kl.png" class="bear-user-avatar" alt="${displayName}">`;
        }

        return `
          <div class="bear-user-card" onclick="viewUserProfile('${user.wallet_address}')">
            <div class="bear-user-avatar-container">
              <div class="bear-user-avatar-border"></div>
              ${avatarHTML}
            </div>
            <div class="bear-user-info">
              <h3 class="bear-user-name">${displayName}</h3>
              <p class="bear-user-friends">${friendCount} BEARfriends</p>
            </div>
          </div>
        `;
      }).join('');

      bearSearchResults.innerHTML = userCards;
    }

    // View User Profile from Search
    window.viewUserProfile = async function(walletAddress) {
      // Switch back to profile mode and load the selected user's profile
      isSearchMode = false;
      profileModalBody.style.display = 'block';
      bearSearchPanel.style.display = 'none';

      // Load the selected user's profile (title will be set by loadProfileData)
      window.currentProfileWallet = walletAddress;
      await loadProfileData();
      await loadComments();
      await loadProfileNFTs();
    };

    // Search Input Handler
    bearSearchInput.addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase().trim();

      if (!searchTerm) {
        renderUserList(allUsers);
        return;
      }

      const filteredUsers = allUsers.filter(user => {
        const displayName = (user.display_name || '').toLowerCase();
        const wallet = (user.wallet_address || '').toLowerCase();
        return displayName.includes(searchTerm) || wallet.includes(searchTerm);
      });

      renderUserList(filteredUsers);
    });

    // Load Profile Data
    async function loadProfileData() {
      try {
        const profileKey = `bearpark_profile_${window.currentProfileWallet}`;
        const localProfile = localStorage.getItem(profileKey);
        let profileData = null;

        if (localProfile) {
          try {
            profileData = JSON.parse(localProfile);
          } catch (e) {
            console.error('Error parsing local profile:', e);
          }
        }

        try {
          const response = await fetch(`${API_BASE_URL}/api/profile/${window.currentProfileWallet}`);
          if (response.ok) {
            const data = await response.json();
            if (data.success && data.profile) {
              profileData = data.profile;
            }
          }
        } catch (error) {
          console.log('Backend not available, using local profile');
        }

        if (profileData) {
          const displayName = profileData.display_name || 'Anonymous BEAR';
          profileDisplayName.textContent = displayName;
          profileWalletAddress.textContent = window.currentProfileWallet;

          // Update modal title based on whose profile is being viewed
          if (window.currentProfileWallet === currentUserWallet) {
            profileModalTitle.textContent = 'MY PROFILE';
          } else {
            profileModalTitle.textContent = `${displayName.toUpperCase()}'S PROFILE`;
          }

          // Update NFT Collection header based on whose profile is being viewed
          const nftCollectionHeader = document.getElementById('nftCollectionHeader');
          if (nftCollectionHeader) {
            if (window.currentProfileWallet === currentUserWallet) {
              nftCollectionHeader.textContent = '🖼️ My NFT Collection';
            } else {
              nftCollectionHeader.textContent = `🖼️ ${displayName}'s NFT Collection`;
            }
          }

          let avatarUrl = profileData.avatar_url;

          if (!avatarUrl && profileData.avatar_nft) {
            try {
              const avatarData = JSON.parse(profileData.avatar_nft);
              avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl;
            } catch (e) {
              avatarUrl = `https://nft.xrpl-labs.com/${profileData.avatar_nft}`;
            }
          }

          // If no avatar set, use default bear avatar
          if (!avatarUrl) {
            avatarUrl = 'https://files.catbox.moe/ugu1kl.png';
          }

          profilePictureDisplay.src = avatarUrl;
          profilePictureDisplay.onerror = function() {
            this.src = 'https://files.catbox.moe/ugu1kl.png';
          };
          profilePictureDisplay.classList.add('loaded');
          profilePicturePlaceholder.style.display = 'none';

          if (profileData.bio) {
            bioDisplay.textContent = profileData.bio;
          } else {
            if (window.currentProfileWallet === currentUserWallet) {
              bioDisplay.textContent = 'No bio yet. Click Edit to add one!';
            } else {
              bioDisplay.textContent = 'No bio yet.';
            }
          }

          // Show/hide edit buttons based on ownership
          const editProfilePictureBtn = document.getElementById('editProfilePictureBtn');
          if (window.currentProfileWallet === currentUserWallet) {
            editBioBtn.style.display = 'block';
            if (editProfilePictureBtn) editProfilePictureBtn.style.display = 'flex';
          } else {
            editBioBtn.style.display = 'none';
            if (editProfilePictureBtn) editProfilePictureBtn.style.display = 'none';
          }
        } else {
          profileDisplayName.textContent = 'Anonymous BEAR';
          profileWalletAddress.textContent = window.currentProfileWallet;

          // Update modal title for anonymous profiles
          if (window.currentProfileWallet === currentUserWallet) {
            profileModalTitle.textContent = 'MY PROFILE';
          } else {
            profileModalTitle.textContent = 'ANONYMOUS BEAR\'S PROFILE';
          }

          // Update NFT Collection header for anonymous profiles
          const nftCollectionHeader = document.getElementById('nftCollectionHeader');
          if (nftCollectionHeader) {
            if (window.currentProfileWallet === currentUserWallet) {
              nftCollectionHeader.textContent = '🖼️ My NFT Collection';
            } else {
              nftCollectionHeader.textContent = '🖼️ Anonymous BEAR\'s NFT Collection';
            }
          }

          // Show/hide edit buttons based on ownership
          const editProfilePictureBtn = document.getElementById('editProfilePictureBtn');
          if (window.currentProfileWallet === currentUserWallet) {
            editBioBtn.style.display = 'block';
            if (editProfilePictureBtn) editProfilePictureBtn.style.display = 'flex';
          } else {
            editBioBtn.style.display = 'none';
            if (editProfilePictureBtn) editProfilePictureBtn.style.display = 'none';
          }
        }
      } catch (error) {
        console.error('Error loading profile:', error);
      }

      // Apply equipped cosmetics to profile
      await applyProfileCosmetics();

      // Load follow counts and button state
      await loadFollowData();
    }

    // Apply equipped cosmetics to the profile modal
    async function applyProfileCosmetics() {
      try {
        const walletAddress = window.currentProfileWallet;
        if (!walletAddress) return;

        console.log('🎨 Loading cosmetics for profile:', walletAddress);

        // Fetch equipped cosmetics
        const response = await fetch(`${API_BASE_URL}/api/cosmetics/equipped/${walletAddress}`);
        if (!response.ok) return;

        const data = await response.json();
        if (!data.success || !data.equipped) return;

        const equippedRing = data.equipped.ring;
        const equippedBanner = data.equipped.banner;

        // Apply banner if equipped
        if (equippedBanner && equippedBanner.css_gradient) {
          const section = document.getElementById('profilePictureSection');
          if (section) {
            // Ensure section allows overflow for ring
            section.style.overflow = 'visible';
            // Apply banner while preserving the gradient border
            section.style.backgroundImage = `${equippedBanner.css_gradient}, linear-gradient(135deg, #8b5cf6, #22c55e, #edb723, #8b5cf6)`;
            section.style.backgroundOrigin = 'padding-box, border-box';
            section.style.backgroundClip = 'padding-box, border-box';
            console.log('✅ Applied banner:', equippedBanner.name);
          }
        } else {
          // Reset to default if no banner
          const section = document.getElementById('profilePictureSection');
          if (section) {
            // Ensure section allows overflow for ring
            section.style.overflow = 'visible';
            section.style.backgroundImage = 'linear-gradient(#141619, #141619), linear-gradient(135deg, #8b5cf6, #22c55e, #edb723, #8b5cf6)';
            section.style.backgroundOrigin = 'padding-box, border-box';
            section.style.backgroundClip = 'padding-box, border-box';
          }
        }

        // Apply ring if equipped
        if (equippedRing && equippedRing.image_url) {
          const container = document.getElementById('profilePictureContainer');
          if (container) {
            // Ensure container allows ring to overflow
            container.style.overflow = 'visible';

            // Remove any existing ring
            const existingRing = container.querySelector('.profile-cosmetic-ring');
            if (existingRing) existingRing.remove();

            // Create ring element
            const ring = document.createElement('img');
            ring.className = `profile-cosmetic-ring ${equippedRing.ring_type}`;
            ring.src = equippedRing.image_url;
            ring.alt = equippedRing.name;
            ring.style.cssText = `
              position: absolute;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%) ${equippedRing.ring_type === 'ouroboros' ? 'rotate(180deg)' : ''};
              width: 240px !important;
              height: 240px !important;
              max-width: 240px !important;
              max-height: 240px !important;
              object-fit: contain;
              pointer-events: none;
              z-index: 1;
              ${equippedRing.rarity === 'bearableguy123' ? 'animation: spinRingImage 3s linear infinite;' : ''}
            `;

            container.appendChild(ring);
            console.log('✅ Applied ring:', equippedRing.name);
          }
        } else {
          // Remove ring if none equipped
          const container = document.getElementById('profilePictureContainer');
          if (container) {
            const existingRing = container.querySelector('.profile-cosmetic-ring');
            if (existingRing) existingRing.remove();
          }
        }

      } catch (error) {
        console.error('❌ Error applying profile cosmetics:', error);
      }
    }

    // Follow System Functions
    async function loadFollowData() {
      try {
        // Load follower/following counts
        const countsResponse = await fetch(`${API_BASE_URL}/api/follow/counts/${window.currentProfileWallet}`);
        if (countsResponse.ok) {
          const countsData = await countsResponse.json();
          if (countsData.success) {
            document.getElementById('followersCount').textContent = countsData.followers;
            document.getElementById('followingCount').textContent = countsData.following;
          }
        }

        // Show/hide follow button and check follow status
        const followBtn = document.getElementById('followBtn');
        if (window.currentProfileWallet === currentUserWallet) {
          // Don't show follow button on own profile
          followBtn.style.display = 'none';
        } else {
          followBtn.style.display = 'flex';

          // Check if we recently synced the button manually (within last 2 seconds)
          const timeSinceLastSync = Date.now() - lastFollowSyncTimestamp;
          if (timeSinceLastSync < 2000) {
            console.log(`⏸️ [LoadFollowData] Skipping database check - button was manually synced ${timeSinceLastSync}ms ago`);
            return;
          }

          // CHECK COMMUNITY LIST BUTTON FIRST - it's the source of truth!
          const communityBtn = document.querySelector(`.community-follow-btn[data-wallet="${window.currentProfileWallet}"]`);
          if (communityBtn) {
            const communityBtnIsFollowing = communityBtn.classList.contains('following');
            console.log('🔵 [LoadFollowData] Found community button:', communityBtnIsFollowing ? 'Following' : 'Follow');

            // Use community button state as source of truth
            if (communityBtnIsFollowing) {
              followBtn.classList.add('following');
              followBtn.querySelector('.follow-btn-text').textContent = 'Following';
              followBtn.querySelector('.follow-btn-icon').textContent = '✓';
              console.log('✅ [LoadFollowData] Synced from community button: Following');
            } else {
              followBtn.classList.remove('following');
              followBtn.querySelector('.follow-btn-text').textContent = 'Follow';
              followBtn.querySelector('.follow-btn-icon').textContent = '+';
              console.log('✅ [LoadFollowData] Synced from community button: Follow');
            }
            return; // Don't check database if community button exists
          }

          // Only check database if community button doesn't exist
          console.log('🔵 [LoadFollowData] No community button found, checking database for:', window.currentProfileWallet);
          const statusResponse = await fetch(
            `${API_BASE_URL}/api/follow/status?follower_wallet=${currentUserWallet}&following_wallet=${window.currentProfileWallet}`
          );
          console.log('🔵 [LoadFollowData] Status response:', statusResponse.status);
          if (statusResponse.ok) {
            const statusData = await statusResponse.json();
            console.log('🔵 [LoadFollowData] Status data:', statusData);
            console.log('🔵 [LoadFollowData] isFollowing:', statusData.isFollowing);
            if (statusData.success && statusData.isFollowing) {
              followBtn.classList.add('following');
              followBtn.querySelector('.follow-btn-text').textContent = 'Following';
              followBtn.querySelector('.follow-btn-icon').textContent = '✓';
              console.log('✅ [LoadFollowData] Set button to: Following');
            } else {
              followBtn.classList.remove('following');
              followBtn.querySelector('.follow-btn-text').textContent = 'Follow';
              followBtn.querySelector('.follow-btn-icon').textContent = '+';
              console.log('✅ [LoadFollowData] Set button to: Follow');
            }
          }
        }
      } catch (error) {
        console.error('Error loading follow data:', error);
      }
    }

    // Make follow functions global
    let isTogglingFollow = false; // Guard against multiple simultaneous clicks

    window.toggleFollow = async function() {
      console.log('🔵 [Follow] toggleFollow called');
      console.log('🔵 [Follow] currentUserWallet:', currentUserWallet);
      console.log('🔵 [Follow] window.currentProfileWallet:', window.currentProfileWallet);

      if (!currentUserWallet || !window.currentProfileWallet) {
        console.log('❌ [Follow] Missing wallet addresses');
        return;
      }
      if (currentUserWallet === window.currentProfileWallet) {
        console.log('❌ [Follow] Cannot follow yourself');
        return;
      }

      // Prevent multiple simultaneous operations
      if (isTogglingFollow) {
        console.log('⏸️ [Follow] Already processing a follow/unfollow action');
        return;
      }

      const followBtn = document.getElementById('followBtn');
      const isFollowing = followBtn.classList.contains('following');
      console.log('🔵 [Follow] Current state - isFollowing:', isFollowing);

      // Set the guard flag
      isTogglingFollow = true;

      // Disable button and show loading state
      followBtn.disabled = true;
      const btnText = followBtn.querySelector('.follow-btn-text');
      const btnIcon = followBtn.querySelector('.follow-btn-icon');

      // Show brief loading animation
      btnText.textContent = 'Loading';
      btnIcon.textContent = '⏳';
      followBtn.style.opacity = '0.7';
      followBtn.style.transform = 'scale(0.95)';

      // Get follower count element
      const followersCountEl = document.getElementById('followersCount');
      const currentCount = parseInt(followersCountEl.textContent) || 0;

      // Wait 200ms for loading feedback, then optimistically update UI
      await new Promise(resolve => setTimeout(resolve, 200));

      // Optimistically update UI immediately for instant feedback
      if (!isFollowing) {
        // Show as following immediately
        followBtn.style.transform = 'scale(1.1)';
        followBtn.classList.add('following');
        btnText.textContent = 'Following';
        btnIcon.textContent = '✓';

        // Add success ripple effect
        const ripple = document.createElement('div');
        ripple.style.cssText = 'position:absolute;top:50%;left:50%;width:100%;height:100%;border-radius:50px;background:rgba(7,174,8,0.4);transform:translate(-50%,-50%) scale(0);pointer-events:none;z-index:100;';
        followBtn.style.position = 'relative';
        followBtn.appendChild(ripple);

        // Animate ripple
        ripple.animate([
          { transform: 'translate(-50%, -50%) scale(0)', opacity: 1 },
          { transform: 'translate(-50%, -50%) scale(2.5)', opacity: 0 }
        ], {
          duration: 600,
          easing: 'ease-out'
        }).onfinish = () => ripple.remove();

        // Update count
        followersCountEl.textContent = currentCount + 1;
        followersCountEl.style.transform = 'scale(1.3)';
        followersCountEl.style.color = 'var(--gold)';
        setTimeout(() => {
          followersCountEl.style.transform = '';
          followersCountEl.style.color = '';
        }, 300);
      } else {
        // Show as unfollowed immediately
        followBtn.style.transform = 'scale(1.05)';
        followBtn.classList.remove('following');
        btnText.textContent = 'Follow';
        btnIcon.textContent = '+';

        // Update count
        followersCountEl.textContent = Math.max(0, currentCount - 1);
        followersCountEl.style.transform = 'scale(0.9)';
        setTimeout(() => {
          followersCountEl.style.transform = '';
        }, 300);
      }

      // Reset transform after animation
      setTimeout(() => {
        followBtn.style.transform = '';
      }, 200);

      // Now send to backend (fire and forget - UI already updated)
      try {
        const response = await fetch(`${API_BASE_URL}/api/follow`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            follower_wallet: currentUserWallet,
            following_wallet: window.currentProfileWallet
          })
        });

        console.log('🔵 [Follow] Response status:', response.status);
        if (response.ok) {
          const data = await response.json();
          console.log('🔵 [Follow] Response data:', data);

          // Verify backend agrees with our optimistic update
          if (data.success) {
            if (data.action === 'followed') {
              console.log('✅ [Follow] Backend confirmed: followed');
            } else if (data.action === 'unfollowed') {
              console.log('✅ [Follow] Backend confirmed: unfollowed');
            }

            // SYNC: Also update the community list follow button if it exists
            const communityBtn = document.querySelector(`.community-follow-btn[data-wallet="${window.currentProfileWallet}"]`);
            if (communityBtn) {
              if (data.action === 'followed') {
                communityBtn.classList.add('following');
                communityBtn.textContent = 'Following';
              } else {
                communityBtn.classList.remove('following');
                communityBtn.textContent = 'Follow';
              }
            }

            // Also update the community list follower count
            const communityFollowerCount = document.querySelector(`.community-user-stat-value[data-wallet="${window.currentProfileWallet}"][data-type="followers"]`);
            if (communityFollowerCount) {
              let currentCount = parseInt(communityFollowerCount.textContent) || 0;
              if (data.action === 'followed') {
                communityFollowerCount.textContent = currentCount + 1;
              } else {
                communityFollowerCount.textContent = Math.max(0, currentCount - 1);
              }
            }
          } else {
            console.warn('⚠️ [Follow] Backend returned success:false, but UI already updated');
          }
        } else {
          console.error('❌ [Follow] Response not OK:', response.status, response.statusText);
          // Could revert UI here if needed, but for now trust the optimistic update
        }
      } catch (error) {
        console.error('❌ [Follow] Error toggling follow:', error);
        // Could revert UI here if needed, but for now trust the optimistic update
      } finally {
        // Always re-enable the button and clear the guard flag
        followBtn.disabled = false;
        followBtn.style.opacity = '';
        isTogglingFollow = false;
        console.log('🔵 [Follow] Operation complete, button re-enabled');
      }
    };

    window.showFollowersList = async function(event) {
      if (event) event.stopPropagation();
      if (!window.currentProfileWallet) return;

      // Store current button state to preserve it
      const followBtn = document.getElementById('followBtn');
      const wasFollowing = followBtn ? followBtn.classList.contains('following') : false;

      try {
        const response = await fetch(`${API_BASE_URL}/api/follow/followers/${window.currentProfileWallet}`);
        if (response.ok) {
          const data = await response.json();
          if (data.success) {
            showFollowListModal('Followers', data.followers, 'follower_wallet');

            // Restore button state after modal is shown
            if (followBtn && wasFollowing) {
              setTimeout(() => {
                followBtn.classList.add('following');
              }, 0);
            }
          }
        }
      } catch (error) {
        console.error('Error loading followers:', error);
      }
    };

    window.showFollowingList = async function(event) {
      if (event) event.stopPropagation();
      if (!window.currentProfileWallet) return;

      // Store current button state to preserve it
      const followBtn = document.getElementById('followBtn');
      const wasFollowing = followBtn ? followBtn.classList.contains('following') : false;

      try {
        const response = await fetch(`${API_BASE_URL}/api/follow/following/${window.currentProfileWallet}`);
        if (response.ok) {
          const data = await response.json();
          if (data.success) {
            showFollowListModal('Following', data.following, 'following_wallet');

            // Restore button state after modal is shown
            if (followBtn && wasFollowing) {
              setTimeout(() => {
                followBtn.classList.add('following');
              }, 0);
            }
          }
        }
      } catch (error) {
        console.error('Error loading following:', error);
      }
    };

    function showFollowListModal(title, users, walletKey) {
      // Create modal HTML
      const modalHTML = `
        <div class="follow-list-modal-overlay" onclick="closeFollowListModal()">
          <div class="follow-list-modal" onclick="event.stopPropagation()">
            <div class="follow-list-header">
              <h3>${title}</h3>
              <button class="follow-list-close" onclick="closeFollowListModal()">&times;</button>
            </div>
            <div class="follow-list-body">
              ${users.length === 0 ? `
                <div class="follow-list-empty">
                  <p>No ${title.toLowerCase()} yet!</p>
                </div>
              ` : users.map(user => {
                const displayName = user.display_name || 'Anonymous BEAR';
                const wallet = user[walletKey];
                let avatarHTML = '';

                if (user.avatar_nft) {
                  try {
                    const avatarData = JSON.parse(user.avatar_nft);
                    const avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl;
                    avatarHTML = `<img src="${avatarUrl}" class="follow-list-avatar" alt="${displayName}" onerror="this.src='https://files.catbox.moe/ugu1kl.png'">`;
                  } catch (e) {
                    avatarHTML = `<img src="https://files.catbox.moe/ugu1kl.png" class="follow-list-avatar" alt="${displayName}">`;
                  }
                } else {
                  avatarHTML = `<img src="https://files.catbox.moe/ugu1kl.png" class="follow-list-avatar" alt="${displayName}">`;
                }

                return `
                  <div class="follow-list-item" onclick="viewUserProfile('${wallet}')">
                    <div class="follow-list-avatar-container">
                      ${avatarHTML}
                    </div>
                    <div class="follow-list-info">
                      <h4 class="follow-list-name">${displayName}</h4>
                      <p class="follow-list-wallet">${wallet.substring(0, 8)}...${wallet.substring(wallet.length - 6)}</p>
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        </div>
      `;

      // Append to body
      document.body.insertAdjacentHTML('beforeend', modalHTML);
    }

    window.closeFollowListModal = function() {
      const modal = document.querySelector('.follow-list-modal-overlay');
      if (modal) {
        modal.remove();
      }
    };

    editBioBtn.addEventListener('click', () => {
      bioDisplay.style.display = 'none';
      bioEditor.style.display = 'block';
      bioTextarea.value = bioDisplay.textContent === 'No bio yet. Click Edit to add one!' ? '' : bioDisplay.textContent;
      bioTextarea.focus();
    });

    cancelBioBtn.addEventListener('click', () => {
      bioEditor.style.display = 'none';
      bioDisplay.style.display = 'block';
    });

    saveBioBtn.addEventListener('click', async () => {
      const bio = bioTextarea.value.trim();

      try {
        const response = await fetch(`${API_BASE_URL}/api/profile/bio`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet_address: currentUserWallet,
            bio: bio
          })
        });

        if (response.ok) {
          bioDisplay.textContent = bio || 'No bio yet. Click Edit to add one!';
          bioEditor.style.display = 'none';
          bioDisplay.style.display = 'block';

          const profileKey = `bearpark_profile_${currentUserWallet}`;
          const localProfile = JSON.parse(localStorage.getItem(profileKey) || '{}');
          localProfile.bio = bio;
          localStorage.setItem(profileKey, JSON.stringify(localProfile));

          alert('Bio updated successfully! 🐻');
        } else {
          alert('Failed to update bio. Please try again.');
        }
      } catch (error) {
        console.error('Error saving bio:', error);
        alert('Error updating bio. Please try again.');
      }
    });

    async function loadComments() {
      try {
        console.log('🔄 [LoadComments] Fetching comments for:', window.currentProfileWallet);
        const response = await fetch(`${API_BASE_URL}/api/comments/${window.currentProfileWallet}`);
        if (!response.ok) throw new Error('Failed to load comments');

        const data = await response.json();
        console.log(`✅ [LoadComments] Received ${data.comments?.length || 0} comments`);
        await displayComments(data.comments || []);
        console.log('✅ [LoadComments] Comments displayed');
      } catch (error) {
        console.error('❌ [LoadComments] Error loading comments:', error);
        commentsList.innerHTML = '<div class="comments-empty">Unable to load comments. Please try again later.</div>';
      }
    }

    // Build nested comment tree from flat array
    function buildCommentTree(comments) {
      const commentMap = {};
      const rootComments = [];

      // First pass: create map of all comments
      comments.forEach(comment => {
        commentMap[comment.id] = { ...comment, children: [] };
      });

      // Second pass: build tree structure
      comments.forEach(comment => {
        if (comment.parent_id && commentMap[comment.parent_id]) {
          commentMap[comment.parent_id].children.push(commentMap[comment.id]);
        } else {
          rootComments.push(commentMap[comment.id]);
        }
      });

      return rootComments;
    }

    // Render a single comment with its replies
    async function renderComment(comment, depth = 0, parentName = null) {
      const maxDepth = 8;
      const isOwner = comment.commenter_wallet === currentUserWallet || comment.profile_wallet === currentUserWallet;
      const timeAgo = getTimeAgo(comment.created_at);
      const hasReplies = comment.children && comment.children.length > 0;
      const replyCount = hasReplies ? comment.children.length : 0;

      let avatarHTML = '';
      if (comment.commenter_avatar) {
        try {
          const avatarData = JSON.parse(comment.commenter_avatar);
          const avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl;
          avatarHTML = `<img src="${avatarUrl}" class="comment-avatar" alt="${comment.commenter_name}" onerror="this.src='https://files.catbox.moe/ugu1kl.png';">`;
        } catch (e) {
          avatarHTML = `<img src="https://files.catbox.moe/ugu1kl.png" class="comment-avatar" alt="${comment.commenter_name}">`;
        }
      } else {
        avatarHTML = `<img src="https://files.catbox.moe/ugu1kl.png" class="comment-avatar" alt="${comment.commenter_name}">`;
      }

      // Load reactions
      const reactions = await loadCommentReactions(comment.id);
      const userReactions = reactions.userReactions?.[currentUserWallet] || [];
      const hasReacted = userReactions.length > 0;

      // Reply indicator for nested comments
      let replyIndicator = '';
      if (depth > 0 && parentName) {
        replyIndicator = `<div class="reply-indicator">
          <span class="reply-arrow">↩</span>
          <span class="reply-to-text">Replying to <span class="reply-to-name">@${parentName}</span></span>
        </div>`;
      }

      const commentHTML = `
        <div class="comment-thread ${depth > 0 ? 'is-reply' : ''}" data-comment-id="${comment.id}" data-depth="${depth}">
          <div class="comment-item">
            ${hasReplies ? `<button class="thread-toggle" onclick="toggleThread(${comment.id})" aria-label="Toggle replies">
              <span class="toggle-icon">▼</span>
            </button>` : '<div class="thread-spacer"></div>'}
            <div class="comment-content">
              ${replyIndicator}
              <div class="comment-header">
                <div class="comment-author-clickable" onclick="openProfileModal('${comment.commenter_wallet}')" style="cursor: pointer; display: flex; align-items: center; gap: 12px; flex: 1;">
                  ${avatarHTML}
                  <div class="comment-author-info">
                    <p class="comment-author-name">${comment.commenter_name || 'Anonymous'}</p>
                    <p class="comment-timestamp">${timeAgo}${hasReplies ? `<span class="reply-count">${replyCount} ${replyCount === 1 ? 'reply' : 'replies'}</span>` : ''}</p>
                  </div>
                </div>
                ${isOwner ? `<button class="comment-delete-btn" data-comment-id="${comment.id}">Delete</button>` : ''}
              </div>
              <p class="comment-text">${escapeHtml(comment.comment_text)}</p>
              ${generateReactionSummary(comment.id, reactions, userReactions)}
              <div class="comment-actions">
                <button class="like-button ${hasReacted ? 'reacted' : ''}" data-comment-id="${comment.id}">
                  <span class="like-emoji">👍</span>
                  <span>Like</span>
                  ${generateReactionPicker(comment.id)}
                </button>
                <button class="reply-button" data-comment-id="${comment.id}" onclick="openReplyBox(${comment.id})">
                  <span class="reply-icon">💬</span>
                  <span>Reply</span>
                </button>
              </div>
            </div>
          </div>
          ${hasReplies ? `<div class="comment-replies" data-parent-id="${comment.id}"></div>` : ''}
        </div>
      `;

      return commentHTML;
    }

    // Recursively render replies
    async function renderReplies(replies, parentId, depth, parentComment = null) {
      const maxDepth = 8;
      const repliesContainer = document.querySelector(`.comment-replies[data-parent-id="${parentId}"]`);
      if (!repliesContainer) return;

      for (const reply of replies) {
        const parentName = parentComment ? (parentComment.commenter_name || 'Anonymous') : 'a bear';
        const replyHTML = await renderComment(reply, depth, parentName);
        repliesContainer.insertAdjacentHTML('beforeend', replyHTML);

        // Render nested replies
        if (reply.children && reply.children.length > 0 && depth < maxDepth) {
          await renderReplies(reply.children, reply.id, depth + 1, reply);
        }
      }
    }

    // Toggle collapse/expand thread
    window.toggleThread = function(commentId) {
      const threadElement = document.querySelector(`.comment-thread[data-comment-id="${commentId}"]`);
      if (!threadElement) return;

      const repliesContainer = threadElement.querySelector('.comment-replies');
      const toggleIcon = threadElement.querySelector('.toggle-icon');

      if (!repliesContainer) return;

      if (repliesContainer.style.display === 'none') {
        repliesContainer.style.display = 'block';
        toggleIcon.textContent = '▼';
        threadElement.classList.remove('collapsed');
      } else {
        repliesContainer.style.display = 'none';
        toggleIcon.textContent = '▶';
        threadElement.classList.add('collapsed');
      }
    };

    // Main display function with Reddit-style threading
    async function displayComments(comments) {
      const totalCount = comments.length;
      commentsCount.textContent = totalCount;

      console.log('🔍 [DisplayComments] Received comments:', comments.map(c => c.id));

      if (totalCount === 0) {
        commentsList.innerHTML = '<div class="comments-empty">No comments yet. Be the first to comment!</div>';
        return;
      }

      console.log('🧹 [DisplayComments] Clearing commentsList innerHTML');
      commentsList.innerHTML = '';

      // Build nested comment tree
      const commentTree = buildCommentTree(comments);
      console.log('🌳 [DisplayComments] Built comment tree with root comments:', commentTree.map(c => c.id));

      // Render root comments
      for (const comment of commentTree) {
        console.log('🎨 [DisplayComments] Rendering comment:', comment.id);
        const commentHTML = await renderComment(comment, 0);
        commentsList.insertAdjacentHTML('beforeend', commentHTML);

        // Render replies recursively
        if (comment.children && comment.children.length > 0) {
          await renderReplies(comment.children, comment.id, 1, comment);
        }
      }

      console.log('✅ [DisplayComments] Finished rendering. DOM should now have', commentTree.length, 'root comments');

      // Debug: Check what's actually in the DOM
      const renderedComments = commentsList.querySelectorAll('.comment-thread');
      console.log('🔍 [DisplayComments] DOM contains', renderedComments.length, 'comment elements');
      const renderedIds = Array.from(renderedComments).map(el => {
        const deleteBtn = el.querySelector('.comment-delete-btn');
        return deleteBtn ? deleteBtn.getAttribute('data-comment-id') : 'no-id';
      });
      console.log('🔍 [DisplayComments] Comment IDs in DOM:', renderedIds);

      // Event listeners are now attached once via event delegation - no need to re-attach
      // attachLikeButtonListeners(); // REMOVED - causes duplicate listeners
    }

    async function loadCommentReactions(commentId) {
      try {
        const response = await fetch(`${API_BASE_URL}/api/comments/${commentId}/reactions`);
        if (!response.ok) return { counts: {}, userReactions: {} };

        const data = await response.json();
        return data;
      } catch (error) {
        console.error('Error loading reactions:', error);
        return { counts: {}, userReactions: {} };
      }
    }

    function generateReactionSummary(commentId, reactions, userReactions = []) {
      const counts = reactions.counts || {};
      const hasCounts = Object.keys(counts).some(key => counts[key] > 0);

      if (!hasCounts) return '';

      const reactionTypes = [
        { type: 'like', emoji: '👍' },
        { type: 'laugh', emoji: '😂' },
        { type: 'heart', emoji: '❤️' },
        { type: 'cry', emoji: '😢' },
        { type: 'thumbs_down', emoji: '👎' },
        { type: 'troll', emoji: '🤡' }
      ];

      const pills = reactionTypes
        .filter(({ type }) => counts[type] > 0)
        .map(({ type, emoji }) => {
          const isUserReaction = userReactions.includes(type);
          // If user already reacted, clicking removes it. Otherwise, clicking adds it.
          const clickHandler = isUserReaction
            ? `removeReaction(${commentId}, '${type}', this)`
            : `toggleReaction(${commentId}, '${type}')`;
          return `
            <div class="reaction-pill ${isUserReaction ? 'user-reacted' : ''}"
                 data-comment-id="${commentId}"
                 data-reaction-type="${type}"
                 onclick="${clickHandler}">
              <span class="pill-emoji">${emoji}</span>
              <span class="pill-count">${counts[type]}</span>
            </div>
          `;
        }).join('');

      return `<div class="reaction-summary">${pills}</div>`;
    }

    function generateReactionPicker(commentId) {
      const reactionTypes = [
        { type: 'like', emoji: '👍', label: 'Like' },
        { type: 'laugh', emoji: '😂', label: 'Laugh' },
        { type: 'heart', emoji: '❤️', label: 'Love' },
        { type: 'cry', emoji: '😢', label: 'Sad' },
        { type: 'thumbs_down', emoji: '👎', label: 'Dislike' },
        { type: 'troll', emoji: '🤡', label: 'Troll' }
      ];

      const items = reactionTypes.map(({ type, emoji, label }) => `
        <div class="reaction-picker-item" data-reaction-type="${type}" data-label="${label}">
          ${emoji}
        </div>
      `).join('');

      return `<div class="reaction-picker" data-comment-id="${commentId}">${items}</div>`;
    }

    // Event delegation for like buttons - attach once, works forever
    // State storage for each button's picker state
    const buttonStates = new Map();

    function getButtonState(btn) {
      if (!buttonStates.has(btn)) {
        buttonStates.set(btn, {
          longPressTimer: null,
          picker: null,
          currentHoveredItem: null,
          selectedReaction: null,
          pickerShown: false
        });
      }
      return buttonStates.get(btn);
    }

    function showPicker(btn) {
      const state = getButtonState(btn);
      state.picker = btn.querySelector('.reaction-picker');
      if (state.picker) {
        state.picker.classList.add('visible');
        state.pickerShown = true;
        if (navigator.vibrate) navigator.vibrate(10);
      }
    }

    function hidePicker(btn) {
      const state = getButtonState(btn);
      if (state.picker) {
        state.picker.classList.remove('visible');
        state.pickerShown = false;
        const items = state.picker.querySelectorAll('.reaction-picker-item');
        items.forEach(item => { item.style.transform = ''; });
      }
    }

    function getEmojiAtTouch(picker, touch) {
      const pickerItems = picker?.querySelectorAll('.reaction-picker-item');
      if (!pickerItems) return null;

      for (const item of pickerItems) {
        const rect = item.getBoundingClientRect();
        if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
            touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
          return item;
        }
      }
      return null;
    }

    function updateHoveredEmoji(btn, touch) {
      const state = getButtonState(btn);
      if (!state.picker || !state.pickerShown) return;

      const hoveredItem = getEmojiAtTouch(state.picker, touch);

      if (hoveredItem !== state.currentHoveredItem) {
        if (state.currentHoveredItem) {
          state.currentHoveredItem.style.transform = '';
        }
        if (hoveredItem) {
          hoveredItem.style.transform = 'scale(1.8) translateY(-12px)';
          hoveredItem.style.filter = 'drop-shadow(0 8px 20px rgba(237,183,35,0.8))';
          if (navigator.vibrate) navigator.vibrate(5);
          state.selectedReaction = hoveredItem.getAttribute('data-reaction-type');
        } else {
          state.selectedReaction = null;
        }
        state.currentHoveredItem = hoveredItem;
      }
    }

    // Attach event listeners ONCE to commentsList using delegation
    if (commentsList && !commentsList.dataset.likeListenersAttached) {
      commentsList.dataset.likeListenersAttached = 'true';

      // Mousedown - start long press timer
      commentsList.addEventListener('mousedown', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getButtonState(btn);
        state.longPressTimer = setTimeout(() => showPicker(btn), 300);
      });

      // Mouseup - clear timer
      commentsList.addEventListener('mouseup', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getButtonState(btn);
        clearTimeout(state.longPressTimer);
      });

      // Mouseleave - clear timer but keep picker open
      commentsList.addEventListener('mouseleave', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getButtonState(btn);
        clearTimeout(state.longPressTimer);
      }, true);

      // Click - quick like or picker item selection
      commentsList.addEventListener('click', async (e) => {
        // Check if clicked on picker item first
        const pickerItem = e.target.closest('.reaction-picker-item');
        if (pickerItem) {
          e.stopPropagation();
          const btn = e.target.closest('.like-button');
          if (btn) {
            const reactionType = pickerItem.getAttribute('data-reaction-type');
            const commentId = btn.getAttribute('data-comment-id');
            await toggleReaction(commentId, reactionType);
            hidePicker(btn);
          }
          return;
        }

        // Otherwise check if clicked on button itself
        const btn = e.target.closest('.like-button');
        if (!btn) return;

        const state = getButtonState(btn);
        state.picker = btn.querySelector('.reaction-picker');
        if (!state.picker || !state.picker.classList.contains('visible')) {
          const commentId = btn.getAttribute('data-comment-id');
          await toggleReaction(commentId, 'like');
        }
      });

      // Touchstart - start long press
      commentsList.addEventListener('touchstart', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        e.preventDefault();
        const state = getButtonState(btn);
        state.selectedReaction = null;
        state.currentHoveredItem = null;
        state.longPressTimer = setTimeout(() => showPicker(btn), 300);
      }, { passive: false });

      // Touchmove - slide to select emoji
      commentsList.addEventListener('touchmove', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getButtonState(btn);

        if (!state.pickerShown) {
          clearTimeout(state.longPressTimer);
          return;
        }

        e.preventDefault();
        const touch = e.touches[0];
        updateHoveredEmoji(btn, touch);
      }, { passive: false });

      // Touchend - complete reaction
      commentsList.addEventListener('touchend', async (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getButtonState(btn);
        clearTimeout(state.longPressTimer);
        state.picker = btn.querySelector('.reaction-picker');

        if (state.pickerShown && state.selectedReaction) {
          const commentId = btn.getAttribute('data-comment-id');
          await toggleReaction(commentId, state.selectedReaction);
          if (navigator.vibrate) navigator.vibrate([10, 20, 10]);
          hidePicker(btn);
          state.selectedReaction = null;
          state.currentHoveredItem = null;
        } else if (!state.pickerShown) {
          const commentId = btn.getAttribute('data-comment-id');
          await toggleReaction(commentId, 'like');
        } else {
          hidePicker(btn);
        }
      });

      // Touchcancel - cleanup
      commentsList.addEventListener('touchcancel', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getButtonState(btn);
        clearTimeout(state.longPressTimer);
        hidePicker(btn);
        state.selectedReaction = null;
        state.currentHoveredItem = null;
      });

      // Hide picker when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.like-button')) {
          // Clicked outside - hide all pickers
          buttonStates.forEach((state, btn) => {
            if (state.pickerShown) {
              hidePicker(btn);
            }
          });
        }
      });

      // Event delegation for delete buttons
      commentsList.addEventListener('click', (e) => {
        const deleteBtn = e.target.closest('.comment-delete-btn');
        if (deleteBtn) {
          const commentId = parseInt(deleteBtn.getAttribute('data-comment-id'));
          console.log('🗑️ Delete button clicked for comment:', commentId);
          deleteProfileComment(commentId);
        }
      });
    }

    // No-op function for compatibility (in case it's called somewhere)
    function attachLikeButtonListeners() {
      // Event delegation is now used - this function does nothing
    }

    postCommentBtn.addEventListener('click', async () => {
      const commentText = commentTextarea.value.trim();
      if (!commentText) {
        alert('Please enter a comment!');
        return;
      }

      if (!currentUserWallet) {
        alert('Please connect your wallet first!');
        return;
      }

      try {
        const profileKey = `bearpark_profile_${currentUserWallet}`;
        const localProfile = JSON.parse(localStorage.getItem(profileKey) || '{}');

        const response = await fetch(`${API_BASE_URL}/api/comments`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            profile_wallet: window.currentProfileWallet,
            commenter_wallet: currentUserWallet,
            comment_text: commentText,
            commenter_name: localProfile.display_name || 'Anonymous',
            commenter_avatar: localProfile.avatar_nft || null
          })
        });

        if (response.ok) {
          commentTextarea.value = '';
          await loadComments();
        } else {
          alert('Failed to post comment. Please try again.');
        }
      } catch (error) {
        console.error('Error posting comment:', error);
        alert('Error posting comment. Please try again.');
      }
    });

    // Profile comment delete function
    window.deleteProfileComment = async function(commentId) {
      if (!confirm('Are you sure you want to delete this comment?')) return;

      try {
        console.log('🔵 [Delete Profile Comment] Deleting comment:', commentId);
        console.log('🔵 [Delete] Current user wallet:', currentUserWallet);

        if (!currentUserWallet) {
          alert('Please connect your wallet first!');
          return;
        }

        const response = await fetch(`${API_BASE_URL}/api/comments/${commentId}`, {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet_address: currentUserWallet,
            is_admin: false
          })
        });

        console.log('🔵 [Delete] Response status:', response.status);

        if (response.ok) {
          console.log('✅ [Delete] Comment deleted successfully');
          console.log('🔄 [Delete] Reloading comments...');
          await loadComments();
          console.log('✅ [Delete] Comments reloaded');
        } else {
          const errorData = await response.json();
          console.error('❌ [Delete] Error response:', errorData);
          alert(`Failed to delete comment: ${errorData.error || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('❌ [Delete] Error deleting comment:', error);
        alert('Error deleting comment.');
      }
    };

    // Open Reply Box
    window.openReplyBox = function(commentId) {
      // Close any other open reply boxes
      document.querySelectorAll('.reply-box').forEach(box => {
        box.classList.remove('visible');
      });

      // Find the comment thread
      const threadElement = document.querySelector(`.comment-thread[data-comment-id="${commentId}"]`);
      if (!threadElement) return;

      const commentContent = threadElement.querySelector('.comment-content');
      let replyBox = commentContent.querySelector('.reply-box');

      if (!replyBox) {
        // Create reply box
        const replyBoxHTML = `
          <div class="reply-box visible" data-parent-id="${commentId}">
            <textarea placeholder="Write a reply..." maxlength="500"></textarea>
            <div class="reply-box-actions">
              <button class="reply-cancel-btn" onclick="closeReplyBox(${commentId})">Cancel</button>
              <button class="reply-submit-btn" onclick="submitReply(${commentId})">Reply</button>
            </div>
          </div>
        `;
        commentContent.insertAdjacentHTML('beforeend', replyBoxHTML);
        replyBox = commentContent.querySelector('.reply-box');

        // Focus textarea
        setTimeout(() => {
          const textarea = replyBox.querySelector('textarea');
          textarea.focus();
        }, 100);
      } else {
        replyBox.classList.add('visible');
        setTimeout(() => {
          const textarea = replyBox.querySelector('textarea');
          textarea.focus();
        }, 100);
      }
    };

    // Close Reply Box
    window.closeReplyBox = function(commentId) {
      const threadElement = document.querySelector(`.comment-thread[data-comment-id="${commentId}"]`);
      if (!threadElement) return;

      const replyBox = threadElement.querySelector('.reply-box');
      if (replyBox) {
        replyBox.classList.remove('visible');
        replyBox.querySelector('textarea').value = '';
      }
    };

    // Submit Reply
    window.submitReply = async function(parentCommentId) {
      if (!currentUserWallet) {
        alert('Please connect your wallet first!');
        return;
      }

      const threadElement = document.querySelector(`.comment-thread[data-comment-id="${parentCommentId}"]`);
      if (!threadElement) return;

      const replyBox = threadElement.querySelector('.reply-box');
      const textarea = replyBox.querySelector('textarea');
      const replyText = textarea.value.trim();

      if (!replyText) {
        alert('Please enter a reply!');
        return;
      }

      try {
        // Get user profile data
        const profileKey = `bearpark_profile_${currentUserWallet}`;
        const localProfile = JSON.parse(localStorage.getItem(profileKey) || '{}');

        const response = await fetch(`${API_BASE_URL}/api/comments`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            profile_wallet: window.currentProfileWallet,
            commenter_wallet: currentUserWallet,
            comment_text: replyText,
            commenter_name: localProfile.display_name || 'Anonymous',
            commenter_avatar: localProfile.avatar_nft || null,
            parent_id: parentCommentId
          })
        });

        if (response.ok) {
          closeReplyBox(parentCommentId);
          await loadComments();
        } else {
          alert('Failed to post reply.');
        }
      } catch (error) {
        console.error('Error posting reply:', error);
        alert('Error posting reply. Please try again.');
      }
    };

    // Prevent double-clicking reactions
    const reactionLocks = new Set();

    window.toggleReaction = async function(commentId, reactionType) {
      if (!currentUserWallet) {
        alert('Please connect your wallet first!');
        return;
      }

      // Create unique lock key for this specific reaction
      const lockKey = `${commentId}-${reactionType}`;

      // If already processing this reaction, ignore
      if (reactionLocks.has(lockKey)) {
        console.log('⏳ Already processing this reaction, ignoring duplicate request');
        return;
      }

      // Lock this reaction
      reactionLocks.add(lockKey);

      try {
        const response = await fetch(`${API_BASE_URL}/api/comments/${commentId}/react`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet_address: currentUserWallet,
            reaction_type: reactionType
          })
        });

        let result;
        try {
          result = await response.json();
        } catch (parseError) {
          console.error('❌ Failed to parse response JSON:', parseError);
          console.error('❌ Response status:', response.status, response.statusText);
          alert('Server error - invalid response');
          return;
        }

        if (response.ok && result.success) {
          console.log('✅ toggleReaction Backend confirmed:', result.action);
          console.log('📦 Backend returned updated counts:', result.counts);
          console.log('📦 Backend returned user reactions:', result.userReactions);

          // Use the fresh data directly from backend response (no fetching needed!)
          updateCommentReactionsWithData(commentId, {
            counts: result.counts || {},
            userReactions: result.userReactions || {}
          });
        } else {
          console.error('❌ toggleReaction Backend error:', result);
          console.error('❌ Response status:', response.status);
          console.error('❌ Failed request: commentId=' + commentId + ', reactionType=' + reactionType);
          // Don't show alert for duplicate errors (user probably double-clicked)
          if (!result.error?.includes('duplicate key')) {
            alert('Failed to toggle reaction: ' + (result.error || 'Unknown error'));
          }
        }
      } catch (error) {
        console.error('Error toggling reaction:', error);
        alert('Error adding reaction.');
      } finally {
        // Always unlock after request completes
        reactionLocks.delete(lockKey);
      }
    };

    // Update reactions using data directly (no fetch needed)
    function updateCommentReactionsWithData(commentId, reactionsData) {
      try {
        const userReactions = reactionsData.userReactions?.[currentUserWallet] || [];

        console.log('🔄 Updating reactions UI for comment', commentId);
        console.log('📊 Reaction counts:', reactionsData.counts);
        console.log('👤 User reactions:', userReactions);

        // Find the comment element (data-comment-id is on .comment-thread, not .comment-item)
        const commentThread = document.querySelector(`.comment-thread[data-comment-id="${commentId}"]`);
        if (!commentThread) return;
        const commentElement = commentThread.querySelector('.comment-item');
        if (!commentElement) return;

        const commentContent = commentElement.querySelector('.comment-content');
        const commentActions = commentContent.querySelector('.comment-actions');
        let existingReactionSummary = commentContent.querySelector('.reaction-summary');

        // Generate the new reaction summary HTML
        const newReactionHTML = generateReactionSummary(commentId, reactionsData, userReactions);

        console.log('🎨 New reaction HTML:', newReactionHTML ? 'Generated' : 'Empty (no reactions)');

        if (existingReactionSummary) {
          // If there's an existing summary and new HTML, replace it
          if (newReactionHTML) {
            existingReactionSummary.outerHTML = newReactionHTML;
          } else {
            // No reactions left, remove the summary
            existingReactionSummary.remove();
          }
        } else if (newReactionHTML) {
          // No existing summary but we have reactions, insert before actions
          commentActions.insertAdjacentHTML('beforebegin', newReactionHTML);
        }

        // Update the like button state
        const likeButton = commentElement.querySelector('.like-button');
        if (likeButton) {
          if (userReactions.length > 0) {
            likeButton.classList.add('reacted');
          } else {
            likeButton.classList.remove('reacted');
          }
        }

        // Event listeners use delegation - no need to re-attach
        // attachLikeButtonListeners(); // REMOVED - causes duplicate listeners
      } catch (error) {
        console.error('Error updating reactions:', error);
      }
    }

    // Update reactions for a specific comment without reloading all comments
    async function updateCommentReactions(commentId) {
      try {
        // Add cache-busting parameter to ensure fresh data
        const timestamp = new Date().getTime();
        const reactionsResponse = await fetch(`${API_BASE_URL}/api/comments/${commentId}/reactions?_=${timestamp}`);
        if (!reactionsResponse.ok) return;

        const reactions = await reactionsResponse.json();
        const userReactions = reactions.userReactions?.[currentUserWallet] || [];

        console.log('🔄 Updating reactions UI for comment', commentId);
        console.log('📊 Reaction counts:', reactions.counts);
        console.log('👤 User reactions:', userReactions);

        // Find the comment element (data-comment-id is on .comment-thread, not .comment-item)
        const commentThread = document.querySelector(`.comment-thread[data-comment-id="${commentId}"]`);
        if (!commentThread) return;
        const commentElement = commentThread.querySelector('.comment-item');
        if (!commentElement) return;

        const commentContent = commentElement.querySelector('.comment-content');
        const commentActions = commentContent.querySelector('.comment-actions');
        let existingReactionSummary = commentContent.querySelector('.reaction-summary');

        // Generate the new reaction summary HTML
        const newReactionHTML = generateReactionSummary(commentId, reactions, userReactions);

        console.log('🎨 New reaction HTML:', newReactionHTML ? 'Generated' : 'Empty (no reactions)');

        if (existingReactionSummary) {
          // If there's an existing summary and new HTML, replace it
          if (newReactionHTML) {
            existingReactionSummary.outerHTML = newReactionHTML;
          } else {
            // No reactions left, remove the summary
            existingReactionSummary.remove();
          }
        } else if (newReactionHTML) {
          // No existing summary but we have reactions, insert before actions
          commentActions.insertAdjacentHTML('beforebegin', newReactionHTML);
        }

        // Update the like button state
        const likeButton = commentElement.querySelector('.like-button');
        if (likeButton) {
          if (userReactions.length > 0) {
            likeButton.classList.add('reacted');
          } else {
            likeButton.classList.remove('reacted');
          }
        }

        // Event listeners use delegation - no need to re-attach
        // attachLikeButtonListeners(); // REMOVED - causes duplicate listeners
      } catch (error) {
        console.error('Error updating reactions:', error);
      }
    }

    window.removeReaction = async function(commentId, reactionType, pillElement) {
      if (!currentUserWallet) {
        alert('Please connect your wallet first!');
        return;
      }

      console.log('🗑️ REMOVING reaction:', reactionType, 'from comment', commentId);

      // Add the removing animation
      pillElement.classList.add('removing');

      // Haptic feedback
      if (navigator.vibrate) {
        navigator.vibrate([5, 10, 5]);
      }

      try {
        const response = await fetch(`${API_BASE_URL}/api/comments/${commentId}/react`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet_address: currentUserWallet,
            reaction_type: reactionType
          })
        });

        const result = await response.json();
        console.log('📡 Backend response:', result);

        if (response.ok && result.success) {
          console.log('✅ Backend confirmed:', result.action);
          console.log('📦 Backend returned updated counts:', result.counts);
          console.log('📦 Backend returned user reactions:', result.userReactions);

          // Use the fresh data directly from backend response (no fetching needed!)
          setTimeout(() => {
            console.log('⏰ Animation complete, updating UI with backend data...');
            // Update UI directly with the counts from backend response
            updateCommentReactionsWithData(commentId, {
              counts: result.counts || {},
              userReactions: result.userReactions || {}
            });
          }, 400); // Match animation duration
        } else {
          console.error('❌ Backend error:', result);
          pillElement.classList.remove('removing');
          alert('Failed to remove reaction: ' + (result.error || 'Unknown error'));
        }
      } catch (error) {
        pillElement.classList.remove('removing');
        console.error('Error removing reaction:', error);
        alert('Error removing reaction: ' + error.message);
      }
    };

    async function loadProfileNFTs() {
      try {
        const walletAddress = window.currentProfileWallet;
        console.log('🖼️ Loading NFTs for wallet:', walletAddress);

        // Fetch ALL NFTs with pagination
        let allNfts = [];
        let marker = null;
        let pageCount = 0;

        do {
          pageCount++;
          console.log(`🖼️ Fetching NFT page ${pageCount}...`);

          const response = await fetch('https://xrplcluster.com/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              method: 'account_nfts',
              params: [{
                account: walletAddress,
                ledger_index: 'validated',
                limit: 400,
                ...(marker && { marker })
              }]
            })
          });

          if (!response.ok) {
            console.log('🖼️ NFT API request failed');
            break;
          }

          const data = await response.json();
          const pageNfts = data.result?.account_nfts || [];
          allNfts = allNfts.concat(pageNfts);
          marker = data.result?.marker;

          console.log(`🖼️ Page ${pageCount}: ${pageNfts.length} NFTs, Total so far: ${allNfts.length}`);

        } while (marker);

        console.log('🖼️ Total NFTs in wallet (all pages):', allNfts.length);

        // Debug: Show sample NFT structure and unique issuers
        if (allNfts.length > 0) {
          console.log('🖼️ Sample NFT structure:', allNfts[0]);
          const uniqueIssuers = [...new Set(allNfts.map(nft => nft.Issuer))];
          console.log('🖼️ Unique issuers in wallet:', uniqueIssuers);
        }

        // Filter for BEAR NFTs by issuer (check multiple known BEAR issuers)
        const bearIssuers = [
          'rBEARGUAsyu7tUw53rufQzFdWmJHpJEqFW',  // Original BEAR issuer
          'rBEARbo4Prn33894evmvYcAf9yAQjp4VJF'   // Alternative BEAR issuer
        ];
        const nfts = allNfts.filter(nft => bearIssuers.includes(nft.Issuer));
        console.log('🖼️ Looking for BEAR issuers:', bearIssuers);
        console.log('🖼️ BEAR NFTs found:', nfts.length);
        if (nfts.length > 0) {
          console.log('🖼️ BEAR NFT sample FULL OBJECT:', JSON.stringify(nfts[0], null, 2));
          console.log('🖼️ NFT fields:', Object.keys(nfts[0]));
          console.log('🖼️ Found from issuer:', nfts[0].Issuer);
        }

        // Debug: Check what taxons are actually in the BEAR NFTs
        const taxons = [...new Set(nfts.map(nft => nft.NFTokenTaxon))];
        console.log('🔍 Taxon values found in BEAR NFTs:', taxons);

        // Count NFTs by each taxon
        taxons.forEach(taxon => {
          const count = nfts.filter(nft => nft.NFTokenTaxon === taxon).length;
          console.log(`📊 Taxon ${taxon}: ${count} NFTs`);
        });

        // Categorize NFTs by taxon
        // Taxon 0 = Ultra Rare BEARS
        // Taxon 1 = Pixel BEARS
        // Taxon 2 = Pixel BEARS (alternative issuer)
        let pixelBears = nfts.filter(nft => nft.NFTokenTaxon === 1 || nft.NFTokenTaxon === 2);
        let ultraRareBears = nfts.filter(nft => nft.NFTokenTaxon === 0);

        console.log('🎨 Pixel BEARS (taxon 1 or 2):', pixelBears.length);
        console.log('💎 Ultra Rare BEARS (taxon 0):', ultraRareBears.length);

        const pixelBearsSection = document.getElementById('pixelBearsSection');
        const ultraRareBearsSection = document.getElementById('ultraRareBearsSection');
        const noNFTsMessage = document.getElementById('noNFTsMessage');

        // Show/hide sections based on what user owns
        if (pixelBears.length > 0) {
          console.log('✅ Showing Pixel BEARS section');
          pixelBearsSection.style.display = 'block';
          document.getElementById('pixelBearsCount').textContent = pixelBears.length;
          await displayNFTCollection('pixelBearsGrid', pixelBears);
          noNFTsMessage.style.display = 'none';
        } else {
          pixelBearsSection.style.display = 'none';
        }

        if (ultraRareBears.length > 0) {
          console.log('✅ Showing Ultra Rare BEARS section');
          ultraRareBearsSection.style.display = 'block';
          document.getElementById('ultraRareBearsCount').textContent = ultraRareBears.length;
          await displayNFTCollection('ultraRareBearsGrid', ultraRareBears);
          noNFTsMessage.style.display = 'none';
        } else {
          ultraRareBearsSection.style.display = 'none';
        }

        // Show "no NFTs" message if user has none
        if (pixelBears.length === 0 && ultraRareBears.length === 0) {
          console.log('❌ No BEAR NFTs found - showing empty message');
          noNFTsMessage.style.display = 'block';
        }
      } catch (error) {
        console.error('Error loading profile NFTs:', error);
        document.getElementById('noNFTsMessage').style.display = 'block';
      }
    }

    async function displayNFTCollection(gridId, nfts) {
      console.log(`🎬 Displaying ${nfts.length} NFTs in grid: ${gridId}`);
      const grid = document.getElementById(gridId);
      if (!grid) {
        console.error(`❌ Grid element not found: ${gridId}`);
        return;
      }

      // Limit to 20 NFTs for performance
      const nftsToShow = nfts.slice(0, 20);
      console.log(`🔍 Processing ${nftsToShow.length} NFTs - fetching metadata...`);

      // Show loading state
      grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 20px; color: #edb723;">Loading NFT images...</div>';

      // Fetch metadata for each NFT to get actual image URLs
      const nftWithImages = [];
      for (let i = 0; i < nftsToShow.length; i++) {
        const nft = nftsToShow[i];
        let imageUrl = null;
        let bearName = null;
        let bearRarity = null;

        if (nft.URI) {
          try {
            // Convert hex URI to string (browser-compatible)
            const uriString = nft.URI.match(/.{1,2}/g).map(byte => String.fromCharCode(parseInt(byte, 16))).join('');

            // Convert IPFS URL to HTTP gateway and properly encode
            let metadataUrl = uriString;
            if (uriString.startsWith('ipfs://')) {
              // Split the IPFS URI to encode the path component properly
              const ipfsPath = uriString.replace('ipfs://', '');
              const parts = ipfsPath.split('/');
              // Encode each part of the path (especially important for filenames with # or spaces)
              const encodedPath = parts.map(part => encodeURIComponent(part)).join('/');
              metadataUrl = 'https://ipfs.io/ipfs/' + encodedPath;
            }

            console.log(`📡 [${i+1}/${nftsToShow.length}] Fetching from:`, metadataUrl.substring(0, 80) + '...');

            // Fetch the JSON metadata
            const response = await fetch(metadataUrl);
            if (response.ok) {
              const metadata = await response.json();

              // Debug log for first NFT to see metadata structure
              if (i === 0) {
                console.log(`🔍 First NFT metadata:`, metadata);
                console.log(`🔍 Attributes array:`, metadata.attributes);
                if (metadata.attributes && Array.isArray(metadata.attributes)) {
                  metadata.attributes.forEach((attr, idx) => {
                    console.log(`🔍 Attribute ${idx}:`, attr);
                  });
                }
              }

              // Extract BEAR name (e.g., "Pixel BEAR #3018")
              if (metadata.name) {
                bearName = metadata.name;
              }

              // Extract rarity from attributes - check multiple possible field names
              if (metadata.attributes && Array.isArray(metadata.attributes)) {
                // Try different possible attribute structures
                const rarityAttr = metadata.attributes.find(attr =>
                  attr.trait_type === 'Rarity' || attr.trait_type === 'rarity' || attr.trait_type === 'RARITY' ||
                  attr.trait === 'Rarity' || attr.trait === 'rarity' || attr.trait === 'RARITY' ||
                  attr.name === 'Rarity' || attr.name === 'rarity' || attr.name === 'RARITY'
                );
                if (rarityAttr) {
                  bearRarity = rarityAttr.value || rarityAttr.val || rarityAttr.content;
                }
              }

              // Extract image URL from metadata - try multiple field names
              // Check animation fields first for animated NFTs, then fall back to image
              imageUrl = metadata.animation || metadata.animation_url || metadata.video ||
                         metadata.image || metadata.image_url || metadata.media || metadata.url;

              if (imageUrl) {
                // Convert IPFS image URLs to HTTP gateway and properly encode
                if (imageUrl.startsWith('ipfs://')) {
                  const ipfsPath = imageUrl.replace('ipfs://', '');
                  const parts = ipfsPath.split('/');
                  // Encode each part of the path (especially important for filenames with # or spaces)
                  const encodedPath = parts.map(part => encodeURIComponent(part)).join('/');
                  imageUrl = 'https://ipfs.io/ipfs/' + encodedPath;
                  console.log(`✅ [${i+1}/${nftsToShow.length}] ${bearName || 'NFT'} loaded`);
                } else {
                  console.log(`✅ [${i+1}/${nftsToShow.length}] ${bearName || 'NFT'} loaded (non-IPFS)`);
                }
              } else {
                console.warn(`⚠️ [${i+1}/${nftsToShow.length}] No image field. Metadata keys:`, Object.keys(metadata));
              }
            } else {
              console.warn(`⚠️ [${i+1}/${nftsToShow.length}] Failed to fetch metadata: ${response.status}`);
            }
          } catch (error) {
            console.error(`❌ [${i+1}/${nftsToShow.length}] Error:`, error.message);
          }
        }

        nftWithImages.push({ ...nft, imageUrl, bearName, bearRarity });

        // Update grid every 5 NFTs for progressive loading
        if ((i + 1) % 5 === 0 || i === nftsToShow.length - 1) {
          grid.innerHTML = nftWithImages.map((nft, index) => {
            const imageUrl = nft.imageUrl || 'data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27100%27 height=%27100%27%3E%3Crect fill=%27%23333%27 width=%27100%27 height=%27100%27/%3E%3Ctext fill=%27%23edb723%27 x=%2750%25%27 y=%2750%25%27 text-anchor=%27middle%27 dy=%27.3em%27%3ENFT%3C/text%3E%3C/svg%3E';

            // Extract BEAR # from name (e.g., "Pixel BEAR #3018" -> "3018")
            let bearNumber = index + 1;
            if (nft.bearName) {
              const match = nft.bearName.match(/#(\d+)/);
              if (match) {
                bearNumber = match[1];
              }
            }

            // Use rarity from metadata or calculate rarity number
            let rarityText;
            if (nft.bearRarity) {
              rarityText = nft.bearRarity;
            } else if (nft.NFTokenTaxon === 0) {
              // Ultra Rare BEARS show "RARITY #0"
              rarityText = 'RARITY #0';
            } else {
              // For Pixel BEARS, calculate rarity score (simplified - using modulo)
              const rarityScore = parseInt(bearNumber) % 1000;
              rarityText = `RARITY ${rarityScore}`;
            }

            // Debug logging
            if (index === 0) {
              console.log(`🎨 NFT Card Info - bearName: "${nft.bearName}", bearNumber: "${bearNumber}", bearRarity: "${nft.bearRarity}", rarityText: "${rarityText}"`);
            }

            const htmlTemplate = `
              <div class="profile-nft-item">
                <div class="nft-image-container">
                  <img src="${imageUrl}" alt="NFT" loading="lazy" onerror="this.style.display='none';">
                  <a href="https://xrp.cafe/nft/${nft.NFTokenID}" target="_blank" rel="noopener noreferrer" class="nft-logo-badge" title="View on XRP.cafe">
                    <img src="https://avatars.githubusercontent.com/u/109316848?s=280&v=4" alt="XRP Cafe">
                  </a>
                </div>
                <div class="nft-info">
                  <div class="nft-title">BEAR #${bearNumber}</div>
                  <div class="nft-rarity">${rarityText}</div>
                </div>
              </div>
            `;

            // Debug first NFT HTML
            if (index === 0) {
              console.log(`🎨 Generated HTML:`, htmlTemplate);
            }

            return htmlTemplate;
          }).join('');
        }
      }

      console.log(`✅ Rendered ${nftWithImages.length} NFTs to ${gridId}`);
    }

    // Toggle NFT collection expansion
    window.toggleNFTCollection = function(collectionName) {
      const grid = document.getElementById(`${collectionName}Grid`);
      const arrow = document.getElementById(`${collectionName}Arrow`);
      const button = grid.previousElementSibling;

      if (grid.style.display === 'none' || grid.style.display === '') {
        grid.style.display = 'grid';
        button.classList.add('expanded');
      } else {
        grid.style.display = 'none';
        button.classList.remove('expanded');
      }
    };

    function getTimeAgo(timestamp) {
      const now = new Date();
      const then = new Date(timestamp);
      const seconds = Math.floor((now - then) / 1000);

      if (seconds < 60) return 'Just now';
      if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
      if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
      if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
      return then.toLocaleDateString();
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    console.log('✅ Profile Modal System initialized');
  })();

  (function wireUpWelcomeButton() {
    const welcomeBtn = document.getElementById('welcomeBtn');
    console.log('🔍 [Welcome Button] Found button:', welcomeBtn);
    if (welcomeBtn) {
      welcomeBtn.addEventListener('click', () => {
        console.log('🐻 Welcome button clicked!');
        const wallet = localStorage.getItem('bearpark_wallet');
        console.log('🔍 [Welcome Button] Wallet:', wallet);
        if (!wallet) {
          // No wallet - shouldn't happen since user needs wallet to access site
          console.log('⚠️ [Welcome Button] No wallet found');
          return;
        }

        // Check if user has completed profile setup
        // NOTE: Using bear_profile_ (without "park") to match updateWelcomeButton
        const profileKey = `bear_profile_${wallet}`;
        const localProfile = localStorage.getItem(profileKey);
        console.log('🔍 [Welcome Button] Profile key:', profileKey);
        console.log('🔍 [Welcome Button] Local profile:', localProfile);

        let hasProfile = false;
        if (localProfile) {
          try {
            const profile = JSON.parse(localProfile);
            // Profile is considered "set" if it has both display_name and avatar
            hasProfile = profile.display_name && (profile.avatar_nft || profile.avatar_url);
            console.log('🔍 [Welcome Button] Has profile:', hasProfile, profile);
          } catch (e) {
            hasProfile = false;
            console.log('❌ [Welcome Button] Error parsing profile:', e);
          }
        }

        if (hasProfile) {
          // User has profile - open profile modal
          console.log('✅ [Welcome Button] Opening profile modal');
          openProfileModal();
        } else {
          // New user without profile - open drawer and scroll to profile setup
          console.log('✅ [Welcome Button] Opening profile setup');
          window.openProfileSetup();
        }
      });
      console.log('✅ Welcome button wired to open profile modal');
    } else {
      console.error('❌ Welcome button not found!');
    }
  })();

  // PWA Install & Notifications
  let deferredPrompt;

  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    const btn = document.getElementById('installAppBtn');
    if (btn) {
      btn.style.display = 'block';
      document.getElementById('pwaControls').style.display = 'block';
    }
  });

  document.getElementById('installAppBtn')?.addEventListener('click', async () => {
    if (!deferredPrompt) return;
    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;
    console.log(`🐻 PWA install: ${outcome}`);
    deferredPrompt = null;
    document.getElementById('installAppBtn').style.display = 'none';
  });

  document.getElementById('enableNotificationsBtn')?.addEventListener('click', async () => {
    const btn = document.getElementById('enableNotificationsBtn');
    btn.disabled = true;
    btn.textContent = '⏳ Requesting permission...';

    // Mark that we asked the user
    localStorage.setItem('bearpark_push_asked', 'true');

    const granted = await window.bearPushNotifications.requestPermission();

    if (granted) {
      btn.textContent = '✅ Notifications Enabled!';
      setTimeout(() => {
        btn.style.display = 'none';
        document.getElementById('pwaControls').style.display = 'none';
      }, 2000);
    } else {
      btn.textContent = '🔔 Enable Raid Alerts';
      btn.disabled = false;
      // Still hide the popup after user made a choice
      setTimeout(() => {
        document.getElementById('pwaControls').style.display = 'none';
      }, 3000);
    }
  });

  window.addEventListener('load', async () => {
    // Check if user already accepted push notifications
    const pushEnabled = localStorage.getItem('bearpark_push_enabled') === 'true';
    const subscribed = await window.bearPushNotifications.isSubscribed();

    // Check if user was already asked and denied/dismissed
    const wasAsked = localStorage.getItem('bearpark_push_asked') === 'true';
    const notificationPermission = Notification.permission;

    console.log('🔔 [Push] Status check:', {
      pushEnabled,
      subscribed,
      wasAsked,
      notificationPermission
    });

    // Hide the popup if:
    // 1. User is subscribed/enabled, OR
    // 2. User explicitly denied permission, OR
    // 3. User was already asked before
    if (subscribed || pushEnabled || notificationPermission === 'denied' || wasAsked) {
      const btn = document.getElementById('enableNotificationsBtn');
      if (btn) btn.style.display = 'none';
      console.log('🔔 [Push] Hiding notification prompt');
    } else {
      // Only show if user has never been asked
      document.getElementById('pwaControls').style.display = 'block';
      console.log('🔔 [Push] Showing notification prompt');
    }
  });

  // ===== NOTIFICATION SYSTEM =====
  (function initNotificationSystem() {
    const API_BASE = window.location.hostname === 'localhost' ? 'http://localhost:3000' : 'https://bearpark-production.up.railway.app';
    let notifications = [];
    let unreadCount = 0;

    // Toggle notification panel
    window.toggleNotificationPanel = function() {
      const panel = document.getElementById('notificationPanel');
      const isVisible = panel.classList.contains('visible');

      if (isVisible) {
        closeNotificationPanel();
      } else {
        openNotificationPanel();
      }
    };

    function closeNotificationPanel() {
      const panel = document.getElementById('notificationPanel');
      panel.classList.remove('visible');
      setTimeout(() => panel.style.display = 'none', 300);
      // Remove click-outside listeners
      document.removeEventListener('mousedown', handleClickOutside, true);
      document.removeEventListener('touchstart', handleClickOutsideTouch, true);
      // Remove touch listeners
      panel.removeEventListener('touchstart', handleTouchStart);
      panel.removeEventListener('touchmove', handleTouchMove);
      panel.removeEventListener('touchend', handleTouchEnd);
    }

    function openNotificationPanel() {
      const panel = document.getElementById('notificationPanel');
      panel.style.display = 'flex';
      setTimeout(() => panel.classList.add('visible'), 10);
      // Mark all as read when opening panel
      markAllNotificationsAsRead();

      // Add click-outside listener after a short delay to prevent immediate close
      setTimeout(() => {
        document.addEventListener('mousedown', handleClickOutside, true);
        document.addEventListener('touchstart', handleClickOutsideTouch, true);
      }, 100);

      // Add touch/swipe listeners for mobile
      panel.addEventListener('touchstart', handleTouchStart, { passive: true });
      panel.addEventListener('touchmove', handleTouchMove, { passive: false });
      panel.addEventListener('touchend', handleTouchEnd);
    }

    // Click outside to close (desktop)
    function handleClickOutside(event) {
      const panel = document.getElementById('notificationPanel');
      const bellBtn = document.getElementById('notificationBellBtn');

      // Don't close if clicking the bell button or inside the panel
      if (!panel.contains(event.target) && !bellBtn.contains(event.target)) {
        event.preventDefault();
        event.stopPropagation();
        closeNotificationPanel();
      }
    }

    // Touch outside to close (mobile)
    function handleClickOutsideTouch(event) {
      const panel = document.getElementById('notificationPanel');
      const bellBtn = document.getElementById('notificationBellBtn');

      // Don't close if touching the bell button or inside the panel
      if (!panel.contains(event.target) && !bellBtn.contains(event.target)) {
        event.preventDefault();
        closeNotificationPanel();
      }
    }

    // Touch/swipe handling for mobile
    let touchStartY = 0;
    let touchStartX = 0;
    let currentTranslateY = 0;

    function handleTouchStart(event) {
      const touch = event.touches[0];
      touchStartY = touch.clientY;
      touchStartX = touch.clientX;
      currentTranslateY = 0;
    }

    function handleTouchMove(event) {
      const panel = document.getElementById('notificationPanel');
      const touch = event.touches[0];
      const deltaY = touch.clientY - touchStartY;
      const deltaX = Math.abs(touch.clientX - touchStartX);

      // Only handle vertical swipes (down)
      if (deltaY > 0 && deltaX < 50) {
        currentTranslateY = deltaY;
        panel.style.transform = `translateY(${deltaY}px)`;
        // Prevent page scroll while swiping
        if (deltaY > 10) {
          event.preventDefault();
        }
      }
    }

    function handleTouchEnd(event) {
      const panel = document.getElementById('notificationPanel');

      // If swiped down more than 80px, close the panel
      if (currentTranslateY > 80) {
        panel.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
        panel.style.transform = 'translateY(100%)';
        panel.style.opacity = '0';
        setTimeout(() => {
          closeNotificationPanel();
          panel.style.transform = '';
          panel.style.opacity = '';
          panel.style.transition = '';
        }, 300);
      } else {
        // Snap back
        panel.style.transition = 'transform 0.3s ease';
        panel.style.transform = 'translateY(0)';
        setTimeout(() => {
          panel.style.transition = '';
        }, 300);
      }

      currentTranslateY = 0;
    }

    // Format relative time
    function formatRelativeTime(timestamp) {
      const now = Date.now();
      const diff = now - new Date(timestamp).getTime();
      const seconds = Math.floor(diff / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      if (days > 0) return `${days}d ago`;
      if (hours > 0) return `${hours}h ago`;
      if (minutes > 0) return `${minutes}m ago`;
      return 'Just now';
    }

    // Render notifications
    function renderNotifications() {
      console.log('🎨 renderNotifications called, count:', notifications.length);
      const list = document.getElementById('notificationList');

      if (notifications.length === 0) {
        list.innerHTML = `
          <div class="notification-empty">
            <div class="notification-empty-icon">🔕</div>
            <p>No notifications yet!</p>
          </div>
        `;
        return;
      }

      list.innerHTML = notifications.map(notif => {
        const unreadClass = notif.read ? '' : 'unread';

        // Helper function to render user avatar
        const renderAvatar = (avatarNft, displayName) => {
          let avatarHTML = '';
          if (avatarNft) {
            try {
              const avatarData = JSON.parse(avatarNft);
              const avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl;
              if (avatarUrl) {
                avatarHTML = `<img src="${avatarUrl}" style="width:40px; height:40px; border-radius:50%; object-fit:cover;" alt="${displayName} avatar" onerror="this.src='https://files.catbox.moe/ugu1kl.png'">`;
              }
            } catch (e) {
              // If not JSON, try using it directly as NFT ID
              avatarHTML = `<img src="https://nft.xrpl-labs.com/${avatarNft}" style="width:40px; height:40px; border-radius:50%; object-fit:cover;" alt="${displayName} avatar" onerror="this.src='https://files.catbox.moe/ugu1kl.png'">`;
            }
          }
          // Default avatar if none provided
          if (!avatarHTML) {
            avatarHTML = `<img src="https://files.catbox.moe/ugu1kl.png" style="width:40px; height:40px; border-radius:50%; object-fit:cover;" alt="${displayName} avatar">`;
          }
          return avatarHTML;
        };

        if (notif.type === 'follower') {
          return `
            <div class="notification-item ${unreadClass}" data-notification-id="${notif.id}">
              ${renderAvatar(notif.data.avatarNft, notif.data.displayName || 'Anonymous')}
              <div class="notification-content">
                <p class="notification-text"><strong>${notif.data.displayName || notif.data.wallet}</strong> followed you!</p>
                <p class="notification-time">${formatRelativeTime(notif.created_at)}</p>
              </div>
            </div>
          `;
        } else if (notif.type === 'reaction') {
          const emojis = notif.data.reactions || [];
          return `
            <div class="notification-item ${unreadClass}" data-notification-id="${notif.id}">
              ${renderAvatar(notif.data.avatarNft, notif.data.displayName || 'Anonymous')}
              <div class="notification-content">
                <p class="notification-text"><strong>${notif.data.displayName || notif.data.wallet}</strong> reacted to your comment</p>
                <div class="notification-reactions">
                  ${emojis.map(emoji => `<span class="notification-reaction-emoji">${emoji}</span>`).join('')}
                </div>
                <p class="notification-time">${formatRelativeTime(notif.created_at)}</p>
              </div>
            </div>
          `;
        } else if (notif.type === 'bulletin_comment') {
          return `
            <div class="notification-item ${unreadClass}" data-notification-id="${notif.id}">
              ${renderAvatar(notif.data.avatarNft, notif.data.displayName || 'Anonymous')}
              <div class="notification-content">
                <p class="notification-text"><strong>${notif.data.displayName || notif.data.wallet}</strong> commented on your bulletin post</p>
                ${notif.data.commentText ? `<p class="notification-preview">"${notif.data.commentText}"</p>` : ''}
                <p class="notification-time">${formatRelativeTime(notif.created_at)}</p>
              </div>
            </div>
          `;
        } else if (notif.type === 'bulletin_reply') {
          return `
            <div class="notification-item ${unreadClass}" data-notification-id="${notif.id}">
              ${renderAvatar(notif.data.avatarNft, notif.data.displayName || 'Anonymous')}
              <div class="notification-content">
                <p class="notification-text"><strong>${notif.data.displayName || notif.data.wallet}</strong> replied to your comment</p>
                ${notif.data.commentText ? `<p class="notification-preview">"${notif.data.commentText}"</p>` : ''}
                <p class="notification-time">${formatRelativeTime(notif.created_at)}</p>
              </div>
            </div>
          `;
        } else if (notif.type === 'bulletin_post_reaction') {
          const emojis = notif.data.reactions || [];
          return `
            <div class="notification-item ${unreadClass}" data-notification-id="${notif.id}">
              ${renderAvatar(notif.data.avatarNft, notif.data.displayName || 'Anonymous')}
              <div class="notification-content">
                <p class="notification-text"><strong>${notif.data.displayName || notif.data.wallet}</strong> reacted to your bulletin post</p>
                <div class="notification-reactions">
                  ${emojis.map(emoji => `<span class="notification-reaction-emoji">${emoji}</span>`).join('')}
                </div>
                <p class="notification-time">${formatRelativeTime(notif.created_at)}</p>
              </div>
            </div>
          `;
        } else if (notif.type === 'bulletin_comment_reaction') {
          const emojis = notif.data.reactions || [];
          return `
            <div class="notification-item ${unreadClass}" data-notification-id="${notif.id}">
              ${renderAvatar(notif.data.avatarNft, notif.data.displayName || 'Anonymous')}
              <div class="notification-content">
                <p class="notification-text"><strong>${notif.data.displayName || notif.data.wallet}</strong> reacted to your bulletin comment</p>
                <div class="notification-reactions">
                  ${emojis.map(emoji => `<span class="notification-reaction-emoji">${emoji}</span>`).join('')}
                </div>
                ${notif.data.commentText ? `<p class="notification-preview">"${notif.data.commentText}"</p>` : ''}
                <p class="notification-time">${formatRelativeTime(notif.created_at)}</p>
              </div>
            </div>
          `;
        } else if (notif.type === 'profile_comment') {
          return `
            <div class="notification-item ${unreadClass}" data-notification-id="${notif.id}">
              ${renderAvatar(notif.data.avatarNft, notif.data.displayName || 'Anonymous')}
              <div class="notification-content">
                <p class="notification-text"><strong>${notif.data.displayName || notif.data.wallet}</strong> commented on your profile</p>
                ${notif.data.commentText ? `<p class="notification-preview">"${notif.data.commentText}"</p>` : ''}
                <p class="notification-time">${formatRelativeTime(notif.created_at)}</p>
              </div>
            </div>
          `;
        } else if (notif.type === 'profile_reply') {
          return `
            <div class="notification-item ${unreadClass}" data-notification-id="${notif.id}">
              ${renderAvatar(notif.data.avatarNft, notif.data.displayName || 'Anonymous')}
              <div class="notification-content">
                <p class="notification-text"><strong>${notif.data.displayName || notif.data.wallet}</strong> replied to your profile comment</p>
                ${notif.data.commentText ? `<p class="notification-preview">"${notif.data.commentText}"</p>` : ''}
                <p class="notification-time">${formatRelativeTime(notif.created_at)}</p>
              </div>
            </div>
          `;
        }
        return '';
      }).join('');
    }

    // Click handler for notification list (event delegation)
    function handleNotificationListClick(e) {
      console.log('🖱️ Click detected on notification list', e.target);
      const notificationItem = e.target.closest('.notification-item');
      console.log('🖱️ Closest notification item:', notificationItem);
      if (notificationItem) {
        const notificationId = notificationItem.getAttribute('data-notification-id');
        console.log('🖱️ Notification ID:', notificationId);
        if (notificationId) {
          handleNotificationClick(notificationId);
        }
      }
    }

    // Update badge
    function updateBadge() {
      const badge = document.getElementById('notificationBadge');
      const bellBtn = document.getElementById('notificationBellBtn');

      if (unreadCount > 0) {
        badge.textContent = unreadCount > 99 ? '99+' : unreadCount;
        badge.style.display = 'flex';
        bellBtn.classList.add('has-notifications');
      } else {
        badge.style.display = 'none';
        bellBtn.classList.remove('has-notifications');
      }
    }

    // Handle notification click
    window.handleNotificationClick = async function(notificationId) {
      console.log('🔔 Notification clicked:', notificationId);
      const notif = notifications.find(n => n.id === notificationId);
      if (!notif) {
        console.error('❌ Notification not found:', notificationId);
        return;
      }

      console.log('🔔 Notification data:', notif);

      // Mark as read
      notif.read = true;
      saveNotificationsToLocalStorage();
      recalculateUnreadCount();
      renderNotifications();
      updateBadge();

      // Navigate based on type
      if (notif.type === 'follower' && notif.data.wallet) {
        console.log('👤 Opening follower profile:', notif.data.wallet);
        // Open the follower's profile
        toggleNotificationPanel();
        setTimeout(() => openProfileModal(notif.data.wallet), 300);
      } else if (notif.type === 'reaction' && notif.data.profileWallet && notif.data.commentId) {
        console.log('💬 Opening profile with comment:', notif.data.profileWallet, notif.data.commentId);
        // Open the profile where the comment was posted and scroll to that comment
        toggleNotificationPanel();
        setTimeout(async () => {
          await openProfileModal(notif.data.profileWallet, true, {
            scrollToCommentId: notif.data.commentId
          });
        }, 300);
      } else if ((notif.type === 'profile_comment' || notif.type === 'profile_reply') && notif.data.profileWallet && notif.data.commentId) {
        console.log('💬 Opening profile with comment:', notif.data.profileWallet, notif.data.commentId);
        // Open the profile where the comment was posted and scroll to that comment
        toggleNotificationPanel();
        setTimeout(async () => {
          await openProfileModal(notif.data.profileWallet, true, {
            scrollToCommentId: notif.data.commentId
          });
        }, 300);
      } else if ((notif.type === 'bulletin_comment' || notif.type === 'bulletin_reply' || notif.type === 'bulletin_post_reaction' || notif.type === 'bulletin_comment_reaction') && notif.data.postId) {
        console.log('📰 Opening bulletin post:', notif.data.postId);
        // Navigate to bulletin board and open the post DIRECTLY
        toggleNotificationPanel();
        setTimeout(() => {
          // Scroll to bulletin board section
          const bulletinSection = document.getElementById('bulletin-board');
          if (bulletinSection) {
            bulletinSection.scrollIntoView({
              behavior: 'smooth',
              block: 'start'
            });
          }
          // Wait for scroll to complete, then open post
          setTimeout(async () => {
            if (typeof window.openBulletinPost === 'function') {
              await window.openBulletinPost(parseInt(notif.data.postId), notif.data.commentId ? parseInt(notif.data.commentId) : null);
            } else {
              console.error('❌ openBulletinPost function not available');
            }
          }, 1000); // Wait for smooth scroll to complete
        }, 300);
      } else {
        console.warn('⚠️ Notification type not handled or missing data:', notif.type, notif.data);
      }
    };

    // Mark all as read
    function markAllNotificationsAsRead() {
      let changed = false;
      notifications.forEach(notif => {
        if (!notif.read) {
          notif.read = true;
          changed = true;
        }
      });

      if (changed) {
        saveNotificationsToLocalStorage();
        recalculateUnreadCount();
        renderNotifications();
        updateBadge();
      }
    }

    // Recalculate unread count
    function recalculateUnreadCount() {
      unreadCount = notifications.filter(n => !n.read).length;
    }

    // Save to localStorage
    function saveNotificationsToLocalStorage() {
      try {
        localStorage.setItem('bearpark_notifications', JSON.stringify(notifications));
      } catch (e) {
        console.error('Failed to save notifications:', e);
      }
    }

    // Load from localStorage
    function loadNotificationsFromLocalStorage() {
      try {
        const stored = localStorage.getItem('bearpark_notifications');
        if (stored) {
          notifications = JSON.parse(stored);
          // Clean old notifications (older than 7 days)
          const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
          notifications = notifications.filter(n => new Date(n.created_at).getTime() > sevenDaysAgo);
          saveNotificationsToLocalStorage();
        }
      } catch (e) {
        console.error('Failed to load notifications:', e);
        notifications = [];
      }
      recalculateUnreadCount();
    }

    // Add notification
    window.addNotification = function(type, data) {
      const notification = {
        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
        type,
        data,
        read: false,
        created_at: new Date().toISOString()
      };

      notifications.unshift(notification);

      // Limit to 50 notifications
      if (notifications.length > 50) {
        notifications = notifications.slice(0, 50);
      }

      saveNotificationsToLocalStorage();
      recalculateUnreadCount();
      renderNotifications();
      updateBadge();

      // Show brief animation
      const bellBtn = document.getElementById('notificationBellBtn');
      bellBtn.style.animation = 'none';
      setTimeout(() => bellBtn.style.animation = '', 10);
    };

    // Fetch notifications from backend
    async function fetchNotifications() {
      const wallet = localStorage.getItem('bearpark_wallet');
      if (!wallet) return;

      try {
        const response = await fetch(`${API_BASE}/api/notifications/${wallet}`);
        if (!response.ok) return;

        const data = await response.json();
        if (data.notifications && Array.isArray(data.notifications)) {
          // Merge with existing notifications (avoid duplicates)
          const existingIds = new Set(notifications.map(n => n.id));
          const newNotifications = data.notifications.filter(n => !existingIds.has(n.id));

          if (newNotifications.length > 0) {
            notifications = [...newNotifications, ...notifications];
            saveNotificationsToLocalStorage();
            recalculateUnreadCount();
            renderNotifications();
            updateBadge();
          }
        }
      } catch (error) {
        console.error('Failed to fetch notifications:', error);
      }
    }

    // Initialize
    loadNotificationsFromLocalStorage();
    renderNotifications();
    updateBadge();

    // Set up click event delegation on notification list (with delay to ensure DOM is ready)
    setTimeout(() => {
      const notificationListEl = document.getElementById('notificationList');
      console.log('🔧 Setting up notification click listener on:', notificationListEl);
      if (notificationListEl) {
        notificationListEl.addEventListener('click', handleNotificationListClick);
        console.log('✅ Notification click listener attached!');
      } else {
        console.error('❌ Could not find notificationList element!');
      }
    }, 500);

    // Poll for new notifications every 30 seconds
    IntervalManager.set('fetchNotifications', fetchNotifications, 30000); // Use IntervalManager to prevent memory leaks

    // Fetch immediately on load
    setTimeout(fetchNotifications, 2000);

    console.log('✅ Notification system initialized');
  })();

  // Helper: Add follower notification when someone follows you
  window.addEventListener('followerAdded', (e) => {
    if (e.detail && e.detail.followerWallet && e.detail.targetWallet) {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      // Only show notification if someone followed YOU
      if (currentWallet === e.detail.targetWallet) {
        window.addNotification('follower', {
          wallet: e.detail.followerWallet,
          displayName: e.detail.displayName || null
        });
      }
    }
  });

  // Helper: Add reaction notification when someone reacts to your comment
  window.addEventListener('reactionAdded', (e) => {
    if (e.detail && e.detail.commentAuthor && e.detail.reactorWallet) {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      // Only show notification if someone reacted to YOUR comment
      if (currentWallet === e.detail.commentAuthor && currentWallet !== e.detail.reactorWallet) {
        window.addNotification('reaction', {
          wallet: e.detail.reactorWallet,
          displayName: e.detail.displayName || null,
          reactions: e.detail.reactions || [],
          commentText: e.detail.commentText || null
        });
      }
    }
  });

  </script>

  <!-- ===== COSMETICS STORE MODAL ===== -->
  <div id="storeModal" class="store-modal">
    <div class="store-modal-content">
      <div class="store-header">
        <div class="store-title-section">
          <h2 class="store-title">🍯 HONEY POINTS STORE</h2>
          <div class="store-subtitle">Unlock legendary cosmetics with your points</div>
        </div>
        <div class="store-balance-container">
          <div class="store-balance">
            <span class="hp-amount" id="storeHoneyBalance">0</span> <span style="font-size: 20px;">HP</span>
          </div>
          <button class="store-close-btn" onclick="closeStoreModal()">×</button>
        </div>
      </div>

      <div class="store-tabs">
        <div class="store-tab active" onclick="switchStoreTab('rings', event)">
          <span>💍 Profile Rings</span>
        </div>
        <div class="store-tab" onclick="switchStoreTab('banners', event)">
          <span>🎨 Profile Banners</span>
        </div>
      </div>

      <div class="store-body">
        <div id="storeRingsGrid" class="store-grid"></div>
        <div id="storeBannersGrid" class="store-grid" style="display: none;"></div>
      </div>
    </div>
  </div>

  <!-- Inventory Modal -->
  <div id="inventoryModal" class="store-modal">
    <div class="store-modal-content">
      <div class="store-header" style="background:linear-gradient(135deg, #8b5cf6, #7c3aed);">
        <div class="store-title-section">
          <h2 class="store-title">🎒 MY INVENTORY</h2>
          <div class="store-subtitle">Equip and manage your cosmetics</div>
        </div>
        <div class="store-balance-container">
          <button class="store-close-btn" onclick="closeInventoryModal()">×</button>
        </div>
      </div>

      <div class="store-tabs">
        <div class="store-tab active" onclick="switchInventoryTab('rings', event)">
          <span>💍 Profile Rings</span>
        </div>
        <div class="store-tab" onclick="switchInventoryTab('banners', event)">
          <span>🎨 Profile Banners</span>
        </div>
      </div>

      <div class="store-body">
        <div id="inventoryRingsGrid" class="store-grid"></div>
        <div id="inventoryBannersGrid" class="store-grid" style="display: none;"></div>
        <div id="inventoryEmptyState" style="display:none; text-align:center; padding:60px 20px; color:#888;">
          <div style="font-size:48px; margin-bottom:20px;">📦</div>
          <div style="font-size:20px; font-weight:700; margin-bottom:10px;">Your inventory is empty</div>
          <div style="font-size:16px;">Visit the store to purchase cosmetics!</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Bulletin Post Detail Modal -->
  <div id="bulletinPostModal" class="bulletin-post-modal" style="display:none;">
    <div class="bulletin-modal-overlay" onclick="closeBulletinPostModal()"></div>
    <div class="bulletin-modal-content">
      <div class="bulletin-modal-header">
        <h3 class="bulletin-modal-title">Bulletin Post</h3>
        <button class="bulletin-close-btn" onclick="closeBulletinPostModal()">&times;</button>
      </div>
      <div class="bulletin-modal-body">
        <!-- Post Content -->
        <div id="bulletinPostDetail" class="bulletin-post-detail"></div>

        <!-- Comments Section -->
        <div class="bulletin-comments-section">
          <h4 class="comments-title">💬 Comments</h4>

          <!-- Comment Input -->
          <div class="comment-input-container">
            <textarea
              id="commentInput"
              class="comment-input"
              placeholder="Add a comment..."
              maxlength="500"
              rows="2"
            ></textarea>
            <button class="btn-post-comment" onclick="postComment()">Post Comment</button>
          </div>

          <!-- Comments List -->
          <div id="commentsList" class="comments-list">
            <div class="loading">Loading comments...</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Celebration Overlay -->
  <div id="celebrationOverlay" class="celebration-overlay">
    <div class="celebration-content">
      <div class="celebration-icon" id="celebrationIcon"></div>
      <div class="celebration-text" id="celebrationText"></div>
      <div class="celebration-subtext" id="celebrationSubtext"></div>
    </div>
  </div>

  <script>
    // ===== BEAR BULLETIN BOARD JAVASCRIPT =====
    let currentPostId = null;
    let bulletinPosts = [];
    const BULLETIN_DEMO_MODE = false; // Using Supabase backend
    let isAdminOrModerator = false; // Will be set after checking admin status

    // State storage for bulletin like buttons
    const bulletinButtonStates = new Map();

    function getBulletinButtonState(btn) {
      if (!bulletinButtonStates.has(btn)) {
        bulletinButtonStates.set(btn, {
          longPressTimer: null,
          picker: null,
          currentHoveredItem: null,
          selectedReaction: null,
          pickerShown: false
        });
      }
      return bulletinButtonStates.get(btn);
    }

    // Build nested comment tree from flat array (bulletin version)
    function buildBulletinCommentTree(comments) {
      const commentMap = {};
      const rootComments = [];

      // First pass: create map of all comments
      comments.forEach(comment => {
        commentMap[comment.id] = { ...comment, children: [] };
      });

      // Second pass: build tree structure
      comments.forEach(comment => {
        if (comment.parent_id && commentMap[comment.parent_id]) {
          commentMap[comment.parent_id].children.push(commentMap[comment.id]);
        } else {
          rootComments.push(commentMap[comment.id]);
        }
      });

      return rootComments;
    }

    // Toggle collapse/expand thread (bulletin version)
    window.toggleBulletinThread = function(commentId) {
      const threadElement = document.querySelector(`.bulletin-comment-thread[data-comment-id="${commentId}"]`);
      if (!threadElement) return;

      const repliesContainer = threadElement.querySelector('.bulletin-comment-replies');
      const toggleIcon = threadElement.querySelector('.bulletin-toggle-icon');

      if (!repliesContainer) return;

      if (repliesContainer.style.display === 'none') {
        repliesContainer.style.display = 'block';
        toggleIcon.textContent = '▼';
        threadElement.classList.remove('collapsed');
      } else {
        repliesContainer.style.display = 'none';
        toggleIcon.textContent = '▶';
        threadElement.classList.add('collapsed');
      }
    };

    // Open profile modal and highlight bulletin input
    function openPostBulletinHighlight() {
      // Open the profile modal
      openProfileModal();

      // Wait for modal to open, then highlight the bulletin input
      setTimeout(() => {
        const bulletinContainer = document.querySelector('.bulletin-post-input-container');
        const bulletinInput = document.getElementById('bulletinPostInput');

        if (bulletinContainer && bulletinInput) {
          // Add highlight animation
          bulletinContainer.style.cssText = `
            animation: highlightPulse 2s ease-in-out 3;
            box-shadow: 0 0 30px rgba(237, 183, 35, 0.8), 0 0 60px rgba(237, 183, 35, 0.6);
            border: 3px solid #edb723 !important;
          `;

          // Scroll to bulletin input
          bulletinInput.scrollIntoView({ behavior: 'smooth', block: 'center' });

          // Focus the input
          bulletinInput.focus();

          // Remove highlight after animation
          setTimeout(() => {
            bulletinContainer.style.animation = '';
            bulletinContainer.style.boxShadow = '';
            bulletinContainer.style.border = '';
          }, 6000);
        }
      }, 300);
    }

    // Check if current user is admin or moderator
    async function checkAdminStatus() {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        isAdminOrModerator = false;
        return;
      }

      try {
        const response = await fetch(`${API_BASE_URL}/api/admin/check-role/${currentWallet}`);
        if (response.ok) {
          const data = await response.json();
          isAdminOrModerator = data.is_moderator || data.is_admin || data.is_master || false;

          if (isAdminOrModerator) {
            console.log(`🛡️ User has ${data.role?.role || 'admin'} privileges - can moderate bulletin board`);
          }
        } else {
          isAdminOrModerator = false;
        }
      } catch (error) {
        console.error('Error checking admin status:', error);
        isAdminOrModerator = false;
      }
    }

    // Load bulletin feed
    async function loadBulletinFeed() {
      const feed = document.getElementById('bulletinFeed');

      // Check admin status before loading feed
      await checkAdminStatus();

      try {
        if (BULLETIN_DEMO_MODE) {
          // Load from localStorage in demo mode
          const stored = localStorage.getItem('bearpark_bulletin_posts');
          bulletinPosts = stored ? JSON.parse(stored) : [];
          bulletinPosts.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
        } else {
          const response = await fetch(`${API_BASE_URL}/api/bulletin/posts`);
          if (!response.ok) throw new Error('Failed to load posts');
          bulletinPosts = await response.json();
        }

        if (bulletinPosts.length === 0) {
          feed.innerHTML = `
            <div style="text-align:center; padding:60px 20px; color:rgba(255,255,255,0.5);">
              <div style="font-size:48px; margin-bottom:20px;">📋</div>
              <div style="font-size:20px; font-weight:700; margin-bottom:10px;">No posts yet!</div>
              <div style="font-size:16px;">Be the first BEAR to share something!</div>
            </div>
          `;
          return;
        }

        feed.innerHTML = bulletinPosts.map(post => createPostCard(post)).join('');
      } catch (error) {
        console.error('Error loading bulletin feed:', error);
        feed.innerHTML = `
          <div style="text-align:center; padding:40px 20px; color:#ff6b6b;">
            <div style="font-size:24px; margin-bottom:12px;">⚠️</div>
            <div>Failed to load posts. Please try again later.</div>
          </div>
        `;
      }
    }

    // Create post card HTML
    // Convert URLs in text to clickable links
    function linkifyText(text) {
      // First escape HTML for security
      const escaped = escapeHtml(text);
      // Then convert URLs to clickable links
      const urlRegex = /(https?:\/\/[^\s<]+)/g;
      return escaped.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer" onclick="event.stopPropagation()" class="bulletin-link">$1</a>');
    }

    // Helper function to parse avatar JSONB data
    function getAvatarUrl(authorAvatar) {
      if (!authorAvatar) return 'https://files.catbox.moe/esp426.png';

      try {
        const avatarData = typeof authorAvatar === 'string' ? JSON.parse(authorAvatar) : authorAvatar;
        return avatarData.imageUrl || avatarData.fallbackImageUrl || 'https://files.catbox.moe/esp426.png';
      } catch (e) {
        return 'https://files.catbox.moe/esp426.png';
      }
    }

    function createPostCard(post) {
      const timeAgo = getTimeAgo(post.created_at);
      const linkPreview = post.link_preview ? createLinkPreview(post.link_preview) : '';
      const currentWallet = localStorage.getItem('bearpark_wallet');
      const isOwner = currentWallet && post.wallet_address === currentWallet;
      const avatarUrl = getAvatarUrl(post.author_avatar);

      // Calculate total reaction count
      const reactionCount = post.reaction_count || 0;

      return `
        <div class="bulletin-post-card" onclick="openBulletinPost(${post.id})">
          <div class="bulletin-post-header">
            <img
              src="${avatarUrl}"
              alt="${post.author_name}"
              class="bulletin-post-avatar"
              onerror="this.src='https://files.catbox.moe/esp426.png';"
            />
            <div class="bulletin-post-info">
              <div class="bulletin-post-author">${escapeHtml(post.author_name)}</div>
              <div class="bulletin-post-time">${timeAgo}</div>
            </div>
            ${isOwner ? `
              <button class="bulletin-delete-btn" onclick="event.stopPropagation(); deletePost(${post.id})" title="Delete post">
                🗑️
              </button>
            ` : ''}
          </div>
          <div class="bulletin-post-content">${linkifyText(post.content)}</div>
          ${linkPreview}
          <div class="bulletin-post-footer">
            ${reactionCount > 0 ? `
              <div class="bulletin-post-stat">
                ❤️ ${reactionCount} ${reactionCount === 1 ? 'reaction' : 'reactions'}
              </div>
            ` : ''}
            <div class="bulletin-post-stat">
              💬 ${post.comment_count || 0} ${post.comment_count === 1 ? 'comment' : 'comments'}
            </div>
          </div>
        </div>
      `;
    }

    // Create link preview HTML (Twitter/X style)
    function createLinkPreview(preview) {
      if (!preview || !preview.url) return '';

      const isYouTube = preview.type === 'youtube';
      const hostname = new URL(preview.url).hostname.replace('www.', '');

      return `
        <div class="bulletin-post-link-preview ${isYouTube ? 'youtube-preview' : ''}" onclick="event.stopPropagation(); window.open('${escapeHtml(preview.url)}', '_blank')">
          ${preview.image ? `
            <div class="bulletin-post-link-image-container">
              <img src="${escapeHtml(preview.image)}" alt="" class="bulletin-post-link-image" onerror="this.style.display='none'">
              ${isYouTube ? '<div class="youtube-play-overlay">▶</div>' : ''}
            </div>
          ` : ''}
          <div class="bulletin-post-link-info">
            <div class="bulletin-post-link-title">${escapeHtml(preview.title || 'Link')}</div>
            ${preview.description ? `<div class="bulletin-post-link-description">${escapeHtml(preview.description)}</div>` : ''}
            <div class="bulletin-post-link-url">
              🔗 ${escapeHtml(hostname)}
            </div>
          </div>
        </div>
      `;
    }

    // Post to bulletin board
    async function postToBulletin() {
      const input = document.getElementById('bulletinPostInput');
      const button = document.getElementById('postToBulletinBtn');
      const content = input.value.trim();

      if (!content) {
        showBulletinNotification('⚠️ Please enter some content to post!', 'warning');
        return;
      }

      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        showBulletinNotification('⚠️ Please connect your wallet first!', 'warning');
        return;
      }

      button.disabled = true;
      button.textContent = 'Posting...';

      try {
        // Check if content contains URLs
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        const urls = content.match(urlRegex);
        let linkPreview = null;

        if (urls && urls.length > 0 && !BULLETIN_DEMO_MODE) {
          // Fetch link preview for the first URL (not in demo mode)
          try {
            const previewResponse = await fetch(`${API_BASE_URL}/api/link-preview?url=${encodeURIComponent(urls[0])}`);
            if (previewResponse.ok) {
              linkPreview = await previewResponse.json();
              console.log('✅ Link preview fetched:', linkPreview);
            }
          } catch (e) {
            console.log('❌ Link preview failed, continuing without it:', e);
          }
        }

        let newPost;

        if (BULLETIN_DEMO_MODE) {
          // Demo mode: save to localStorage
          // Get profile from localStorage or fetch from API
          let authorName = 'Anonymous BEAR';
          let authorAvatar = 'https://files.catbox.moe/esp426.png';

          // Try to get from current session first
          const cachedProfile = localStorage.getItem(`bearpark_profile_${currentWallet}`);
          console.log('🐻 Loading profile for wallet:', currentWallet);
          console.log('💾 Cached profile:', cachedProfile);

          if (cachedProfile) {
            try {
              const profileData = JSON.parse(cachedProfile);
              // Handle nested structure from API (profile.profile.display_name)
              const profile = profileData.profile || profileData;
              authorName = profile.display_name || 'Anonymous BEAR';

              // Parse avatar_nft JSON to get imageUrl
              if (profile.avatar_nft) {
                try {
                  const avatarData = typeof profile.avatar_nft === 'string'
                    ? JSON.parse(profile.avatar_nft)
                    : profile.avatar_nft;
                  authorAvatar = avatarData.imageUrl || avatarData.fallbackImageUrl || 'https://files.catbox.moe/esp426.png';
                } catch (e) {
                  console.log('Failed to parse avatar_nft, using default');
                  authorAvatar = 'https://files.catbox.moe/esp426.png';
                }
              } else {
                authorAvatar = profile.avatar_url || 'https://files.catbox.moe/esp426.png';
              }

              console.log('✅ Using cached profile:', { authorName, authorAvatar });
            } catch (e) {
              console.log('❌ Failed to parse cached profile:', e);
            }
          } else {
            // Fetch from API
            console.log('📡 No cached profile, fetching from API...');
            try {
              const apiUrl = window.location.hostname === 'localhost' ? 'http://localhost:3000' : '';
              const profileResponse = await fetch(`${apiUrl}/api/profile/${currentWallet}`);
              if (profileResponse.ok) {
                const profileData = await profileResponse.json();
                const profile = profileData.profile || profileData;
                authorName = profile.display_name || 'Anonymous BEAR';

                // Parse avatar_nft JSON to get imageUrl
                if (profile.avatar_nft) {
                  try {
                    const avatarData = typeof profile.avatar_nft === 'string'
                      ? JSON.parse(profile.avatar_nft)
                      : profile.avatar_nft;
                    authorAvatar = avatarData.imageUrl || avatarData.fallbackImageUrl || 'https://files.catbox.moe/esp426.png';
                  } catch (e) {
                    authorAvatar = 'https://files.catbox.moe/esp426.png';
                  }
                } else {
                  authorAvatar = profile.avatar_url || profile.profile_picture || 'https://files.catbox.moe/esp426.png';
                }

                // Cache it
                localStorage.setItem(`bearpark_profile_${currentWallet}`, JSON.stringify(profileData));
                console.log('✅ Fetched and cached profile:', { authorName, authorAvatar });
              }
            } catch (e) {
              console.log('❌ Failed to fetch profile, using defaults:', e);
            }
          }

          // Generate link preview for demo mode using microlink.io
          if (urls && urls.length > 0) {
            try {
              const previewUrl = `https://api.microlink.io/?url=${encodeURIComponent(urls[0])}`;
              const previewResponse = await fetch(previewUrl);
              if (previewResponse.ok) {
                const previewData = await previewResponse.json();
                if (previewData.status === 'success' && previewData.data) {
                  linkPreview = {
                    url: urls[0],
                    title: previewData.data.title || urls[0],
                    description: previewData.data.description || 'Click to open link',
                    image: previewData.data.image?.url || previewData.data.logo?.url || null
                  };
                }
              }
            } catch (e) {
              console.log('Link preview fetch failed, using simple preview');
              linkPreview = {
                url: urls[0],
                title: urls[0],
                description: 'Click to open link',
                image: null
              };
            }
          }

          newPost = {
            id: Date.now().toString(),
            wallet_address: currentWallet,
            author_name: authorName,
            author_avatar: authorAvatar,
            content: content,
            link_preview: linkPreview,
            created_at: new Date().toISOString(),
            comment_count: 0
          };

          const stored = localStorage.getItem('bearpark_bulletin_posts');
          const posts = stored ? JSON.parse(stored) : [];
          posts.unshift(newPost);
          localStorage.setItem('bearpark_bulletin_posts', JSON.stringify(posts));

          // Also initialize comments storage for this post
          localStorage.setItem(`bearpark_bulletin_comments_${newPost.id}`, JSON.stringify([]));
        } else {
          const response = await fetch(`${API_BASE_URL}/api/bulletin/posts`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              wallet_address: currentWallet,
              content: content,
              link_preview: linkPreview
            })
          });

          if (!response.ok) throw new Error('Failed to create post');
          newPost = await response.json();
        }

        // Clear input
        input.value = '';

        // Reload feed
        await loadBulletinFeed();

        showBulletinNotification('Your post is now on the bulletin board!', 'success');

        // Scroll bulletin board into view
        const bulletinSection = document.getElementById('bulletin-board');
        if (bulletinSection) {
          bulletinSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      } catch (error) {
        console.error('Error posting to bulletin:', error);
        showBulletinNotification('❌ Failed to post. Please try again.', 'error');
      } finally {
        button.disabled = false;
        button.textContent = '📢 Post to Bulletin Board';
      }
    }

    // Open bulletin post modal
    // Make openBulletinPost globally accessible for notifications
    window.openBulletinPost = async function(postId, scrollToCommentId = null) {
      currentPostId = postId;
      const modal = document.getElementById('bulletinPostModal');
      const detailContainer = document.getElementById('bulletinPostDetail');
      const commentsContainer = document.getElementById('commentsList');

      if (!modal) {
        console.error('❌ Bulletin post modal not found - bulletin board may not be initialized');
        return;
      }

      modal.style.display = 'flex';
      document.body.style.overflow = 'hidden';

      // If bulletinPosts is empty, load it first
      if (bulletinPosts.length === 0) {
        console.log('📥 Bulletin posts not loaded yet, loading now...');
        await loadBulletinFeed();
      }

      // Find the post
      const post = bulletinPosts.find(p => p.id === postId);
      if (!post) {
        detailContainer.innerHTML = '<div class="loading">Post not found</div>';
        return;
      }

      // Render post detail
      const timeAgo = getTimeAgo(post.created_at);
      const linkPreview = post.link_preview ? createLinkPreview(post.link_preview) : '';
      const avatarUrl = getAvatarUrl(post.author_avatar);

      detailContainer.innerHTML = `
        <div class="bulletin-post-header">
          <img
            src="${avatarUrl}"
            alt="${post.author_name}"
            class="bulletin-post-avatar"
            onerror="this.src='https://files.catbox.moe/esp426.png';"
          />
          <div class="bulletin-post-info">
            <div class="bulletin-post-author">${escapeHtml(post.author_name)}</div>
            <div class="bulletin-post-time">${timeAgo}</div>
          </div>
        </div>
        <div class="bulletin-post-content">${linkifyText(post.content)}</div>
        ${linkPreview}
        <div id="postReactionContainer" style="margin-top: 20px; padding-top: 16px; border-top: 1px solid rgba(237, 183, 35, 0.2);">
          <div id="postReactionSummary" style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 12px;"></div>
          <div class="comment-actions">
            <button class="like-button" id="postLikeButton" data-post-id="${postId}">
              <span class="like-emoji">👍</span>
              <span>Like</span>
              ${generatePostReactionPicker(postId)}
            </button>
          </div>
        </div>
      `;

      // Load post reactions
      await loadPostReactions(postId);

      // Attach post reaction listener
      attachPostReactionListener();

      // Load comments
      await loadComments(postId);

      // Scroll to specific comment if provided (from notification)
      if (scrollToCommentId) {
        setTimeout(() => {
          const commentThread = document.querySelector(`.bulletin-comment-thread[data-comment-id="${scrollToCommentId}"]`);
          if (commentThread) {
            // If this is a reply, we need to expand all parent threads first
            if (commentThread.classList.contains('is-reply')) {
              // Find all ancestor reply containers and expand them
              let currentElement = commentThread.parentElement;
              while (currentElement && currentElement !== modal) {
                if (currentElement.classList.contains('bulletin-comment-replies')) {
                  // This is a replies container - make sure it's visible
                  if (currentElement.style.display === 'none') {
                    currentElement.style.display = 'block';
                    // Update the toggle icon
                    const parentThread = currentElement.parentElement;
                    if (parentThread) {
                      const toggleIcon = parentThread.querySelector('.bulletin-toggle-icon');
                      if (toggleIcon) {
                        toggleIcon.textContent = '▼';
                      }
                      parentThread.classList.remove('collapsed');
                    }
                  }
                }
                currentElement = currentElement.parentElement;
              }
            }

            // Now scroll to the comment
            setTimeout(() => {
              const modalBody = modal.querySelector('.bulletin-modal-body');
              if (modalBody) {
                const commentTop = commentThread.offsetTop;
                modalBody.scrollTo({
                  top: commentTop - 100,
                  behavior: 'smooth'
                });
                // Add gold glow highlight effect
                commentThread.style.backgroundColor = 'rgba(237, 183, 35, 0.3)';
                commentThread.style.boxShadow = '0 0 20px rgba(237, 183, 35, 0.5)';
                commentThread.style.transition = 'all 0.3s ease';
                setTimeout(() => {
                  commentThread.style.backgroundColor = '';
                  commentThread.style.boxShadow = '';
                }, 2500);
              }
            }, 200);
          } else {
            console.warn('⚠️ Comment not found:', scrollToCommentId);
          }
        }, 500);
      }
    }

    // Close bulletin post modal
    function closeBulletinPostModal() {
      const modal = document.getElementById('bulletinPostModal');
      modal.style.display = 'none';
      document.body.style.overflow = '';
      currentPostId = null;
    }

    // Load reactions for the bulletin post
    async function loadPostReactions(postId) {
      try {
        const response = await fetch(`${API_BASE_URL}/api/bulletin/posts/${postId}/reactions`);
        if (!response.ok) return;

        const data = await response.json();
        updatePostReactionSummary(postId, data);
      } catch (error) {
        console.error('Error loading post reactions:', error);
      }
    }

    // Update post reaction summary display
    function updatePostReactionSummary(postId, reactionsData) {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      const userReactions = reactionsData.userReactions?.[currentWallet] || [];
      const counts = reactionsData.counts || {};

      const summaryContainer = document.getElementById('postReactionSummary');
      if (!summaryContainer) return;

      // Generate reaction pills
      const reactionTypes = [
        { type: 'like', emoji: '👍' },
        { type: 'laugh', emoji: '😂' },
        { type: 'heart', emoji: '❤️' },
        { type: 'cry', emoji: '😢' },
        { type: 'thumbs_down', emoji: '👎' },
        { type: 'troll', emoji: '🤡' }
      ];

      const pills = reactionTypes
        .filter(({ type }) => counts[type] > 0)
        .map(({ type, emoji }) => {
          const isUserReaction = userReactions.includes(type);
          const clickHandler = `togglePostReaction(${postId}, '${type}')`;
          return `
            <div class="reaction-pill ${isUserReaction ? 'user-reacted' : ''}"
                 data-post-id="${postId}"
                 data-reaction-type="${type}"
                 onclick="${clickHandler}">
              <span class="pill-emoji">${emoji}</span>
              <span class="pill-count">${counts[type]}</span>
            </div>
          `;
        }).join('');

      summaryContainer.innerHTML = pills;

      // Update like button state
      const likeButton = document.getElementById('postLikeButton');
      if (likeButton && userReactions.length > 0) {
        likeButton.classList.add('reacted');
      } else if (likeButton) {
        likeButton.classList.remove('reacted');
      }
    }

    // Generate reaction picker for post
    function generatePostReactionPicker(postId) {
      const reactionTypes = [
        { type: 'like', emoji: '👍', label: 'Like' },
        { type: 'laugh', emoji: '😂', label: 'Laugh' },
        { type: 'heart', emoji: '❤️', label: 'Love' },
        { type: 'cry', emoji: '😢', label: 'Sad' },
        { type: 'thumbs_down', emoji: '👎', label: 'Dislike' },
        { type: 'troll', emoji: '🤡', label: 'Troll' }
      ];

      const items = reactionTypes.map(({ type, emoji, label }) => `
        <div class="reaction-picker-item" data-reaction-type="${type}" data-label="${label}">
          ${emoji}
        </div>
      `).join('');

      return `<div class="reaction-picker" data-post-id="${postId}">${items}</div>`;
    }

    // Toggle reaction on the post
    window.togglePostReaction = async function(postId, reactionType) {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        showBulletinNotification('⚠️ Please connect your wallet first!', 'warning');
        return;
      }

      try {
        const response = await fetch(`${API_BASE_URL}/api/bulletin/posts/${postId}/react`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet_address: currentWallet,
            reaction_type: reactionType
          })
        });

        const result = await response.json();

        if (response.ok && result.success) {
          // Update UI with new counts
          updatePostReactionSummary(postId, {
            counts: result.counts || {},
            userReactions: result.userReactions || {}
          });
        }
      } catch (error) {
        console.error('Error toggling post reaction:', error);
        showBulletinNotification('❌ Failed to add reaction.', 'error');
      }
    };

    // Attach event listeners to post reaction button using delegation (like comments)
    function attachPostReactionListener() {
      const postReactionContainer = document.getElementById('postReactionContainer');
      if (!postReactionContainer || postReactionContainer.dataset.likeListenersAttached) return;

      postReactionContainer.dataset.likeListenersAttached = 'true';

      const buttonState = {
        longPressTimer: null,
        pickerShown: false,
        selectedReaction: null,
        currentHoveredItem: null,
        picker: null
      };

      function showPicker() {
        const btn = document.getElementById('postLikeButton');
        if (!btn) return;
        buttonState.picker = btn.querySelector('.reaction-picker');
        if (buttonState.picker) {
          buttonState.picker.classList.add('visible');
          buttonState.pickerShown = true;
          if (navigator.vibrate) navigator.vibrate(10);
        }
      }

      function hidePicker() {
        if (buttonState.picker) {
          buttonState.picker.classList.remove('visible');
          buttonState.pickerShown = false;
          const items = buttonState.picker.querySelectorAll('.reaction-picker-item');
          items.forEach(item => { item.style.transform = ''; item.style.filter = ''; });
        }
      }

      function getEmojiAtTouch(picker, touch) {
        const pickerItems = picker?.querySelectorAll('.reaction-picker-item');
        if (!pickerItems) return null;

        for (const item of pickerItems) {
          const rect = item.getBoundingClientRect();
          if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
              touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
            return item;
          }
        }
        return null;
      }

      function updateHoveredEmoji(touch) {
        if (!buttonState.picker || !buttonState.pickerShown) return;

        const hoveredItem = getEmojiAtTouch(buttonState.picker, touch);

        if (hoveredItem !== buttonState.currentHoveredItem) {
          if (buttonState.currentHoveredItem) {
            buttonState.currentHoveredItem.style.transform = '';
            buttonState.currentHoveredItem.style.filter = '';
          }
          if (hoveredItem) {
            hoveredItem.style.transform = 'scale(1.8) translateY(-12px)';
            hoveredItem.style.filter = 'drop-shadow(0 8px 20px rgba(237,183,35,0.8))';
            if (navigator.vibrate) navigator.vibrate(5);
            buttonState.selectedReaction = hoveredItem.getAttribute('data-reaction-type');
          } else {
            buttonState.selectedReaction = null;
          }
          buttonState.currentHoveredItem = hoveredItem;
        }
      }

      // Mousedown - start long press timer
      postReactionContainer.addEventListener('mousedown', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        buttonState.longPressTimer = setTimeout(() => showPicker(), 300);
      });

      // Mouseup - clear timer
      postReactionContainer.addEventListener('mouseup', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        clearTimeout(buttonState.longPressTimer);
      });

      // Mouseleave - clear timer but keep picker open
      postReactionContainer.addEventListener('mouseleave', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        clearTimeout(buttonState.longPressTimer);
      }, true);

      // Click - quick like or picker item selection
      postReactionContainer.addEventListener('click', async (e) => {
        // Check if clicked on picker item first
        const pickerItem = e.target.closest('.reaction-picker-item');
        if (pickerItem) {
          e.stopPropagation();
          const btn = e.target.closest('.like-button');
          if (btn) {
            const reactionType = pickerItem.getAttribute('data-reaction-type');
            const postId = btn.getAttribute('data-post-id');
            await togglePostReaction(postId, reactionType);
            hidePicker();
          }
          return;
        }

        // Otherwise check if clicked on button itself
        const btn = e.target.closest('.like-button');
        if (!btn) return;

        buttonState.picker = btn.querySelector('.reaction-picker');
        if (!buttonState.picker || !buttonState.picker.classList.contains('visible')) {
          const postId = btn.getAttribute('data-post-id');
          await togglePostReaction(postId, 'like');
        }
      });

      // Touchstart - start long press
      postReactionContainer.addEventListener('touchstart', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        e.preventDefault();
        buttonState.selectedReaction = null;
        buttonState.currentHoveredItem = null;
        buttonState.longPressTimer = setTimeout(() => showPicker(), 300);
      }, { passive: false });

      // Touchmove - slide to select emoji
      postReactionContainer.addEventListener('touchmove', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;

        if (!buttonState.pickerShown) {
          clearTimeout(buttonState.longPressTimer);
          return;
        }

        e.preventDefault();
        const touch = e.touches[0];
        updateHoveredEmoji(touch);
      }, { passive: false });

      // Touchend - complete reaction
      postReactionContainer.addEventListener('touchend', async (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        clearTimeout(buttonState.longPressTimer);
        buttonState.picker = btn.querySelector('.reaction-picker');

        if (buttonState.pickerShown && buttonState.selectedReaction) {
          const postId = btn.getAttribute('data-post-id');
          await togglePostReaction(postId, buttonState.selectedReaction);
          if (navigator.vibrate) navigator.vibrate([10, 20, 10]);
          hidePicker();
          buttonState.selectedReaction = null;
          buttonState.currentHoveredItem = null;
        } else if (!buttonState.pickerShown) {
          const postId = btn.getAttribute('data-post-id');
          await togglePostReaction(postId, 'like');
        } else {
          hidePicker();
        }
      });
    }

    // Load comments for a post (USING TREE STRUCTURE AND ASYNC RENDERING)
    async function loadComments(postId) {
      console.log('📥 Loading bulletin comments for post:', postId);

      const commentsSection = document.querySelector('.bulletin-comments-section');
      if (!commentsSection) {
        console.error('❌ Comments section not found');
        return;
      }

      // Clear ALL previous content (comments, empty state, loading)
      const allDivs = Array.from(commentsSection.children).filter(el =>
        el.id !== 'commentInput' && !el.classList.contains('comment-input-container') && !el.classList.contains('comments-title')
      );
      allDivs.forEach(el => el.remove());

      // Show loading state
      commentsSection.insertAdjacentHTML('beforeend', '<div class="loading">Loading comments...</div>');

      try {
        // Fetch comments from Supabase API
        const response = await fetch(`${API_BASE_URL}/api/bulletin/posts/${postId}/comments`);
        if (!response.ok) throw new Error('Failed to load comments');
        const comments = await response.json();

        // Remove loading indicator
        document.querySelectorAll('.loading').forEach(el => el.remove());

        if (comments.length === 0) {
          console.log('📝 No comments found for this post');
          commentsSection.insertAdjacentHTML('beforeend', `
            <div style="text-align:center; padding:40px 20px; color:rgba(255,255,255,0.5);">
              <div style="font-size:32px; margin-bottom:12px;">💬</div>
              <div style="font-size:16px;">No comments yet. Be the first!</div>
            </div>
          `);
          return;
        }

        console.log('✅ Building comment tree from', comments.length, 'comments');

        // Build nested tree structure
        const commentTree = buildBulletinCommentTree(comments);
        console.log('🌳 Comment tree built with', commentTree.length, 'root comments');

        // Render root comments and their replies recursively
        for (const rootComment of commentTree) {
          const commentHTML = await renderBulletinComment(rootComment, 0, null);
          commentsSection.insertAdjacentHTML('beforeend', commentHTML);

          // Render nested replies
          if (rootComment.children && rootComment.children.length > 0) {
            await renderBulletinReplies(rootComment.children, rootComment.id, 1, rootComment);
          }
        }

        console.log('💥 Rendered all bulletin comments with nested replies');

        // Attach event listeners for like buttons (only once)
        attachBulletinLikeListeners();

      } catch (error) {
        console.error('❌ Error loading bulletin comments:', error);
        document.querySelectorAll('.loading').forEach(el => el.remove());
        commentsSection.insertAdjacentHTML('beforeend', `
          <div style="text-align:center; padding:20px; color:#ff6b6b;">
            Failed to load comments. Please try again.
          </div>
        `);
      }
    }

    // ===== BULLETIN REACTION SYSTEM (IDENTICAL to profile modal) =====

    // Load reactions for a bulletin comment
    async function loadBulletinCommentReactions(commentId) {
      try {
        const response = await fetch(`${API_BASE_URL}/api/bulletin/comments/${commentId}/reactions`);
        if (!response.ok) return { counts: {}, userReactions: {} };

        const data = await response.json();
        return data;
      } catch (error) {
        console.error('Error loading bulletin reactions:', error);
        return { counts: {}, userReactions: {} };
      }
    }

    // Generate reaction summary pills for bulletin comments
    function generateBulletinReactionSummary(commentId, reactions, userReactions = []) {
      const counts = reactions.counts || {};
      const hasCounts = Object.keys(counts).some(key => counts[key] > 0);

      if (!hasCounts) return '';

      const reactionTypes = [
        { type: 'like', emoji: '👍' },
        { type: 'laugh', emoji: '😂' },
        { type: 'heart', emoji: '❤️' },
        { type: 'cry', emoji: '😢' },
        { type: 'thumbs_down', emoji: '👎' },
        { type: 'troll', emoji: '🤡' }
      ];

      const pills = reactionTypes
        .filter(({ type }) => counts[type] > 0)
        .map(({ type, emoji }) => {
          const isUserReaction = userReactions.includes(type);
          // If user already reacted, clicking removes it. Otherwise, clicking adds it.
          const clickHandler = isUserReaction
            ? `removeBulletinReaction(${commentId}, '${type}', this)`
            : `toggleBulletinReaction(${commentId}, '${type}')`;
          return `
            <div class="reaction-pill ${isUserReaction ? 'user-reacted' : ''}"
                 data-comment-id="${commentId}"
                 data-reaction-type="${type}"
                 onclick="${clickHandler}">
              <span class="pill-emoji">${emoji}</span>
              <span class="pill-count">${counts[type]}</span>
            </div>
          `;
        }).join('');

      return `<div class="reaction-summary">${pills}</div>`;
    }

    // Generate reaction picker for bulletin comments
    function generateBulletinReactionPicker(commentId) {
      const reactionTypes = [
        { type: 'like', emoji: '👍', label: 'Like' },
        { type: 'laugh', emoji: '😂', label: 'Laugh' },
        { type: 'heart', emoji: '❤️', label: 'Love' },
        { type: 'cry', emoji: '😢', label: 'Sad' },
        { type: 'thumbs_down', emoji: '👎', label: 'Dislike' },
        { type: 'troll', emoji: '🤡', label: 'Troll' }
      ];

      const items = reactionTypes.map(({ type, emoji, label }) => `
        <div class="reaction-picker-item" data-reaction-type="${type}" data-label="${label}">
          ${emoji}
        </div>
      `).join('');

      return `<div class="reaction-picker" data-comment-id="${commentId}">${items}</div>`;
    }

    // ===== BULLETIN EVENT DELEGATION FOR LIKE BUTTONS =====

    function showBulletinPicker(btn) {
      const state = getBulletinButtonState(btn);
      state.picker = btn.querySelector('.reaction-picker');
      if (state.picker) {
        state.picker.classList.add('visible');
        state.pickerShown = true;
        if (navigator.vibrate) navigator.vibrate(10);
      }
    }

    function hideBulletinPicker(btn) {
      const state = getBulletinButtonState(btn);
      if (state.picker) {
        state.picker.classList.remove('visible');
        state.pickerShown = false;
        const items = state.picker.querySelectorAll('.reaction-picker-item');
        items.forEach(item => { item.style.transform = ''; });
      }
    }

    function getBulletinEmojiAtTouch(picker, touch) {
      const pickerItems = picker?.querySelectorAll('.reaction-picker-item');
      if (!pickerItems) return null;

      for (const item of pickerItems) {
        const rect = item.getBoundingClientRect();
        if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
            touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
          return item;
        }
      }
      return null;
    }

    function updateBulletinHoveredEmoji(btn, touch) {
      const state = getBulletinButtonState(btn);
      if (!state.picker || !state.pickerShown) return;

      const hoveredItem = getBulletinEmojiAtTouch(state.picker, touch);

      if (hoveredItem !== state.currentHoveredItem) {
        if (state.currentHoveredItem) {
          state.currentHoveredItem.style.transform = '';
        }
        if (hoveredItem) {
          hoveredItem.style.transform = 'scale(1.8) translateY(-12px)';
          hoveredItem.style.filter = 'drop-shadow(0 8px 20px rgba(237,183,35,0.8))';
          if (navigator.vibrate) navigator.vibrate(5);
          state.selectedReaction = hoveredItem.getAttribute('data-reaction-type');
        } else {
          state.selectedReaction = null;
        }
        state.currentHoveredItem = hoveredItem;
      }
    }

    // Attach event listeners to bulletin comments section using delegation
    function attachBulletinLikeListeners() {
      const bulletinCommentsSection = document.querySelector('.bulletin-comments-section');
      if (!bulletinCommentsSection || bulletinCommentsSection.dataset.likeListenersAttached) return;

      bulletinCommentsSection.dataset.likeListenersAttached = 'true';

      // Mousedown - start long press timer
      bulletinCommentsSection.addEventListener('mousedown', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getBulletinButtonState(btn);
        state.longPressTimer = setTimeout(() => showBulletinPicker(btn), 300);
      });

      // Mouseup - clear timer
      bulletinCommentsSection.addEventListener('mouseup', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getBulletinButtonState(btn);
        clearTimeout(state.longPressTimer);
      });

      // Mouseleave - clear timer but keep picker open
      bulletinCommentsSection.addEventListener('mouseleave', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getBulletinButtonState(btn);
        clearTimeout(state.longPressTimer);
      }, true);

      // Click - quick like or picker item selection
      bulletinCommentsSection.addEventListener('click', async (e) => {
        // Check if clicked on picker item first
        const pickerItem = e.target.closest('.reaction-picker-item');
        if (pickerItem) {
          e.stopPropagation();
          const btn = e.target.closest('.like-button');
          if (btn) {
            const reactionType = pickerItem.getAttribute('data-reaction-type');
            const commentId = btn.getAttribute('data-comment-id');
            await toggleBulletinReaction(commentId, reactionType);
            hideBulletinPicker(btn);
          }
          return;
        }

        // Otherwise check if clicked on button itself
        const btn = e.target.closest('.like-button');
        if (!btn) return;

        const state = getBulletinButtonState(btn);
        state.picker = btn.querySelector('.reaction-picker');
        if (!state.picker || !state.picker.classList.contains('visible')) {
          const commentId = btn.getAttribute('data-comment-id');
          await toggleBulletinReaction(commentId, 'like');
        }
      });

      // Touchstart - start long press
      bulletinCommentsSection.addEventListener('touchstart', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        e.preventDefault();
        const state = getBulletinButtonState(btn);
        state.selectedReaction = null;
        state.currentHoveredItem = null;
        state.longPressTimer = setTimeout(() => showBulletinPicker(btn), 300);
      }, { passive: false });

      // Touchmove - slide to select emoji
      bulletinCommentsSection.addEventListener('touchmove', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getBulletinButtonState(btn);

        if (!state.pickerShown) {
          clearTimeout(state.longPressTimer);
          return;
        }

        e.preventDefault();
        const touch = e.touches[0];
        updateBulletinHoveredEmoji(btn, touch);
      }, { passive: false });

      // Touchend - complete reaction
      bulletinCommentsSection.addEventListener('touchend', async (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getBulletinButtonState(btn);
        clearTimeout(state.longPressTimer);
        state.picker = btn.querySelector('.reaction-picker');

        if (state.pickerShown && state.selectedReaction) {
          const commentId = btn.getAttribute('data-comment-id');
          await toggleBulletinReaction(commentId, state.selectedReaction);
          if (navigator.vibrate) navigator.vibrate([10, 20, 10]);
          hideBulletinPicker(btn);
          state.selectedReaction = null;
          state.currentHoveredItem = null;
        } else if (!state.pickerShown) {
          const commentId = btn.getAttribute('data-comment-id');
          await toggleBulletinReaction(commentId, 'like');
        } else {
          hideBulletinPicker(btn);
        }
      });
    }

    // ===== BULLETIN REPLY FUNCTIONALITY =====

    // Open Reply Box for bulletin comments
    window.openBulletinReplyBox = function(commentId) {
      // Close any other open reply boxes
      document.querySelectorAll('.reply-box').forEach(box => {
        box.classList.remove('visible');
      });

      // Find the comment thread
      const threadElement = document.querySelector(`.bulletin-comment-thread[data-comment-id="${commentId}"]`);
      if (!threadElement) return;

      const commentContent = threadElement.querySelector('.comment-content');
      let replyBox = commentContent.querySelector('.reply-box');

      if (!replyBox) {
        // Create reply box
        const replyBoxHTML = `
          <div class="reply-box visible" data-parent-id="${commentId}">
            <textarea placeholder="Write a reply..." maxlength="500"></textarea>
            <div class="reply-box-actions">
              <button class="reply-cancel-btn" onclick="closeBulletinReplyBox(${commentId})">Cancel</button>
              <button class="reply-submit-btn" onclick="submitBulletinReply(${commentId})">Reply</button>
            </div>
          </div>
        `;
        commentContent.insertAdjacentHTML('beforeend', replyBoxHTML);
        replyBox = commentContent.querySelector('.reply-box');

        // Focus textarea
        setTimeout(() => {
          const textarea = replyBox.querySelector('textarea');
          textarea.focus();
        }, 100);
      } else {
        replyBox.classList.add('visible');
        setTimeout(() => {
          const textarea = replyBox.querySelector('textarea');
          textarea.focus();
        }, 100);
      }
    };

    // Close Reply Box for bulletin comments
    window.closeBulletinReplyBox = function(commentId) {
      const threadElement = document.querySelector(`.bulletin-comment-thread[data-comment-id="${commentId}"]`);
      if (!threadElement) return;

      const replyBox = threadElement.querySelector('.reply-box');
      if (replyBox) {
        replyBox.classList.remove('visible');
        replyBox.querySelector('textarea').value = '';
      }
    };

    // Submit Reply for bulletin comments
    window.submitBulletinReply = async function(parentCommentId) {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        showBulletinNotification('⚠️ Please connect your wallet first!', 'warning');
        return;
      }

      const threadElement = document.querySelector(`.bulletin-comment-thread[data-comment-id="${parentCommentId}"]`);
      if (!threadElement) return;

      const replyBox = threadElement.querySelector('.reply-box');
      const textarea = replyBox.querySelector('textarea');
      const replyText = textarea.value.trim();

      if (!replyText) {
        showBulletinNotification('⚠️ Please enter a reply!', 'warning');
        return;
      }

      try {
        // Backend will fetch author info from profiles table automatically
        const response = await fetch(`${API_BASE_URL}/api/bulletin/comments`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            post_id: currentPostId,
            wallet_address: currentWallet,
            content: replyText,
            parent_id: parentCommentId
          })
        });

        if (response.ok) {
          closeBulletinReplyBox(parentCommentId);
          await loadComments(currentPostId);
          showBulletinNotification('✅ Reply posted!', 'success');
        } else {
          showBulletinNotification('❌ Failed to post reply.', 'error');
        }
      } catch (error) {
        console.error('Error posting reply:', error);
        showBulletinNotification('❌ Error posting reply. Please try again.', 'error');
      }
    };

    // ===== BULLETIN REACTION API FUNCTIONS =====

    // Prevent double-clicking reactions
    const bulletinReactionLocks = new Set();

    // Toggle reaction on bulletin comment
    window.toggleBulletinReaction = async function(commentId, reactionType) {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        showBulletinNotification('⚠️ Please connect your wallet first!', 'warning');
        return;
      }

      // Create unique lock key for this specific reaction
      const lockKey = `${commentId}-${reactionType}`;

      // If already processing this reaction, ignore
      if (bulletinReactionLocks.has(lockKey)) {
        console.log('⏳ Already processing this reaction, ignoring duplicate request');
        return;
      }

      // Lock this reaction
      bulletinReactionLocks.add(lockKey);

      try {
        const response = await fetch(`${API_BASE_URL}/api/bulletin/comments/${commentId}/react`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet_address: currentWallet,
            reaction_type: reactionType
          })
        });

        let result;
        try {
          result = await response.json();
        } catch (parseError) {
          console.error('❌ Failed to parse response JSON:', parseError);
          console.error('❌ Response status:', response.status, response.statusText);
          showBulletinNotification('❌ Server error - invalid response', 'error');
          return;
        }

        if (response.ok && result.success) {
          console.log('✅ toggleBulletinReaction Backend confirmed:', result.action);
          console.log('📦 Backend returned updated counts:', result.counts);
          console.log('📦 Backend returned user reactions:', result.userReactions);

          // Use the fresh data directly from backend response (no fetching needed!)
          updateBulletinCommentReactionsWithData(commentId, {
            counts: result.counts || {},
            userReactions: result.userReactions || {}
          });
        } else {
          console.error('❌ toggleBulletinReaction Backend error:', result);
          console.error('❌ Response status:', response.status);
          console.error('❌ Failed request: commentId=' + commentId + ', reactionType=' + reactionType);
          // Don't show alert for duplicate errors (user probably double-clicked)
          if (!result.error?.includes('duplicate key')) {
            showBulletinNotification('❌ Failed to toggle reaction: ' + (result.error || 'Unknown error'), 'error');
          }
        }
      } catch (error) {
        console.error('Error toggling bulletin reaction:', error);
        showBulletinNotification('❌ Error adding reaction.', 'error');
      } finally {
        // Unlock after a short delay
        setTimeout(() => bulletinReactionLocks.delete(lockKey), 500);
      }
    };

    // Remove reaction from bulletin comment
    window.removeBulletinReaction = async function(commentId, reactionType, pillElement) {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        showBulletinNotification('⚠️ Please connect your wallet first!', 'warning');
        return;
      }

      console.log('🗑️ REMOVING bulletin reaction:', reactionType, 'from comment', commentId);

      // Add the removing animation
      pillElement.classList.add('removing');

      // Haptic feedback
      if (navigator.vibrate) {
        navigator.vibrate([5, 10, 5]);
      }

      try {
        const response = await fetch(`${API_BASE_URL}/api/bulletin/comments/${commentId}/react`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet_address: currentWallet,
            reaction_type: reactionType
          })
        });

        const result = await response.json();
        console.log('📡 Backend response:', result);

        if (response.ok && result.success) {
          console.log('✅ Backend confirmed:', result.action);
          console.log('📦 Backend returned updated counts:', result.counts);
          console.log('📦 Backend returned user reactions:', result.userReactions);

          // Use the fresh data directly from backend response (no fetching needed!)
          setTimeout(() => {
            console.log('⏰ Animation complete, updating UI with backend data...');
            // Update UI directly with the counts from backend response
            updateBulletinCommentReactionsWithData(commentId, {
              counts: result.counts || {},
              userReactions: result.userReactions || {}
            });
          }, 400); // Match animation duration
        } else {
          console.error('❌ Backend error:', result);
          pillElement.classList.remove('removing');
          showBulletinNotification('❌ Failed to remove reaction: ' + (result.error || 'Unknown error'), 'error');
        }
      } catch (error) {
        pillElement.classList.remove('removing');
        console.error('Error removing bulletin reaction:', error);
        showBulletinNotification('❌ Error removing reaction: ' + error.message, 'error');
      }
    };

    // Update bulletin comment reactions using data directly (no fetch needed)
    function updateBulletinCommentReactionsWithData(commentId, reactionsData) {
      try {
        const currentWallet = localStorage.getItem('bearpark_wallet');
        const userReactions = reactionsData.userReactions?.[currentWallet] || [];

        console.log('🔄 Updating bulletin reactions UI for comment', commentId);
        console.log('📊 Reaction counts:', reactionsData.counts);
        console.log('👤 User reactions:', userReactions);

        // Find the comment element (data-comment-id is on .bulletin-comment-thread, not .comment-item)
        const commentThread = document.querySelector(`.bulletin-comment-thread[data-comment-id="${commentId}"]`);
        if (!commentThread) return;
        const commentElement = commentThread.querySelector('.comment-item');
        if (!commentElement) return;

        const commentContent = commentElement.querySelector('.comment-content');
        const commentActions = commentContent.querySelector('.comment-actions');
        let existingReactionSummary = commentContent.querySelector('.reaction-summary');

        // Generate the new reaction summary HTML
        const newReactionHTML = generateBulletinReactionSummary(commentId, reactionsData, userReactions);

        console.log('🎨 New reaction HTML:', newReactionHTML ? 'Generated' : 'Empty (no reactions)');

        if (existingReactionSummary) {
          // If there's an existing summary and new HTML, replace it
          if (newReactionHTML) {
            existingReactionSummary.outerHTML = newReactionHTML;
          } else {
            // No reactions left, remove the summary
            existingReactionSummary.remove();
          }
        } else if (newReactionHTML) {
          // No existing summary but we have reactions, insert before actions
          commentActions.insertAdjacentHTML('beforebegin', newReactionHTML);
        }

        // Update the like button state
        const likeButton = commentElement.querySelector('.like-button');
        if (likeButton) {
          if (userReactions.length > 0) {
            likeButton.classList.add('reacted');
          } else {
            likeButton.classList.remove('reacted');
          }
        }

        // Event listeners use delegation - no need to re-attach
      } catch (error) {
        console.error('Error updating bulletin reactions:', error);
      }
    }

    // Create comment HTML
    // Render a single bulletin comment with reactions and replies (IDENTICAL to profile modal)
    async function renderBulletinComment(comment, depth = 0, parentName = null) {
      const maxDepth = 8;
      const currentWallet = localStorage.getItem('bearpark_wallet');
      const isOwner = comment.wallet_address === currentWallet;
      const canDelete = isOwner || isAdminOrModerator; // Show delete for owner OR admin/moderator
      const timeAgo = getTimeAgo(comment.created_at);
      const hasReplies = comment.children && comment.children.length > 0;
      const replyCount = hasReplies ? comment.children.length : 0;

      // Parse avatar using helper function
      const avatarUrl = getAvatarUrl(comment.author_avatar);
      const avatarHTML = `<img src="${avatarUrl}" class="comment-avatar" alt="${comment.author_name || 'Anonymous'}" onerror="this.src='https://files.catbox.moe/esp426.png';">`;

      // Load reactions
      const reactions = await loadBulletinCommentReactions(comment.id);
      const userReactions = reactions.userReactions?.[currentWallet] || [];
      const hasReacted = userReactions.length > 0;

      // Reply indicator for nested comments
      let replyIndicator = '';
      if (depth > 0 && parentName) {
        replyIndicator = `<div class="reply-indicator">
          <span class="reply-arrow">↩</span>
          <span class="reply-to-text">Replying to <span class="reply-to-name">@${parentName}</span></span>
        </div>`;
      }

      const commentHTML = `
        <div class="bulletin-comment-thread ${depth > 0 ? 'is-reply' : ''}" data-comment-id="${comment.id}" data-depth="${depth}">
          <div class="comment-item">
            ${hasReplies ? `<button class="thread-toggle" onclick="toggleBulletinThread(${comment.id})" aria-label="Toggle replies">
              <span class="bulletin-toggle-icon">▼</span>
            </button>` : '<div class="thread-spacer"></div>'}
            <div class="comment-content">
              ${replyIndicator}
              <div class="comment-header">
                <div class="comment-author-clickable" onclick="openProfileModal('${comment.wallet_address}')" style="cursor: pointer; display: flex; align-items: center; gap: 12px; flex: 1;">
                  ${avatarHTML}
                  <div class="comment-author-info">
                    <p class="comment-author-name">${comment.author_name || 'Anonymous'}</p>
                    <p class="comment-timestamp">${timeAgo}${hasReplies ? `<span class="reply-count">${replyCount} ${replyCount === 1 ? 'reply' : 'replies'}</span>` : ''}</p>
                  </div>
                </div>
                ${canDelete ? `<button class="comment-delete-btn" onclick="deleteBulletinComment('${comment.id}')">Delete</button>` : ''}
              </div>
              <p class="comment-text">${escapeHtml(comment.content)}</p>
              ${generateBulletinReactionSummary(comment.id, reactions, userReactions)}
              <div class="comment-actions">
                <button class="like-button ${hasReacted ? 'reacted' : ''}" data-comment-id="${comment.id}">
                  <span class="like-emoji">👍</span>
                  <span>Like</span>
                  ${generateBulletinReactionPicker(comment.id)}
                </button>
                <button class="reply-button" data-comment-id="${comment.id}" onclick="openBulletinReplyBox(${comment.id})">
                  <span class="reply-icon">💬</span>
                  <span>Reply</span>
                </button>
              </div>
            </div>
          </div>
          ${hasReplies ? `<div class="bulletin-comment-replies" data-parent-id="${comment.id}"></div>` : ''}
        </div>
      `;

      return commentHTML;
    }

    // Recursively render bulletin replies
    async function renderBulletinReplies(replies, parentId, depth, parentComment = null) {
      const maxDepth = 8;
      const repliesContainer = document.querySelector(`.bulletin-comment-replies[data-parent-id="${parentId}"]`);
      if (!repliesContainer) return;

      for (const reply of replies) {
        const parentName = parentComment ? (parentComment.author_name || 'Anonymous') : 'a bear';
        const replyHTML = await renderBulletinComment(reply, depth, parentName);
        repliesContainer.insertAdjacentHTML('beforeend', replyHTML);

        // Render nested replies
        if (reply.children && reply.children.length > 0 && depth < maxDepth) {
          await renderBulletinReplies(reply.children, reply.id, depth + 1, reply);
        }
      }
    }

    // Post a comment (using Supabase API)
    async function postComment() {
      if (!currentPostId) return;

      const input = document.getElementById('commentInput');
      const content = input.value.trim();

      if (!content) {
        showBulletinNotification('⚠️ Please enter a comment!', 'warning');
        return;
      }

      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        showBulletinNotification('⚠️ Please connect your wallet first!', 'warning');
        return;
      }

      try {
        // Backend will fetch author info from profiles table automatically
        const response = await fetch(`${API_BASE_URL}/api/bulletin/comments`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            post_id: currentPostId,
            wallet_address: currentWallet,
            content: content,
            parent_id: null  // Top-level comment (no parent)
          })
        });

        if (!response.ok) throw new Error('Failed to post comment');

        // Clear input
        input.value = '';

        console.log('💬 Comment posted successfully, reloading comments...');

        // Reload comments
        await loadComments(currentPostId);

        // Update comment count in feed
        const post = bulletinPosts.find(p => p.id === currentPostId);
        if (post) {
          post.comment_count = (post.comment_count || 0) + 1;
        }
        await loadBulletinFeed();

        showBulletinNotification('✅ Your comment has been posted!', 'success');
      } catch (error) {
        console.error('Error posting comment:', error);
        showBulletinNotification('❌ Failed to post comment. Please try again.', 'error');
      }
    }

    // Delete a bulletin comment
    window.deleteBulletinComment = async function(commentId) {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        showBulletinNotification('⚠️ Please connect your wallet first!', 'warning');
        return;
      }

      if (!confirm('Are you sure you want to delete this comment?')) {
        return;
      }

      try {
        const response = await fetch(`${API_BASE_URL}/api/bulletin/comments/${commentId}`, {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            wallet_address: currentWallet
          })
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to delete comment');
        }

        console.log('✅ Comment deleted successfully');
        showBulletinNotification('✅ Comment deleted!', 'success');

        // Reload comments
        await loadComments(currentPostId);

        // Update comment count in feed
        const post = bulletinPosts.find(p => p.id === currentPostId);
        if (post && post.comment_count > 0) {
          post.comment_count--;
        }
        await loadBulletinFeed();

      } catch (error) {
        console.error('❌ Error deleting bulletin comment:', error);
        showBulletinNotification('❌ Failed to delete comment: ' + error.message, 'error');
      }
    };

    // Delete a post
    async function deletePost(postId) {
      if (!confirm('Are you sure you want to delete this post? This cannot be undone.')) {
        return;
      }

      try {
        if (BULLETIN_DEMO_MODE) {
          // Delete from localStorage
          const stored = localStorage.getItem('bearpark_bulletin_posts');
          if (stored) {
            const posts = JSON.parse(stored);
            const filtered = posts.filter(p => p.id !== postId);
            localStorage.setItem('bearpark_bulletin_posts', JSON.stringify(filtered));
          }
          // Also delete associated comments
          localStorage.removeItem(`bearpark_bulletin_comments_${postId}`);
        } else {
          const currentWallet = localStorage.getItem('bearpark_wallet');
          const response = await fetch(`${API_BASE_URL}/api/bulletin/posts/${postId}`, {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              wallet_address: currentWallet
            })
          });
          if (!response.ok) throw new Error('Failed to delete post');
        }

        // Reload feed
        await loadBulletinFeed();

        // Close modal if it's open
        if (currentPostId === postId) {
          closeBulletinPostModal();
        }

        showBulletinNotification('Post deleted', 'success');
      } catch (error) {
        console.error('Error deleting post:', error);
        showBulletinNotification('❌ Failed to delete post. Please try again.', 'error');
      }
    }

    // Delete a comment
    async function deleteComment(commentId) {
      if (!confirm('Are you sure you want to delete this comment?')) {
        return;
      }

      if (!currentPostId) return;

      try {
        if (BULLETIN_DEMO_MODE) {
          // Delete from localStorage
          const stored = localStorage.getItem(`bearpark_bulletin_comments_${currentPostId}`);
          if (stored) {
            const comments = JSON.parse(stored);
            const filtered = comments.filter(c => c.id !== commentId);
            localStorage.setItem(`bearpark_bulletin_comments_${currentPostId}`, JSON.stringify(filtered));
          }

          // Update comment count
          const postsStored = localStorage.getItem('bearpark_bulletin_posts');
          if (postsStored) {
            const posts = JSON.parse(postsStored);
            const post = posts.find(p => p.id === currentPostId);
            if (post && post.comment_count > 0) {
              post.comment_count -= 1;
              localStorage.setItem('bearpark_bulletin_posts', JSON.stringify(posts));
            }
          }
        } else {
          const response = await fetch(`${API_BASE_URL}/bulletin/posts/${currentPostId}/comments/${commentId}`, {
            method: 'DELETE'
          });
          if (!response.ok) throw new Error('Failed to delete comment');
        }

        // Reload comments
        await loadComments(currentPostId);

        // Update feed
        await loadBulletinFeed();

        showBulletinNotification('Comment deleted', 'success');
      } catch (error) {
        console.error('Error deleting comment:', error);
        showBulletinNotification('❌ Failed to delete comment. Please try again.', 'error');
      }
    }

    // Utility function to get time ago
    function getTimeAgo(timestamp) {
      const now = new Date();
      const posted = new Date(timestamp);
      const diffMs = now - posted;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      const diffDays = Math.floor(diffMs / 86400000);

      if (diffMins < 1) return 'Just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays < 7) return `${diffDays}d ago`;
      return posted.toLocaleDateString();
    }

    // Utility function to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Show notification
    function showBulletinNotification(message, type = 'info') {
      if (type === 'success') {
        // Use the existing celebration system with green checkmark
        const overlay = document.getElementById('celebrationOverlay');
        const icon = document.getElementById('celebrationIcon');
        const text = document.getElementById('celebrationText');
        const subtext = document.getElementById('celebrationSubtext');

        icon.textContent = '✅';
        text.textContent = 'POSTED!';
        text.style.color = '#22c55e';
        subtext.textContent = message;
        subtext.style.color = '#22c55e';

        overlay.classList.add('active');

        // Create confetti
        const confettiCount = 150;
        const color = '#22c55e';
        for (let i = 0; i < confettiCount; i++) {
          const confetti = document.createElement('div');
          confetti.className = 'confetti';
          confetti.style.left = Math.random() * 100 + '%';
          confetti.style.background = i % 3 === 0 ? color : (i % 3 === 1 ? '#ffae00' : '#ffffff');
          confetti.style.animationDelay = Math.random() * 0.3 + 's';
          confetti.style.animationDuration = (Math.random() * 1.5 + 2.5) + 's';
          confetti.style.setProperty('--drift', (Math.random() - 0.5) * 200 + 'px');
          confetti.style.boxShadow = `0 0 10px ${i % 3 === 0 ? color : '#ffae00'}`;
          overlay.appendChild(confetti);
        }

        setTimeout(() => {
          overlay.classList.remove('active');
          setTimeout(() => {
            const confettiElements = overlay.querySelectorAll('.confetti');
            confettiElements.forEach(c => c.remove());
          }, 500);
        }, 3000);
      } else if (type === 'warning' || type === 'error') {
        console.log(`[${type.toUpperCase()}] ${message}`);
        alert(message);
      }
    }

    // Initialize bulletin board
    document.addEventListener('DOMContentLoaded', () => {
      loadBulletinFeed();

      // Reload feed every 30 seconds
      setInterval(loadBulletinFeed, 30000);
    });
  </script>

  <script>
    // ===== COSMETICS STORE JAVASCRIPT =====
    let currentStoreTab = 'rings';
    let currentBalance = 0;

    // Cosmetics catalog - loaded from API
    let rings = [];
    let banners = [];
    let catalogLoaded = false;

    // User inventory - loaded from API
    let userInventory = [];
    let inventoryLoaded = false;

    // Load cosmetics catalog from API
    async function loadCosmeticsCatalog() {
      if (catalogLoaded) return; // Only load once

      try {
        console.log('📦 Loading cosmetics catalog from API...');
        const response = await fetch(`${API_BASE_URL}/api/cosmetics/catalog`);

        if (!response.ok) throw new Error('Failed to load catalog');

        const data = await response.json();

        if (data.success && data.items) {
          // Separate rings and banners
          rings = data.items
            .filter(item => item.cosmetic_type === 'ring')
            .map(item => ({
              id: item.id,
              name: item.name,
              description: item.description,
              cost: item.honey_cost,
              rarity: item.rarity,
              ringType: item.ring_type,
              imageUrl: item.image_url
            }));

          banners = data.items
            .filter(item => item.cosmetic_type === 'banner')
            .map(item => ({
              id: item.id,
              name: item.name,
              description: item.description,
              cost: item.honey_cost,
              rarity: item.rarity,
              gradient: item.css_gradient
            }));

          catalogLoaded = true;
          console.log(`✅ Loaded ${rings.length} rings and ${banners.length} banners`);
        }
      } catch (error) {
        console.error('❌ Error loading cosmetics catalog:', error);
        // Fallback to empty arrays
        rings = [];
        banners = [];
      }
    }

    // Load user's inventory from API
    async function loadUserInventory() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) {
        console.log('⚠️ No wallet connected, skipping inventory load');
        userInventory = [];
        return;
      }

      try {
        console.log('👜 Loading user inventory from API...');
        const response = await fetch(`${API_BASE_URL}/api/cosmetics/inventory/${walletAddress}`);

        if (!response.ok) throw new Error('Failed to load inventory');

        const data = await response.json();

        if (data.success && data.items) {
          userInventory = data.items.map(item => item.cosmetic_id);
          inventoryLoaded = true;
          console.log(`✅ Loaded ${userInventory.length} owned items`);
        }
      } catch (error) {
        console.error('❌ Error loading user inventory:', error);
        userInventory = [];
      }
    }

    async function openStoreModal() {
      // Load catalog and inventory from API
      await Promise.all([
        loadCosmeticsCatalog(),
        loadUserInventory()
      ]);

      // Get current honey points from the page
      const honeyPointsEl = document.getElementById('totalHoneyPoints');
      if (honeyPointsEl) {
        currentBalance = parseFloat(honeyPointsEl.textContent) || 0;
      }

      document.getElementById('storeModal').classList.add('active');
      document.getElementById('storeHoneyBalance').textContent = currentBalance.toFixed(1);
      loadStoreItems('rings');
    }

    function closeStoreModal() {
      document.getElementById('storeModal').classList.remove('active');
    }

    function switchStoreTab(tab, event) {
      currentStoreTab = tab;
      document.querySelectorAll('.store-tab').forEach(btn => btn.classList.remove('active'));
      event.target.closest('.store-tab').classList.add('active');

      document.getElementById('storeRingsGrid').style.display = tab === 'rings' ? 'grid' : 'none';
      document.getElementById('storeBannersGrid').style.display = tab === 'banners' ? 'grid' : 'none';

      loadStoreItems(tab);
    }

    function loadStoreItems(tab) {
      const items = tab === 'rings' ? rings : banners;
      const gridId = tab === 'rings' ? 'storeRingsGrid' : 'storeBannersGrid';
      const grid = document.getElementById(gridId);

      // Group items by rarity
      const rarityOrder = ['common', 'rare', 'epic', 'legendary', 'bearableguy123'];
      const rarityLabels = {
        common: '🌿 COMMON',
        rare: '💎 RARE',
        epic: '⚡ EPIC',
        legendary: '👑 LEGENDARY',
        bearableguy123: '🌑 BEARABLEGUY123'
      };

      const groupedItems = {};
      rarityOrder.forEach(rarity => {
        groupedItems[rarity] = items.filter(item => item.rarity === rarity);
      });

      let htmlContent = '';

      rarityOrder.forEach(rarity => {
        const rarityItems = groupedItems[rarity];
        if (rarityItems.length === 0) return;

        htmlContent += `<div class="rarity-section ${rarity}-section">`;
        htmlContent += `<div class="rarity-header ${rarity}-header">${rarityLabels[rarity]}</div>`;
        htmlContent += `<div class="store-grid">`;

        rarityItems.forEach(item => {
          // Check if user owns this item
          const isOwned = userInventory.includes(item.id);

          let previewHTML;

          if (item.ringType) {
            // Ring preview
            if (item.imageUrl) {
              // Image-based ring (like ouroboros or waves)
              const spinAnimation = item.rarity === 'bearableguy123'
                ? `animation: spinRingImage 3s linear infinite;`
                : '';

              // Determine ring size based on type
              let baseRingSize = '160px';
              if (item.ringType === 'castle' || item.ringType === 'castle-static') {
                baseRingSize = '160px';
              } else if (item.ringType === 'waves-static') {
                baseRingSize = '160px';
              } else if (item.rarity === 'bearableguy123' && (item.ringType === 'ouroboros' || item.ringType === 'waves')) {
                baseRingSize = '160px';
              }

              const ouroborosSize = baseRingSize;
              const glowSize = '100px';

              const glowWrapper = item.rarity === 'bearableguy123'
                ? `<div class="ring-glow-wrapper ${item.ringType}" style="width: ${glowSize}; height: ${glowSize};"></div>`
                : '';

              const finalRingSize = item.ringType === 'ouroboros' ? ouroborosSize : baseRingSize;
              const ouroborosRotation = item.ringType === 'ouroboros' ? ' rotate(180deg)' : '';

              previewHTML = `
                <div class="ring-demo">
                  <img src="https://files.catbox.moe/2f0v9c.webp" alt="Avatar" style="position: relative; z-index: 1;">
                  ${glowWrapper}
                  <img src="${item.imageUrl}" alt="${item.name}" class="image-ring-${item.ringType}" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%)${ouroborosRotation}; object-fit: contain; z-index: 2; pointer-events: none; ${spinAnimation}">
                </div>
              `;
            } else {
              // CSS-based ring (like purple, tricolor, etc)
              previewHTML = `
                <div class="ring-demo">
                  <div class="ring-border ${item.ringType}"></div>
                  <img src="https://files.catbox.moe/2f0v9c.webp" alt="Avatar">
                </div>
              `;
            }
          } else if (item.gradient) {
            // Banner preview with profile picture overlay
            previewHTML = `
              <div class="banner-demo" style="background: ${item.gradient};">
                <div class="banner-profile-preview">
                  <img src="https://files.catbox.moe/2f0v9c.webp" alt="Profile">
                </div>
              </div>
            `;
          }

          // Button text and state based on ownership
          const buttonText = isOwned ? 'OWNED' : 'BUY NOW';
          const buttonDisabled = isOwned ? 'disabled' : '';
          const buttonClass = isOwned ? 'store-item-btn owned' : 'store-item-btn';

          htmlContent += `
            <div class="store-item ${item.rarity}">
              <div class="store-item-preview">
                ${previewHTML}
                <div class="store-item-badge rarity-${item.rarity}">${item.rarity.toUpperCase()}</div>
                ${isOwned ? '<div class="store-item-owned-badge">✓ OWNED</div>' : ''}
              </div>
              <div class="store-item-name">${item.name}</div>
              <div class="store-item-description">${item.description}</div>
              <div class="store-item-footer">
                <div class="store-item-price">${item.cost} HP</div>
                <button class="${buttonClass}" ${buttonDisabled} onclick="purchaseItem(${item.id}, ${item.cost}, '${item.rarity}', '${item.name}', event)">${buttonText}</button>
              </div>
            </div>
          `;
        });

        htmlContent += `</div></div>`;
      });

      grid.innerHTML = htmlContent;
    }

    async function purchaseItem(id, cost, rarity, name, event) {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) {
        alert('Please connect your wallet first!');
        return;
      }

      if (currentBalance < cost) {
        alert(`Not enough Honey Points! You need ${cost} HP but only have ${currentBalance.toFixed(1)} HP.`);
        return;
      }

      // Get the button element
      const button = event?.target || document.querySelector(`button[onclick*="purchaseItem(${id}"]`);

      // Disable button during purchase
      if (button) {
        button.disabled = true;
        button.textContent = 'PURCHASING...';
      }

      try {
        // Show hype message
        showHypeMessage();

        // Call API to purchase item
        const response = await fetch(`${API_BASE_URL}/api/cosmetics/purchase`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            wallet_address: walletAddress,
            cosmetic_id: id
          })
        });

        const data = await response.json();

        if (!response.ok || !data.success) {
          throw new Error(data.error || 'Purchase failed');
        }

        console.log('✅ Purchase successful!', data);

        // Update balance and button after 400ms
        setTimeout(() => {
          currentBalance = data.new_balance;
          document.getElementById('storeHoneyBalance').textContent = currentBalance.toFixed(1);

          // Update main honey points display
          const honeyPointsEl = document.getElementById('totalHoneyPoints');
          if (honeyPointsEl) {
            honeyPointsEl.textContent = currentBalance.toFixed(1);
          }

          // Add to user inventory
          userInventory.push(id);

          // Update button to show "OWNED"
          if (button) {
            button.textContent = 'OWNED';
            button.classList.add('owned');
            button.disabled = true;
            button.onclick = null;
          }

          // Add OWNED badge to preview
          const storeItem = button.closest('.store-item');
          if (storeItem) {
            const preview = storeItem.querySelector('.store-item-preview');
            if (preview && !preview.querySelector('.store-item-owned-badge')) {
              const ownedBadge = document.createElement('div');
              ownedBadge.className = 'store-item-owned-badge';
              ownedBadge.textContent = '✓ OWNED';
              preview.appendChild(ownedBadge);
            }
          }
        }, 400);

        // Show celebration after hype message completes (2.6s total)
        setTimeout(() => {
          showCelebration(rarity, name);
        }, 2600);

      } catch (error) {
        console.error('❌ Purchase error:', error);
        alert(`Purchase failed: ${error.message}`);

        // Re-enable button on error
        if (button) {
          button.disabled = false;
          button.textContent = 'BUY NOW';
        }
      }
    }

    function showHypeMessage() {
      const messages = [
        "WOO!!! SEND IT! 🚀",
        "LET'S GOOO! 🚀",
        "YESSS! SEND IT! 🚀",
        "HELL YEAH! 🚀",
        "YOU'RE A LEGEND! 🚀"
      ];

      const message = messages[Math.floor(Math.random() * messages.length)];

      const hypeDiv = document.createElement('div');
      hypeDiv.textContent = message;
      hypeDiv.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.5);
        font-size: 48px;
        font-weight: 900;
        color: #ffae00;
        text-shadow: 0 4px 20px rgba(255, 174, 0, 0.8);
        z-index: 30000;
        pointer-events: none;
        font-family: "Luckiest Guy", "Arial Black", Impact, sans-serif;
      `;

      document.body.appendChild(hypeDiv);

      // Animate in
      setTimeout(() => {
        hypeDiv.style.animation = 'hypePopIn 2.5s cubic-bezier(0.16, 1, 0.3, 1) forwards';
      }, 10);

      setTimeout(() => {
        hypeDiv.remove();
      }, 2500);
    }

    let celebrationTimeout = null;

    function clearCelebration() {
      const overlay = document.getElementById('celebrationOverlay');
      if (overlay.classList.contains('active')) {
        overlay.classList.remove('active');
        overlay.innerHTML = '<div class="celebration-content"><div class="celebration-icon" id="celebrationIcon"></div><div class="celebration-text" id="celebrationText"></div><div class="celebration-subtext" id="celebrationSubtext"></div></div>';

        if (celebrationTimeout) {
          clearTimeout(celebrationTimeout);
          celebrationTimeout = null;
        }
      }
    }

    function showCelebration(rarity, itemName) {
      const overlay = document.getElementById('celebrationOverlay');
      const icon = document.getElementById('celebrationIcon');
      const text = document.getElementById('celebrationText');
      const subtext = document.getElementById('celebrationSubtext');

      const celebrations = {
        common: { icon: '👑', text: 'UNLOCKED!', color: '#22c55e', confettiCount: 150, shake: 'shake' },
        rare: { icon: '💎', text: 'RARE UNLOCK!', color: '#3b82f6', confettiCount: 200, shake: 'shake-medium' },
        epic: { icon: '🌟', text: 'EPIC UNLOCK!', color: '#a855f7', confettiCount: 300, shake: 'shake-heavy' },
        legendary: { icon: '🔥', text: 'LEGENDARY!', color: '#f59e0b', confettiCount: 500, shake: 'shake-legendary' },
        bearableguy123: { icon: '🌑', text: 'BEARABLEGUY123!!!', color: '#ff0000', confettiCount: 800, shake: 'shake-bearableguy123' }
      };

      const config = celebrations[rarity] || celebrations.common;
      icon.textContent = config.icon;
      text.textContent = config.text;
      text.style.color = config.color;
      subtext.textContent = itemName;
      subtext.style.color = config.color;

      overlay.classList.add('active');
      createConfetti(config.confettiCount, config.color);

      // Add shake effect to modal
      const modal = document.getElementById('storeModal');
      if (modal && config.shake) {
        modal.style.animation = `${config.shake} 1s ease-in-out`;
        setTimeout(() => {
          modal.style.animation = '';
        }, 1000);
      }

      celebrationTimeout = setTimeout(() => {
        clearCelebration();
      }, 5000);
    }

    function createConfetti(count, color) {
      const overlay = document.getElementById('celebrationOverlay');
      for (let i = 0; i < count; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + '%';
        confetti.style.background = i % 3 === 0 ? color : (i % 3 === 1 ? '#ffae00' : '#ffffff');
        confetti.style.animationDelay = Math.random() * 0.3 + 's';
        confetti.style.animationDuration = (Math.random() * 1.5 + 2.5) + 's';
        confetti.style.setProperty('--drift', (Math.random() - 0.5) * 200 + 'px');
        confetti.style.boxShadow = `0 0 10px ${i % 3 === 0 ? color : '#ffae00'}`;
        overlay.appendChild(confetti);
      }
    }

    // Add hype animation keyframes dynamically
    const style = document.createElement('style');
    style.textContent = `
      @keyframes hypePopIn {
        0% {
          transform: translate(-50%, -50%) scale(0.3) rotate(-15deg);
          opacity: 0;
          filter: blur(10px);
        }
        15% {
          transform: translate(-50%, -50%) scale(1.15) rotate(3deg);
          opacity: 1;
          filter: blur(0px);
        }
        25% {
          transform: translate(-50%, -50%) scale(0.95) rotate(-2deg);
        }
        35% {
          transform: translate(-50%, -50%) scale(1) rotate(0deg);
        }
        75% {
          transform: translate(-50%, -50%) scale(1) rotate(0deg);
          opacity: 1;
          filter: blur(0px);
        }
        100% {
          transform: translate(-50%, -50%) scale(0.85) rotate(5deg);
          opacity: 0;
          filter: blur(15px);
        }
      }
    `;
    document.head.appendChild(style);

    // Close modal when clicking outside
    document.getElementById('storeModal')?.addEventListener('click', (e) => {
      if (e.target.id === 'storeModal') {
        closeStoreModal();
      } else {
        clearCelebration();
      }
    });

    // ===== INVENTORY MODAL JAVASCRIPT =====
    let currentInventoryTab = 'rings';
    let equippedItems = { ring: null, banner: null };

    async function openInventoryModal() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) {
        alert('Please connect your wallet first!');
        return;
      }

      // Load catalog, inventory, and equipped items
      await Promise.all([
        loadCosmeticsCatalog(),
        loadUserInventory(),
        loadEquippedItems()
      ]);

      document.getElementById('inventoryModal').classList.add('active');
      loadInventoryItems('rings');
    }

    function closeInventoryModal() {
      document.getElementById('inventoryModal').classList.remove('active');
    }

    function switchInventoryTab(tab, event) {
      currentInventoryTab = tab;
      document.querySelectorAll('#inventoryModal .store-tab').forEach(btn => btn.classList.remove('active'));
      event.target.closest('.store-tab').classList.add('active');

      document.getElementById('inventoryRingsGrid').style.display = tab === 'rings' ? 'grid' : 'none';
      document.getElementById('inventoryBannersGrid').style.display = tab === 'banners' ? 'grid' : 'none';

      loadInventoryItems(tab);
    }

    async function loadEquippedItems() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) return;

      try {
        console.log('👔 Loading equipped items from API...');
        const response = await fetch(`${API_BASE_URL}/api/cosmetics/equipped/${walletAddress}`);

        if (!response.ok) throw new Error('Failed to load equipped items');

        const data = await response.json();

        if (data.success && data.equipped) {
          equippedItems = {
            ring: data.equipped.ring?.cosmetic_id || null,
            banner: data.equipped.banner?.cosmetic_id || null
          };
          console.log(`✅ Loaded equipped items:`, equippedItems);
        }
      } catch (error) {
        console.error('❌ Error loading equipped items:', error);
        equippedItems = { ring: null, banner: null };
      }
    }

    function loadInventoryItems(tab) {
      const type = tab === 'rings' ? 'ring' : 'banner';
      const allItems = tab === 'rings' ? rings : banners;
      const ownedItems = allItems.filter(item => userInventory.includes(item.id));

      const gridId = tab === 'rings' ? 'inventoryRingsGrid' : 'inventoryBannersGrid';
      const grid = document.getElementById(gridId);
      const emptyState = document.getElementById('inventoryEmptyState');

      if (ownedItems.length === 0) {
        grid.style.display = 'none';
        emptyState.style.display = 'block';
        return;
      }

      emptyState.style.display = 'none';
      grid.style.display = 'grid';

      // Group items by rarity
      const rarityOrder = ['common', 'rare', 'epic', 'legendary', 'bearableguy123'];
      const rarityLabels = {
        common: '🌿 COMMON',
        rare: '💎 RARE',
        epic: '⚡ EPIC',
        legendary: '👑 LEGENDARY',
        bearableguy123: '🌑 BEARABLEGUY123'
      };

      const groupedItems = {};
      rarityOrder.forEach(rarity => {
        groupedItems[rarity] = ownedItems.filter(item => item.rarity === rarity);
      });

      let htmlContent = '';

      rarityOrder.forEach(rarity => {
        const rarityItems = groupedItems[rarity];
        if (rarityItems.length === 0) return;

        htmlContent += `<div class="rarity-section ${rarity}-section">`;
        htmlContent += `<div class="rarity-header ${rarity}-header">${rarityLabels[rarity]}</div>`;
        htmlContent += `<div class="store-grid">`;

        rarityItems.forEach(item => {
          const isEquipped = type === 'ring' ? equippedItems.ring === item.id : equippedItems.banner === item.id;

          let previewHTML;

          if (item.ringType) {
            // Ring preview (same as store)
            if (item.imageUrl) {
              const spinAnimation = item.rarity === 'bearableguy123' ? `animation: spinRingImage 3s linear infinite;` : '';
              const glowWrapper = item.rarity === 'bearableguy123'
                ? `<div class="ring-glow-wrapper ${item.ringType}" style="width: 100px; height: 100px;"></div>`
                : '';
              const ouroborosRotation = item.ringType === 'ouroboros' ? ' rotate(180deg)' : '';

              previewHTML = `
                <div class="ring-demo">
                  <img src="https://files.catbox.moe/2f0v9c.webp" alt="Avatar" style="position: relative; z-index: 1;">
                  ${glowWrapper}
                  <img src="${item.imageUrl}" alt="${item.name}" class="image-ring-${item.ringType}" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%)${ouroborosRotation}; object-fit: contain; z-index: 2; pointer-events: none; ${spinAnimation}">
                </div>
              `;
            } else {
              previewHTML = `
                <div class="ring-demo">
                  <div class="ring-border ${item.ringType}"></div>
                  <img src="https://files.catbox.moe/2f0v9c.webp" alt="Avatar">
                </div>
              `;
            }
          } else if (item.gradient) {
            // Banner preview
            previewHTML = `
              <div class="banner-demo" style="background: ${item.gradient};">
                <div class="banner-profile-preview">
                  <img src="https://files.catbox.moe/2f0v9c.webp" alt="Profile">
                </div>
              </div>
            `;
          }

          const buttonText = isEquipped ? '✓ EQUIPPED' : 'EQUIP';
          const buttonClass = isEquipped ? 'store-item-btn equipped' : 'store-item-btn';
          const buttonAction = isEquipped ? `unequipItem(${item.id}, '${type}', event)` : `equipItem(${item.id}, '${type}', '${item.name}', event)`;

          htmlContent += `
            <div class="store-item ${item.rarity}">
              <div class="store-item-preview">
                ${previewHTML}
                <div class="store-item-badge rarity-${item.rarity}">${item.rarity.toUpperCase()}</div>
                ${isEquipped ? '<div class="store-item-equipped-badge">⚡ EQUIPPED</div>' : ''}
              </div>
              <div class="store-item-name">${item.name}</div>
              <div class="store-item-description">${item.description}</div>
              <div class="store-item-footer">
                <button class="${buttonClass}" onclick="${buttonAction}">${buttonText}</button>
              </div>
            </div>
          `;
        });

        htmlContent += `</div></div>`;
      });

      grid.innerHTML = htmlContent;
    }

    // Equip an item
    async function equipItem(cosmeticId, type, itemName, event) {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) {
        alert('Please connect your wallet first!');
        return;
      }

      const button = event?.target;
      if (button) {
        button.disabled = true;
        button.textContent = 'EQUIPPING...';
      }

      try {
        console.log(`⚡ Equipping ${type}:`, cosmeticId);
        const response = await fetch(`${API_BASE_URL}/api/cosmetics/equip`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            wallet_address: walletAddress,
            cosmetic_id: cosmeticId,
            cosmetic_type: type
          })
        });

        const data = await response.json();

        if (!response.ok || !data.success) {
          throw new Error(data.error || 'Failed to equip item');
        }

        console.log('✅ Item equipped successfully!');

        // Update local equipped state
        if (type === 'ring') {
          equippedItems.ring = cosmeticId;
        } else {
          equippedItems.banner = cosmeticId;
        }

        // Reload inventory to show new equipped state
        loadInventoryItems(currentInventoryTab);

        // Show success message
        showHypeMessage();
        setTimeout(() => {
          const overlay = document.getElementById('celebrationOverlay');
          const icon = document.getElementById('celebrationIcon');
          const text = document.getElementById('celebrationText');
          const subtext = document.getElementById('celebrationSubtext');

          icon.textContent = '⚡';
          text.textContent = 'EQUIPPED!';
          text.style.color = '#fbbf24';
          subtext.textContent = itemName;
          subtext.style.color = '#fbbf24';

          overlay.classList.add('active');
          createConfetti(100, '#fbbf24');

          setTimeout(() => {
            clearCelebration();
          }, 2000);
        }, 400);

      } catch (error) {
        console.error('❌ Equip error:', error);
        alert(`Failed to equip item: ${error.message}`);

        // Reset button on error
        if (button) {
          button.disabled = false;
          button.textContent = 'EQUIP';
        }
      }
    }

    // Unequip an item
    async function unequipItem(cosmeticId, type, event) {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) {
        alert('Please connect your wallet first!');
        return;
      }

      const button = event?.target;
      if (button) {
        button.disabled = true;
        button.textContent = 'UNEQUIPPING...';
      }

      try {
        console.log(`🔓 Unequipping ${type}:`, cosmeticId);
        const response = await fetch(`${API_BASE_URL}/api/cosmetics/unequip`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            wallet_address: walletAddress,
            cosmetic_type: type
          })
        });

        const data = await response.json();

        if (!response.ok || !data.success) {
          throw new Error(data.error || 'Failed to unequip item');
        }

        console.log('✅ Item unequipped successfully!');

        // Update local equipped state
        if (type === 'ring') {
          equippedItems.ring = null;
        } else {
          equippedItems.banner = null;
        }

        // Reload inventory to show new state
        loadInventoryItems(currentInventoryTab);

      } catch (error) {
        console.error('❌ Unequip error:', error);
        alert(`Failed to unequip item: ${error.message}`);

        // Reset button on error
        if (button) {
          button.disabled = false;
          button.textContent = '✓ EQUIPPED';
        }
      }
    }

    // Close inventory modal when clicking outside
    document.getElementById('inventoryModal')?.addEventListener('click', (e) => {
      if (e.target.id === 'inventoryModal') {
        closeInventoryModal();
      }
    });
  </script>
  <!-- ===== END COSMETICS STORE ===== -->

</body>
</html><!-- Cache bust Mon, Nov 10, 2025  6:44:10 PM -->
