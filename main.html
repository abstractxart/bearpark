<!doctype html>
<html lang="en" id="top" class="no-js" data-version="2025-01-12-waves-130-v8">
<head>
  <meta charset="utf-8" />
  <script>
  // üêª‚ùÑÔ∏è COCAINE BEAR: Register service worker for caching (PERFORMANCE!)
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
      navigator.serviceWorker.register('/sw.js').catch(function(){});
    });
  }
  // üêª CDN FALLBACK DETECTION: Gracefully handle blocked CDNs (Brave shields, etc)
  window.addEventListener('load', function() {
    // Check if Chart.js loaded (may be blocked by Brave shields)
    if (typeof Chart === 'undefined') {
      console.warn('‚ö†Ô∏è Chart.js blocked by browser - charts will be disabled');
      document.querySelectorAll('.chart-container, #plChart').forEach(function(el) {
        el.innerHTML = '<p style="color:#888;text-align:center;padding:20px;">Charts unavailable in this browser</p>';
      });
    }
    // Check if QRCode loaded
    if (typeof QRCode === 'undefined') {
      console.warn('‚ö†Ô∏è QRCode library blocked - QR codes will show as text');
      window.QRCodeFallback = true;
    }
    // Check if xrpl loaded
    if (typeof xrpl === 'undefined') {
      console.warn('‚ö†Ô∏è XRPL library blocked - some wallet features may be limited');
    }
  });
  </script>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, viewport-fit=cover" />
  <!-- üêª‚ùÑÔ∏è COCAINE BEAR: Enable caching for SPEED -->
  <meta http-equiv="Cache-Control" content="public, max-age=31536000" />
  <title>BEAR Park ‚Äî BEARcade</title>
  <meta name="description" content="Welcome to BEAR Park ‚Äî play BEARcade games, explore the lore of Bearableguy123, view BEAR NFTs, watch the live stream, and join the $BEAR community." />
  <meta name="theme-color" content="#edb723" />
  <meta name="color-scheme" content="dark light" />
  <link rel="canonical" href="https://bearpark.xyz/" />

  <!-- Open Graph / Twitter -->
  <meta property="og:type" content="website" />
  <meta property="og:title" content="BEAR Park ‚Äî BEARcade" />
  <meta property="og:description" content="Defend the castle. Play BEARcade. Join the $BEAR fam." />
  <meta property="og:image" content="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/qnd2tx.png" />
  <meta property="og:url" content="https://bearpark.xyz/" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="BEAR Park ‚Äî BEARcade" />
  <meta name="twitter:description" content="Defend the castle. Play BEARcade. Join the $BEAR fam." />
  <meta name="twitter:image" content="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/qnd2tx.png" />

  <!-- Favicons -->
  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" href="/favicon-16x16.png" sizes="16x16" type="image/png">
  <link rel="icon" href="/favicon-32x32.png" sizes="32x32" type="image/png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="icon" href="/android-chrome-192x192.png" sizes="192x192" type="image/png">
  <link rel="icon" href="/android-chrome-512x512.png" sizes="512x512" type="image/png">
  <link rel="manifest" href="/site.webmanifest">

  <!-- PWA Meta Tags -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="BEAR Park">
  <meta name="mobile-web-app-capable" content="yes">

  <!-- Performance: preconnects -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <!-- üêª‚ùÑÔ∏è COCAINE BEAR: Removed preload - caused perpetual loading spinner in tab -->
  <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&family=Nunito:wght@400;500;600;700;800&display=swap" rel="stylesheet" />

  <!-- üêª‚ùÑÔ∏è COCAINE BEAR: Preconnect to CDNs -->
  <link rel="preconnect" href="https://unpkg.com" crossorigin />
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin />
  <link rel="preconnect" href="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev" crossorigin />

  <!-- üêª‚ùÑÔ∏è Console logs enabled temporarily for debugging infinite load issue -->
  <script>
  // DEBUG MODE: Keeping console logs enabled to diagnose tab spinning issue
  </script>

  <!-- üêª‚ùÑÔ∏è COCAINE BEAR: Removed polyfill.io (blocking) - inline fallbacks below handle everything -->
  <!-- PERFORMANCE WIN: No external polyfill request for 99% of users with modern browsers -->

  <!-- üêª Fallbacks for browsers that block polyfill.io -->
  <script>
  (function(){
    // Fetch polyfill fallback
    if(!window.fetch){
      var s=document.createElement('script');
      s.src='https://cdn.jsdelivr.net/npm/whatwg-fetch@3.6.2/dist/fetch.umd.js';
      document.head.appendChild(s);
    }
    // AbortController fallback
    if(!window.AbortController){
      var s=document.createElement('script');
      s.src='https://cdn.jsdelivr.net/npm/abortcontroller-polyfill@1.7.5/dist/polyfill-patch-fetch.js';
      document.head.appendChild(s);
    }
    // IntersectionObserver fallback (old Safari, old iOS)
    if(!window.IntersectionObserver){
      var s=document.createElement('script');
      s.src='https://cdn.jsdelivr.net/npm/intersection-observer@0.12.2/intersection-observer.js';
      document.head.appendChild(s);
    }
    // ResizeObserver fallback
    if(!window.ResizeObserver){
      var s=document.createElement('script');
      s.src='https://cdn.jsdelivr.net/npm/resize-observer-polyfill@1.5.1/dist/ResizeObserver.js';
      document.head.appendChild(s);
    }
    // requestAnimationFrame fallback (very old browsers)
    if(!window.requestAnimationFrame){
      window.requestAnimationFrame=window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||function(cb){return setTimeout(cb,16)};
      window.cancelAnimationFrame=window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||clearTimeout;
    }
    // Object.assign polyfill
    if(typeof Object.assign!=='function'){
      Object.assign=function(t){for(var i=1;i<arguments.length;i++){var s=arguments[i];if(s!=null){for(var k in s){if(Object.prototype.hasOwnProperty.call(s,k)){t[k]=s[k]}}}}return t};
    }
    // Array.from polyfill
    if(!Array.from){
      Array.from=function(a,m,t){var arr=[];for(var i=0;i<a.length;i++){arr.push(m?m.call(t,a[i],i):a[i])}return arr};
    }
    // Array.prototype.includes polyfill
    if(!Array.prototype.includes){
      Array.prototype.includes=function(v){return this.indexOf(v)!==-1};
    }
    // Array.prototype.find polyfill
    if(!Array.prototype.find){
      Array.prototype.find=function(p){for(var i=0;i<this.length;i++){if(p(this[i],i,this))return this[i]}};
    }
    // Array.prototype.findIndex polyfill
    if(!Array.prototype.findIndex){
      Array.prototype.findIndex=function(p){for(var i=0;i<this.length;i++){if(p(this[i],i,this))return i}return -1};
    }
    // String.prototype.includes polyfill
    if(!String.prototype.includes){
      String.prototype.includes=function(s){return this.indexOf(s)!==-1};
    }
    // String.prototype.startsWith polyfill
    if(!String.prototype.startsWith){
      String.prototype.startsWith=function(s){return this.slice(0,s.length)===s};
    }
    // String.prototype.endsWith polyfill
    if(!String.prototype.endsWith){
      String.prototype.endsWith=function(s){return this.slice(-s.length)===s};
    }
    // Element.closest polyfill (IE, old Edge)
    if(!Element.prototype.closest){
      Element.prototype.closest=function(s){var el=this;while(el&&el.nodeType===1){if(el.matches(s))return el;el=el.parentElement}return null};
    }
    // Element.matches polyfill
    if(!Element.prototype.matches){
      Element.prototype.matches=Element.prototype.msMatchesSelector||Element.prototype.webkitMatchesSelector||function(s){var m=document.querySelectorAll(s);return Array.prototype.indexOf.call(m,this)>-1};
    }
    // NodeList.forEach polyfill
    if(!NodeList.prototype.forEach){
      NodeList.prototype.forEach=Array.prototype.forEach;
    }
    // CustomEvent polyfill (IE)
    if(typeof window.CustomEvent!=='function'){
      window.CustomEvent=function(e,p){p=p||{bubbles:false,cancelable:false,detail:null};var evt=document.createEvent('CustomEvent');evt.initCustomEvent(e,p.bubbles,p.cancelable,p.detail);return evt};
    }
    // URLSearchParams polyfill check
    if(!window.URLSearchParams){
      var s=document.createElement('script');
      s.src='https://cdn.jsdelivr.net/npm/url-search-params-polyfill@8.2.0/index.js';
      document.head.appendChild(s);
    }
    // Performance.now polyfill
    if(!window.performance){window.performance={}}
    if(!window.performance.now){
      var start=Date.now();
      window.performance.now=function(){return Date.now()-start};
    }
  })();
  </script>

  <!-- üêª‚ùÑÔ∏è COCAINE BEAR: Defer ALL scripts (non-blocking) -->
  <script defer src="https://unpkg.com/xrpl@3.0.0/build/xrpl-latest-min.js"></script>

  <!-- ü¶ò JOEY WALLET: WalletConnect SDK for Joey integration -->
  <!-- Fallback script for browsers that don't support dynamic import -->
  <script defer src="https://unpkg.com/@walletconnect/sign-client@2.11.0/dist/index.umd.js"
          onerror="console.warn('WalletConnect UMD fallback blocked')"
          onload="window.WalletConnectSignClient = window.WalletConnectSignClient || window.SignClient"></script>
  <script>
    (async function loadWalletConnect() {
      // Skip if already loaded via fallback script
      if (window.WalletConnectSignClient) {
        console.log('‚úÖ WalletConnect already loaded');
        return;
      }
      try {
        console.log('ü¶ò Loading WalletConnect via dynamic import...');
        const module = await import('https://esm.sh/@walletconnect/sign-client@2.11.0');
        window.WalletConnectSignClient = module.default;
        console.log('‚úÖ WalletConnect SignClient loaded successfully');
      } catch (err) {
        // Dynamic import failed - check if UMD fallback loaded
        if (window.SignClient) {
          window.WalletConnectSignClient = window.SignClient;
          console.log('‚úÖ WalletConnect loaded via UMD fallback');
        } else {
          console.warn('‚ö†Ô∏è WalletConnect unavailable - Joey Wallet disabled:', err.message);
        }
      }
    })();
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>

  <style>
  /* üêª BROWSER COMPATIBILITY CSS =========================================== */
  /* Vendor prefixes for older browsers (Opera, old Chrome, Safari, Edge, Firefox) */

  /* Flexbox fallbacks */
  .flex-container {
    display: -webkit-box;      /* OLD - iOS 6-, Safari 3.1-6 */
    display: -moz-box;         /* OLD - Firefox 19- */
    display: -ms-flexbox;      /* TWEENER - IE 10 */
    display: -webkit-flex;     /* NEW - Chrome */
    display: flex;
  }

  /* Grid fallbacks - use flexbox as backup */
  @supports not (display: grid) {
    .grid-container {
      display: -webkit-box;
      display: -moz-box;
      display: -ms-flexbox;
      display: -webkit-flex;
      display: flex;
      -webkit-flex-wrap: wrap;
      -ms-flex-wrap: wrap;
      flex-wrap: wrap;
    }
  }

  /* Transform prefixes */
  .transform-element {
    -webkit-transform: translateZ(0);
    -moz-transform: translateZ(0);
    -ms-transform: translateZ(0);
    -o-transform: translateZ(0);
    transform: translateZ(0);
  }

  /* Transition prefixes */
  .transition-element {
    -webkit-transition: all 0.3s ease;
    -moz-transition: all 0.3s ease;
    -o-transition: all 0.3s ease;
    transition: all 0.3s ease;
  }

  /* Animation prefixes */
  @-webkit-keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
  @-moz-keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
  @-o-keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
  @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

  /* üêª MOBILE PERFORMANCE OPTIMIZATION =========================================== */
  /* Disable expensive backdrop-filter effects on mobile devices to improve scrolling */
  @media (max-width: 768px), (prefers-reduced-motion: reduce) {
    .glass-effect,
    .blur-bg,
    [style*="backdrop-filter"] {
      -webkit-backdrop-filter: none !important;
      backdrop-filter: none !important;
    }
    /* Provide solid background fallback */
    .glass-effect, .blur-bg {
      background: rgba(0,0,0,0.85) !important;
    }
    /* Reduce box-shadow complexity on mobile */
    .card, .honey-card, .stat-box, .tri-border-rounded {
      box-shadow: 0 4px 12px rgba(0,0,0,0.3) !important;
    }
  }

  /* Backdrop filter fallback (not supported in old browsers) */
  @supports not ((-webkit-backdrop-filter: blur(10px)) or (backdrop-filter: blur(10px))) {
    .glass-effect {
      background: rgba(30, 34, 38, 0.98) !important;
    }
  }

  /* position: sticky fallback */
  .sticky-element {
    position: -webkit-sticky;
    position: sticky;
  }

  /* User-select prefixes */
  .no-select {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }

  /* Appearance prefixes (for buttons/inputs) */
  button, input, select, textarea {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
  }

  /* üêª‚ùÑÔ∏è COCAINE BEAR PERFORMANCE CSS ====================================== */
  *,*::before,*::after{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}
  html{-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%;text-size-adjust:100%;scroll-behavior:auto!important}
  img,video,iframe{content-visibility:auto;contain-intrinsic-size:300px 200px}
  /* üêª‚ùÑÔ∏è COCAINE BEAR: Skip rendering offscreen sections */
  section{content-visibility:auto;contain-intrinsic-size:auto 500px}
  .card,.modal,.drawer{contain:layout style paint}
  img[loading="lazy"]{opacity:0;-webkit-transition:opacity .3s;-moz-transition:opacity .3s;-o-transition:opacity .3s;transition:opacity .3s}
  img[loading="lazy"].loaded,img:not([loading="lazy"]){opacity:1}
  @media(prefers-reduced-motion:reduce){*{-webkit-animation:none!important;-moz-animation:none!important;-o-animation:none!important;animation:none!important;-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;transition:none!important;scroll-behavior:auto!important}}

  /* ==== THEME =========================================================== */
  :root{
    --gold:#ffae00;
    --gold-ink:#231b04;
    --charcoal:#141619;
    --card:#1e2226;
    --ink:#0b0d0e;
    --accent:#d75c46;
    --honey:#ffefb3;
    --elev: 0 0.8px 1.6px rgba(0,0,0,.18), 0 5px 18px rgba(0,0,0,.28);
    --elev-strong: 0 10px 28px rgba(0,0,0,.45), 0 1px 0 rgba(255,255,255,.03) inset;
    --ease-spring:cubic-bezier(.18,.9,.2,1);
    --ring: 0 0 0 4px #000, 0 0 0 6px rgba(255,174,0,.66);
    accent-color: var(--gold);
    --stripe-purple: #680cd9;
    --stripe-yellow: #ffae00;
    --stripe-green: #07ae08;
    --tri-gradient: linear-gradient(to right, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);

    /* üî•üêª GODMODE GLASSMORPHISM + MATERIAL 3 SYSTEM üêªüî• */
    /* üêª‚ùÑÔ∏è COCAINE BEAR OPTIMIZATION: Removed heavy blur - backgrounds are opaque anyway! */
    /* Original values were blur(40-80px) which KILLED GPU on older devices */
    --glass-blur: none;
    --glass-blur-heavy: none;
    --glass-blur-light: none;

    /* Transparent Glass Backgrounds */
    --glass-bg: rgba(30, 34, 38, 0.95);
    --glass-bg-heavy: rgba(30, 34, 38, 1);
    --glass-bg-light: rgba(30, 34, 38, 0.85);
    --glass-bg-ultra: rgba(30, 34, 38, 0.75);

    /* Glass Borders */
    --glass-border: rgba(255, 174, 0, 0.15);
    --glass-border-hover: rgba(255, 174, 0, 0.4);

    /* Material 3 Elevation with Glass */
    /* üêª‚ùÑÔ∏è COCAINE BEAR: Simplified shadows - 1-2 layers max for performance */
    --elevation-1-glass: 0 2px 4px rgba(0, 0, 0, 0.25);
    --elevation-2-glass: 0 4px 12px rgba(0, 0, 0, 0.3);
    --elevation-3-glass: 0 6px 16px rgba(0, 0, 0, 0.35);
    --elevation-4-glass: 0 8px 24px rgba(0, 0, 0, 0.4);
    --elevation-5-glass: 0 12px 32px rgba(0, 0, 0, 0.45);

    /* Godmode Glow Effects */
    /* üêª‚ùÑÔ∏è COCAINE BEAR: Simplified glows - less layers = faster paint */
    --glow-gold: 0 0 15px rgba(255, 174, 0, 0.3);
    --glow-honey: 0 0 12px rgba(255, 239, 179, 0.3);
    --glow-tri: 0 0 15px rgba(255, 174, 0, 0.25);

    /* 420FPS Smooth Spring Physics */
    --spring-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
    --spring-smooth: cubic-bezier(0.25, 0.46, 0.45, 0.94);
    --spring-sharp: cubic-bezier(0.4, 0.0, 0.2, 1);
    --spring-elastic: cubic-bezier(0.68, -0.6, 0.32, 1.6);
    --spring-butter: cubic-bezier(0.16, 1, 0.3, 1);

    /* Performance Optimization */
    /* üêª‚ùÑÔ∏è COCAINE BEAR: Removed will-change variable - creates too many composite layers! */
    /* Only apply will-change on ACTIVE animations, not as a variable */
    --transform-gpu: translateZ(0);
    --will-change-transform: auto;
  }

  /* ==== BASE ============================================================ */
  html,body{margin:0;padding:0;background:var(--charcoal);color:#fff}
  body{padding-bottom:calc(160px + env(safe-area-inset-bottom));-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}

  /* Tri-color border utility for rounded elements */
  .tri-border-rounded {
    position: relative;
    border: none;
  }
  .tri-border-rounded::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: inherit;
    padding: 6px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: -1;
  }
  /* üêª‚ùÑÔ∏è COCAINE BEAR: Smooth scroll disabled for performance */
  img{max-width:100%;height:auto;display:block}
  a{color:inherit;text-decoration:none}
  .wrap{max-width:1100px;margin:0 auto;padding:52px 20px}
  .center{display:flex;justify-content:center;align-items:center}

  /* Global fonts */
  :root {
    --font-body: "Nunito", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    --font-heading: "Luckiest Guy", "Arial Black", Impact, sans-serif;
  }

  /* Base body font - Nunito */
  body {
    font-family: var(--font-body);
    font-size: 17px;
    text-rendering: optimizeLegibility;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  /* Body text elements - Nunito */
  p, small, span, div, label,
  input, textarea, select,
  .description, .text, .content,
  .tile .lbl, .tile .val,
  .leaderboard-name,
  .raid-description, .raid-reward,
  .meme-caption, .gallery-caption,
  .modal-body, .card-body,
  .community-search-input,
  .profile-section p,
  td, th, li {
    font-family: var(--font-body) !important;
  }

  /* Headings & titles - Luckiest Guy */
  h1, h2, h3, h4, h5, h6,
  .title, .subtitle,
  .section-title,
  .modal-title,
  .leaderboard-rank,
  .btn,
  .raid-action-btn,
  .nav-modal-item span,
  .raid-title,
  .meme-title {
    font-family: var(--font-heading) !important;
  }

  /* Monospace for wallet addresses/code */
  .leaderboard-wallet,
  .wallet-address,
  code, pre {
    font-family: 'Courier New', monospace !important;
  }

  /* üêª‚ùÑÔ∏è COCAINE BEAR: Simplified decorative effects (removed heavy blur) */
  body::before{
    content:"";
    position:fixed; inset:0; pointer-events:none; z-index:-2;
    background: linear-gradient(135deg, rgba(237,183,35,.03) 0%, transparent 50%, rgba(215,92,70,.03) 100%);
    will-change:transform;
  }
  body::after{
    content:"";
    position:fixed; inset:0; pointer-events:none; z-index:-1;
    background: repeating-linear-gradient(0deg, rgba(255,255,255,.015) 0 1px, transparent 1px 3px);
    opacity:.15;
    will-change:transform;
  }

  /* Skip link */
  .skip-link{position:absolute;left:-999px;top:auto;width:1px;height:1px;overflow:hidden}
  .skip-link:focus{left:12px;top:12px;width:auto;height:auto;z-index:1000;background:#000;color:#fff;border:3px solid var(--gold);border-radius:10px;padding:10px 14px}

  /* Sticky nav + scroll progress */
  .site-nav{position:sticky;top:0;z-index:50;background:linear-gradient(180deg, #0f1114, rgba(15,17,20,.8));backdrop-filter:saturate(1.05) blur(6px);border-bottom:4px solid transparent; border-image: var(--tri-gradient) 1}
  .site-nav .bar{max-width:1100px;margin:0 auto;display:flex;align-items:center;gap:14px;padding:10px 20px}
  .brand{display:flex;align-items:center;gap:10px;font-weight:900}
  .brand img{width:36px;height:36px}
  .links{display:flex;gap:10px;flex-wrap:wrap}
  .links a{font-weight:900;padding:8px 12px;border-radius:12px}
  .links a[aria-current="true"], .links a:hover{background:#1c1f23}
  .nav-cta{margin-left:auto}
  .progress{position:absolute;inset-inline:0;top:0;height:4px;background:linear-gradient(90deg,var(--gold),#ffe280);transform-origin:left center;transform:scaleX(0)}

  /* Headings */
  .h1,.h2,.h3{font-weight:900; letter-spacing:.5px; text-align:center; line-height:1.05; margin:0 0 14px; color:#fff; text-shadow:0 4px 0 rgba(0,0,0,.35), 0 1px 0 rgba(0,0,0,.25)}
  .h1{font-size:clamp(44px,7vw,96px)}
  .h2{font-size:clamp(38px,5.5vw,72px)}
  .h3{font-size:clamp(28px,3.5vw,44px)}
  p{margin:0 0 14px;font-weight:600;font-size:18px;line-height:1.35}
  .on-dark{color:var(--gold)!important}

  /* Sections */
  section{
    position:relative;
    border-top: 6px solid;
    border-bottom: 6px solid;
    border-image: linear-gradient(to right, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%) 1;
  }
  section.alt{background:var(--gold);color:var(--gold-ink)}
  section.dark{background:linear-gradient(180deg,#141619 0%, #101215 100%);color:#fff}
  .spacer{height:12px}

  /* Buttons */
  .btn{display:inline-flex;align-items:center;justify-content:center;gap:.6rem;font:900 clamp(18px,2.5vw,24px)/1 "Luckiest Guy","Arial Black",Impact,system-ui,sans-serif;border-radius:26px;padding:1.1rem 1.6rem;color:#fff;background:var(--accent);border:none; box-shadow:0 10px 0 #7b2a20, 0 18px 24px rgba(0,0,0,.35);transition:transform .12s var(--ease-spring), box-shadow .12s var(--ease-spring), filter .2s ease;white-space:nowrap; position:relative; will-change:transform}
  .btn::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 26px;
    padding: 6px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: -1;
  }
  .btn{transition:all 0.2s ease;}
  .btn:hover{filter:brightness(1.12); transform:translateY(-2px);}
  .btn:active{transform:translateY(4px); box-shadow:0 6px 0 #7b2a20, 0 10px 16px rgba(0,0,0,.35)}
  .btn.ghost{background:#1c1f23;color:#fff;box-shadow:0 10px 0 #000,0 18px 24px rgba(0,0,0,.35)}
  .btn.gold{background:var(--gold);color:#000;box-shadow:0 10px 0 #9b7a0d,0 18px 24px rgba(0,0,0,.35)}
  .btn.gold:hover{box-shadow:0 12px 0 #9b7a0d,0 22px 28px rgba(0,0,0,.4); filter:brightness(1.15);}
  .btn:focus-visible{outline:none; box-shadow:var(--ring)}

  /* Input Styles */
  input[type="text"]:focus{
    border-color:var(--gold) !important;
    box-shadow:0 0 0 3px rgba(237,183,35,0.2);
    outline:none;
  }

  /* Cards */
  .card{
    background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    border:4px solid transparent;
    border-radius:20px;
    padding:22px;
    box-shadow:var(--elev-strong);
    overflow:hidden;
    -webkit-overflow-scrolling:auto;
    backdrop-filter:saturate(1.1) blur(2px);
    transform-style:preserve-3d;
    will-change:transform;
    transition:transform .4s var(--ease-spring), box-shadow .4s var(--ease-spring);
    background-image: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02)), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
  }
  .card:hover{ transform:translateY(-4px); box-shadow:0 18px 40px rgba(0,0,0,.5) }
  .card:focus-within{ box-shadow:var(--ring), var(--elev-strong) }

  /* Hero */
  .hero{--hero-bg:url("https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/qnd2tx.png"); background:radial-gradient(1200px 500px at 50% -10%, rgba(255,255,255,.065), transparent 60%) , var(--hero-bg) center/cover no-repeat; min-height:56vh; display:flex; align-items:center; position:relative; border-bottom:6px solid transparent; border-image: var(--tri-gradient) 1}
  .hero .plate{background:var(--gold); color:var(--ink); border:6px solid transparent; border-radius:22px; box-shadow:0 22px 48px rgba(0,0,0,.45), 0 2px 0 rgba(255,255,255,.25) inset; padding:20px 28px; display:inline-block; margin:0 auto; position:relative; transform:perspective(800px) rotateX(0) rotateY(0) translateZ(0); transition:transform .6s var(--ease-spring), box-shadow .4s var(--ease-spring); will-change:transform; background-image: linear-gradient(var(--gold), var(--gold)), var(--tri-gradient); background-origin: padding-box, border-box; background-clip: padding-box, border-box;}
  .hero .logo{position:absolute; left:-72px; top:-40px; width:120px; transform:rotate(-4deg); filter:drop-shadow(0 8px 0 rgba(0,0,0,.4))}
  .hero .subtitle{font:800 clamp(16px,2.4vw,22px)/1.2 "Luckiest Guy"; margin-top:-6px; color:var(--ink)}

  /* Side honey rails */
  .rails::before,.rails::after{content:"";position:fixed;top:0;bottom:0;width:18px;z-index:1;pointer-events:none;opacity:.65}
  .rails::before{left:80px;background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0)), repeating-linear-gradient(180deg, rgba(0,0,0,.8) 0 3px, rgba(0,0,0,0) 3px 6px), linear-gradient(180deg, var(--gold) 0%, #946e00 100%);border:3px solid transparent;border-image: var(--tri-gradient) 1;border-radius:999px}
  .rails::after{right:6px;background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0)), repeating-linear-gradient(180deg, rgba(0,0,0,.8) 0 3px, rgba(0,0,0,0) 3px 6px), linear-gradient(180deg, var(--gold) 0%, #946e00 100%);border:3px solid transparent;border-image: var(--tri-gradient) 1;border-radius:999px}

  /* Arcade image */
  .arcade{position:relative;width:100%;max-width:1100px;margin:0 auto}
  .arcade img{width:100%;height:auto;display:block;border:4px solid transparent;border-radius:20px;box-shadow:0 18px 40px rgba(0,0,0,.45); background-image: linear-gradient(rgba(0,0,0,0), rgba(0,0,0,0)), var(--tri-gradient); background-origin: padding-box, border-box; background-clip: padding-box, border-box;}
  .arcade a.hotspot{position:absolute;display:block;border-radius:16px;text-indent:-9999px;overflow:hidden;outline:none;background:transparent;transition: box-shadow .25s var(--ease-spring), transform .25s var(--ease-spring)}
  .arcade a.hotspot:focus-visible{outline:6px solid rgba(237,183,35,.7)}
  .arcade a.hotspot:hover, .arcade a.hotspot:focus-visible{ box-shadow: 0 0 0 6px rgba(237,183,35,.35), 0 0 0 10px rgba(0,0,0,.6); }
  .arcade a.hotspot::after{
    content:"";
    position:absolute; left:50%; top:0; width:20px; height:0; transform:translate(-50%,0);
    background: linear-gradient(180deg, #fff6c7 0%, #ffe280 40%, #edb723 70%, #9b7a0d 100%);
  border:3px solid transparent; border-top:none; border-radius:0 0 16px 16px; border-image: var(--tri-gradient) 1; box-shadow:0 6px 0 #946e00, 0 12px 20px rgba(0,0,0,.4);
    transition:height .35s var(--ease-spring), opacity .25s ease; opacity:0;
  }
  .arcade a.hotspot:hover::after, .arcade a.hotspot:focus-visible::after{ height:36px; opacity:1 }

  /* Game cards */
  .game-card {
    position: relative;
  }
  .game-card a > div {
    cursor: pointer;
  }
  .game-card:hover a > div {
    transform: translateY(-8px) scale(1.02);
    box-shadow: 0 16px 40px rgba(0,0,0,0.6), 0 0 40px rgba(104, 12, 217, 0.3);
  }
  .game-card:active a > div {
    transform: translateY(-4px) scale(1.01);
    box-shadow: 0 12px 32px rgba(0,0,0,0.5);
  }

  /* Grid & tiles */
  .grid-2{display:grid;grid-template-columns:repeat(2,1fr);gap:22px}
  @media (max-width:820px){.grid-2{grid-template-columns:1fr}}
  .grid-3{display:grid;grid-template-columns:repeat(3,1fr);gap:22px}
  @media (max-width:1024px){.grid-3{grid-template-columns:1fr}}
  .tile{text-decoration:none;display:flex;flex-direction:column;align-items:center;gap:14px}
  .tile .face{width:100%;min-height:140px;padding:22px;background:var(--card);border:4px solid transparent;border-radius:18px;box-shadow:0 12px 0 #000,0 18px 28px rgba(0,0,0,.35);display:flex;align-items:center;justify-content:center;transition:transform .35s var(--ease-spring), box-shadow .35s var(--ease-spring);transform-style:preserve-3d; will-change:transform; background-image: linear-gradient(var(--card), var(--card)), var(--tri-gradient); background-origin: padding-box, border-box; background-clip: padding-box, border-box;}
  .tile:hover .face{ transform:translateY(-4px); box-shadow:0 16px 0 #000,0 26px 40px rgba(0,0,0,.45) }
  .tile img{max-width:220px;max-height:64px;object-fit:contain;filter:drop-shadow(0 2px 0 rgba(0,0,0,.4))}
  .tile .lbl{font-weight:800;font-size:18px;line-height:1.2;color:var(--ink);opacity:.9}
  .dark .tile .lbl{color:var(--gold)}

  /* NFTs */
  #nfts .card{padding:26px}
  #nfts .card{background:linear-gradient(180deg,#141619 0%, #101215 100%) !important; border:4px solid transparent !important; border-radius:20px !important; background-image: linear-gradient(180deg,#141619 0%, #101215 100%), var(--tri-gradient) !important; background-origin: padding-box, border-box !important; background-clip: padding-box, border-box !important;}
  .nft-media{display:block;border:6px solid transparent;border-radius:16px;overflow:hidden; background-image: linear-gradient(rgba(0,0,0,0), rgba(0,0,0,0)), var(--tri-gradient); background-origin: padding-box, border-box; background-clip: padding-box, border-box;}
  .nft-media img,.nft-media video{display:block;width:100%;height:auto}
  #nfts .card h3,#nfts .card p{color:var(--gold)!important}

  /* Leaderboards */
  .leaderboard-card{
    position:relative;
    background:radial-gradient(500px 200px at 50% -20%, rgba(118,174,255,.12), transparent 60%), var(--ink);
    border-radius:28px;
    padding:32px 24px;
    isolation:isolate;
  }
  .leaderboard-card::before{
    content:'';
    position:absolute;
    inset:0;
    border-radius:28px;
    padding:4px;
    background:var(--tri-gradient);
    -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite:xor;
    mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite:exclude;
    pointer-events:none;
    z-index:0;
    opacity:1;
  }
  .leaderboard-list{
    display:grid;
    grid-template-columns:1fr;
    gap:20px;
    max-height:500px;
    overflow-y:auto;
  }

  .leaderboard-list::-webkit-scrollbar{
    width:8px;
  }

  .leaderboard-list::-webkit-scrollbar-track{
    background:rgba(0,0,0,0.2);
    border-radius:4px;
  }

  .leaderboard-list::-webkit-scrollbar-thumb{
    background:var(--gold);
    border-radius:4px;
  }
  .leaderboard-entry{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:16px;
    border-radius:12px;
    background:linear-gradient(135deg, rgba(104, 12, 217, 0.15) 0%, rgba(7, 174, 8, 0.15) 100%);
    border-left:4px solid var(--gold);
    transition:all 0.2s ease;
  }
  .leaderboard-entry:hover{transform:translateX(8px);background:linear-gradient(135deg, rgba(104, 12, 217, 0.25) 0%, rgba(7, 174, 8, 0.25) 100%)}
  .leaderboard-entry.rank-1{background:linear-gradient(135deg, rgba(237, 183, 35, 0.3) 0%, rgba(255, 215, 0, 0.2) 100%);border-left-color:#FFD700;border-left-width:6px}
  .leaderboard-entry.rank-2{background:linear-gradient(135deg, rgba(192, 192, 192, 0.2) 0%, rgba(169, 169, 169, 0.15) 100%);border-left-color:#C0C0C0;border-left-width:5px}
  .leaderboard-entry.rank-3{background:linear-gradient(135deg, rgba(205, 127, 50, 0.2) 0%, rgba(184, 115, 51, 0.15) 100%);border-left-color:#CD7F32;border-left-width:5px}
  .leaderboard-rank{font-size:24px;color:var(--gold);text-shadow:2px 2px 0px #000;min-width:50px;font-family:'Luckiest Guy',cursive}
  .leaderboard-name{font-size:18px;color:#fff;text-shadow:2px 2px 0px #000;flex:1;margin:0 16px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .leaderboard-score{font-size:22px;color:var(--stripe-yellow);text-shadow:2px 2px 0px #000;font-weight:800}
  .leaderboard-wallet{font-size:11px;color:#888;font-family:monospace;margin-top:4px}
  .loading{text-align:center;padding:32px;color:#888;font-size:16px}

  /* Community banner */
  .community-banner{position:relative;overflow:hidden;border-radius:22px;border:6px solid transparent;background:#000;box-shadow:0 20px 40px rgba(0,0,0,.45); background-image: linear-gradient(#000, #000), var(--tri-gradient); background-origin: padding-box, border-box; background-clip: padding-box, border-box; min-height:500px;}
  .community-banner img.bg{position:absolute;top:50%;left:50%;width:140%;height:140%;min-width:140%;min-height:140%;object-fit:cover;opacity:.5;filter:saturate(1.15) contrast(1.1) blur(1px);animation:slow-pan 60s linear infinite;will-change:transform;transition:transform 0.3s ease-out;transform:translate(-50%, -50%)}
  @keyframes slow-pan{0%{transform:translate(-50%, -50%) translateX(0)}50%{transform:translate(-50%, -50%) translateX(-14.29%)}100%{transform:translate(-50%, -50%) translateX(0)}}
  @keyframes profile-banner-pan{0%{transform:translate(-50%, -50%) translate(0, 0)}25%{transform:translate(-50%, -50%) translate(-8%, -5%)}50%{transform:translate(-50%, -50%) translate(5%, -8%)}75%{transform:translate(-50%, -50%) translate(-5%, 8%)}100%{transform:translate(-50%, -50%) translate(0, 0)}}
  .community-banner .overlay{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:32px 24px;background:radial-gradient(circle at center, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.7) 100%)}
  .community-content{display:flex;flex-direction:column;align-items:center;max-width:700px;position:relative;z-index:2}
  .community-badge{width:160px;height:160px;background:var(--gold);border-radius:50%;display:flex;align-items:center;justify-content:center;box-shadow:0 12px 32px rgba(237,183,35,0.5), 0 0 0 8px rgba(237,183,35,0.3), 0 0 0 16px rgba(0,0,0,0.4);animation:badge-float 3s ease-in-out infinite}
  @keyframes badge-float{0%,100%{transform:translateY(0)}50%{transform:translateY(-10px)}}
  .community-buttons{display:flex;gap:16px;flex-wrap:wrap;justify-content:center;margin-bottom:32px}
  .community-btn{display:flex;align-items:center;gap:10px;font-size:16px;padding:14px 28px;transition:all 0.3s ease;position:relative;overflow:hidden}
  .community-btn::before{content:"";position:absolute;top:50%;left:50%;width:0;height:0;border-radius:50%;background:rgba(255,255,255,0.3);transform:translate(-50%,-50%);transition:width 0.6s,height 0.6s}
  .community-btn:hover::before{width:300px;height:300px}
  .community-btn:hover{transform:translateY(-4px) scale(1.05);box-shadow:0 12px 32px rgba(237,183,35,0.5)}
  .btn-icon{font-size:22px;filter:drop-shadow(2px 2px 0 rgba(0,0,0,0.3))}
  .btn-text{position:relative;z-index:1}
  .community-stats{display:grid;grid-template-columns:repeat(4,1fr);gap:24px;padding:20px;background:rgba(0,0,0,0.85);border-radius:16px;border:2px solid rgba(237,183,35,0.2);max-width:700px}
  .stat-item{display:flex;flex-direction:column;align-items:center;gap:8px;min-width:100px}
  .stat-emoji{font-size:32px;animation:stat-pulse 2s ease-in-out infinite}
  .stat-text{font-size:13px;color:rgba(255,255,255,0.85);font-weight:700;text-align:center;text-shadow:1px 1px 2px #000}
  @keyframes stat-pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.1)}}
  .paw-prints{position:absolute;top:20px;left:20px;right:20px;bottom:20px;pointer-events:none;z-index:1}
  .paw{position:absolute;font-size:24px;opacity:0.15;animation:paw-walk 20s linear infinite}
  .paw:nth-child(1){top:10%;left:-50px;animation-delay:0s}
  .paw:nth-child(2){top:30%;left:-50px;animation-delay:5s}
  .paw:nth-child(3){top:50%;left:-50px;animation-delay:10s}
  .paw:nth-child(4){top:70%;left:-50px;animation-delay:15s}
  @keyframes paw-walk{0%{left:-50px;transform:rotate(-15deg)}100%{left:calc(100% + 50px);transform:rotate(15deg)}}
  @media (max-width:640px){
    .community-banner{min-height:700px}
    .community-badge{width:140px;height:140px}
    .community-buttons{flex-direction:column;width:100%;max-width:280px}
    .community-btn{width:100%;justify-content:center}
    .community-stats{grid-template-columns:repeat(2,1fr);gap:16px;padding:16px;max-width:100%}
    .stat-item{min-width:auto}
    .stat-emoji{font-size:28px}
    .stat-text{font-size:12px}
  }
  .pair{display:flex;gap:16px;flex-wrap:wrap;justify-content:center}

  /* Kick stream (true 16:9) */
  .square{position:relative;width:100%;max-width:900px;margin:0 auto;aspect-ratio:16/9;border-radius:16px;overflow:hidden}
  .square iframe,.square .placeholder{position:absolute;inset:0;width:100%;height:100%;border:0;border-radius:16px}
  .square .placeholder{display:grid;place-items:center;background:#0b0d0e;border:0}

  /* Carousel */
  .carousel{position:relative;overflow:visible;border:6px solid transparent;border-radius:16px; background-image: linear-gradient(rgba(0,0,0,0), rgba(0,0,0,0)), var(--tri-gradient); background-origin: padding-box, border-box; background-clip: padding-box, border-box;}
  .carousel .viewport{position:relative;width:100%;min-height:400px;overflow:hidden;touch-action:none;cursor:grab;background:#0b0d0e;display:flex;align-items:center;border-radius:12px}
  .carousel .viewport.grabbing{cursor:grabbing}
  .slides{display:flex;will-change:transform;transition:transform .7s var(--ease-spring);align-items:center}
  .slides img{width:100%;height:auto;flex:0 0 100%;object-fit:contain; user-select:none;-webkit-user-drag:none;pointer-events:none;background:#0b0d0e; transform-origin:center center;display:block;max-height:600px}

  /* Carousel Navigation Arrows */
  .carousel-arrow{position:absolute;top:50%;transform:translateY(-50%);z-index:10;width:56px;height:56px;border-radius:50%;border:3px solid transparent;background:linear-gradient(#0b0d0e, #0b0d0e) padding-box, var(--tri-gradient) border-box;color:var(--gold);cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all 0.3s var(--ease-spring);opacity:0.9}
  .carousel-arrow:hover{opacity:1;transform:translateY(-50%) scale(1.1);box-shadow:0 8px 24px rgba(0,0,0,0.5), 0 0 20px rgba(237,183,35,0.3)}
  .carousel-arrow:active{transform:translateY(-50%) scale(0.95)}
  .carousel-arrow-left{left:-28px}
  .carousel-arrow-right{right:-28px}
  .carousel-arrow svg{filter:drop-shadow(0 2px 4px rgba(0,0,0,0.8))}

  /* Hide arrows on mobile/tablet */
  @media (max-width: 1024px) {
    .carousel-arrow{display:none}
  }

  .dots{display:flex;gap:8px;justify-content:center;margin-top:12px}
  .dot{width:16px;height:16px;border-radius:50%;background:#000;border:3px solid transparent;background-image:linear-gradient(#000, #000), var(--tri-gradient);background-origin:padding-box, border-box;background-clip:padding-box, border-box;opacity:1;transition:all .25s var(--ease-spring);cursor:pointer}
  .dot:hover{transform:scale(1.1)}
  .dot.active{background-image:linear-gradient(var(--gold), var(--gold)), var(--tri-gradient);transform:scale(1.15);box-shadow:0 0 12px rgba(237,183,35,0.6)}
  footer{border-top:6px solid transparent; border-image: var(--tri-gradient) 1}

  /* Scroll reveal */
  .reveal{opacity:1; transform:translateY(0) scale(1); filter:blur(0)}
  .reveal.in{opacity:1; transform:translateY(0) scale(1); filter:blur(0); transition:opacity .6s var(--ease-spring), transform .6s var(--ease-spring), filter .6s var(--ease-spring)}

  /* Reduced motion */
  @media (prefers-reduced-motion:reduce){
    html{scroll-behavior:auto}
    .reveal{opacity:1; transform:none; filter:none}
    .slides{transition:none}
    .btn, .card, .tile .face{transition:none}
  }

  /* Buy drawer + FAB base styles used by JS */
  .fab-buy{
    position:fixed; right:20px; bottom:calc(20px + env(safe-area-inset-bottom)); z-index:60;
    display:inline-flex; align-items:center; justify-content:center; gap:.6rem;
    font:900 22px/1 "Luckiest Guy","Arial Black",Impact,system-ui,sans-serif;
    padding:18px 28px; border-radius:999px;
    color:var(--gold);
    background:#1a1a1a;
    text-shadow: 0 2px 8px rgba(237, 183, 35, 0.4), 0 0 20px rgba(237, 183, 35, 0.3);
    border: 4px solid transparent;
    box-shadow:0 8px 0 #000, 0 12px 32px rgba(0,0,0,0.8);
    background-image: linear-gradient(#1a1a1a, #1a1a1a), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    transition:transform .12s var(--ease-spring), filter .15s ease, box-shadow .2s ease;
    cursor: pointer;
  }
  .fab-buy:hover{
    filter:brightness(1.15);
    transform:translateY(-3px);
    box-shadow:0 10px 0 #000, 0 16px 40px rgba(0,0,0,0.9), 0 0 30px rgba(237, 183, 35, 0.4);
    text-shadow: 0 2px 10px rgba(237, 183, 35, 0.6), 0 0 30px rgba(237, 183, 35, 0.5);
  }
  .fab-buy:active{
    transform:translateY(2px);
    box-shadow:0 4px 0 #000, 0 6px 16px rgba(0,0,0,0.6);
  }

  /* Disconnect button inside drawer */
  .drawer-disconnect-btn {
    display:flex; align-items:center; justify-content:center; gap:.6rem;
    font:900 18px/1 "Luckiest Guy","Arial Black",Impact,system-ui,sans-serif;
    padding:14px 20px; border-radius:20px; color:#fff; background:var(--accent);
    border: 3px solid transparent;
    box-shadow:0 6px 0 #7b2a20, 0 8px 16px rgba(0,0,0,.35);
    transition:all .2s ease;
    cursor:pointer;
    width:100%;
    margin-top:8px;
    margin-bottom:0;
    text-transform:uppercase;
    background-image: linear-gradient(var(--accent), var(--accent)), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
  }

  #drawerDisconnectContainer {
    margin-top: auto;
    padding-top: 8px;
  }
  .drawer-disconnect-btn:hover{
    filter:brightness(1.15);
    transform:translateY(-2px);
    box-shadow:0 8px 0 #7b2a20, 0 10px 20px rgba(0,0,0,.45);
  }
  .drawer-disconnect-btn:active{transform:translateY(0); box-shadow:0 2px 0 #7b2a20, 0 4px 10px rgba(0,0,0,.35);}

  .drawer{
    position:fixed; top:0; right:0; bottom:0;
    width:min(420px, calc(100% - 72px));
    background:linear-gradient(180deg,#141619 0%, #0e1013 100%);
    border-left:6px solid;
    border-image: linear-gradient(to bottom, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%) 1;
    z-index:70;
    transform:translateX(102%); transition:transform .38s var(--ease-spring);
    box-shadow:-24px 0 40px rgba(0,0,0,.55);
    display:flex; flex-direction:column;
  }
  .drawer.open{ transform:translateX(0) }
  .drawer-scrim{ position:fixed; inset:0; background:rgba(0,0,0,.75); z-index:65 }
  .drawer-head{ flex-shrink:0; display:flex; align-items:center; justify-content:space-between; gap:12px; padding:14px 18px; padding-top:calc(88px + env(safe-area-inset-top)); border-bottom:4px solid; border-image: linear-gradient(to right, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%) 1; background:linear-gradient(180deg, rgba(237,183,35,0.12) 0%, #1a1d22 100%); z-index:71 }
  .drawer-body{ flex:1; padding:20px; padding-bottom:calc(220px + env(safe-area-inset-bottom)); overflow:auto; display:flex; flex-direction:column; gap:20px }

  .drawer-close-btn{
    position:relative;
    width:48px;
    height:48px;
    border-radius:50%;
    background:linear-gradient(135deg, var(--gold) 0%, #d4a617 100%);
    color:#000;
    border:3px solid rgba(255,255,255,.5);
    cursor:pointer;
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow:0 4px 16px rgba(237,183,35,.5), 0 0 0 2px rgba(0,0,0,.3), inset 0 1px 0 rgba(255,255,255,.3);
    transition:all .25s cubic-bezier(0.4, 0, 0.2, 1);
    font-weight:900;
    font-size:26px;
    flex-shrink:0;
  }
  .drawer-close-btn:hover{
    background:linear-gradient(135deg, #ffd700 0%, var(--gold) 100%);
    border-color:rgba(255,255,255,.7);
    transform:scale(1.1) rotate(90deg);
    box-shadow:0 6px 20px rgba(237,183,35,.7), 0 0 0 3px rgba(237,183,35,.2), inset 0 1px 0 rgba(255,255,255,.4);
  }
  .drawer-close-btn:active{
    transform:scale(0.9) rotate(90deg);
    box-shadow:0 2px 10px rgba(237,183,35,.6), 0 0 0 2px rgba(237,183,35,.15);
  }

  /* BEAR Space Popup Teaser */
  .bear-space-popup {
    position: fixed;
    inset: 0;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,.9);
    opacity: 0;
    pointer-events: none;
    transition: opacity .3s var(--ease-spring);
  }
  .bear-space-popup.show {
    opacity: 1;
    pointer-events: auto;
  }
  .bear-space-popup-content {
    position: relative;
    padding: 40px 48px;
    border-radius: 28px;
    background: radial-gradient(600px 300px at 50% 0%, rgba(93, 63, 211, 0.25), transparent 70%),
                radial-gradient(400px 200px at 50% 100%, rgba(237,183,35,0.15), transparent 60%),
                #0b0d0e;
    box-shadow: 0 24px 48px rgba(0,0,0,.65), 0 0 0 1px rgba(255,255,255,.05) inset;
    text-align: center;
    max-width: 420px;
    isolation: isolate;
    transform: scale(0.8) translateY(30px);
    transition: transform .4s var(--ease-spring);
  }
  .bear-space-popup.show .bear-space-popup-content {
    transform: scale(1) translateY(0);
  }
  .bear-space-popup-content::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 28px;
    padding: 4px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: 0;
    opacity: 1;
  }
  .bear-space-icon {
    font-size: 72px;
    line-height: 1;
    margin-bottom: 16px;
    filter: drop-shadow(0 4px 8px rgba(0,0,0,.4));
    animation: floatBear 3s ease-in-out infinite;
  }
  @keyframes floatBear {
    0%, 100% { transform: translateY(0) rotate(0deg); }
    25% { transform: translateY(-8px) rotate(-3deg); }
    50% { transform: translateY(-12px) rotate(0deg); }
    75% { transform: translateY(-8px) rotate(3deg); }
  }

  .bear-space-title {
    font-size: 48px;
    font-weight: 900;
    color: var(--gold);
    text-shadow: 0 4px 0 rgba(0,0,0,.4), 0 0 24px rgba(237,183,35,.5);
    margin-bottom: 8px;
    letter-spacing: 2px;
  }
  .bear-space-subtitle {
    font-size: 24px;
    font-weight: 800;
    color: var(--stripe-purple);
    text-shadow: 0 2px 4px rgba(0,0,0,.6);
    margin-bottom: 20px;
    text-transform: uppercase;
  }
  .bear-space-description {
    font-size: 18px;
    font-weight: 600;
    color: rgba(255,255,255,.85);
    line-height: 1.4;
    text-shadow: 0 2px 4px rgba(0,0,0,.4);
  }

  /* Success Popup - Bubbly and Meme-y */
  .bear-success-popup {
    position: fixed;
    inset: 0;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,.8);
    /* backdrop-filter removed for performance */
    opacity: 0;
    pointer-events: none;
    transition: opacity .4s ease;
  }
  .bear-success-popup.show {
    opacity: 1;
    pointer-events: auto;
  }
  .bear-success-popup-content {
    position: relative;
    padding: 48px 56px;
    border-radius: 32px;
    background: radial-gradient(600px 300px at 50% 0%, rgba(237,183,35,0.3), transparent 70%),
                linear-gradient(135deg, #edb723, #f4a623);
    box-shadow: 0 32px 64px rgba(237,183,35,.4), 0 0 0 4px rgba(255,255,255,.2) inset;
    text-align: center;
    max-width: 480px;
    transform: scale(0.5) translateY(50px) rotate(-5deg);
    transition: transform .6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    animation: bounce 0.8s ease infinite alternate;
  }
  .bear-success-popup.show .bear-success-popup-content {
    transform: scale(1) translateY(0) rotate(0deg);
  }
  @keyframes bounce {
    0% { transform: scale(1) translateY(0) rotate(0deg); }
    100% { transform: scale(1.05) translateY(-10px) rotate(1deg); }
  }
  .bear-success-icon {
    font-size: 96px;
    line-height: 1;
    margin-bottom: 20px;
    filter: drop-shadow(0 8px 16px rgba(0,0,0,.5));
    animation: spin-celebrate 1.5s ease-in-out infinite;
  }
  @keyframes spin-celebrate {
    0%, 100% { transform: rotate(0deg) scale(1); }
    25% { transform: rotate(-15deg) scale(1.1); }
    50% { transform: rotate(0deg) scale(1.2); }
    75% { transform: rotate(15deg) scale(1.1); }
  }
  .bear-success-title {
    font-size: 56px;
    font-weight: 900;
    color: #000;
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 16px;
    text-shadow: 3px 3px 0 rgba(255,255,255,.5), -2px -2px 0 rgba(0,0,0,.2);
    line-height: 1.1;
  }
  .bear-success-message {
    font-size: 22px;
    font-weight: 700;
    color: #000;
    margin-bottom: 16px;
    line-height: 1.4;
  }
  .bear-success-sub {
    font-size: 28px;
    font-weight: 900;
    color: #fff;
    text-shadow: 2px 2px 4px rgba(0,0,0,.4);
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .btn.sm{ font-size:26px; padding:1.2rem 1.8rem; border-radius:28px; box-shadow:0 10px 0 #000,0 16px 24px rgba(0,0,0,.35) }

  .price-card{
    position: relative;
    display:grid; gap:12px; padding:28px;
    border-radius:28px;
    background:radial-gradient(500px 200px at 50% -20%, rgba(237,183,35,.1), transparent 60%), #0b0d0e;
    box-shadow:0 12px 22px rgba(0,0,0,.35)
  }
  .price-card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 16px;
    padding: 6px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: -1;
  }
  .price-card .metric{ font-size:52px; font-weight:900; display:flex; align-items:baseline; gap:10px }
  .price-card .metric small{ opacity:.8; font-size:24px }
  .price-card .sub{ opacity:.9; font-size:20px }

  /* Portfolio Card */
  .portfolio-card{
    position: relative;
    padding:32px;
    border-radius:28px;
    background:radial-gradient(500px 200px at 50% -20%, rgba(118,174,255,.12), transparent 60%), #0b0d0e;
    box-shadow:0 12px 22px rgba(0,0,0,.35);
    transition:transform 0.2s ease, box-shadow 0.2s ease;
    isolation: isolate;
  }
  .portfolio-card:hover{
    transform:translateY(-2px);
    box-shadow:0 16px 32px rgba(0,0,0,.45);
  }
  .portfolio-card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 28px;
    padding: 4px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: 0;
    opacity: 1;
  }

  /* LP Card */
  .lp-card{
    position: relative;
    padding:32px;
    border-radius:28px;
    background:radial-gradient(500px 200px at 50% -20%, rgba(76,175,80,.12), transparent 60%), #0b0d0e;
    box-shadow:0 12px 22px rgba(0,0,0,.35);
    transition:transform 0.2s ease, box-shadow 0.2s ease;
    isolation: isolate;
    margin-bottom: 20px;
  }
  .lp-card:hover{
    transform:translateY(-2px);
    box-shadow:0 16px 32px rgba(0,0,0,.45);
  }
  .lp-card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 28px;
    padding: 4px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: 0;
    opacity: 1;
  }

  /* P&L Card */
  .pl-card{
    position: relative;
    padding:32px;
    border-radius:28px;
    background:radial-gradient(500px 200px at 50% -20%, rgba(93, 63, 211,.12), transparent 60%), #0b0d0e;
    box-shadow:0 12px 22px rgba(0,0,0,.35);
    transition:transform 0.2s ease, box-shadow 0.2s ease;
    isolation: isolate;
    margin-bottom: 20px;
  }
  .pl-card:hover{
    transform:translateY(-2px);
    box-shadow:0 16px 32px rgba(0,0,0,.45);
  }
  .pl-card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 28px;
    padding: 4px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: 0;
    opacity: 1;
  }

  /* P&L Toggle Buttons */
  .pl-toggle-group {
    display: flex;
    gap: 8px;
    background: rgba(0,0,0,0.4);
    padding: 4px;
    border-radius: 12px;
    border: 2px solid rgba(255,255,255,0.1);
  }
  .pl-toggle-btn {
    padding: 8px 20px;
    background: transparent;
    color: rgba(255,255,255,0.6);
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 900;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .pl-toggle-btn:hover {
    background: rgba(255,255,255,0.05);
    color: rgba(255,255,255,0.8);
  }
  .pl-toggle-btn.active {
    background: linear-gradient(135deg, var(--gold) 0%, #d4a017 100%);
    color: #000;
    box-shadow: 0 4px 12px rgba(237,183,35,0.4);
  }
  .pl-timeframe-btn {
    padding: 6px 12px;
    background: rgba(0,0,0,0.4);
    color: rgba(255,255,255,0.6);
    border: 2px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    font-size: 12px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    white-space: nowrap;
  }
  .pl-timeframe-btn:hover {
    background: rgba(255,255,255,0.08);
    color: rgba(255,255,255,0.9);
    border-color: rgba(255,255,255,0.2);
    transform: translateY(-2px);
  }
  .pl-timeframe-btn.active {
    background: rgba(237,183,35,0.2);
    color: var(--gold);
    border-color: var(--gold);
    box-shadow: 0 0 12px rgba(237,183,35,0.3);
  }

  /* P&L Stat Boxes */
  .pl-stat-box {
    background: rgba(0,0,0,0.3);
    padding: 14px 16px;
    border-radius: 12px;
    border: 2px solid rgba(255,255,255,0.08);
    text-align: center;
  }
  .pl-stat-label {
    font-size: 12px;
    color: rgba(255,255,255,0.6);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-weight: 700;
    margin-bottom: 6px;
  }
  .pl-stat-value {
    font-size: 20px;
    font-weight: 900;
    color: var(--gold);
  }
  .pl-stat-value.positive {
    color: #4CAF50;
  }
  .pl-stat-value.negative {
    color: #f44336;
  }

  /* Profile Card */
  .profile-card{
    position: relative;
    padding:32px;
    border-radius:28px;
    background:radial-gradient(500px 200px at 50% -20%, rgba(237,183,35,.08), transparent 60%), #0b0d0e;
    box-shadow:0 12px 22px rgba(0,0,0,.35);
    transition:transform 0.2s ease, box-shadow 0.2s ease;
    isolation: isolate;
  }
  .profile-card:hover{
    transform:translateY(-2px);
    box-shadow:0 16px 32px rgba(0,0,0,.45);
  }

  /* Pulsing highlight animation for profile section */
  @keyframes profile-pulse {
    0%, 100% {
      box-shadow: 0 0 0 0 rgba(237,183,35,0.9), 0 12px 22px rgba(0,0,0,.35);
      transform: scale(1);
    }
    50% {
      box-shadow: 0 0 0 15px rgba(237,183,35,0), 0 16px 32px rgba(237,183,35,.4);
      transform: scale(1.02);
    }
  }
  .profile-highlight-pulse {
    animation: profile-pulse 1.5s ease-in-out infinite !important;
    border: 3px solid var(--gold) !important;
  }

  /* Better input field interactions */
  #profileUsername:focus {
    outline: none !important;
    border-color: var(--gold) !important;
    box-shadow: 0 0 0 4px rgba(237,183,35,0.3) !important;
    transform: scale(1.02);
  }
  #profileAvatarSelector {
    transition: all 0.3s ease;
  }
  #profileAvatarSelector:hover {
    border-color: var(--gold);
    transform: translateY(-2px);
  }
  .profile-card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 28px;
    padding: 4px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: 0;
    opacity: 1;
  }

  .portfolio-stats{ display:grid; gap:12px }
  .stat-row{
    display:flex; justify-content:space-between; align-items:center; gap:12px;
    padding:14px 16px; background:rgba(255,255,255,.03); border-radius:12px;
    border:2px solid rgba(255,255,255,.08);
    flex-wrap:wrap;
  }
  .stat-label{ font-size:13px; opacity:.85; flex-shrink:0; }
  .stat-value{ font-size:16px; font-weight:800; color:var(--gold); text-align:right; word-break:break-word; min-width:0; }

  /* Points Card */
  .points-card{
    padding:28px;
  border:4px solid transparent; border-radius:28px;
    background:radial-gradient(500px 200px at 50% -20%, rgba(237,183,35,.08), transparent 60%), #0b0d0e;
    box-shadow:0 12px 22px rgba(0,0,0,.35);
    background-image: radial-gradient(500px 200px at 50% -20%, rgba(237,183,35,.08), transparent 60%), linear-gradient(#0b0d0e, #0b0d0e), var(--tri-gradient);
    background-origin: padding-box, padding-box, border-box;
    background-clip: padding-box, padding-box, border-box;
  }
  .points-card .activity-item{
    padding:16px 18px; background:rgba(255,255,255,.03); border-radius:14px;
    border-left:4px solid var(--gold); margin-bottom:10px; font-size:20px;
    display:flex; justify-content:space-between; align-items:center
  }
  .points-card .activity-item .points{ color:var(--gold); font-weight:900; font-size:24px }

  .links-grid{ display:grid; grid-template-columns:1fr 1fr; gap:14px }
  .links-grid .tile .lbl{ color:var(--gold) }
  @media (max-width:520px){ .links-grid{ grid-template-columns:1fr } }

  /* === User-requested removals === */
  .site-nav{display:none !important}
  .rails::before,.rails::after{display:none !important}

  /* ===== NEW FIXED NAVIGATION BAR ===== */
  .top-nav {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 9999;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
  }

  /* Three-color stripe background */
  .top-nav-stripes {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    z-index: -1;
  }
  .top-nav-stripes .stripe-1 {
    flex: 1;
    background: #680cd9;
  }
  .top-nav-stripes .stripe-2 {
    flex: 1;
    background: #feb501;
  }
  .top-nav-stripes .stripe-3 {
    flex: 1;
    background: #07ae08;
  }

  /* Main nav bar */
  .top-nav-bar {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 24px;
    max-width: 1400px;
    margin: 0 auto;
  }

  /* Menu button with logo */
  .menu-btn {
    display: flex;
    align-items: center;
    position: relative;
    background: none;
    cursor: pointer;
    padding: 0;
    border-radius: 12px;
    transition: all 0.2s;
    border: 4px solid transparent;
    background-image: linear-gradient(#141619, #141619), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.8));
  }

  .menu-btn:hover {
    transform: scale(1.05);
    filter: drop-shadow(3px 3px 6px rgba(0,0,0,0.9));
  }

  .menu-btn img {
    width: 52px;
    height: 52px;
    display: block;
    border-radius: 8px;
  }

  /* Hamburger icon overlay */
  .menu-btn::after {
    content: '';
    position: absolute;
    bottom: -4px;
    right: -4px;
    width: 24px;
    height: 24px;
    background: #edb723;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 6px rgba(0,0,0,0.5);
    background-image:
      linear-gradient(#000 0%, #000 100%),
      linear-gradient(#000 0%, #000 100%),
      linear-gradient(#000 0%, #000 100%);
    background-size: 14px 2px;
    background-position: center calc(50% - 5px), center 50%, center calc(50% + 5px);
    background-repeat: no-repeat;
  }

  /* Nav buttons container */
  .nav-buttons-container {
    position: relative;
    display: flex;
    align-items: center;
    gap: 12px;
  }

  /* Honey points button - compact circular design */
  .honey-points-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
    padding: 8px 12px;
    background: #1a1a1a;
    color: var(--gold);
    border: 3px solid transparent;
    border-radius: 22px;
    font-size: 14px;
    font-weight: 900;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 4px 0 #000, 0 4px 12px rgba(0,0,0,0.8);
    filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.8));
    background-image: linear-gradient(#1a1a1a, #1a1a1a), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    white-space: nowrap;
  }

  .honey-points-btn img {
    height: 1.2em;
    width: auto;
    vertical-align: middle;
  }

  .honey-points-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 0 #000, 0 6px 18px rgba(0,0,0,0.9);
    filter: drop-shadow(3px 3px 6px rgba(0,0,0,0.9));
    background: #252525;
  }

  .honey-points-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 #000, 0 2px 8px rgba(0,0,0,0.6);
  }

  /* Welcome profile button - purple with tri-color border */
  .welcome-profile-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 16px;
    background: #5D3FD3;
    color: #fff;
    border: 3px solid transparent;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 900;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 4px 0 #000, 0 4px 12px rgba(0,0,0,0.8);
    filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.8));
    background-image: linear-gradient(#5D3FD3, #5D3FD3), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
  }

  .welcome-profile-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 0 #000, 0 6px 18px rgba(0,0,0,0.9);
    filter: drop-shadow(3px 3px 6px rgba(0,0,0,0.9));
    background: #6D4FE3;
  }

  .welcome-profile-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 0 #000, 0 2px 8px rgba(0,0,0,0.6);
  }

  .welcome-avatar {
    width: 43px !important;
    height: 43px !important;
    border-radius: 50%;
    object-fit: cover;
    box-shadow: 0 2px 4px rgba(0,0,0,0.4);
    position: relative;
    z-index: 1;
  }

  .welcome-avatar-container {
    position: relative;
    width: 43px;
    height: 43px;
    margin-left: 8px;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: visible;
  }

  .welcome-cosmetic-ring {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 10;
    object-fit: contain;
    max-width: none !important;
    max-height: none !important;
  }

  .welcome-cosmetic-ring.castle,
  .welcome-cosmetic-ring.castle-static {
    width: 68px !important;
    height: 68px !important;
  }

  .welcome-cosmetic-ring.ouroboros {
    width: 62px !important;
    height: 62px !important;
    transform: translate(-50%, -50%) rotate(180deg);
  }

  .welcome-cosmetic-ring.waves,
  .welcome-cosmetic-ring.waves-static {
    width: 58px !important;
    height: 58px !important;
  }

  .welcome-cosmetic-ring:not(.castle):not(.castle-static):not(.ouroboros):not(.waves):not(.waves-static):not(.purple):not(.green):not(.yellow):not(.bg123-red) {
    width: 60px !important;
    height: 60px !important;
  }

  /* Color rings bigger in profile modal */
  .welcome-cosmetic-ring.purple,
  .welcome-cosmetic-ring.green,
  .welcome-cosmetic-ring.yellow,
  .welcome-cosmetic-ring.bg123-red {
    width: 77px !important;
    height: 77px !important;
  }

  /* ===== NOTIFICATION BELL ===== */
  .notification-bell-btn {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 44px;
    height: 44px;
    background: #1a1a1a;
    border: 3px solid transparent;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.18, 0.9, 0.2, 1);
    box-shadow: 0 4px 0 #000, 0 4px 12px rgba(0,0,0,0.8);
    filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.8));
    background-image: linear-gradient(#1a1a1a, #1a1a1a), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
  }

  .notification-bell-btn:hover {
    transform: translateY(-2px) scale(1.05);
    box-shadow: 0 6px 0 #000, 0 6px 18px rgba(0,0,0,0.9);
    filter: drop-shadow(3px 3px 6px rgba(0,0,0,0.9));
    background: #252525;
  }

  .notification-bell-btn:active {
    transform: translateY(0) scale(0.95);
    box-shadow: 0 2px 0 #000, 0 2px 8px rgba(0,0,0,0.6);
  }

  .notification-bell-btn.has-notifications {
    animation: bellBounce 0.8s cubic-bezier(0.18, 0.9, 0.2, 1) infinite;
  }

  @keyframes bellBounce {
    0%, 100% {
      transform: translateY(0) rotate(0deg);
    }
    10%, 30% {
      transform: translateY(-4px) rotate(-10deg);
    }
    20%, 40% {
      transform: translateY(-4px) rotate(10deg);
    }
    50% {
      transform: translateY(0) rotate(0deg);
    }
  }

  .notification-badge {
    position: absolute;
    top: -4px;
    right: -4px;
    min-width: 20px;
    height: 20px;
    padding: 0 6px;
    background: linear-gradient(135deg, #ff6b9d 0%, #ff4757 100%);
    color: #fff;
    border-radius: 10px;
    font-size: 11px;
    font-weight: 900;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 2px solid #000;
    box-shadow: 0 2px 6px rgba(255, 71, 87, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.2) inset;
    animation: badgePulse 2s ease-in-out infinite;
  }

  @keyframes badgePulse {
    0%, 100% {
      transform: scale(1);
      box-shadow: 0 2px 6px rgba(255, 71, 87, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.2) inset;
    }
    50% {
      transform: scale(1.1);
      box-shadow: 0 3px 10px rgba(255, 71, 87, 0.8), 0 0 0 1px rgba(255, 255, 255, 0.3) inset;
    }
  }

  /* Notification Panel - Dropdown from bell */
  .notification-panel {
    position: absolute;
    top: 60px;
    right: 0;
    width: 380px;
    max-height: 500px;
    background: linear-gradient(135deg, #1e2226 0%, #141619 100%);
    border: 3px solid transparent;
    border-radius: 16px;
    box-shadow: 0 12px 32px rgba(0,0,0,0.7), 0 0 0 1px rgba(255,255,255,0.05) inset;
    display: none;
    flex-direction: column;
    overflow: hidden;
    z-index: 10000;
    background-image: linear-gradient(135deg, #1e2226 0%, #141619 100%), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    opacity: 0;
    transform: translateY(-10px);
    transition: opacity 0.3s cubic-bezier(0.18, 0.9, 0.2, 1),
                transform 0.3s cubic-bezier(0.18, 0.9, 0.2, 1);
  }

  @keyframes notificationSlideIn {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .notification-panel.visible {
    display: flex;
    animation: notificationSlideIn 0.3s cubic-bezier(0.18, 0.9, 0.2, 1);
    opacity: 1;
    transform: translateY(0);
  }

  .notification-panel-header {
    padding: 16px 20px;
    background: rgba(0,0,0,0.3);
    border-bottom: 2px solid rgba(237, 183, 35, 0.2);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .notification-panel-header h3 {
    margin: 0;
    font-family: 'Luckiest Guy', Arial, sans-serif;
    font-size: 18px;
    color: var(--gold);
    text-shadow: 2px 2px 0 #000;
  }

  .notification-close-btn {
    background: none;
    border: none;
    color: rgba(255,255,255,0.6);
    font-size: 24px;
    cursor: pointer;
    padding: 0;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s;
  }

  .notification-close-btn:hover {
    background: rgba(255,255,255,0.1);
    color: #fff;
  }

  .notification-list {
    flex: 1;
    overflow-y: auto;
    padding: 0;
    margin: 0;
  }

  .notification-item {
    padding: 16px 20px;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    display: flex;
    align-items: flex-start;
    gap: 12px;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    pointer-events: auto; /* Ensure item can receive clicks even with children having pointer-events: none */
  }

  .notification-item:hover {
    background: rgba(237, 183, 35, 0.1);
  }

  .notification-item.unread {
    background: rgba(93, 63, 211, 0.1);
  }

  .notification-item.unread::before {
    content: '';
    position: absolute;
    left: 8px;
    top: 50%;
    transform: translateY(-50%);
    width: 6px;
    height: 6px;
    background: linear-gradient(135deg, #ff6b9d 0%, #ff4757 100%);
    border-radius: 50%;
    box-shadow: 0 0 8px rgba(255, 71, 87, 0.8);
  }

  .notification-icon {
    flex-shrink: 0;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    background: rgba(0,0,0,0.3);
    border-radius: 50%;
    border: 2px solid rgba(237, 183, 35, 0.3);
  }

  .notification-content {
    flex: 1;
    pointer-events: none;
  }

  .notification-text {
    margin: 0 0 4px 0;
    font-size: 14px;
    color: #fff;
    line-height: 1.4;
  }

  .notification-text strong {
    color: var(--gold);
    font-weight: 900;
  }

  .notification-time {
    font-size: 11px;
    color: rgba(255,255,255,0.5);
    margin: 0;
  }

  .notification-reactions {
    display: flex;
    align-items: center;
    gap: 6px;
    flex-wrap: wrap;
    margin-top: 6px;
  }

  .notification-reaction-emoji {
    font-size: 18px;
    padding: 4px 8px;
    background: rgba(0,0,0,0.4);
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.1);
  }

  .notification-preview {
    font-size: 12px;
    color: rgba(255, 255, 255, 0.7);
    font-style: italic;
    margin: 6px 0 0 0;
    line-height: 1.3;
  }

  /* Make sure child elements don't block notification clicks */
  .notification-item img,
  .notification-item .notification-content * {
    pointer-events: none;
  }

  .notification-empty {
    padding: 60px 20px;
    text-align: center;
    color: rgba(255,255,255,0.5);
  }

  .notification-empty-icon {
    font-size: 48px;
    margin-bottom: 12px;
    opacity: 0.3;
  }

  @media (max-width: 640px) {
    .notification-panel {
      left: auto;
      right: 0;
      width: auto;
      max-width: calc(100vw - 20px);
      top: 55px;
      max-height: 70vh;
    }

    .notification-bell-btn {
      width: 40px;
      height: 40px;
      font-size: 18px;
    }

    .notification-badge {
      min-width: 18px;
      height: 18px;
      font-size: 10px;
    }
  }

  /* Hamburger menu overlay */
  .menu-overlay {
    position: fixed;
    top: 0;
    left: -100%;
    width: 100%;
    max-width: 400px;
    height: 100vh;
    background: linear-gradient(180deg, #141619 0%, #0e1013 100%);
    box-shadow: 4px 0 24px rgba(0,0,0,0.5);
    z-index: 10000;
    transition: left 0.3s var(--ease-spring);
    overflow-y: auto;
    border-right: 6px solid;
    border-image: linear-gradient(to bottom, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%) 1;
  }

  .menu-overlay.open {
    left: 0;
  }

  .menu-overlay-header {
    padding: 20px;
    background: #0f1114;
    border-bottom: 4px solid;
    border-image: linear-gradient(to right, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%) 1;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .menu-overlay-header h2 {
    margin: 0;
    color: var(--gold);
    font-size: 24px;
  }

  .menu-close-btn {
    background: none;
    border: none;
    color: var(--gold);
    font-size: 32px;
    cursor: pointer;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    transition: all 0.2s;
  }

  .menu-close-btn:hover {
    background: rgba(237,183,35,0.1);
  }

  .menu-items {
    padding: 16px;
    display: grid;
    gap: 10px;
  }

  .menu-item {
    position: relative;
    display: block;
    padding: 18px 20px;
    background: radial-gradient(500px 200px at 50% -20%, rgba(237,183,35,0.08), transparent 60%), #0b0d0e;
    border-radius: 16px;
    color: var(--gold);
    font-size: 16px;
    font-weight: 900;
    text-transform: uppercase;
    transition: all 0.2s;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0,0,0,0.35);
    text-decoration: none;
    opacity: 0;
    transform: translateX(-20px);
    animation: slideInStagger 0.4s var(--ease-spring) forwards;
  }
  .menu-item:nth-child(1) { animation-delay: 0.05s; }
  .menu-item:nth-child(2) { animation-delay: 0.1s; }
  .menu-item:nth-child(3) { animation-delay: 0.15s; }
  .menu-item:nth-child(4) { animation-delay: 0.2s; }
  .menu-item:nth-child(5) { animation-delay: 0.25s; }
  .menu-item:nth-child(6) { animation-delay: 0.3s; }
  .menu-item:nth-child(7) { animation-delay: 0.35s; }
  .menu-item:nth-child(8) { animation-delay: 0.4s; }

  @keyframes slideInStagger {
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }
  .menu-item::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 16px;
    padding: 6px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: -1;
  }

  .menu-item:hover {
    background: radial-gradient(500px 200px at 50% -20%, rgba(237,183,35,0.15), transparent 60%), #0b0d0e;
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0,0,0,0.45);
  }

  .menu-item-icon {
    margin-right: 12px;
    font-size: 20px;
  }

  /* Scrim for menu */
  .menu-scrim {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    background: rgba(0,0,0,0.7);
    z-index: 9998;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
  }

  .menu-scrim.open {
    opacity: 1;
    pointer-events: all;
  }

  /* Adjust body padding for fixed nav */
  body {
    padding-top: 72px;
  }

  /* ===== PROFILE MODAL STYLES ===== */
  .profile-modal {
    position: fixed;
    inset: 0;
    z-index: 10000;
    display: none;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .profile-modal.visible {
    opacity: 1;
  }

  .profile-modal-overlay {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.85);
    /* backdrop-filter removed for performance */
  }

  .profile-modal-content {
    position: relative;
    background: linear-gradient(180deg, #141619 0%, #101215 100%);
    border: 4px solid transparent;
    border-radius: 24px;
    width: 90%;
    max-width: 700px;
    max-height: 90vh;
    overflow: hidden;
    box-shadow: 0 24px 60px rgba(0,0,0,0.6);
    background-image: linear-gradient(180deg, #141619 0%, #101215 100%), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    animation: modalSlideIn 0.4s var(--ease-spring);
  }

  @keyframes modalSlideIn {
    from { transform: translateY(40px) scale(0.95); opacity: 0; }
    to { transform: translateY(0) scale(1); opacity: 1; }
  }

  .profile-modal-header {
    padding: 24px;
    border-bottom: 2px solid rgba(237,183,35,0.2);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: radial-gradient(500px 200px at 50% -20%, rgba(237,183,35,0.08), transparent 60%);
  }

  .profile-close-btn {
    background: none;
    border: none;
    color: var(--gold);
    font-size: 36px;
    cursor: pointer;
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    transition: all 0.2s;
    line-height: 1;
  }

  .profile-close-btn:hover {
    background: rgba(237,183,35,0.15);
    transform: rotate(90deg);
  }

  /* BEAR Search Button */
  .bear-search-btn {
    background: linear-gradient(135deg, rgba(237,183,35,0.2), rgba(237,183,35,0.1));
    border: 2px solid rgba(237,183,35,0.5);
    color: var(--gold);
    width: 44px;
    height: 44px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    position: relative;
  }

  .bear-search-btn:hover {
    background: linear-gradient(135deg, rgba(237,183,35,0.4), rgba(237,183,35,0.2));
    border-color: var(--gold);
    transform: scale(1.1) rotate(15deg);
    box-shadow: 0 0 20px rgba(237,183,35,0.6);
  }

  .bear-search-btn svg {
    filter: drop-shadow(0 0 4px rgba(237,183,35,0.5));
  }

  /* Profile Back Button */
  .profile-back-btn {
    background: linear-gradient(135deg, rgba(104, 12, 217, 0.2), rgba(104, 12, 217, 0.1));
    border: 2px solid rgba(104, 12, 217, 0.5);
    color: rgba(104, 12, 217, 1);
    width: 44px;
    height: 44px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    position: relative;
  }

  .profile-back-btn:hover {
    background: linear-gradient(135deg, rgba(104, 12, 217, 0.4), rgba(104, 12, 217, 0.2));
    border-color: rgba(104, 12, 217, 1);
    transform: scale(1.1) translateX(-3px);
    box-shadow: 0 0 20px rgba(104, 12, 217, 0.6);
  }

  .profile-back-btn svg {
    filter: drop-shadow(0 0 4px rgba(104, 12, 217, 0.5));
  }

  /* BEAR Search Panel */
  .bear-search-panel {
    padding: 24px;
    overflow-y: auto;
    max-height: calc(90vh - 100px);
  }

  .search-input-container {
    margin-bottom: 20px;
  }

  .bear-search-input {
    width: 100%;
    padding: 16px 20px;
    background: rgba(0,0,0,0.4);
    border: 3px solid rgba(237,183,35,0.3);
    border-radius: 16px;
    color: #fff;
    font-size: 16px;
    font-weight: 700;
    font-family: inherit;
    transition: all 0.3s ease;
  }

  .bear-search-input:focus {
    outline: none;
    border-color: var(--gold);
    background: rgba(0,0,0,0.6);
    box-shadow: 0 0 20px rgba(237,183,35,0.3);
  }

  .bear-search-input::placeholder {
    color: rgba(255,255,255,0.7);
  }

  /* BEAR Search Results */
  .bear-search-results {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .bear-user-card {
    background: linear-gradient(135deg, rgba(0,0,0,0.6), rgba(0,0,0,0.4));
    border: 3px solid rgba(237,183,35,0.3);
    border-radius: 20px;
    padding: 16px;
    display: flex;
    align-items: center;
    gap: 16px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
  }

  .bear-user-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, rgba(237,183,35,0.1), transparent);
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .bear-user-card:hover {
    border-color: var(--gold);
    transform: translateX(8px);
    box-shadow: 0 8px 24px rgba(237,183,35,0.3);
  }

  .bear-user-card:hover::before {
    opacity: 1;
  }

  .bear-user-avatar-container {
    position: relative;
    width: 60px;
    height: 60px;
    flex-shrink: 0;
  }

  .bear-user-avatar-border {
    display: none;
  }

  .bear-user-avatar {
    position: relative;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    border: 3px solid rgba(0,0,0,0.9);
    object-fit: cover;
  }

  .bear-user-avatar-placeholder {
    position: relative;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    border: 3px solid rgba(0,0,0,0.9);
    background: rgba(0,0,0,0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
  }

  .bear-user-info {
    flex: 1;
    min-width: 0;
  }

  .bear-user-name {
    color: var(--gold);
    font-size: 18px;
    font-weight: 900;
    margin: 0 0 4px 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .bear-user-friends {
    color: rgba(255,255,255,0.6);
    font-size: 13px;
    margin: 0;
    font-weight: 600;
  }

  .bear-search-empty {
    text-align: center;
    padding: 60px 20px;
    color: rgba(255,255,255,0.8);
    font-size: 16px;
    font-weight: 700;
  }

  .bear-search-empty-icon {
    font-size: 48px;
    margin-bottom: 12px;
    opacity: 0.6;
  }

  /* BEAR Community Section */
  .community-bordered-container {
    max-width: 900px;
    margin: 0 auto;
    padding: 32px 28px;
    background: linear-gradient(135deg, rgba(20, 22, 25, 0.95) 0%, rgba(15, 17, 20, 0.95) 100%);
    border: 4px solid transparent;
    background-image:
      linear-gradient(135deg, rgba(20, 22, 25, 0.95) 0%, rgba(15, 17, 20, 0.95) 100%),
      var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    border-radius: 24px;
    box-shadow:
      0 8px 32px rgba(0,0,0,0.5),
      inset 0 1px 0 rgba(255,255,255,0.05),
      0 0 80px rgba(93,63,211,0.15);
  }

  .community-search-container {
    max-width: 800px;
    margin: 0 auto 32px;
  }

  .community-search-wrapper {
    position: relative;
    margin-bottom: 16px;
  }

  .community-search-icon {
    position: absolute;
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--gold);
    opacity: 0.7;
    pointer-events: none;
  }

  .community-search-input {
    width: 100%;
    padding: 18px 20px 18px 56px;
    background: rgba(0,0,0,0.5);
    border: 2px solid transparent;
    background-image:
      linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)),
      var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    border-radius: 16px;
    color: #fff;
    font-size: 16px;
    font-weight: 600;
    font-family: 'Nunito', sans-serif;
    transition: all 0.3s ease;
    box-shadow:
      0 2px 8px rgba(0,0,0,0.3),
      inset 0 1px 0 rgba(255,255,255,0.05);
  }

  .community-search-input::placeholder {
    color: rgba(255,255,255,0.45);
    font-weight: 500;
  }

  .community-search-input:focus {
    outline: none;
    background: rgba(0,0,0,0.65);
    background-image:
      linear-gradient(rgba(0,0,0,0.65), rgba(0,0,0,0.65)),
      var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    box-shadow:
      0 4px 20px rgba(237,183,35,0.3),
      0 0 40px rgba(93,63,211,0.2),
      inset 0 1px 0 rgba(255,255,255,0.1);
  }

  .community-count {
    text-align: center;
    background: linear-gradient(135deg, #edb723, #f4c542, #edb723);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    font-size: 18px;
    font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    filter: drop-shadow(0 2px 6px rgba(237,183,35,0.4));
  }

  .community-user-grid {
    max-height: 600px;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 4px;
    margin-top: 24px;
  }

  /* Custom scrollbar for community grid */
  .community-user-grid::-webkit-scrollbar {
    width: 12px;
  }

  .community-user-grid::-webkit-scrollbar-track {
    background: rgba(0,0,0,0.2);
    border-radius: 10px;
  }

  .community-user-grid::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #5d3fd3, #edb723, #22c55e);
    border-radius: 10px;
  }

  .community-user-grid::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #7c5fef, #f4c542, #34d369);
  }

  .community-loading {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 60px 20px;
    gap: 20px;
  }

  .loading-spinner {
    width: 50px;
    height: 50px;
    border: 4px solid rgba(237,183,35,0.2);
    border-top-color: var(--gold);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .community-loading p {
    color: rgba(255,255,255,0.7);
    font-size: 16px;
    margin: 0;
  }

  .community-user-card {
    background: linear-gradient(135deg, #1a1d24 0%, #141619 100%);
    border: 3px solid transparent;
    background-image: linear-gradient(135deg, #1a1d24 0%, #141619 100%), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    border-radius: 16px;
    padding: 20px 24px;
    margin-bottom: 12px;
    cursor: pointer;
    transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex;
    align-items: center;
    gap: 20px;
    box-shadow:
      0 2px 8px rgba(0,0,0,0.4),
      inset 0 1px 0 rgba(255,255,255,0.05);
    position: relative;
    overflow: hidden;
  }

  .community-user-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg,
      transparent,
      rgba(237,183,35,0.1),
      transparent
    );
    transition: left 0.6s ease;
  }

  .community-user-card:hover::before {
    left: 100%;
  }

  .community-user-card:hover {
    transform: translateX(6px) scale(1.01);
    box-shadow:
      0 8px 32px rgba(237,183,35,0.4),
      0 0 60px rgba(93,63,211,0.2),
      inset 0 1px 0 rgba(255,255,255,0.1);
  }

  .community-user-avatar-wrapper {
    width: 64px;
    height: 64px;
    flex-shrink: 0;
    position: relative;
    transition: transform 0.3s ease;
    overflow: hidden;
    border-radius: 50%;
  }

  .community-user-card:hover .community-user-avatar-wrapper {
    transform: scale(1.05) rotate(-2deg);
  }

  .community-user-avatar,
  .community-user-avatar-placeholder {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
    box-shadow:
      0 4px 12px rgba(0,0,0,0.4),
      0 0 20px rgba(237,183,35,0.2);
    position: absolute;
    top: 0;
    left: 0;
    display: block;
  }

  .community-user-avatar-placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
    background: linear-gradient(135deg, rgba(93, 63, 211, 0.3), rgba(237, 183, 35, 0.3));
  }

  .community-user-info {
    flex: 1;
    min-width: 0;
    display: flex;
    align-items: center;
    gap: 20px;
  }

  .community-user-name-section {
    flex: 1;
    min-width: 0;
  }

  .community-user-name {
    background: linear-gradient(135deg, #edb723, #f4c542, #edb723);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    font-size: 22px;
    font-weight: 900;
    margin: 0 0 4px 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    text-shadow: 0 2px 12px rgba(237,183,35,0.5);
    filter: drop-shadow(0 2px 8px rgba(237,183,35,0.4));
    letter-spacing: 0.3px;
  }

  .community-user-wallet {
    color: rgba(255,255,255,0.35);
    font-size: 11px;
    font-family: 'Courier New', monospace;
    margin: 0;
    font-weight: 600;
    letter-spacing: 0.5px;
  }

  .community-user-stats {
    display: flex;
    gap: 28px;
    align-items: center;
    flex-shrink: 0;
  }

  .community-user-stat {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    padding: 8px 16px;
    background: rgba(0,0,0,0.3);
    border-radius: 12px;
    border: 1px solid rgba(237,183,35,0.15);
    transition: all 0.3s ease;
  }

  .community-user-stat:hover {
    background: rgba(237,183,35,0.08);
    border-color: rgba(237,183,35,0.3);
    transform: translateY(-2px);
  }

  .community-user-stat-value {
    background: linear-gradient(135deg, #edb723, #f4c542);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    font-size: 24px;
    font-weight: 900;
    margin: 0;
    line-height: 1;
    filter: drop-shadow(0 2px 4px rgba(237,183,35,0.3));
  }

  .community-user-stat-label {
    color: rgba(255,255,255,0.6);
    font-size: 10px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin: 0;
  }

  .community-follow-btn {
    padding: 8px 20px;
    background: linear-gradient(135deg, var(--gold), #c9941a);
    color: #000;
    border: none;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(237,183,35,0.3);
    white-space: nowrap;
  }

  .community-follow-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(237,183,35,0.5);
    background: linear-gradient(135deg, #f4c542, var(--gold));
  }

  .community-follow-btn.following {
    background: linear-gradient(135deg, #28a745, #1e7e34);
    color: #fff;
    box-shadow: 0 2px 8px rgba(40,167,69,0.3);
  }

  .community-follow-btn.following:hover {
    background: linear-gradient(135deg, #34ce57, #28a745);
    box-shadow: 0 4px 12px rgba(40,167,69,0.5);
  }

  .community-follow-btn.following::before {
    content: '‚úì ';
  }

  .community-empty {
    grid-column: 1 / -1;
    text-align: center;
    padding: 60px 20px;
  }

  .community-empty-icon {
    font-size: 64px;
    margin-bottom: 16px;
    opacity: 0.5;
  }

  .community-empty p {
    color: rgba(255,255,255,0.6);
    font-size: 18px;
    margin: 0;
  }

  /* Mobile Responsive for Community Section */
  @media (max-width: 768px) {
    .community-bordered-container {
      padding: 24px 20px;
      border-width: 3px;
      border-radius: 20px;
    }

    .community-user-grid {
      max-height: 500px;
    }

    .community-search-input {
      font-size: 14px;
      padding: 16px 18px 16px 52px;
    }

    .community-user-card {
      flex-direction: column;
      align-items: flex-start;
      padding: 16px 18px;
      gap: 14px;
    }

    .community-user-avatar-wrapper {
      width: 56px;
      height: 56px;
    }

    .community-user-info {
      width: 100%;
      flex-direction: column;
      align-items: flex-start;
      gap: 12px;
    }

    .community-user-stats {
      width: 100%;
      justify-content: space-around;
      padding-top: 12px;
      border-top: 1px solid rgba(237,183,35,0.2);
      gap: 12px;
    }

    .community-user-stat {
      flex: 1;
      padding: 10px 12px;
    }

    .community-user-name {
      font-size: 19px;
    }

    .community-user-stat-value {
      font-size: 20px;
    }

    .community-user-stat-label {
      font-size: 9px;
    }
  }

  .profile-modal-body {
    padding: 24px;
    overflow-y: auto;
    max-height: calc(90vh - 100px);
  }

  /* Profile Picture Section */
  .profile-picture-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    margin-bottom: 32px;
    padding: 20px;
    border-radius: 16px;
    background: #141619;
  }

  .profile-picture-container {
    position: relative;
    width: 153px;
    height: 153px;
  }

  .profile-picture,
  .profile-picture-placeholder {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
  }

  .profile-picture-placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, rgba(93, 63, 211, 0.2), rgba(237, 183, 35, 0.2));
  }

  .profile-picture {
    display: none;
  }

  .profile-picture.loaded {
    display: block;
  }

  .profile-info-header {
    text-align: center;
    position: relative;
    z-index: 10;
  }

  .profile-name {
    font-size: 26px;
    font-weight: 900;
    color: var(--gold);
    margin: 0 0 8px 0;
    text-shadow: 0 2px 8px rgba(0,0,0,0.4);
    position: relative;
    z-index: 10;
  }

  .profile-wallet {
    font-size: 14px;
    color: rgba(255,255,255,0.6);
    margin: 0;
    font-family: monospace;
    position: relative;
    z-index: 10;
  }


  /* Follow Section */
  .profile-follow-section {
    background: rgba(0,0,0,0.3);
    border: 2px solid rgba(237,183,35,0.2);
    border-radius: 16px;
    padding: 20px;
    margin: 20px 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 20px;
  }

  .follow-stats {
    display: flex;
    gap: 40px;
    flex: 1;
  }

  .follow-stat-item {
    text-align: center;
    transition: all 0.3s ease;
  }

  .follow-stat-item:hover {
    transform: scale(1.05);
  }

  .follow-stat-item:hover .follow-stat-number {
    color: var(--gold);
    text-shadow: 0 0 12px rgba(237,183,35,0.6);
  }

  .follow-stat-number {
    font-size: 32px;
    font-weight: 900;
    color: rgba(255,255,255,0.9);
    margin: 0;
    transition: all 0.3s ease;
    text-shadow: 0 2px 8px rgba(0,0,0,0.4);
  }

  .follow-stat-label {
    font-size: 14px;
    color: rgba(255,255,255,0.6);
    margin-top: 4px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .follow-btn {
    background: linear-gradient(135deg, rgba(237,183,35,0.3), rgba(237,183,35,0.15));
    border: 2px solid rgba(237,183,35,0.5);
    color: var(--gold);
    padding: 12px 32px;
    font-size: 18px;
    font-weight: 900;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    text-transform: uppercase;
    letter-spacing: 1px;
    animation: followBtnWiggle 2s ease-in-out infinite;
  }

  @keyframes followBtnWiggle {
    0%, 100% { transform: rotate(0deg); }
    25% { transform: rotate(-3deg); }
    75% { transform: rotate(3deg); }
  }

  .follow-btn:hover {
    background: linear-gradient(135deg, rgba(237,183,35,0.5), rgba(237,183,35,0.3));
    border-color: var(--gold);
    box-shadow: 0 0 20px rgba(237,183,35,0.5);
    transform: scale(1.05);
    animation: none;
  }

  .follow-btn.following {
    background: linear-gradient(135deg, rgba(50,205,50,0.2), rgba(50,205,50,0.1));
    border-color: rgba(50,205,50,0.3);
    color: rgba(50,205,50,0.7);
    animation: none;
    padding: 8px 20px;
    font-size: 14px;
    opacity: 0.8;
  }

  .follow-btn.following:hover {
    background: linear-gradient(135deg, rgba(220,20,60,0.15), rgba(220,20,60,0.1));
    border-color: rgba(220,20,60,0.3);
    color: rgba(220,20,60,0.6);
    box-shadow: none;
    transform: scale(0.95);
    opacity: 0.7;
    padding: 6px 16px;
    font-size: 12px;
  }

  .follow-btn.following:hover .follow-btn-text::before {
    content: "Un";
  }

  .follow-btn:disabled {
    opacity: 0.7 !important;
    cursor: not-allowed !important;
    pointer-events: none;
  }

  .follow-btn-icon {
    font-size: 20px;
    transition: transform 0.3s ease;
  }

  .follow-btn-text {
    transition: color 0.3s ease;
  }

  /* Mobile Responsive Follow Section */
  @media (max-width: 768px) {
    .profile-follow-section {
      flex-direction: column;
      align-items: stretch;
      padding: 16px;
    }

    .follow-stats {
      justify-content: space-around;
      gap: 20px;
      width: 100%;
    }

    .follow-stat-number {
      font-size: 28px;
    }

    .follow-stat-label {
      font-size: 12px;
    }

    .follow-btn {
      width: 100%;
      justify-content: center;
      padding: 14px 24px;
      font-size: 16px;
      margin-top: 8px;
    }

    .follow-btn.following {
      padding: 8px 16px;
      font-size: 13px;
    }

    .follow-btn.following:hover {
      padding: 6px 14px;
      font-size: 11px;
    }
  }

  /* Follow List Modal */
  .follow-list-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    /* backdrop-filter removed for performance */
  }

  .follow-list-modal {
    background: linear-gradient(135deg, #1a1d24 0%, #141619 100%);
    border: 3px solid rgba(237,183,35,0.3);
    border-radius: 24px;
    width: 90%;
    max-width: 500px;
    max-height: 80vh;
    overflow: hidden;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5), 0 0 40px rgba(237,183,35,0.2);
    animation: followModalSlideIn 0.3s ease-out;
  }

  @keyframes followModalSlideIn {
    from {
      opacity: 0;
      transform: translateY(-30px) scale(0.9);
    }
    to {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }

  .follow-list-header {
    padding: 24px;
    border-bottom: 2px solid rgba(237,183,35,0.2);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .follow-list-header h3 {
    margin: 0;
    color: var(--gold);
    font-size: 24px;
    font-weight: 900;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .follow-list-close {
    background: rgba(237,183,35,0.2);
    border: 2px solid rgba(237,183,35,0.3);
    color: var(--gold);
    font-size: 28px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
  }

  .follow-list-close:hover {
    background: rgba(237,183,35,0.4);
    border-color: var(--gold);
    transform: rotate(90deg);
  }

  .follow-list-body {
    padding: 16px;
    max-height: calc(80vh - 100px);
    overflow-y: auto;
  }

  .follow-list-empty {
    padding: 60px 20px;
    text-align: center;
  }

  .follow-list-empty p {
    color: rgba(255,255,255,0.6);
    font-size: 18px;
    margin: 0;
  }

  .follow-list-item {
    background: rgba(0,0,0,0.3);
    border: 2px solid rgba(237,183,35,0.2);
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 16px;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .follow-list-item:hover {
    background: rgba(0,0,0,0.5);
    border-color: rgba(237,183,35,0.5);
    transform: translateX(5px);
    box-shadow: 0 4px 12px rgba(237,183,35,0.2);
  }

  .follow-list-avatar-container {
    width: 50px;
    height: 50px;
    flex-shrink: 0;
  }

  .follow-list-avatar,
  .follow-list-avatar-placeholder {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
  }

  .follow-list-avatar-placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    background: linear-gradient(135deg, rgba(93, 63, 211, 0.2), rgba(237, 183, 35, 0.2));
  }

  .follow-list-info {
    flex: 1;
  }

  .follow-list-name {
    margin: 0 0 4px 0;
    color: var(--gold);
    font-size: 18px;
    font-weight: 700;
  }

  .follow-list-wallet {
    margin: 0;
    color: rgba(255,255,255,0.5);
    font-size: 13px;
    font-family: monospace;
  }

  /* Profile Sections */
  .profile-section {
    background: rgba(0,0,0,0.3);
    border: 2px solid rgba(237,183,35,0.2);
    border-radius: 16px;
    padding: 20px;
    margin-bottom: 20px;
  }

  .profile-section h4 {
    color: var(--gold);
    font-size: 20px;
    margin: 0 0 16px 0;
    font-weight: 900;
  }

  .profile-section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
  }

  .profile-section-header h4 {
    margin: 0;
  }

  /* Bio Section */
  .edit-bio-btn {
    background: rgba(237,183,35,0.15);
    border: 2px solid var(--gold);
    color: var(--gold);
    padding: 6px 16px;
    border-radius: 8px;
    font-size: 13px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s;
  }

  .edit-bio-btn:hover {
    background: var(--gold);
    color: #000;
    transform: translateY(-2px);
  }

  .edit-profile-picture-btn:hover {
    background: rgba(237,183,35,0.9) !important;
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(237,183,35,0.4);
  }

  .edit-profile-picture-btn:active {
    transform: scale(0.95);
  }

  .bio-display {
    color: rgba(255,255,255,0.85);
    line-height: 1.6;
    font-size: 15px;
    white-space: pre-wrap;
  }

  .bio-editor textarea {
    width: 100%;
    min-height: 100px;
    background: rgba(0,0,0,0.5);
    border: 2px solid rgba(237,183,35,0.3);
    border-radius: 10px;
    padding: 12px;
    color: #fff;
    font-size: 15px;
    font-family: inherit;
    resize: vertical;
  }

  .bio-editor textarea:focus {
    outline: none;
    border-color: var(--gold);
  }

  .bio-editor-actions {
    display: flex;
    gap: 10px;
    margin-top: 12px;
  }

  .btn-save-bio,
  .btn-cancel-bio {
    padding: 10px 20px;
    border-radius: 10px;
    font-size: 14px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s;
    border: 2px solid transparent;
  }

  .btn-save-bio {
    background: var(--gold);
    color: #000;
    border-color: var(--gold);
  }

  .btn-save-bio:hover {
    background: #ffca3a;
    transform: translateY(-2px);
  }

  .btn-cancel-bio {
    background: rgba(255,255,255,0.1);
    color: #fff;
    border-color: rgba(255,255,255,0.2);
  }

  .btn-cancel-bio:hover {
    background: rgba(255,255,255,0.2);
  }

  /* ===== BULLETIN BOARD STYLES ===== */
  /* Bulletin Post Input in Profile Modal */
  .bulletin-post-section {
    background: rgba(237, 183, 35, 0.05);
    border: 2px solid rgba(237, 183, 35, 0.2);
    border-radius: 12px;
    padding: 20px;
  }

  .bulletin-post-input-container {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .bulletin-post-input {
    width: 100%;
    min-height: 80px;
    background: rgba(0, 0, 0, 0.5);
    border: 2px solid rgba(237, 183, 35, 0.3);
    border-radius: 10px;
    padding: 12px;
    color: #fff;
    font-size: 15px;
    font-family: inherit;
    resize: vertical;
    transition: all 0.3s ease;
  }

  .bulletin-post-input:focus {
    outline: none;
    border-color: var(--gold);
    box-shadow: 0 0 0 3px rgba(237, 183, 35, 0.1);
  }

  .bulletin-post-input::placeholder {
    color: rgba(255, 255, 255, 0.4);
  }

  .bulletin-post-actions {
    display: flex;
    justify-content: flex-end;
  }

  .btn-post-bulletin {
    padding: 12px 24px;
    background: var(--gold);
    color: #000;
    border: 2px solid var(--gold);
    border-radius: 10px;
    font-size: 15px;
    font-weight: 800;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .btn-post-bulletin:hover {
    background: #ffca3a;
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(237, 183, 35, 0.3);
  }

  .btn-post-bulletin:active {
    transform: translateY(0);
  }

  .btn-post-bulletin:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* Bulletin Feed Container */
  .post-bulletin-btn {
    display: inline-block;
    background: linear-gradient(135deg, #edb723, #f4d06f);
    color: #000;
    font-weight: 700;
    font-size: 18px;
    padding: 14px 28px;
    border: 3px solid #edb723;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 0 20px rgba(237, 183, 35, 0.6),
                0 0 40px rgba(237, 183, 35, 0.4),
                0 4px 12px rgba(0, 0, 0, 0.3);
    animation: pulseGlow 2s ease-in-out infinite;
  }

  .post-bulletin-btn:hover {
    background: linear-gradient(135deg, #f4d06f, #edb723);
    transform: scale(1.05);
    box-shadow: 0 0 30px rgba(237, 183, 35, 0.8),
                0 0 60px rgba(237, 183, 35, 0.6),
                0 6px 16px rgba(0, 0, 0, 0.4);
  }

  .post-bulletin-btn:active {
    transform: scale(0.98);
  }

  @keyframes pulseGlow {
    0%, 100% {
      box-shadow: 0 0 20px rgba(237, 183, 35, 0.6),
                  0 0 40px rgba(237, 183, 35, 0.4),
                  0 4px 12px rgba(0, 0, 0, 0.3);
    }
    50% {
      box-shadow: 0 0 30px rgba(237, 183, 35, 0.8),
                  0 0 50px rgba(237, 183, 35, 0.5),
                  0 4px 12px rgba(0, 0, 0, 0.3);
    }
  }

  @keyframes highlightPulse {
    0%, 100% {
      box-shadow: 0 0 20px rgba(237, 183, 35, 0.6), 0 0 40px rgba(237, 183, 35, 0.4);
      transform: scale(1);
    }
    50% {
      box-shadow: 0 0 40px rgba(237, 183, 35, 1), 0 0 80px rgba(237, 183, 35, 0.8);
      transform: scale(1.02);
    }
  }

  .bulletin-feed-container {
    max-width: 800px;
    margin: 0 auto;
  }

  .bulletin-feed {
    display: flex;
    flex-direction: column;
    gap: 20px;
    max-height: 600px;
    overflow-y: auto;
    padding: 20px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 16px;
    border: 2px solid rgba(237, 183, 35, 0.2);
  }

  .bulletin-feed::-webkit-scrollbar {
    width: 10px;
  }

  .bulletin-feed::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
  }

  .bulletin-feed::-webkit-scrollbar-thumb {
    background: var(--gold);
    border-radius: 10px;
  }

  .bulletin-feed::-webkit-scrollbar-thumb:hover {
    background: #ffca3a;
  }

  /* Bulletin Post Card */
  .bulletin-post-card {
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid rgba(237, 183, 35, 0.3);
    border-radius: 12px;
    padding: 20px;
    transition: all 0.3s ease;
    cursor: pointer;
  }

  .bulletin-post-card:hover {
    border-color: var(--gold);
    box-shadow: 0 4px 20px rgba(237, 183, 35, 0.2);
    transform: translateY(-2px);
  }

  .bulletin-post-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
  }

  .bulletin-post-avatar-container {
    position: relative;
    width: 48px;
    height: 48px;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: visible;
  }

  .bulletin-post-avatar {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    border: 2px solid var(--gold);
    object-fit: cover;
    position: relative;
    z-index: 1;
  }

  .bulletin-post-cosmetic-ring {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 10;
    object-fit: contain;
    max-width: none !important;
    max-height: none !important;
  }

  .bulletin-post-cosmetic-ring.castle,
  .bulletin-post-cosmetic-ring.castle-static {
    width: 72px !important;
    height: 72px !important;
  }

  .bulletin-post-cosmetic-ring.ouroboros {
    width: 65px !important;
    height: 65px !important;
    transform: translate(-50%, -50%) rotate(180deg);
  }

  .bulletin-post-cosmetic-ring.waves,
  .bulletin-post-cosmetic-ring.waves-static {
    width: 57px !important;
    height: 57px !important;
  }

  .bulletin-post-cosmetic-ring:not(.castle):not(.castle-static):not(.ouroboros):not(.waves):not(.waves-static):not(.purple):not(.green):not(.yellow):not(.bg123-red) {
    width: 60px !important;
    height: 60px !important;
  }

  /* Color rings 20% bigger in bulletin posts */
  .bulletin-post-cosmetic-ring.purple,
  .bulletin-post-cosmetic-ring.green,
  .bulletin-post-cosmetic-ring.yellow,
  .bulletin-post-cosmetic-ring.bg123-red {
    width: 72px !important;
    height: 72px !important;
  }

  .bulletin-post-info {
    flex: 1;
  }

  .bulletin-post-author {
    font-size: 16px;
    font-weight: 800;
    color: var(--gold);
    margin-bottom: 4px;
  }

  .bulletin-post-time {
    font-size: 13px;
    color: rgba(255, 255, 255, 0.5);
  }

  .bulletin-delete-btn {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: rgba(255, 75, 75, 0.1);
    border: 2px solid rgba(255, 75, 75, 0.3);
    color: #ff4b4b;
    font-size: 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    margin-left: auto;
  }

  .bulletin-delete-btn:hover {
    background: rgba(255, 75, 75, 0.2);
    border-color: #ff4b4b;
    transform: scale(1.1);
  }

  .bulletin-delete-btn:active {
    transform: scale(0.95);
  }

  .bulletin-post-content {
    color: rgba(255, 255, 255, 0.9);
    font-size: 15px;
    line-height: 1.6;
    margin-bottom: 12px;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .bulletin-link {
    color: var(--gold);
    text-decoration: underline;
    transition: all 0.2s ease;
    word-break: break-all;
  }

  .bulletin-link:hover {
    color: #ffd700;
    text-decoration: none;
  }

  /* Link Preview Card - Twitter/X Style */
  .bulletin-post-link-preview {
    margin-top: 16px;
    border: 2px solid rgba(237, 183, 35, 0.4);
    border-radius: 16px;
    overflow: hidden;
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.5) 0%, rgba(20, 20, 20, 0.5) 100%);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }

  .bulletin-post-link-preview:hover {
    border-color: var(--gold);
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(237, 183, 35, 0.3), 0 0 40px rgba(237, 183, 35, 0.1);
  }

  .bulletin-post-link-image-container {
    position: relative;
    width: 100%;
    height: 280px;
    overflow: hidden;
    background: rgba(0, 0, 0, 0.3);
  }

  .bulletin-post-link-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.3s ease;
  }

  .bulletin-post-link-preview:hover .bulletin-post-link-image {
    transform: scale(1.05);
  }

  /* YouTube Play Button Overlay */
  .youtube-play-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 80px;
    height: 80px;
    background: rgba(237, 183, 35, 0.95);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
    color: #000;
    padding-left: 6px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    transition: all 0.3s ease;
    pointer-events: none;
  }

  .bulletin-post-link-preview:hover .youtube-play-overlay {
    transform: translate(-50%, -50%) scale(1.1);
    background: var(--gold);
    box-shadow: 0 6px 30px rgba(237, 183, 35, 0.6);
  }

  .youtube-preview {
    border-color: rgba(255, 0, 0, 0.4) !important;
  }

  .youtube-preview:hover {
    border-color: rgba(255, 0, 0, 0.8) !important;
    box-shadow: 0 8px 24px rgba(255, 0, 0, 0.3), 0 0 40px rgba(255, 0, 0, 0.1) !important;
  }

  .bulletin-post-link-info {
    padding: 16px;
    background: rgba(0, 0, 0, 0.3);
  }

  .bulletin-post-link-title {
    font-size: 17px;
    font-weight: 700;
    color: #fff;
    margin-bottom: 8px;
    line-height: 1.3;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .bulletin-post-link-description {
    font-size: 14px;
    color: rgba(255, 255, 255, 0.75);
    line-height: 1.5;
    margin-bottom: 8px;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .bulletin-post-link-url {
    font-size: 13px;
    color: var(--gold);
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .bulletin-post-footer {
    display: flex;
    align-items: center;
    gap: 20px;
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid rgba(237, 183, 35, 0.2);
  }

  .bulletin-post-stat {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 14px;
    color: rgba(255, 255, 255, 0.6);
  }

  /* Bulletin Post Modal */
  .bulletin-post-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .bulletin-modal-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(4px);
  }

  .bulletin-modal-content {
    position: relative;
    width: 90%;
    max-width: 700px;
    max-height: 90vh;
    background: #1a1a1a;
    border: 3px solid var(--gold);
    border-radius: 16px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
  }

  .bulletin-modal-header {
    padding: 20px;
    background: linear-gradient(135deg, rgba(237, 183, 35, 0.2), rgba(237, 183, 35, 0.1));
    border-bottom: 2px solid rgba(237, 183, 35, 0.3);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .bulletin-modal-title {
    margin: 0;
    color: var(--gold);
    font-size: 24px;
  }

  .bulletin-close-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    color: #fff;
    font-size: 28px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    line-height: 1;
  }

  .bulletin-close-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: rotate(90deg);
  }

  .bulletin-modal-body {
    padding: 20px;
    overflow-y: auto;
    max-height: calc(90vh - 80px);
  }

  .bulletin-modal-body::-webkit-scrollbar {
    width: 8px;
  }

  .bulletin-modal-body::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.3);
  }

  .bulletin-modal-body::-webkit-scrollbar-thumb {
    background: var(--gold);
    border-radius: 4px;
  }

  .bulletin-post-detail {
    margin-bottom: 30px;
  }

  /* Comments Section */
  .bulletin-comments-section {
    margin-top: 20px;
    padding-top: 20px;
    border-top: 2px solid rgba(237, 183, 35, 0.2);
  }

  .comments-title {
    color: var(--gold);
    font-size: 20px;
    margin-bottom: 16px;
  }

  .comment-input-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-bottom: 20px;
  }

  .comment-input {
    width: 100%;
    min-height: 60px;
    background: rgba(0, 0, 0, 0.5);
    border: 2px solid rgba(237, 183, 35, 0.3);
    border-radius: 10px;
    padding: 12px;
    color: #fff;
    font-size: 15px;
    font-family: inherit;
    resize: vertical;
  }

  .comment-input:focus {
    outline: none;
    border-color: var(--gold);
  }

  .btn-post-comment {
    align-self: flex-end;
    padding: 10px 20px;
    background: var(--gold);
    color: #000;
    border: 2px solid var(--gold);
    border-radius: 10px;
    font-size: 14px;
    font-weight: 800;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .btn-post-comment:hover {
    background: #ffca3a;
    transform: translateY(-2px);
  }

  .comments-list {
    display: flex;
    flex-direction: column;
    gap: 16px;
    min-height: 50px;
  }

  .bulletin-comments-section .comment-item {
    background: rgba(0, 0, 0, 0.4);
    border: 1px solid rgba(237, 183, 35, 0.2);
    border-radius: 10px;
    padding: 14px;
    min-height: 80px;
    display: block !important;
  }

  .bulletin-comments-section .comment-header {
    display: flex !important;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
    min-height: 40px;
  }

  .bulletin-comment-avatar-container {
    position: relative;
    width: 36px;
    height: 36px;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: visible;
  }

  .bulletin-comments-section .comment-avatar {
    width: 36px !important;
    height: 36px !important;
    border-radius: 50%;
    border: 2px solid var(--gold);
    object-fit: cover;
    flex-shrink: 0;
    position: relative;
    z-index: 1;
  }

  .bulletin-comment-cosmetic-ring {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 10;
    object-fit: contain;
    max-width: none !important;
    max-height: none !important;
  }

  .bulletin-comment-cosmetic-ring.castle,
  .bulletin-comment-cosmetic-ring.castle-static {
    width: 54px !important;
    height: 54px !important;
  }

  .bulletin-comment-cosmetic-ring.ouroboros {
    width: 49px !important;
    height: 49px !important;
    transform: translate(-50%, -50%) rotate(180deg);
  }

  .bulletin-comment-cosmetic-ring.waves,
  .bulletin-comment-cosmetic-ring.waves-static {
    width: 43px !important;
    height: 43px !important;
  }

  .bulletin-comment-cosmetic-ring:not(.castle):not(.castle-static):not(.ouroboros):not(.waves):not(.waves-static):not(.purple):not(.green):not(.yellow):not(.bg123-red) {
    width: 45px !important;
    height: 45px !important;
  }

  /* Color rings 20% bigger in bulletin comments */
  .bulletin-comment-cosmetic-ring.purple,
  .bulletin-comment-cosmetic-ring.green,
  .bulletin-comment-cosmetic-ring.yellow,
  .bulletin-comment-cosmetic-ring.bg123-red {
    width: 54px !important;
    height: 54px !important;
  }

  .bulletin-comments-section .comment-author {
    font-size: 14px !important;
    font-weight: 700;
    color: var(--gold);
  }

  .bulletin-comments-section .comment-time {
    font-size: 12px !important;
    color: rgba(255, 255, 255, 0.5);
  }

  .comment-delete-btn {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background: rgba(255, 75, 75, 0.1);
    border: 2px solid rgba(255, 75, 75, 0.3);
    color: #ff4b4b;
    font-size: 14px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    margin-left: auto;
  }

  .comment-delete-btn:hover {
    background: rgba(255, 75, 75, 0.2);
    border-color: #ff4b4b;
    transform: scale(1.1);
  }

  .comment-delete-btn:active {
    transform: scale(0.95);
  }

  .bulletin-comments-section .comment-text {
    color: rgba(255, 255, 255, 0.85);
    font-size: 14px !important;
    line-height: 1.5;
    white-space: pre-wrap;
    word-break: break-word;
    min-height: 20px;
    display: block !important;
  }

  /* Achievements Grid */
  .achievements-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 16px;
  }

  .achievement-placeholder {
    aspect-ratio: 1;
    background: rgba(0,0,0,0.4);
    border: 2px dashed rgba(237,183,35,0.2);
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 12px;
  }

  /* NFT Grid */
  .profile-nft-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 12px;
  }

  .profile-nft-item {
    aspect-ratio: 1;
    border-radius: 12px;
    overflow: hidden;
    border: 3px solid transparent;
    background-image: linear-gradient(#000, #000), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    transition: all 0.2s;
    cursor: pointer;
  }

  .profile-nft-item:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba(237,183,35,0.4);
  }

  .profile-nft-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  /* NFT Collection Sections */
  .nft-collection-section {
    margin-bottom: 16px;
  }

  .nft-collection-toggle {
    width: 100%;
    padding: 20px 24px;
    background: linear-gradient(135deg, rgba(20,20,30,0.8), rgba(30,30,40,0.8));
    border: 3px solid transparent;
    background-image:
      linear-gradient(135deg, rgba(20,20,30,0.8), rgba(30,30,40,0.8)),
      var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    border-radius: 16px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    font-family: 'Luckiest Guy', cursive;
    box-shadow:
      0 4px 12px rgba(0,0,0,0.5),
      inset 0 2px 0 rgba(255,255,255,0.08),
      0 0 20px rgba(237,183,35,0.15);
  }

  .nft-collection-toggle:hover {
    background: linear-gradient(135deg, rgba(30,30,45,0.9), rgba(40,40,50,0.9));
    background-image:
      linear-gradient(135deg, rgba(30,30,45,0.9), rgba(40,40,50,0.9)),
      var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    transform: translateY(-2px);
    box-shadow:
      0 6px 20px rgba(237,183,35,0.4),
      inset 0 2px 0 rgba(255,255,255,0.12),
      0 0 30px rgba(237,183,35,0.3);
  }

  .nft-collection-toggle:active {
    transform: translateY(0);
    box-shadow:
      0 2px 8px rgba(237,183,35,0.3),
      inset 0 1px 0 rgba(255,255,255,0.05);
  }

  .nft-collection-title {
    flex: 1;
    text-align: left;
    font-size: 22px;
    font-weight: 400;
    color: var(--gold);
    text-shadow:
      2px 2px 0px rgba(0,0,0,0.8),
      0 0 15px rgba(237,183,35,0.5);
    letter-spacing: 1px;
  }

  .nft-collection-count {
    background: linear-gradient(135deg, rgba(237,183,35,0.2), rgba(237,183,35,0.1));
    padding: 8px 16px;
    border-radius: 24px;
    font-size: 16px;
    font-weight: 400;
    font-family: 'Luckiest Guy', cursive;
    color: var(--gold);
    border: 2px solid rgba(237,183,35,0.4);
    box-shadow:
      0 2px 8px rgba(0,0,0,0.3),
      inset 0 1px 0 rgba(255,255,255,0.1);
  }

  .nft-collection-arrow {
    font-size: 18px;
    color: var(--gold);
    transition: transform 0.3s ease;
    filter: drop-shadow(2px 2px 0px rgba(0,0,0,0.8));
  }

  .nft-collection-toggle.expanded .nft-collection-arrow {
    transform: rotate(180deg);
  }

  .nft-collection-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    gap: 20px;
    padding: 24px;
    background: rgba(0,0,0,0.3);
    border-radius: 0 0 12px 12px;
    margin-top: 8px;
  }

  .profile-nft-item {
    background: linear-gradient(135deg, rgba(20,20,30,0.9), rgba(30,30,40,0.9));
    border-radius: 12px;
    overflow: hidden;
    border: 2px solid rgba(93,63,211,0.3);
    transition: all 0.3s ease;
    display: flex;
    flex-direction: column;
  }

  .profile-nft-item:hover {
    transform: translateY(-4px);
    border-color: var(--gold);
    box-shadow: 0 8px 24px rgba(237,183,35,0.3);
  }

  .nft-image-container {
    position: relative;
    width: 100%;
    padding-top: 100%; /* 1:1 Aspect ratio */
    background: #000;
    flex-shrink: 0;
  }

  .nft-image-container img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .nft-logo-badge {
    position: absolute;
    top: 8px;
    left: 8px;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: white;
    padding: 3px;
    border: 2px solid transparent;
    background-image:
      linear-gradient(white, white),
      var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    box-shadow: 0 2px 8px rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    z-index: 10;
  }

  .nft-logo-badge:hover {
    transform: scale(1.15);
    box-shadow: 0 4px 12px rgba(0,0,0,0.7);
  }

  .nft-logo-badge img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
  }

  .nft-info {
    padding: 16px 12px;
    text-align: center;
    background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(10,10,15,0.95));
    border-top: 1px solid rgba(93,63,211,0.3);
    min-height: 65px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 6px;
    flex-shrink: 0;
    visibility: visible !important;
    opacity: 1 !important;
  }

  .nft-title {
    font-family: 'Luckiest Guy', 'Arial Black', Impact, sans-serif;
    font-size: 16px;
    font-weight: 400;
    color: var(--gold);
    text-transform: uppercase;
    margin: 0;
    padding: 0;
    line-height: 1.2;
    text-shadow:
      2px 2px 0px rgba(0,0,0,0.8),
      0 0 12px rgba(237,183,35,0.5);
    letter-spacing: 0.5px;
    visibility: visible !important;
    opacity: 1 !important;
    display: block !important;
  }

  .nft-rarity {
    font-family: 'Luckiest Guy', 'Arial Black', Impact, sans-serif;
    font-size: 13px;
    font-weight: 400;
    color: rgba(255,255,255,0.95);
    text-transform: uppercase;
    margin: 0;
    padding: 0;
    line-height: 1.2;
    text-shadow:
      1px 1px 0px rgba(0,0,0,0.8),
      0 0 10px rgba(255,255,255,0.3);
    letter-spacing: 0.5px;
    visibility: visible !important;
    opacity: 1 !important;
    display: block !important;
  }

  .no-nfts-message {
    text-align: center;
    padding: 48px 20px;
    opacity: 0.5;
  }

  .no-nfts-message p {
    margin-top: 12px;
    font-size: 14px;
    color: rgba(255,255,255,0.6);
  }

  /* Comments Section */
  .comment-form {
    margin-bottom: 24px;
  }

  .comment-form textarea {
    width: 100%;
    min-height: 80px;
    background: rgba(0,0,0,0.5);
    border: 2px solid rgba(237,183,35,0.3);
    border-radius: 12px;
    padding: 12px;
    color: #fff;
    font-size: 14px;
    font-family: inherit;
    resize: vertical;
    margin-bottom: 10px;
  }

  .comment-form textarea:focus {
    outline: none;
    border-color: var(--gold);
  }

  .btn-post-comment {
    background: linear-gradient(135deg, #5D3FD3, #7D5FE3);
    border: 3px solid transparent;
    background-image: linear-gradient(135deg, #5D3FD3, #7D5FE3), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    color: #fff;
    padding: 12px 24px;
    border-radius: 12px;
    font-size: 15px;
    font-weight: 900;
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .btn-post-comment:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(93, 63, 211, 0.5);
  }

  .comments-list {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .comments-loading {
    text-align: center;
    padding: 20px;
    color: rgba(255,255,255,0.5);
    font-style: italic;
  }

  /* Reddit-Style Threading */
  .comment-thread {
    position: relative;
    margin-bottom: 8px;
  }

  .comment-thread[data-depth="1"] { margin-left: 12px; }
  .comment-thread[data-depth="2"] { margin-left: 24px; }
  .comment-thread[data-depth="3"] { margin-left: 36px; }
  .comment-thread[data-depth="4"] { margin-left: 48px; }
  .comment-thread[data-depth="5"] { margin-left: 60px; }
  .comment-thread[data-depth="6"] { margin-left: 72px; }
  .comment-thread[data-depth="7"] { margin-left: 84px; }
  .comment-thread[data-depth="8"] { margin-left: 96px; }

  /* Compact styling for deeply nested comments (3+ levels) */
  .comment-thread[data-depth="3"] .comment-item,
  .comment-thread[data-depth="4"] .comment-item,
  .comment-thread[data-depth="5"] .comment-item,
  .comment-thread[data-depth="6"] .comment-item,
  .comment-thread[data-depth="7"] .comment-item,
  .comment-thread[data-depth="8"] .comment-item {
    padding: 8px;
  }

  .comment-thread[data-depth="3"] .comment-actions,
  .comment-thread[data-depth="4"] .comment-actions,
  .comment-thread[data-depth="5"] .comment-actions,
  .comment-thread[data-depth="6"] .comment-actions,
  .comment-thread[data-depth="7"] .comment-actions,
  .comment-thread[data-depth="8"] .comment-actions {
    gap: 4px;
    margin-top: 6px;
  }

  /* Make buttons icon-only at depth 3+ */
  .comment-thread[data-depth="3"] .like-button span:not(.like-emoji),
  .comment-thread[data-depth="4"] .like-button span:not(.like-emoji),
  .comment-thread[data-depth="5"] .like-button span:not(.like-emoji),
  .comment-thread[data-depth="6"] .like-button span:not(.like-emoji),
  .comment-thread[data-depth="7"] .like-button span:not(.like-emoji),
  .comment-thread[data-depth="8"] .like-button span:not(.like-emoji),
  .comment-thread[data-depth="3"] .reply-button span:not(.reply-icon),
  .comment-thread[data-depth="4"] .reply-button span:not(.reply-icon),
  .comment-thread[data-depth="5"] .reply-button span:not(.reply-icon),
  .comment-thread[data-depth="6"] .reply-button span:not(.reply-icon),
  .comment-thread[data-depth="7"] .reply-button span:not(.reply-icon),
  .comment-thread[data-depth="8"] .reply-button span:not(.reply-icon) {
    display: none;
  }

  .comment-thread[data-depth="3"] .like-button,
  .comment-thread[data-depth="3"] .reply-button,
  .comment-thread[data-depth="4"] .like-button,
  .comment-thread[data-depth="4"] .reply-button,
  .comment-thread[data-depth="5"] .like-button,
  .comment-thread[data-depth="5"] .reply-button,
  .comment-thread[data-depth="6"] .like-button,
  .comment-thread[data-depth="6"] .reply-button,
  .comment-thread[data-depth="7"] .like-button,
  .comment-thread[data-depth="7"] .reply-button,
  .comment-thread[data-depth="8"] .like-button,
  .comment-thread[data-depth="8"] .reply-button {
    padding: 4px 6px;
    font-size: 14px;
    min-width: unset;
  }

  .comment-thread[data-depth="3"] .comment-delete-btn,
  .comment-thread[data-depth="4"] .comment-delete-btn,
  .comment-thread[data-depth="5"] .comment-delete-btn,
  .comment-thread[data-depth="6"] .comment-delete-btn,
  .comment-thread[data-depth="7"] .comment-delete-btn,
  .comment-thread[data-depth="8"] .comment-delete-btn {
    padding: 3px 6px;
    font-size: 10px;
  }

  .comment-thread[data-depth="3"] .comment-text,
  .comment-thread[data-depth="4"] .comment-text,
  .comment-thread[data-depth="5"] .comment-text,
  .comment-thread[data-depth="6"] .comment-text,
  .comment-thread[data-depth="7"] .comment-text,
  .comment-thread[data-depth="8"] .comment-text {
    font-size: 12px;
  }

  .comment-thread[data-depth="3"] .comment-author-name,
  .comment-thread[data-depth="4"] .comment-author-name,
  .comment-thread[data-depth="5"] .comment-author-name,
  .comment-thread[data-depth="6"] .comment-author-name,
  .comment-thread[data-depth="7"] .comment-author-name,
  .comment-thread[data-depth="8"] .comment-author-name {
    font-size: 13px;
  }

  /* Threading line visual indicator */
  .comment-thread[data-depth]::before {
    content: '';
    position: absolute;
    left: -12px;
    top: 0;
    bottom: 0;
    width: 2px;
    background: linear-gradient(180deg,
      rgba(237,183,35,0.3) 0%,
      rgba(129,212,250,0.2) 50%,
      rgba(237,183,35,0.3) 100%
    );
    transition: all 0.2s;
  }

  .comment-thread[data-depth]:hover::before {
    background: linear-gradient(180deg,
      rgba(237,183,35,0.6) 0%,
      rgba(129,212,250,0.4) 50%,
      rgba(237,183,35,0.6) 100%
    );
    width: 3px;
  }

  .thread-toggle {
    position: absolute;
    left: -32px;
    top: 16px;
    width: 24px;
    height: 24px;
    background: linear-gradient(135deg, rgba(237,183,35,0.2), rgba(129,212,250,0.2));
    border: 2px solid rgba(237,183,35,0.4);
    border-radius: 4px;
    color: var(--gold);
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
  }

  .thread-toggle:hover {
    background: linear-gradient(135deg, rgba(237,183,35,0.4), rgba(129,212,250,0.4));
    border-color: var(--gold);
    transform: scale(1.1);
  }

  .toggle-icon {
    transition: transform 0.2s;
  }

  .comment-thread.collapsed .toggle-icon {
    transform: rotate(-90deg);
  }

  .thread-spacer {
    width: 24px;
    flex-shrink: 0;
  }

  .comment-replies {
    margin-top: 8px;
    transition: all 0.3s ease-in-out;
  }

  .reply-count {
    font-size: 11px;
    color: rgba(129,212,250,0.8);
    margin-left: 8px;
    font-weight: 700;
  }

  .comment-item {
    background: rgba(0,0,0,0.4);
    border: 2px solid rgba(237,183,35,0.15);
    border-radius: 12px;
    padding: 16px;
    transition: all 0.2s;
    display: flex;
    gap: 12px;
  }

  .comment-content {
    flex: 1;
    min-width: 0;
  }

  /* Reply indicator styling */
  .reply-indicator {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 8px;
    padding: 4px 8px;
    background: linear-gradient(90deg, rgba(129,212,250,0.15), transparent);
    border-left: 3px solid rgba(129,212,250,0.5);
    border-radius: 4px;
  }

  .reply-arrow {
    font-size: 14px;
    color: rgba(129,212,250,0.9);
    animation: replyPulse 2s ease-in-out infinite;
  }

  @keyframes replyPulse {
    0%, 100% { transform: translateX(0); opacity: 1; }
    50% { transform: translateX(-2px); opacity: 0.7; }
  }

  /* Highlight flash animation for notification navigation */
  @keyframes highlight-flash {
    0%, 100% {
      background: transparent;
      box-shadow: none;
    }
    10%, 30%, 50% {
      background: linear-gradient(135deg, rgba(237,183,35,0.3), rgba(237,183,35,0.1));
      box-shadow: 0 0 20px rgba(237,183,35,0.5), inset 0 0 15px rgba(237,183,35,0.2);
    }
    20%, 40%, 60% {
      background: transparent;
      box-shadow: none;
    }
  }

  .reply-to-text {
    font-size: 12px;
    color: rgba(255,255,255,0.6);
    font-weight: 600;
  }

  .reply-to-name {
    color: rgba(129,212,250,0.9);
    font-weight: 900;
  }

  /* Subtle background tint for replies */
  .comment-thread.is-reply .comment-item {
    background: linear-gradient(135deg, rgba(129,212,250,0.05), rgba(0,0,0,0.4));
    border-left: 3px solid rgba(129,212,250,0.3);
  }

  .comment-thread.is-reply .comment-item:hover {
    background: linear-gradient(135deg, rgba(129,212,250,0.1), rgba(0,0,0,0.5));
    border-left-color: rgba(129,212,250,0.6);
  }

  .comment-item:hover {
    border-color: rgba(237,183,35,0.3);
    background: rgba(0,0,0,0.5);
  }

  .comment-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 12px;
  }

  .comment-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid var(--gold);
    object-fit: cover;
  }

  .comment-avatar-placeholder {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid var(--gold);
    background: linear-gradient(135deg, rgba(93, 63, 211, 0.3), rgba(237, 183, 35, 0.3));
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
  }

  .comment-author-info {
    flex: 1;
  }

  .comment-author-clickable {
    transition: all 0.2s ease;
    border-radius: 8px;
    padding: 4px;
    margin: -4px;
  }

  .comment-author-clickable:hover {
    background: rgba(237,183,35,0.1);
    transform: translateX(2px);
  }

  .comment-author-clickable:hover .comment-author-name {
    color: rgba(237,183,35,1);
    text-decoration: underline;
  }

  .comment-author-name {
    font-weight: 900;
    color: var(--gold);
    font-size: 15px;
    margin: 0;
    transition: all 0.2s ease;
  }

  .comment-timestamp {
    font-size: 12px;
    color: rgba(255,255,255,0.5);
    margin: 0;
  }

  .comment-delete-btn {
    background: rgba(255,0,0,0.2);
    border: 2px solid rgba(255,0,0,0.4);
    color: #ff6b6b;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s;
  }

  .comment-delete-btn:hover {
    background: rgba(255,0,0,0.4);
    border-color: #ff6b6b;
  }

  .comment-text {
    color: rgba(255,255,255,0.9);
    line-height: 1.5;
    font-size: 14px;
    white-space: pre-wrap;
    margin: 0;
  }

  .comments-empty {
    text-align: center;
    padding: 40px 20px;
    color: rgba(255,255,255,0.5);
    font-style: italic;
  }

  /* Facebook-Style Reactions */
  .comment-actions {
    display: flex;
    gap: 12px;
    margin-top: 8px;
    align-items: center;
  }

  .like-button {
    position: relative;
    background: none;
    border: none;
    color: rgba(255,255,255,0.6);
    font-size: 14px;
    font-weight: 700;
    cursor: pointer;
    padding: 6px 12px;
    border-radius: 6px;
    transition: all 0.2s;
    user-select: none;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .like-button:hover {
    background: rgba(255,255,255,0.1);
    color: rgba(255,255,255,0.9);
  }

  .like-button.reacted {
    color: var(--gold);
  }

  .like-button .like-emoji {
    font-size: 16px;
  }

  /* Reply Button */
  .reply-button {
    position: relative;
    background: linear-gradient(135deg, rgba(237,183,35,0.15), rgba(129,212,250,0.15));
    border: 2px solid transparent;
    background-image: linear-gradient(rgba(20,22,25,0.9), rgba(20,22,25,0.9)), var(--tri-gradient);
    background-origin: border-box;
    background-clip: padding-box, border-box;
    color: rgba(255,255,255,0.8);
    font-size: 14px;
    font-weight: 700;
    cursor: pointer;
    padding: 6px 14px;
    border-radius: 20px;
    transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    user-select: none;
    display: flex;
    align-items: center;
    gap: 6px;
    animation: wiggle 2s ease-in-out infinite;
    box-shadow: 0 4px 15px rgba(237,183,35,0.2);
  }

  .reply-button:hover {
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 8px 25px rgba(237,183,35,0.4), 0 0 20px rgba(129,212,250,0.3);
    background-image: linear-gradient(rgba(20,22,25,0.7), rgba(20,22,25,0.7)), var(--tri-gradient);
    color: rgba(255,255,255,1);
    animation: none;
  }

  .reply-button .reply-icon {
    font-size: 16px;
    filter: drop-shadow(0 2px 4px rgba(237,183,35,0.4));
  }

  @keyframes wiggle {
    0%, 100% {
      transform: rotate(0deg);
    }
    25% {
      transform: rotate(-3deg);
    }
    75% {
      transform: rotate(3deg);
    }
  }

  /* Reply Box */
  .reply-box {
    margin-top: 12px;
    padding: 12px;
    background: rgba(0,0,0,0.3);
    border: 2px solid transparent;
    background-image: linear-gradient(rgba(20,22,25,0.95), rgba(20,22,25,0.95)), var(--tri-gradient);
    background-origin: border-box;
    background-clip: padding-box, border-box;
    border-radius: 12px;
    display: none;
    animation: slideDown 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  }

  .reply-box.visible {
    display: block;
  }

  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-10px) scale(0.95);
    }
    to {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }

  .reply-box textarea {
    width: 100%;
    min-height: 60px;
    background: rgba(0,0,0,0.4);
    border: 2px solid rgba(237,183,35,0.3);
    border-radius: 8px;
    color: white;
    padding: 8px 12px;
    font-family: inherit;
    font-size: 14px;
    resize: vertical;
    transition: all 0.2s;
  }

  .reply-box textarea:focus {
    outline: none;
    border-color: var(--gold);
    box-shadow: 0 0 15px rgba(237,183,35,0.3);
  }

  .reply-box-actions {
    display: flex;
    gap: 8px;
    margin-top: 8px;
    justify-content: flex-end;
  }

  .reply-box-actions button {
    padding: 6px 16px;
    border-radius: 8px;
    font-weight: 700;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
    border: none;
  }

  .reply-cancel-btn {
    background: rgba(255,255,255,0.1);
    color: rgba(255,255,255,0.7);
  }

  .reply-cancel-btn:hover {
    background: rgba(255,255,255,0.2);
    color: white;
  }

  .reply-submit-btn {
    background: linear-gradient(135deg, var(--gold), #d4a028);
    color: black;
    font-weight: 900;
  }

  .reply-submit-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(237,183,35,0.5);
  }

  /* Reaction Summary (shows counts of reactions) */
  .reaction-summary {
    display: flex;
    gap: 4px;
    align-items: center;
    margin-top: 8px;
    flex-wrap: wrap;
  }

  .reaction-pill {
    background: rgba(0,0,0,0.4);
    border: 2px solid rgba(237,183,35,0.3);
    border-radius: 16px;
    padding: 4px 10px;
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 13px;
    color: rgba(255,255,255,0.8);
    cursor: pointer;
    transition: all 0.2s;
    user-select: none;
  }

  .reaction-pill:hover {
    background: rgba(237,183,35,0.15);
    border-color: var(--gold);
    transform: translateY(-2px) scale(1.05);
  }

  .reaction-pill.user-reacted {
    background: linear-gradient(135deg, rgba(237,183,35,0.3), rgba(237,183,35,0.2));
    border-color: var(--gold);
    box-shadow: 0 0 12px rgba(237,183,35,0.4);
  }

  .reaction-pill.removing {
    animation: bubbleErase 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
  }

  @keyframes bubbleErase {
    0% {
      transform: scale(1);
      opacity: 1;
    }
    50% {
      transform: scale(1.3);
      opacity: 0.8;
    }
    100% {
      transform: scale(0);
      opacity: 0;
    }
  }

  .reaction-pill .pill-emoji {
    font-size: 16px;
    transition: transform 0.2s;
  }

  .reaction-pill:hover .pill-emoji {
    transform: scale(1.2);
  }

  .reaction-pill .pill-count {
    font-weight: 700;
    color: var(--gold);
  }

  /* Facebook-Style Reaction Picker Bubble */
  .reaction-picker {
    position: absolute;
    bottom: 100%;
    left: 0;
    margin-bottom: 8px;
    background: linear-gradient(135deg, rgba(20, 22, 25, 0.98), rgba(16, 18, 21, 0.98));
    border: 3px solid transparent;
    background-image: linear-gradient(135deg, rgba(20, 22, 25, 0.98), rgba(16, 18, 21, 0.98)), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    border-radius: 50px;
    padding: 8px 12px;
    display: none;
    gap: 4px;
    box-shadow: 0 12px 40px rgba(0,0,0,0.8), 0 0 20px rgba(237,183,35,0.3);
    z-index: 1000;
    transform-origin: bottom left;
    animation: pickerBounceIn 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  }

  .reaction-picker.visible {
    display: flex;
  }

  @keyframes pickerBounceIn {
    0% {
      opacity: 0;
      transform: scale(0) translateY(20px);
    }
    50% {
      transform: scale(1.1) translateY(0);
    }
    100% {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
  }

  .reaction-picker-item {
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
    cursor: pointer;
    border-radius: 50%;
    transition: transform 0.1s cubic-bezier(0.34, 1.56, 0.64, 1), filter 0.1s ease;
    position: relative;
    background: transparent;
    transform: scale(1);
    touch-action: none;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    -webkit-user-select: none;
  }

  /* Desktop hover effect */
  @media (hover: hover) and (pointer: fine) {
    .reaction-picker-item:hover {
      transform: scale(1.5) translateY(-8px);
      filter: drop-shadow(0 8px 16px rgba(237,183,35,0.6));
    }

    .reaction-picker-item:active {
      transform: scale(1.3) translateY(-4px);
    }
  }

  /* Reaction label on hover */
  .reaction-picker-item::before {
    content: attr(data-label);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%) translateY(-8px) scale(0);
    background: rgba(0,0,0,0.9);
    color: var(--gold);
    padding: 4px 10px;
    border-radius: 8px;
    font-size: 12px;
    font-weight: 700;
    white-space: nowrap;
    pointer-events: none;
    opacity: 0;
    transition: all 0.2s;
    font-family: 'Luckiest Guy', cursive;
  }

  .reaction-picker-item:hover::before {
    opacity: 1;
    transform: translateX(-50%) translateY(-4px) scale(1);
  }

  /* Stagger animation for picker items */
  .reaction-picker-item:nth-child(1) { animation: itemPop 0.3s 0.05s both; }
  .reaction-picker-item:nth-child(2) { animation: itemPop 0.3s 0.1s both; }
  .reaction-picker-item:nth-child(3) { animation: itemPop 0.3s 0.15s both; }
  .reaction-picker-item:nth-child(4) { animation: itemPop 0.3s 0.2s both; }
  .reaction-picker-item:nth-child(5) { animation: itemPop 0.3s 0.25s both; }
  .reaction-picker-item:nth-child(6) { animation: itemPop 0.3s 0.3s both; }

  @keyframes itemPop {
    0% {
      opacity: 0;
      transform: scale(0) translateY(10px);
    }
    50% {
      transform: scale(1.2) translateY(-4px);
    }
    100% {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
  }

  @media (max-width: 768px) {
    .menu-overlay {
      max-width: 100%;
    }

    .honey-points-btn,
    .welcome-profile-btn {
      padding: 6px 12px;
      font-size: 11px;
      gap: 4px;
    }

    .nav-buttons-container {
      gap: 8px;
    }

    .menu-btn img {
      width: 40px;
      height: 40px;
    }

    .top-nav-bar {
      padding: 8px 16px;
    }

    .welcome-avatar {
      width: 32px !important;
      height: 32px !important;
    }

    .welcome-avatar-container {
      width: 32px;
      height: 32px;
      margin-left: 6px;
    }

    .welcome-cosmetic-ring.castle,
    .welcome-cosmetic-ring.castle-static {
      width: 51px !important;
      height: 51px !important;
    }

    .welcome-cosmetic-ring.ouroboros {
      width: 46px !important;
      height: 46px !important;
    }

    .welcome-cosmetic-ring.waves,
    .welcome-cosmetic-ring.waves-static {
      width: 43px !important;
      height: 43px !important;
    }

    .welcome-cosmetic-ring:not(.castle):not(.castle-static):not(.ouroboros):not(.waves):not(.waves-static):not(.purple):not(.green):not(.yellow):not(.bg123-red) {
      width: 45px !important;
      height: 45px !important;
    }

    /* Color rings bigger in profile modal (mobile) */
    .welcome-cosmetic-ring.purple,
    .welcome-cosmetic-ring.green,
    .welcome-cosmetic-ring.yellow,
    .welcome-cosmetic-ring.bg123-red {
      width: 59px !important;
      height: 59px !important;
    }
  }

  /* Tablet and larger screens - increase header padding for foldables */
  @media (min-width:768px) and (max-width:1024px){
    #buyDrawer .drawer-head{padding-top:calc(env(safe-area-inset-top,0px) + 105px) !important;}
  }

  /* Make the drawer full-screen on phones & foldables so width isn't the limiter */
  @media (max-width:1024px){
    #buyDrawer{
      left:0 !important; right:0 !important; top:0 !important; bottom:0 !important;
      width:100vw !important; height:100vh !important; border-left:0 !important; border-radius:0 !important;
    }
    .drawer-scrim{display:none !important;}
    #buyDrawer .drawer-head{padding-top:calc(env(safe-area-inset-top,0px) + 70px)}
    #buyDrawer .drawer-body{padding-bottom:calc(env(safe-area-inset-bottom,0px) + 200px); overscroll-behavior:contain}
  }

  /* Phone-specific adjustments for smaller devices like iPhone SE */
  @media (max-width:667px){
    #buyDrawer .drawer-body{padding-bottom:calc(env(safe-area-inset-bottom,0px) + 180px) !important;}
  }

  /* Use dynamic viewport height where supported */
  @supports (height: 100dvh){
    #buyDrawer{height:100dvh}
  }

  /* ===== BEAR OVERVIEW SECTION (DexScreener Style) ===== */
  .dex-layout{
    display:grid;
    grid-template-columns:1fr 360px;
    gap:20px;
    margin-top:24px;
  }
  @media(max-width:1100px){
    .dex-layout{grid-template-columns:1fr;}
    .dex-stats-sidebar{order:-1;}
  }

  .dex-chart-container{
    min-height:600px;
  }

  .dex-stats-sidebar{
    display:flex;
    flex-direction:column;
  }

  /* Stats List (DexScreener style) */
  .stats-list{
    display:flex;
    flex-direction:column;
    gap:12px;
  }

  .stat-item{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:12px 14px;
    background:rgba(237,183,35,0.05);
    border-radius:8px;
    border:1px solid rgba(237,183,35,0.15);
    transition:all 0.2s;
  }

  .stat-item:hover{
    background:rgba(237,183,35,0.08);
    border-color:rgba(237,183,35,0.25);
  }

  .stat-label{
    font-size:15px;
    color:#fff;
    opacity:0.7;
    text-transform:uppercase;
    letter-spacing:0.5px;
    font-weight:700;
  }

  .stat-value{
    font-size:16px;
    font-weight:800;
    color:var(--gold);
    text-align:right;
  }

  /* ===== BEAR HONEY POINTS SECTION ===== */
  .honey-points-grid{
    display:grid;
    grid-template-columns:repeat(2, 1fr);
    gap:24px;
    margin-top:24px;
    max-width:1400px;
    margin-left:auto;
    margin-right:auto;
  }
  @media(max-width:1200px){
    .honey-points-grid{grid-template-columns:1fr;}
  }

  .honey-card{
    position: relative;
    background: var(--glass-bg);
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
    border-radius:24px;
    padding:24px;
    box-shadow: var(--elevation-2-glass);
    border: 1px solid var(--glass-border);
    margin-bottom:24px;
    overflow: hidden;
    transition: all 0.4s var(--spring-butter);
    will-change: var(--will-change-transform);
    transform: var(--transform-gpu);
  }
  .honey-card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 24px;
    padding: 6px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: 0;
    opacity: 0.8;
    transition: opacity 0.3s var(--spring-smooth);
  }
  .honey-card::after {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(
      45deg,
      transparent 30%,
      rgba(255, 174, 0, 0.05) 50%,
      transparent 70%
    );
    transform: rotate(0deg);
    opacity: 0;
    pointer-events: none;
    transition: all 0.6s var(--spring-smooth);
  }
  .honey-card:hover {
    transform: translateY(-8px) var(--transform-gpu);
    box-shadow: var(--elevation-4-glass);
    background: var(--glass-bg-heavy);
    border-color: var(--glass-border-hover);
  }
  .honey-card:hover::before {
    opacity: 1;
  }
  .honey-card:hover::after {
    opacity: 1;
    transform: rotate(180deg);
  }

  /* üî• GODMODE GLASS ENHANCEMENTS FOR ALL SECTIONS üî• */
  section.alt, section.dark {
    position: relative;
  }
  section.alt::before, section.dark::before {
    content: '';
    position: absolute;
    inset: 0;
    background: radial-gradient(
      circle at 50% 0%,
      rgba(255, 174, 0, 0.03) 0%,
      transparent 50%
    );
    pointer-events: none;
    animation: section-glow 8s ease-in-out infinite;
  }
  @keyframes section-glow {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.6; }
  }

  /* Enhanced .card class with glass */
  .card {
    backdrop-filter: var(--glass-blur-light);
    -webkit-backdrop-filter: var(--glass-blur-light);
    border: 1px solid var(--glass-border);
    transition: all 0.3s var(--spring-butter);
  }
  .card:hover {
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
    border-color: var(--glass-border-hover);
    box-shadow: var(--elevation-3-glass);
  }

  .honey-card-title{
    margin:0 0 16px 0;
    font-size:22px;
    font-weight:900;
    color:var(--gold);
    text-transform:uppercase;
    letter-spacing:0.5px;
    text-shadow: 0 2px 8px rgba(255, 174, 0, 0.3);
  }

  /* DEXScreener Style Stats */
  .dex-stats-container {
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid rgba(237,183,35,0.2);
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
  }

  .dex-stat-box {
    background: rgba(0,0,0,0.3);
    border-radius: 8px;
    padding: 12px;
    border: 1px solid rgba(237,183,35,0.15);
  }

  .dex-stat-label {
    font-size: 11px;
    font-weight: 600;
    color: rgba(255,255,255,0.6);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 6px;
  }

  .dex-stat-value {
    font-size: 20px;
    font-weight: 900;
    color: #fff;
    margin-bottom: 8px;
  }

  .dex-stat-subgrid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-bottom: 8px;
  }

  .dex-stat-sub {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .dex-sub-label {
    font-size: 10px;
    font-weight: 600;
    color: rgba(255,255,255,0.5);
    text-transform: uppercase;
    letter-spacing: 0.3px;
  }

  .dex-sub-value {
    font-size: 14px;
    font-weight: 700;
    color: #fff;
  }

  .dex-progress-bar {
    display: flex;
    height: 6px;
    background: rgba(0,0,0,0.4);
    border-radius: 3px;
    overflow: hidden;
    gap: 1px;
  }

  .dex-progress-fill {
    height: 100%;
    transition: width 0.3s ease;
  }

  .dex-progress-buy {
    background: linear-gradient(90deg, #22c55e 0%, #16a34a 100%);
  }

  .dex-progress-sell {
    background: linear-gradient(90deg, #ef4444 0%, #dc2626 100%);
  }

  @media (max-width: 768px) {
    .dex-stats-container {
      grid-template-columns: 1fr;
    }
    .dex-stat-value {
      font-size: 18px;
    }
  }

  /* Price Stats Grid */
  .price-stats-grid{
    display:grid;
    grid-template-columns:repeat(3, 1fr);
    gap:12px;
  }
  @media(max-width:768px){
    .price-stats-grid{grid-template-columns:repeat(2, 1fr);}
  }

  .price-stat{
    background:rgba(237,183,35,0.08);
    padding:14px;
    border-radius:10px;
    border:2px solid rgba(237,183,35,0.2);
  }

  .price-stat-label{
    font-size:12px;
    color:#fff;
    opacity:0.9;
    margin-bottom:6px;
    text-transform:uppercase;
    letter-spacing:0.5px;
  }

  .price-stat-value{
    font-size:20px;
    font-weight:900;
    color:var(--gold);
  }

  /* Chart Container */
  .chart-container{
    background:rgba(0,0,0,0.3);
    border-radius:12px;
    overflow:hidden;
    border:2px solid rgba(0,0,0,0.5);
  }
  .chart-container iframe{
    display:block;
  }

  /* Liquidity Grid */
  .liquidity-grid{
    display:grid;
    gap:12px;
  }

  .liquidity-stat{
    display:flex;
    align-items:center;
    gap:14px;
    background:rgba(237,183,35,0.08);
    padding:16px;
    border-radius:10px;
    border:2px solid rgba(237,183,35,0.2);
  }

  .liquidity-icon{
    font-size:32px;
    line-height:1;
  }

  .liquidity-label{
    font-size:12px;
    color:#fff;
    opacity:0.9;
    margin-bottom:4px;
    text-transform:uppercase;
    letter-spacing:0.5px;
  }

  .liquidity-value{
    font-size:20px;
    font-weight:900;
    color:var(--gold);
  }

  /* My Points Card */
  .my-points-card{
    background:linear-gradient(135deg, rgba(237,183,35,0.15), rgba(215,92,70,0.15));
    border:3px solid var(--gold);
  }

  .points-hero{
    text-align:center;
    padding:24px;
    background:rgba(0,0,0,0.4);
    border-radius:12px;
    margin-bottom:16px;
    border:2px solid rgba(237,183,35,0.3);
  }

  .points-hero-value{
    font-size:56px;
    font-weight:900;
    color:var(--gold);
    line-height:1;
    text-shadow:0 2px 8px rgba(237,183,35,0.5);
  }

  .points-hero-label{
    font-size:14px;
    margin-top:8px;
    opacity:0.8;
    text-transform:uppercase;
    letter-spacing:1px;
  }

  /* Points Breakdown */
  .points-breakdown{
    display:flex;
    flex-direction:column;
    gap:12px;
    margin-bottom:16px;
  }

  .points-breakdown-item{
    display:flex;
    align-items:center;
    gap:16px;
    padding:16px;
    background:rgba(0,0,0,0.3);
    border-radius:12px;
    border:2px solid rgba(237,183,35,0.2);
    transition:all 0.3s ease;
  }

  .points-breakdown-item:hover{
    border-color:rgba(237,183,35,0.4);
    transform:translateX(4px);
  }

  .points-breakdown-icon{
    font-size:32px;
    line-height:1;
  }

  .points-breakdown-content{
    flex:1;
  }

  .points-breakdown-label{
    font-size:14px;
    opacity:0.8;
    margin-bottom:4px;
    text-transform:uppercase;
    letter-spacing:0.5px;
  }

  .points-breakdown-value{
    font-size:24px;
    font-weight:900;
    color:var(--gold);
  }

  /* Daily Game Progress Widget */
  .daily-game-progress{
    background:linear-gradient(135deg, rgba(237,183,35,0.1) 0%, rgba(255,215,0,0.05) 100%);
    border:2px solid rgba(237,183,35,0.3);
    border-radius:16px;
    padding:20px;
    margin:20px 0;
    transition:all 0.3s ease;
  }

  .daily-game-progress:hover{
    border-color:rgba(237,183,35,0.5);
    transform:translateY(-2px);
    box-shadow:0 8px 24px rgba(237,183,35,0.2);
  }

  .daily-progress-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:12px;
  }

  .daily-progress-title{
    font-size:16px;
    font-weight:700;
    color:#fff;
    text-transform:uppercase;
    letter-spacing:0.5px;
  }

  .daily-progress-count{
    font-size:20px;
    font-weight:900;
    color:var(--gold);
    text-shadow:0 0 10px rgba(237,183,35,0.5);
  }

  .daily-progress-bar-container{
    height:12px;
    background:rgba(0,0,0,0.3);
    border-radius:20px;
    overflow:hidden;
    margin-bottom:12px;
    border:1px solid rgba(237,183,35,0.2);
  }

  .daily-progress-bar{
    height:100%;
    background:linear-gradient(90deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%);
    border-radius:20px;
    transition:width 0.6s cubic-bezier(0.65, 0, 0.35, 1);
    box-shadow:0 0 20px rgba(255,215,0,0.6), inset 0 1px 0 rgba(255,255,255,0.3);
    position:relative;
    background-size:200% 100%;
    animation:shimmer 2s infinite;
  }

  @keyframes shimmer{
    0%{ background-position:0% 50%; }
    50%{ background-position:100% 50%; }
    100%{ background-position:0% 50%; }
  }

  /* Shimmer Skeleton Loaders */
  .skeleton {
    background: linear-gradient(90deg, rgba(237,183,35,0.1) 0%, rgba(237,183,35,0.2) 50%, rgba(237,183,35,0.1) 100%);
    background-size: 200% 100%;
    animation: shimmer 2s infinite;
    border-radius: 8px;
    position: relative;
    overflow: hidden;
  }
  .skeleton::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.1) 50%, transparent 100%);
    animation: shimmerSlide 2s infinite;
  }
  @keyframes shimmerSlide {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
  }
  .skeleton-text {
    height: 20px;
    margin-bottom: 10px;
  }
  .skeleton-title {
    height: 32px;
    width: 60%;
    margin-bottom: 16px;
  }
  .skeleton-card {
    height: 200px;
    width: 100%;
  }
  .skeleton-circle {
    width: 50px;
    height: 50px;
    border-radius: 50%;
  }

  .daily-progress-info{
    display:flex;
    justify-content:space-between;
    align-items:center;
    font-size:13px;
  }

  .daily-progress-points{
    color:var(--gold);
    font-weight:700;
    text-shadow:0 0 10px rgba(237,183,35,0.3);
  }

  .daily-progress-remaining{
    color:rgba(255,255,255,0.7);
    font-weight:600;
  }

  .points-rank{
    text-align:center;
    padding:12px;
    background:rgba(0,0,0,0.3);
    border-radius:8px;
    margin-bottom:12px;
    font-size:14px;
  }

  .points-rank strong{
    color:var(--gold);
    font-size:16px;
  }

  .points-twitter{
    display:flex;
    align-items:center;
    justify-content:center;
    gap:8px;
    padding:10px;
    background:rgba(29,155,240,0.1);
    border-radius:8px;
    border:2px solid rgba(29,155,240,0.3);
  }

  .points-cta{
    text-align:center;
    padding:24px;
  }

  /* Leaderboard */
  .leaderboard-card{
    max-height:600px;
    display:flex;
    flex-direction:column;
  }

  .leaderboard{
    flex:1;
    overflow-y:auto;
    margin:-8px;
    padding:8px;
  }

  .leaderboard::-webkit-scrollbar{
    width:8px;
  }

  .leaderboard::-webkit-scrollbar-track{
    background:rgba(0,0,0,0.2);
    border-radius:4px;
  }

  .leaderboard::-webkit-scrollbar-thumb{
    background:var(--gold);
    border-radius:4px;
  }

  .leaderboard-loading{
    text-align:center;
    padding:32px;
    opacity:0.6;
  }

  .leaderboard-item{
    display:flex;
    flex-direction:row;
    align-items:center;
    gap:12px;
    padding:12px;
    background:rgba(237,183,35,0.08);
    border-radius:10px;
    border:2px solid rgba(237,183,35,0.2);
    margin-bottom:8px;
    transition:all 0.2s var(--ease-spring);
    opacity: 0;
    transform: translateY(10px);
    animation: fadeInUp 0.4s var(--ease-spring) forwards;
  }
  .leaderboard-item:nth-child(1) { animation-delay: 0.05s; }
  .leaderboard-item:nth-child(2) { animation-delay: 0.1s; }
  .leaderboard-item:nth-child(3) { animation-delay: 0.15s; }
  .leaderboard-item:nth-child(4) { animation-delay: 0.2s; }
  .leaderboard-item:nth-child(5) { animation-delay: 0.25s; }
  .leaderboard-item:nth-child(6) { animation-delay: 0.3s; }
  .leaderboard-item:nth-child(7) { animation-delay: 0.35s; }
  .leaderboard-item:nth-child(8) { animation-delay: 0.4s; }
  .leaderboard-item:nth-child(9) { animation-delay: 0.45s; }
  .leaderboard-item:nth-child(10) { animation-delay: 0.5s; }

  @keyframes fadeInUp {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .leaderboard-item:hover{
    background:rgba(237,183,35,0.15);
    border-color:rgba(237,183,35,0.4);
    transform:translateX(4px);
  }

  .leaderboard-rank{
    font-size:20px;
    font-weight:900;
    color:var(--gold);
    min-width:32px;
    text-align:center;
  }

  .leaderboard-rank.top-3{
    font-size:24px;
  }

  .leaderboard-user{
    flex:1;
    min-width:0;
  }

  .leaderboard-username{
    font-weight:900;
    font-size:14px;
    color:var(--gold);
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  .leaderboard-wallet{
    font-size:11px;
    opacity:0.6;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  .leaderboard-points{
    font-size:16px;
    font-weight:900;
    color:var(--honey);
    white-space:nowrap;
  }

  /* Trophy colors for top 3 */
  .leaderboard-item.rank-1 .leaderboard-rank{color:#FFD700;}
  .leaderboard-item.rank-2 .leaderboard-rank{color:#C0C0C0;}
  .leaderboard-item.rank-3 .leaderboard-rank{color:#CD7F32;}

  .leaderboard-item.rank-1{
    background:linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05));
    border-color:rgba(255,215,0,0.4);
  }

  .leaderboard-item.rank-2{
    background:linear-gradient(135deg, rgba(192,192,192,0.15), rgba(192,192,192,0.05));
    border-color:rgba(192,192,192,0.4);
  }

  .leaderboard-item.rank-3{
    background:linear-gradient(135deg, rgba(205,127,50,0.15), rgba(205,127,50,0.05));
    border-color:rgba(205,127,50,0.4);
  }

  /* Raids Card */
  .raids-card{
    position:relative;
  }

  .admin-raid-btn{
    position:absolute;
    top:-12px;
    left:20px;
    background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color:#fff;
    border:none;
    padding:8px 16px;
    border-radius:8px;
    font-size:12px;
    font-weight:900;
    cursor:pointer;
    text-transform:uppercase;
    letter-spacing:0.5px;
    transition:all 0.3s ease;
    box-shadow:0 4px 12px rgba(102, 126, 234, 0.4);
    z-index:10;
  }
  .admin-raid-btn:hover{
    transform:translateY(-2px) scale(1.05);
    box-shadow:0 6px 20px rgba(102, 126, 234, 0.6);
  }

  .raids-toggle-btn{
    position:absolute;
    top:-12px;
    right:20px;
    background:var(--gold);
    color:#000;
    border:none;
    padding:6px 12px;
    border-radius:6px;
    font-size:11px;
    font-weight:900;
    cursor:pointer;
    text-transform:uppercase;
    letter-spacing:0.5px;
    transition:all 0.2s;
    z-index:10;
  }

  .raids-toggle-btn:hover{
    transform:scale(1.05);
    box-shadow:0 4px 12px rgba(237,183,35,0.4);
  }

  .raids-list{
    display:flex;
    flex-direction:column;
    gap:16px;
    max-height:500px;
    overflow-y:auto;
  }

  .raid-item{
    background:rgba(0,0,0,0.3);
    border:2px solid rgba(237,183,35,0.3);
    border-radius:12px;
    padding:16px;
    transition:all 0.3s;
    display:flex;
    flex-direction:column;
    gap:12px;
  }

  .raid-item:hover{
    border-color:rgba(237,183,35,0.5);
    transform:translateY(-2px);
  }

  .raid-profile-header{
    display:flex;
    align-items:center;
    gap:12px;
    margin-bottom:12px;
  }

  .raid-profile-emoji{
    width:52px;
    height:52px;
    border-radius:50%;
    background:linear-gradient(135deg, rgba(237,183,35,0.15), rgba(237,183,35,0.05));
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:28px;
    flex-shrink:0;
  }

  .raid-profile-pic{
    width:48px;
    height:48px;
    border-radius:50%;
    object-fit:cover;
  }

  .raid-profile-info{
    flex:1;
  }

  .raid-profile-name{
    font-size:15px;
    font-weight:900;
    color:var(--gold);
    margin-bottom:2px;
  }

  .raid-profile-handle{
    font-size:13px;
    opacity:0.7;
  }

  .raid-preview-image{
    width:100%;
    height:200px;
    object-fit:cover;
    border-radius:8px;
    border:2px solid rgba(237,183,35,0.2);
  }

  .raid-tweet-preview{
    margin:16px 0;
    padding:12px;
    background:rgba(0,0,0,0.2);
    border-radius:8px;
    border:1px solid rgba(237,183,35,0.2);
    min-height:100px;
    display:flex;
    align-items:center;
    justify-content:center;
    transition:all 0.3s ease;
  }

  .raid-tweet-preview:hover{
    background:rgba(237,183,35,0.1);
    border-color:rgba(237,183,35,0.4);
    transform:translateY(-2px);
  }

  .raid-preview-loading{
    color:rgba(255,255,255,0.5);
    font-size:13px;
    text-align:center;
  }

  .raid-preview-error{
    color:rgba(255,255,255,0.3);
    font-size:13px;
    text-align:center;
    font-style:italic;
  }

  /* Twitter embed styling */
  .raid-tweet-preview{
    position: relative;
  }

  .raid-tweet-preview blockquote{
    margin:0 !important;
  }

  .raid-tweet-preview .twitter-tweet{
    margin:0 auto !important;
  }

  .raid-tweet-click-overlay{
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    cursor: pointer;
    z-index: 10;
    background: transparent;
  }

  .raid-item.completed{
    opacity:0.6;
    border-color:rgba(0,255,0,0.3);
  }

  .raid-item.missed{
    opacity:0.4;
    border-color:rgba(255,0,0,0.3);
  }

  .raid-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:12px;
  }

  .raid-timer{
    font-size:12px;
    font-weight:900;
    color:var(--gold);
    background:rgba(237,183,35,0.1);
    padding:4px 8px;
    border-radius:6px;
  }

  .raid-timer.expired{
    color:#ff6b6b;
    background:rgba(255,0,0,0.1);
  }

  .raid-description{
    font-size:14px;
    line-height:1.5;
    margin-bottom:12px;
    opacity:0.9;
  }

  .raid-footer{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:12px;
  }

  .raid-reward{
    font-size:13px;
    font-weight:900;
    color:var(--gold);
  }

  .raid-btn{
    background:linear-gradient(135deg, var(--gold), #d4a127);
    color:#000;
    border:none;
    padding:10px 20px;
    border-radius:8px;
    font-size:14px;
    font-weight:900;
    cursor:pointer;
    text-transform:uppercase;
    letter-spacing:0.5px;
    transition:all 0.3s;
    text-decoration:none;
    display:inline-block;
  }

  .raid-btn:hover{
    transform:scale(1.05);
    box-shadow:0 4px 12px rgba(237,183,35,0.4);
  }

  .raid-btn:disabled{
    opacity:0.5;
    cursor:not-allowed;
    transform:none;
  }

  .raids-empty{
    text-align:center;
    padding:32px;
    opacity:0.7;
  }

  /* Completing state */
  .raid-item.completing{
    border-color:rgba(255,215,0,0.6);
    background:rgba(255,215,0,0.05);
  }

  /* Fade out animation */
  .raid-item.fade-out{
    animation:fadeOutSlide 1s ease-out forwards;
  }

  @keyframes fadeOutSlide{
    0%{
      opacity:1;
      transform:translateY(0) scale(1);
      max-height:500px;
    }
    50%{
      opacity:0.5;
      transform:translateY(-10px) scale(0.98);
    }
    100%{
      opacity:0;
      transform:translateY(-20px) scale(0.95);
      max-height:0;
      margin:0;
      padding:0;
      border:none;
    }
  }

  /* Completing button state */
  .raid-btn.completing{
    background:linear-gradient(135deg, #ffd700, #ffa500);
    pointer-events:none;
    animation:pulse 1.5s ease-in-out infinite;
  }

  @keyframes pulse{
    0%, 100%{
      opacity:1;
    }
    50%{
      opacity:0.7;
    }
  }

  /* ===== GODMODE RAIDS SECTION ===== */

  /* Raid Performance Stats */
  .stat-box {
    padding: 20px;
    background: radial-gradient(circle at top, rgba(237,183,35,0.1), transparent);
    border-radius: 16px;
    border: 2px solid rgba(237,183,35,0.2);
    transition: all 0.3s ease;
    text-align: center;
  }
  .stat-box:hover {
    border-color: rgba(237,183,35,0.5);
    transform: translateY(-4px);
    box-shadow: 0 8px 20px rgba(237,183,35,0.2);
  }
  .stat-icon {
    font-size: 48px;
    margin-bottom: 8px;
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
  }
  .stat-value {
    font-size: 16px;
    font-weight: 800;
    color: var(--gold);
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    margin-bottom: 4px;
    text-align: center;
  }
  .stat-label {
    font-size: 14px;
    opacity: 0.8;
    text-transform: uppercase;
    letter-spacing: 1px;
    text-align: center;
  }

  /* Filter Buttons */
  .raid-filter-btn {
    padding: 16px 32px;
    border-radius: 24px;
    border: 3px solid rgba(237,183,35,0.3);
    background: rgba(0,0,0,0.4);
    color: rgba(255,255,255,0.7);
    font-family: inherit;
    font-size: 18px;
    font-weight: 900;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }
  .raid-filter-btn:hover {
    border-color: rgba(237,183,35,0.6);
    background: rgba(237,183,35,0.1);
    color: var(--gold);
    transform: translateY(-2px);
  }
  .raid-filter-btn.active {
    border-color: var(--gold);
    background: linear-gradient(135deg, rgba(237,183,35,0.3), rgba(237,183,35,0.15));
    color: var(--gold);
    box-shadow: 0 0 30px rgba(237,183,35,0.5), 0 6px 16px rgba(0,0,0,0.4);
    transform: scale(1.05);
  }

  /* Raids Grid */
  .raids-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
    gap: 20px;
    margin-top: 24px;
  }
  .raids-grid.scrollable {
    max-height: 600px;
    overflow-y: auto;
    padding-right: 8px;
    scrollbar-width: thin;
    scrollbar-color: var(--gold) rgba(0,0,0,0.3);
  }
  .raids-grid.scrollable::-webkit-scrollbar {
    width: 8px;
  }
  .raids-grid.scrollable::-webkit-scrollbar-track {
    background: rgba(0,0,0,0.3);
    border-radius: 4px;
  }
  .raids-grid.scrollable::-webkit-scrollbar-thumb {
    background: var(--gold);
    border-radius: 4px;
  }
  .raids-grid.scrollable::-webkit-scrollbar-thumb:hover {
    background: #ffc107;
  }
  @media (max-width: 768px) {
    .raids-grid {
      grid-template-columns: 1fr;
    }
    .raids-grid.scrollable {
      max-height: 500px;
    }
  }

  /* Raid Card - Compact Design */
  .raid-card-compact {
    position: relative;
    background: var(--glass-bg);
    backdrop-filter: var(--glass-blur);
    border-radius: 20px;
    border: 2px solid rgba(237,183,35,0.2);
    padding: 20px;
    transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    cursor: pointer;
    overflow: hidden;
  }
  .raid-card-compact::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 20px;
    padding: 3px;
    background: var(--tri-gradient);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }
  .raid-card-compact:hover::before {
    opacity: 1;
  }
  .raid-card-compact:hover {
    transform: translateY(-8px) scale(1.02);
    box-shadow: 0 12px 40px rgba(0,0,0,0.4);
    border-color: var(--gold);
  }

  /* Urgency States */
  .raid-card-compact.urgency-high {
    border-color: rgba(255, 69, 58, 0.6);
    animation: urgentPulse 2s ease-in-out infinite;
  }
  .raid-card-compact.urgency-medium {
    border-color: rgba(255, 214, 10, 0.6);
  }
  .raid-card-compact.urgency-low {
    border-color: rgba(50, 215, 75, 0.6);
  }
  @keyframes urgentPulse {
    0%, 100% {
      box-shadow: 0 0 0 rgba(255, 69, 58, 0);
      border-color: rgba(255, 69, 58, 0.6);
    }
    50% {
      box-shadow: 0 0 30px rgba(255, 69, 58, 0.4);
      border-color: rgba(255, 69, 58, 1);
    }
  }

  /* Card Header */
  .raid-card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 16px;
    gap: 12px;
  }
  .raid-points-badge {
    background: linear-gradient(135deg, var(--gold), #ffca3a);
    color: #000;
    padding: 8px 16px;
    border-radius: 12px;
    font-size: 20px;
    font-weight: 900;
    box-shadow: 0 4px 12px rgba(237,183,35,0.4);
    white-space: nowrap;
  }
  .raid-timer-badge {
    padding: 6px 12px;
    border-radius: 10px;
    font-size: 14px;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .raid-timer-badge.urgent {
    background: rgba(255, 69, 58, 0.2);
    border: 2px solid rgba(255, 69, 58, 0.6);
    color: #ff453a;
  }
  .raid-timer-badge.medium {
    background: rgba(255, 214, 10, 0.2);
    border: 2px solid rgba(255, 214, 10, 0.6);
    color: #ffd60a;
  }
  .raid-timer-badge.safe {
    background: rgba(50, 215, 75, 0.2);
    border: 2px solid rgba(50, 215, 75, 0.6);
    color: #32d74b;
  }

  /* Tweet Preview Compact */
  .raid-tweet-preview-compact {
    background: rgba(0,0,0,0.4);
    border-radius: 12px;
    padding: 24px;
    margin-bottom: 16px;
    border: 1px solid rgba(255,255,255,0.1);
    transition: all 0.3s ease;
    min-height: 180px;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }
  .raid-tweet-preview-compact:hover {
    background: rgba(0,0,0,0.5);
    border-color: rgba(237,183,35,0.3);
  }
  .raid-tweet-text {
    font-size: 18px;
    line-height: 1.8;
    color: rgba(255,255,255,0.95);
    margin-bottom: 16px;
    display: -webkit-box;
    -webkit-line-clamp: 5;
    -webkit-box-orient: vertical;
    overflow: hidden;
    font-family: 'Nunito', sans-serif;
    font-weight: 500;
  }
  .raid-tweet-thumbnail {
    width: 100%;
    max-height: 250px;
    object-fit: cover;
    border-radius: 8px;
    margin-bottom: 16px;
    border: 1px solid rgba(237,183,35,0.2);
  }
  .raid-tweet-author {
    font-size: 16px;
    color: var(--gold);
    font-weight: 700;
    margin-bottom: 8px;
  }

  /* Card Footer */
  .raid-card-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
  }
  .raid-participants {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
    color: rgba(255,255,255,0.7);
  }
  .raid-participants-count {
    font-weight: 700;
    color: var(--gold);
  }
  .raid-popularity-badge {
    background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
    color: #fff;
    padding: 4px 10px;
    border-radius: 8px;
    font-size: 12px;
    font-weight: 700;
    animation: popBadge 2s ease-in-out infinite;
  }
  @keyframes popBadge {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }

  /* Raid Action Button */
  .raid-action-btn {
    padding: 12px 24px;
    border-radius: 12px;
    border: none;
    font-family: inherit;
    font-size: 14px;
    font-weight: 900;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.3s ease;
    letter-spacing: 0.5px;
    white-space: nowrap;
  }
  .raid-action-btn.join {
    background: linear-gradient(135deg, #5D3FD3, #7c3aed);
    color: #fff;
    box-shadow: 0 4px 0 #3d1f93, 0 4px 12px rgba(93, 63, 211, 0.4);
  }
  .raid-action-btn.join:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 0 #3d1f93, 0 8px 20px rgba(93, 63, 211, 0.6);
  }
  .raid-action-btn.join:active {
    transform: translateY(2px);
    box-shadow: 0 2px 0 #3d1f93, 0 2px 8px rgba(93, 63, 211, 0.4);
  }
  .raid-action-btn.completing {
    background: linear-gradient(135deg, #ffa500, #ff8c00);
    color: #fff;
    box-shadow: 0 4px 0 #cc7000, 0 4px 12px rgba(255, 165, 0, 0.6);
    animation: pulseGlow 2s ease-in-out infinite;
    cursor: wait;
  }
  .raid-action-btn.completed {
    background: linear-gradient(135deg, #32d74b, #2db840);
    color: #000;
    box-shadow: 0 4px 0 #1a8028, 0 4px 12px rgba(50, 215, 75, 0.4);
    cursor: default;
  }
  .raid-action-btn.expired {
    background: rgba(255,255,255,0.1);
    color: rgba(255,255,255,0.4);
    box-shadow: none;
    cursor: not-allowed;
  }
  @keyframes pulseGlow {
    0%, 100% {
      box-shadow: 0 4px 0 #cc7000, 0 4px 12px rgba(255, 165, 0, 0.6);
    }
    50% {
      box-shadow: 0 4px 0 #cc7000, 0 4px 30px rgba(255, 165, 0, 1);
    }
  }

  /* Greyed out completed/expired raids */
  .raid-card-compact.completed-raid,
  .raid-card-compact.expired-raid {
    opacity: 0.5;
    filter: grayscale(0.7);
    pointer-events: none;
  }
  .raid-card-compact.completed-raid:hover,
  .raid-card-compact.expired-raid:hover {
    transform: none;
    box-shadow: none;
  }

  /* Completion animations */
  @keyframes floatUp {
    0% {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
    100% {
      opacity: 0;
      transform: translate(-50%, -200%) scale(1.5);
    }
  }
  @keyframes raidComplete {
    0% {
      transform: scale(1);
      opacity: 1;
    }
    50% {
      transform: scale(1.05);
      box-shadow: 0 0 40px rgba(50, 215, 75, 0.8);
    }
    100% {
      transform: scale(1);
      opacity: 1;
    }
  }

  /* Progress Bar */
  .raid-progress-bar {
    height: 6px;
    background: rgba(0,0,0,0.3);
    border-radius: 10px;
    overflow: hidden;
    margin-bottom: 12px;
  }
  .raid-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--stripe-purple), var(--stripe-yellow), var(--stripe-green));
    border-radius: 10px;
    transition: width 1s ease;
  }

  /* Badge Styles */
  .raid-badge {
    position: absolute;
    top: 12px;
    right: 12px;
    padding: 6px 12px;
    border-radius: 8px;
    font-size: 12px;
    font-weight: 700;
    z-index: 10;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  }
  .raid-badge.expiring-soon {
    background: linear-gradient(135deg, #ff453a, #ff6961);
    color: #fff;
    animation: shakeBadge 0.5s ease-in-out infinite;
  }
  @keyframes shakeBadge {
    0%, 100% { transform: rotate(0deg); }
    25% { transform: rotate(-5deg); }
    75% { transform: rotate(5deg); }
  }

  /* Tweet Modal */
  .raid-tweet-modal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.9);
    /* backdrop-filter removed for performance */
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    animation: fadeIn 0.3s ease;
  }
  .raid-tweet-modal-content {
    background: var(--glass-bg-heavy);
    backdrop-filter: var(--glass-blur-heavy);
    border-radius: 24px;
    border: 4px solid transparent;
    background-image: linear-gradient(var(--glass-bg-heavy), var(--glass-bg-heavy)), var(--tri-gradient);
    background-origin: padding-box, border-box;
    background-clip: padding-box, border-box;
    padding: 32px;
    max-width: 600px;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
    position: relative;
    box-shadow: 0 24px 60px rgba(0,0,0,0.8);
    animation: slideUp 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
  }
  .raid-modal-close {
    position: absolute;
    top: 16px;
    right: 16px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: none;
    background: rgba(255,255,255,0.1);
    color: #fff;
    font-size: 24px;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 10;
  }
  .raid-modal-close:hover {
    background: rgba(255,69,58,0.8);
    transform: rotate(90deg);
  }
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  @keyframes slideUp {
    from {
      opacity: 0;
      transform: translateY(40px) scale(0.9);
    }
    to {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }

  /* Loading State */
  .raids-loading {
    text-align: center;
    padding: 60px 20px;
    color: rgba(255,255,255,0.6);
    font-size: 18px;
  }
  .raids-empty {
    grid-column: 1 / -1;
    text-align: center;
    padding: 80px 40px;
    color: #ffffff;
    font-size: 16px;
    background: rgba(0,0,0,0.4);
    border-radius: 20px;
    border: 2px solid rgba(237,183,35,0.3);
    text-shadow: 0 2px 4px rgba(0,0,0,0.8);
  }

  /* TOP RAIDERS Leaderboard */
  .top-raiders-container {
    margin-bottom: 24px;
  }
  .top-raiders-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 16px;
  }
  .top-raiders-title {
    font-size: 20px;
    font-weight: 900;
    color: var(--gold);
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .top-raiders-scroll {
    max-height: 400px;
    overflow-y: auto;
    padding-right: 8px;
    scrollbar-width: thin;
    scrollbar-color: var(--gold) rgba(0,0,0,0.3);
  }
  .top-raiders-scroll::-webkit-scrollbar {
    width: 8px;
  }
  .top-raiders-scroll::-webkit-scrollbar-track {
    background: rgba(0,0,0,0.3);
    border-radius: 4px;
  }
  .top-raiders-scroll::-webkit-scrollbar-thumb {
    background: var(--gold);
    border-radius: 4px;
  }
  .top-raiders-scroll::-webkit-scrollbar-thumb:hover {
    background: #ffc107;
  }
  .raider-row {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    background: rgba(0,0,0,0.4);
    border-radius: 12px;
    margin-bottom: 8px;
    transition: all 0.2s ease;
    border: 1px solid rgba(237,183,35,0.2);
  }
  .raider-row:hover {
    background: rgba(237,183,35,0.15);
    border-color: rgba(237,183,35,0.4);
    transform: translateX(4px);
  }
  .raider-row.top-3 {
    border-color: rgba(237,183,35,0.5);
    background: linear-gradient(90deg, rgba(237,183,35,0.15), transparent);
  }
  .raider-row.current-user {
    border-color: var(--gold);
    background: linear-gradient(90deg, rgba(237,183,35,0.25), rgba(237,183,35,0.1));
    box-shadow: 0 0 20px rgba(237,183,35,0.2);
  }
  .raider-rank {
    min-width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 900;
    font-size: 16px;
    border-radius: 50%;
    background: rgba(0,0,0,0.5);
    color: rgba(255,255,255,0.7);
  }
  .raider-rank.gold {
    background: linear-gradient(135deg, #FFD700, #FFA500);
    color: #000;
    box-shadow: 0 0 15px rgba(255,215,0,0.5);
  }
  .raider-rank.silver {
    background: linear-gradient(135deg, #C0C0C0, #A8A8A8);
    color: #000;
    box-shadow: 0 0 10px rgba(192,192,192,0.5);
  }
  .raider-rank.bronze {
    background: linear-gradient(135deg, #CD7F32, #B87333);
    color: #000;
    box-shadow: 0 0 10px rgba(205,127,50,0.5);
  }
  .raider-avatar {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid rgba(237,183,35,0.4);
    background: rgba(237,183,35,0.1);
  }
  .raider-info {
    flex: 1;
    min-width: 0;
  }
  .raider-name {
    font-weight: 700;
    font-size: 15px;
    color: #fff;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .raider-wallet {
    font-size: 12px;
    color: rgba(255,255,255,0.5);
    font-family: monospace;
  }
  .raider-stats {
    display: flex;
    gap: 16px;
    align-items: center;
  }
  .raider-stat {
    text-align: center;
  }
  .raider-stat-value {
    font-weight: 900;
    font-size: 16px;
    color: var(--gold);
  }
  .raider-stat-label {
    font-size: 10px;
    color: rgba(255,255,255,0.5);
    text-transform: uppercase;
  }
  .raiders-loading, .raiders-empty {
    text-align: center;
    padding: 40px;
    color: rgba(255,255,255,0.6);
    font-size: 15px;
  }
  @media (max-width: 600px) {
    .raider-stats {
      gap: 12px;
    }
    .raider-stat-value {
      font-size: 14px;
    }
    .raider-name {
      font-size: 14px;
    }
    .raider-wallet {
      display: none;
    }
  }

  /* ===== END GODMODE RAIDS SECTION ===== */

  /* Image error handling */
  .raid-profile-pic{
    background:rgba(237,183,35,0.1);
  }

  .raid-preview-image{
    background:rgba(0,0,0,0.3);
  }

  @media(max-width:768px){
    .honey-card{
      padding:16px;
    }
    .price-stats-grid{
      grid-template-columns:1fr;
    }
    .points-hero-value{
      font-size:42px;
    }
    .points-breakdown-item{
      flex-direction:row;
      padding:12px;
    }
    .points-breakdown-icon{
      font-size:28px;
    }
    .points-breakdown-label{
      font-size:12px;
    }
    .points-breakdown-value{
      font-size:20px;
    }
    .chart-container iframe{
      height:400px !important;
    }
  }

  /* ===== COSMETICS STORE STYLES ===== */
  .store-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.92);
    /* backdrop-filter removed for performance */
    z-index: 10001;
    justify-content: center;
    align-items: center;
  }

  .store-modal.active {
    display: flex;
    animation: modalFadeIn 0.4s cubic-bezier(0.16, 1, 0.3, 1);
  }

  @keyframes modalFadeIn {
    from {
      opacity: 0;
      backdrop-filter: blur(0px);
    }
    to {
      opacity: 1;
      /* backdrop-filter removed for performance */
    }
  }

  .store-modal-content {
    background: linear-gradient(135deg, #1a1a2e, #16213e);
    border-radius: 28px;
    border: 5px solid;
    border-image: linear-gradient(135deg, #680cd9, #ffae00, #07ae08) 1;
    max-width: 1100px;
    width: 92%;
    max-height: 92vh;
    overflow: hidden;
    box-shadow: 0 30px 100px rgba(237, 183, 35, 0.4),
                0 0 80px rgba(104, 12, 217, 0.3);
    animation: modalSlideIn 0.6s cubic-bezier(0.16, 1, 0.3, 1);
  }

  @keyframes modalSlideIn {
    0% {
      transform: translateY(-40px) scale(0.95);
      opacity: 0;
    }
    100% {
      transform: translateY(0) scale(1);
      opacity: 1;
    }
  }

  .store-header {
    background: linear-gradient(135deg, rgba(104, 12, 217, 0.4), rgba(237, 183, 35, 0.4), rgba(7, 174, 8, 0.4));
    padding: 28px 36px;
    border-bottom: 4px solid rgba(237, 183, 35, 0.6);
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: relative;
    overflow: hidden;
  }

  .store-header::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255,255,255,0.05), transparent);
    animation: shimmer 3s infinite;
  }

  @keyframes shimmer {
    0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
    100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
  }

  .store-title-section {
    position: relative;
    z-index: 1;
  }

  .store-title {
    font-size: 36px;
    font-weight: 900;
    color: #ffae00;
    text-shadow: 0 3px 12px rgba(237, 183, 35, 0.8),
                 0 0 30px rgba(237, 183, 35, 0.5);
    margin-bottom: 4px;
  }

  .store-subtitle {
    font-size: 14px;
    color: #aaa;
    font-weight: 400;
  }

  .store-balance-container {
    position: relative;
    z-index: 1;
    display: flex;
    gap: 16px;
    align-items: center;
  }

  .store-balance {
    font-size: 28px;
    font-weight: 900;
    color: #ffae00;
    background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,20,30,0.9));
    padding: 14px 24px;
    border-radius: 16px;
    border: 3px solid #ffae00;
    box-shadow: 0 0 20px rgba(255, 174, 0, 0.4),
                inset 0 0 20px rgba(255, 174, 0, 0.1);
    animation: pulseGlow 2s ease-in-out infinite;
  }

  @keyframes pulseGlow {
    0%, 100% { box-shadow: 0 0 20px rgba(255, 174, 0, 0.4), inset 0 0 20px rgba(255, 174, 0, 0.1); }
    50% { box-shadow: 0 0 30px rgba(255, 174, 0, 0.6), inset 0 0 30px rgba(255, 174, 0, 0.2); }
  }

  .store-balance .hp-amount {
    font-size: 32px;
    text-shadow: 0 2px 10px rgba(255, 174, 0, 0.8);
  }

  .store-close-btn {
    background: rgba(255, 0, 0, 0.2);
    border: 3px solid #ff4444;
    color: #ff4444;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    font-size: 28px;
    font-weight: 900;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    z-index: 1;
  }

  .store-close-btn:hover {
    background: rgba(255, 0, 0, 0.5);
    transform: scale(1.15) rotate(90deg);
    box-shadow: 0 0 20px rgba(255, 68, 68, 0.6);
  }

  .store-tabs {
    display: flex;
    gap: 12px;
    padding: 20px 36px;
    background: rgba(0,0,0,0.4);
    border-bottom: 3px solid rgba(237, 183, 35, 0.3);
  }

  .store-tab {
    padding: 14px 28px;
    font-size: 18px;
    font-weight: 900;
    background: rgba(0,0,0,0.6);
    border: 3px solid rgba(237, 183, 35, 0.3);
    border-radius: 14px;
    color: #888;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(.18,.9,.2,1);
    position: relative;
    overflow: hidden;
  }

  .store-tab::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(237, 183, 35, 0.3);
    transform: translate(-50%, -50%);
    transition: width 0.4s, height 0.4s;
  }

  .store-tab:hover::before {
    width: 200%;
    height: 200%;
  }

  .store-tab:hover {
    border-color: rgba(237, 183, 35, 0.7);
    color: #ddd;
    transform: translateY(-2px);
  }

  .store-tab.active {
    background: linear-gradient(135deg, #ffae00, #edb723);
    color: #000;
    border-color: #ffae00;
    box-shadow: 0 4px 15px rgba(255, 174, 0, 0.4);
  }

  .store-tab span {
    position: relative;
    z-index: 1;
  }

  .store-body {
    padding: 36px;
    overflow-y: auto;
    max-height: calc(92vh - 280px);
  }

  .store-body::-webkit-scrollbar {
    width: 12px;
  }

  .store-body::-webkit-scrollbar-track {
    background: rgba(0,0,0,0.3);
    border-radius: 10px;
  }

  .store-body::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #680cd9, #ffae00);
    border-radius: 10px;
  }

  .store-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 24px;
    justify-items: center;
  }

  /* When store-grid contains rarity sections, use 3-column layout */
  #storeRingsGrid,
  #storeBannersGrid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 24px;
    align-items: start;
  }

  /* Make rarity sections fill their column */
  #storeRingsGrid > .rarity-section,
  #storeBannersGrid > .rarity-section {
    width: 100%;
  }

  /* On smaller screens, stack columns */
  @media (max-width: 1200px) {
    #storeRingsGrid,
    #storeBannersGrid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  @media (max-width: 768px) {
    #storeRingsGrid,
    #storeBannersGrid {
      grid-template-columns: 1fr;
    }
  }

  .store-item {
    background: linear-gradient(135deg, rgba(20,20,30,0.8), rgba(10,10,20,0.9));
    border: 4px solid;
    border-radius: 20px;
    padding: 20px;
    transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
    position: relative;
    overflow: hidden;
    width: 100%;
    max-width: 320px;
    opacity: 0;
    animation: storeItemFadeIn 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  @keyframes storeItemFadeIn {
    0% {
      opacity: 0;
      transform: translateY(20px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .store-item:nth-child(1) { animation-delay: 0.05s; }
  .store-item:nth-child(2) { animation-delay: 0.1s; }
  .store-item:nth-child(3) { animation-delay: 0.15s; }
  .store-item:nth-child(4) { animation-delay: 0.2s; }
  .store-item:nth-child(5) { animation-delay: 0.25s; }
  .store-item:nth-child(6) { animation-delay: 0.3s; }

  .store-item.common { border-color: #22c55e; }
  .store-item.rare { border-color: #3b82f6; }
  .store-item.epic { border-color: #a855f7; }
  .store-item.legendary {
    border-color: #f59e0b;
    background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(239, 68, 68, 0.1));
    animation: legendaryPulse 3s ease-in-out infinite, storeItemFadeIn 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  .store-item.bearableguy123 {
    border-color: #ff0000;
    background: linear-gradient(135deg, rgba(255, 0, 0, 0.2), rgba(139, 0, 0, 0.2));
    animation: bearableguy123Eclipse 3s ease-in-out infinite, storeItemFadeIn 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  @keyframes legendaryPulse {
    0%, 100% {
      box-shadow: 0 4px 20px rgba(245, 158, 11, 0.4), 0 0 30px rgba(239, 68, 68, 0.2);
    }
    50% {
      box-shadow: 0 8px 35px rgba(245, 158, 11, 0.8), 0 0 50px rgba(239, 68, 68, 0.5);
    }
  }

  @keyframes bearableguy123Eclipse {
    0%, 100% {
      box-shadow: 0 6px 30px rgba(255, 0, 0, 0.6),
                  0 0 50px rgba(139, 0, 0, 0.4),
                  0 0 80px rgba(255, 0, 0, 0.3);
      border-color: #ff0000;
    }
    50% {
      box-shadow: 0 10px 50px rgba(255, 0, 0, 1),
                  0 0 80px rgba(139, 0, 0, 0.8),
                  0 0 120px rgba(255, 0, 0, 0.6),
                  0 0 160px rgba(139, 0, 0, 0.4);
      border-color: #ff4444;
    }
  }

  .store-item::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(255,255,255,0.1), transparent 70%);
    opacity: 0;
    transition: opacity 0.4s;
  }

  .store-item:hover::before {
    opacity: 1;
    animation: rotateBg 3s linear infinite;
  }

  @keyframes rotateBg {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  .store-item:hover {
    transform: translateY(-6px) scale(1.02);
  }

  .store-item.common:hover {
    box-shadow: 0 12px 40px rgba(34, 197, 94, 0.4);
  }

  .store-item.rare:hover {
    box-shadow: 0 12px 40px rgba(59, 130, 246, 0.5);
  }

  .store-item.epic:hover {
    box-shadow: 0 12px 40px rgba(168, 85, 247, 0.6);
  }

  .store-item.legendary:hover {
    box-shadow: 0 16px 50px rgba(245, 158, 11, 0.7),
                0 0 60px rgba(239, 68, 68, 0.5);
    transform: translateY(-8px) scale(1.03);
  }

  .store-item.bearableguy123:hover {
    box-shadow: 0 20px 60px rgba(255, 0, 0, 0.9),
                0 0 80px rgba(139, 0, 0, 0.8),
                0 0 120px rgba(255, 0, 0, 0.6);
    transform: translateY(-10px) scale(1.05);
  }

  .store-item-preview {
    width: 100%;
    height: 140px;
    background: rgba(0,0,0,0.7);
    border-radius: 16px;
    margin-bottom: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
  }

  .store-item-badge {
    position: absolute;
    top: 10px;
    right: 10px;
    padding: 6px 12px;
    border-radius: 10px;
    font-size: 11px;
    font-weight: 900;
    text-transform: uppercase;
    box-shadow: 0 3px 10px rgba(0,0,0,0.4);
    z-index: 2;
    white-space: nowrap;
    max-width: 90%;
  }

  .rarity-common {
    background: linear-gradient(135deg, #22c55e, #16a34a);
    color: #fff;
  }

  .rarity-rare {
    background: linear-gradient(135deg, #3b82f6, #2563eb);
    color: #fff;
  }

  .rarity-epic {
    background: linear-gradient(135deg, #a855f7, #9333ea);
    color: #fff;
    animation: epicGlow 2s ease-in-out infinite;
  }

  @keyframes epicGlow {
    0%, 100% { box-shadow: 0 3px 10px rgba(168, 85, 247, 0.4); }
    50% { box-shadow: 0 3px 20px rgba(168, 85, 247, 0.8); }
  }

  .rarity-legendary {
    background: linear-gradient(135deg, #f59e0b, #ef4444);
    color: #fff;
    animation: legendaryShine 2s linear infinite;
    position: relative;
    overflow: hidden;
  }

  .rarity-legendary::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255,255,255,0.6), transparent);
    animation: shineMove 2s infinite;
  }

  .rarity-bearableguy123 {
    background: linear-gradient(135deg, #ff0000, #8b0000);
    color: #fff;
    animation: bearableguy123Shine 1.5s linear infinite;
    position: relative;
    overflow: hidden;
  }

  .rarity-bearableguy123::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255,255,255,0.8), transparent);
    animation: shineMove 1.5s infinite;
  }

  @keyframes shineMove {
    0% { transform: translateX(-100%) rotate(45deg); }
    100% { transform: translateX(100%) rotate(45deg); }
  }

  @keyframes legendaryShine {
    0%, 100% { box-shadow: 0 3px 15px rgba(245, 158, 11, 0.6), 0 0 25px rgba(239, 68, 68, 0.4); }
    50% { box-shadow: 0 3px 25px rgba(245, 158, 11, 1), 0 0 40px rgba(239, 68, 68, 0.7); }
  }

  @keyframes bearableguy123Shine {
    0%, 100% {
      box-shadow: 0 4px 20px rgba(255, 0, 0, 0.8),
                  0 0 35px rgba(139, 0, 0, 0.6),
                  0 0 50px rgba(255, 0, 0, 0.4);
    }
    50% {
      box-shadow: 0 4px 30px rgba(255, 0, 0, 1),
                  0 0 50px rgba(139, 0, 0, 1),
                  0 0 70px rgba(255, 0, 0, 0.8);
    }
  }

  .store-item-name {
    font-size: 20px;
    font-weight: 900;
    margin-bottom: 10px;
  }

  .store-item.common .store-item-name { color: #22c55e; }
  .store-item.rare .store-item-name { color: #3b82f6; }
  .store-item.epic .store-item-name { color: #a855f7; }
  .store-item.legendary .store-item-name {
    background: linear-gradient(135deg, #f59e0b, #ef4444);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .store-item.bearableguy123 .store-item-name {
    background: linear-gradient(135deg, #ff0000, #ff4444, #ff0000);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: redPulse 2s ease-in-out infinite;
  }

  @keyframes redPulse {
    0%, 100% { filter: drop-shadow(0 0 5px rgba(255, 0, 0, 0.6)); }
    50% { filter: drop-shadow(0 0 15px rgba(255, 0, 0, 1)); }
  }

  .store-item-description {
    font-size: 14px;
    color: #aaa;
    margin-bottom: 16px;
    min-height: 42px;
    line-height: 1.4;
  }

  .store-item-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
  }

  .store-item-price {
    font-size: 24px;
    font-weight: 900;
    color: #ffae00;
    text-shadow: 0 2px 8px rgba(255, 174, 0, 0.6);
  }

  .store-item-btn {
    padding: 10px 20px;
    font-size: 16px;
    font-weight: 900;
    background: linear-gradient(135deg, #ffae00, #edb723);
    color: #000;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    box-shadow: 0 4px 12px rgba(237, 183, 35, 0.4);
    font-family: inherit;
    position: relative;
    overflow: hidden;
  }

  .store-item-btn::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.4);
    transform: translate(-50%, -50%);
    transition: width 0.5s cubic-bezier(0.16, 1, 0.3, 1), height 0.5s cubic-bezier(0.16, 1, 0.3, 1);
  }

  .store-item-btn:hover::before {
    width: 300%;
    height: 300%;
  }

  .store-item-btn:hover {
    background: linear-gradient(135deg, #ffc422, #ffae00);
    transform: scale(1.05) translateY(-2px);
    box-shadow: 0 8px 24px rgba(237, 183, 35, 0.6);
  }

  .store-item-btn:active {
    animation: btnBounce 0.5s cubic-bezier(0.16, 1, 0.3, 1);
  }

  @keyframes btnBounce {
    0% { transform: scale(1.05) translateY(-2px); }
    40% { transform: scale(0.92); }
    60% { transform: scale(1.08); }
    80% { transform: scale(0.98); }
    100% { transform: scale(1); }
  }

  /* Owned button state */
  .store-item-btn.owned,
  .store-item-btn:disabled {
    background: linear-gradient(135deg, #6b7280, #9ca3af);
    color: #fff;
    cursor: not-allowed;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  }

  .store-item-btn.owned:hover,
  .store-item-btn:disabled:hover {
    transform: none;
    background: linear-gradient(135deg, #6b7280, #9ca3af);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  }

  .store-item-btn.owned::before,
  .store-item-btn:disabled::before {
    display: none;
  }

  /* Owned badge */
  .store-item-owned-badge {
    position: absolute;
    top: 10px;
    left: 10px;
    padding: 6px 12px;
    background: linear-gradient(135deg, #10b981, #059669);
    color: #fff;
    border-radius: 10px;
    font-size: 13px;
    font-weight: 900;
    text-transform: uppercase;
    box-shadow: 0 3px 10px rgba(16, 185, 129, 0.5);
    z-index: 3;
    animation: ownedPulse 2s ease-in-out infinite;
  }

  @keyframes ownedPulse {
    0%, 100% { box-shadow: 0 3px 10px rgba(16, 185, 129, 0.5); }
    50% { box-shadow: 0 3px 20px rgba(16, 185, 129, 0.8); }
  }

  /* Equipped badge */
  .store-item-equipped-badge {
    position: absolute;
    top: 10px;
    left: 10px;
    padding: 6px 12px;
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
    color: #000;
    border-radius: 10px;
    font-size: 13px;
    font-weight: 900;
    text-transform: uppercase;
    box-shadow: 0 3px 10px rgba(251, 191, 36, 0.5);
    z-index: 3;
    animation: equippedGlow 2s ease-in-out infinite;
  }

  @keyframes equippedGlow {
    0%, 100% { box-shadow: 0 3px 10px rgba(251, 191, 36, 0.5); }
    50% { box-shadow: 0 3px 20px rgba(251, 191, 36, 0.9); }
  }

  /* Equipped button state */
  .store-item-btn.equipped {
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
    color: #000;
    box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
  }

  .store-item-btn.equipped:hover {
    background: linear-gradient(135deg, #fcd34d, #fbbf24);
    transform: scale(1.05) translateY(-2px);
    box-shadow: 0 8px 24px rgba(251, 191, 36, 0.6);
  }

  .owned-badge {
    background: linear-gradient(135deg, #22c55e, #16a34a);
    color: #fff;
    padding: 8px 16px;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 900;
    box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
    animation: ownedBadgeFadeIn 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  @keyframes ownedBadgeFadeIn {
    0% {
      opacity: 0;
      transform: scale(0.8);
    }
    100% {
      opacity: 1;
      transform: scale(1);
    }
  }

  /* Ring preview styles */
  .ring-demo {
    width: 130px;
    height: 130px;
    border-radius: 50%;
    position: relative;
    background: transparent;
  }

  .ring-border {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90px;
    height: 90px;
    border-radius: 50%;
  }

  .ring-border.purple { border: 6px solid #680cd9; }
  .ring-border.green { border: 6px solid #07ae08; }
  .ring-border.yellow { border: 6px solid #ffae00; }
  .ring-border.red { border: 6px solid #ef4444; }

  .ring-border.bearableguy123 {
    border: none;
    background: radial-gradient(circle, transparent 40%, rgba(255, 0, 0, 0.3) 60%, transparent 80%);
    animation: eclipseGlow 2s ease-in-out infinite;
  }
  .ring-border.bearableguy123::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 50%;
    border: 6px solid #ff0000;
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.8),
                0 0 40px rgba(139, 0, 0, 0.6);
    animation: eclipseGlow 2s ease-in-out infinite;
  }
  .ring-border.bearableguy123::after {
    content: '';
    position: absolute;
    inset: 6px;
    background: rgba(0,0,0,0.7);
    border-radius: 50%;
    z-index: 1;
  }
  @keyframes eclipseGlow {
    0%, 100% {
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.6),
                  0 0 40px rgba(139, 0, 0, 0.4);
    }
    50% {
      box-shadow: 0 0 20px rgba(255, 0, 0, 1),
                  0 0 40px rgba(139, 0, 0, 0.8);
    }
  }

  .ring-border.tricolor {
    background: conic-gradient(
      #680cd9 0deg 120deg,
      #ffae00 120deg 240deg,
      #07ae08 240deg 360deg
    );
  }

  .ring-border.tricolor::before {
    content: '';
    position: absolute;
    inset: 6px;
    background: rgba(0,0,0,0.7);
    border-radius: 50%;
  }

  .ring-border.animated {
    background: conic-gradient(
      #680cd9 0deg 120deg,
      #ffae00 120deg 240deg,
      #07ae08 240deg 360deg
    );
    animation: spinRing 2s linear infinite;
    transform-origin: center;
  }

  .ring-border.animated::before {
    content: '';
    position: absolute;
    inset: 6px;
    background: rgba(0,0,0,0.7);
    border-radius: 50%;
  }

  @keyframes spinRing {
    from { transform: translate(-50%, -50%) rotate(0deg); }
    to { transform: translate(-50%, -50%) rotate(360deg); }
  }

  .ring-demo img {
    width: 90px;
    height: 90px;
    border-radius: 50%;
    object-fit: cover;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1;
  }

  @keyframes spinRingImage {
    from { transform: translate(-50%, -50%) rotate(0deg); }
    to { transform: translate(-50%, -50%) rotate(360deg); }
  }

  .ring-glow-wrapper {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100px;
    height: 100px;
    border-radius: 50%;
    z-index: 0;
  }

  .ring-glow-wrapper.ouroboros {
    box-shadow: 0 0 20px rgba(7, 174, 8, 0.6), 0 0 40px rgba(7, 174, 8, 0.4);
    animation: glowPulse-ouroboros 2s ease-in-out infinite;
  }

  .ring-glow-wrapper.waves {
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.6), 0 0 40px rgba(255, 255, 255, 0.4);
    animation: glowPulse-waves 2s ease-in-out infinite;
  }

  .ring-glow-wrapper.castle {
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.6), 0 0 40px rgba(255, 255, 255, 0.4);
    animation: glowPulse-castle 2s ease-in-out infinite;
  }

  @keyframes glowPulse-ouroboros {
    0%, 100% {
      box-shadow: 0 0 20px rgba(7, 174, 8, 0.6), 0 0 40px rgba(7, 174, 8, 0.4);
    }
    50% {
      box-shadow: 0 0 20px rgba(7, 174, 8, 1), 0 0 40px rgba(7, 174, 8, 0.8);
    }
  }

  @keyframes glowPulse-waves {
    0%, 100% {
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.6), 0 0 40px rgba(255, 255, 255, 0.4);
    }
    50% {
      box-shadow: 0 0 20px rgba(255, 255, 255, 1), 0 0 40px rgba(255, 255, 255, 0.8);
    }
  }

  @keyframes glowPulse-castle {
    0%, 100% {
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.6), 0 0 40px rgba(255, 255, 255, 0.4);
    }
    50% {
      box-shadow: 0 0 20px rgba(255, 255, 255, 1), 0 0 40px rgba(255, 255, 255, 0.8);
    }
  }

  /* Image-based ring sizes for desktop - UPDATED */
  .store-item-preview img.image-ring-ouroboros {
    width: 140px !important;
    height: 140px !important;
    max-width: 140px !important;
    max-height: 140px !important;
  }

  .store-item-preview img.image-ring-castle,
  .store-item-preview img.image-ring-castle-static {
    width: 145px !important;
    height: 145px !important;
    max-width: 145px !important;
    max-height: 145px !important;
  }

  .store-item-preview img.image-ring-waves,
  .store-item-preview img.image-ring-waves-static {
    width: 130px !important;
    height: 130px !important;
    max-width: 130px !important;
    max-height: 130px !important;
  }

  /* Color rings - 20% bigger than default */
  .store-item-preview img.purple,
  .store-item-preview img.green,
  .store-item-preview img.yellow,
  .store-item-preview img.bg123-red,
  .ring-demo img.purple,
  .ring-demo img.green,
  .ring-demo img.yellow,
  .ring-demo img.bg123-red {
    width: 174px !important;
    height: 174px !important;
    max-width: 174px !important;
    max-height: 174px !important;
  }

  /* Banner demo */
  .banner-demo {
    width: 100%;
    height: 100%;
    border-radius: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
  }

  .banner-profile-preview {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    overflow: hidden;
    border: 4px solid rgba(255,255,255,0.2);
    box-shadow: 0 4px 16px rgba(0,0,0,0.5);
    position: relative;
    z-index: 3;
  }

  .banner-profile-preview img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  /* Celebration overlay */
  .celebration-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 20000;
    pointer-events: none;
  }

  .celebration-overlay.active {
    display: block;
  }

  .celebration-content {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    pointer-events: none;
  }

  .celebration-icon {
    font-size: 120px;
    animation: celebrationBounce 1.5s cubic-bezier(0.16, 1, 0.3, 1),
               iconFadeOut 0.8s cubic-bezier(0.16, 1, 0.3, 1) 4s forwards;
    filter: drop-shadow(0 0 20px rgba(255, 174, 0, 0.6));
  }

  @keyframes celebrationBounce {
    0% {
      transform: scale(0) rotate(-30deg);
      opacity: 0;
      filter: blur(10px) drop-shadow(0 0 20px rgba(255, 174, 0, 0.6));
    }
    50% {
      transform: scale(1.2) rotate(10deg);
      opacity: 1;
      filter: blur(0px) drop-shadow(0 0 30px rgba(255, 174, 0, 0.8));
    }
    70% {
      transform: scale(0.9) rotate(-5deg);
    }
    85% {
      transform: scale(1.05) rotate(2deg);
    }
    100% {
      transform: scale(1) rotate(0deg);
      opacity: 1;
      filter: blur(0px) drop-shadow(0 0 20px rgba(255, 174, 0, 0.6));
    }
  }

  @keyframes iconFadeOut {
    0% {
      opacity: 1;
      transform: scale(1) rotate(0deg);
      filter: blur(0px) drop-shadow(0 0 20px rgba(255, 174, 0, 0.6));
    }
    100% {
      opacity: 0;
      transform: scale(0.8) rotate(15deg);
      filter: blur(10px) drop-shadow(0 0 0px rgba(255, 174, 0, 0));
    }
  }

  .celebration-text {
    font-size: 48px;
    font-weight: 900;
    margin-top: 20px;
    text-shadow: 0 4px 20px rgba(0,0,0,0.8);
    animation: textSlideUp 1.2s cubic-bezier(0.16, 1, 0.3, 1) 0.3s backwards,
               textFadeOut 0.8s cubic-bezier(0.16, 1, 0.3, 1) 4s forwards;
  }

  @keyframes textSlideUp {
    0% {
      transform: translateY(20px);
      opacity: 0;
      filter: blur(5px);
    }
    100% {
      transform: translateY(0);
      opacity: 1;
      filter: blur(0px);
    }
  }

  @keyframes textFadeOut {
    0% {
      opacity: 1;
      filter: blur(0px);
    }
    100% {
      opacity: 0;
      filter: blur(10px);
      transform: translateY(-10px);
    }
  }

  .celebration-subtext {
    font-size: 24px;
    margin-top: 10px;
    opacity: 0.9;
    animation: textSlideUp 1.2s cubic-bezier(0.16, 1, 0.3, 1) 0.4s backwards,
               textFadeOut 0.8s cubic-bezier(0.16, 1, 0.3, 1) 4s forwards;
  }

  .confetti {
    position: absolute;
    width: 10px;
    height: 10px;
    background: #ffae00;
    border-radius: 2px;
    animation: confettiFall 3.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    box-shadow: 0 0 10px rgba(255, 174, 0, 0.6);
    pointer-events: none;
  }

  @keyframes confettiFall {
    0% {
      transform: translateY(0) translateX(0) rotate(0deg) scale(1);
      opacity: 1;
    }
    100% {
      transform: translateY(100vh) translateX(var(--drift, 0)) rotate(1080deg) scale(0.5);
      opacity: 0;
    }
  }

  /* Rarity Section Styles */
  .rarity-section {
    margin-bottom: 48px;
    position: relative;
    background: linear-gradient(135deg, rgba(20,20,30,0.6), rgba(10,10,20,0.8));
    border-radius: 24px;
    padding: 24px;
    border: 4px solid;
  }

  .common-section {
    border-color: #22c55e;
    box-shadow: 0 4px 20px rgba(34, 197, 94, 0.2);
  }

  .rare-section {
    border-color: #3b82f6;
    box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
  }

  .epic-section {
    border-color: #a855f7;
    box-shadow: 0 6px 30px rgba(168, 85, 247, 0.4);
  }

  .legendary-section {
    border-color: #f59e0b;
    box-shadow: 0 8px 40px rgba(245, 158, 11, 0.5),
                0 0 60px rgba(239, 68, 68, 0.3);
  }

  .bearableguy123-section {
    border-color: #ff0000;
    box-shadow: 0 10px 50px rgba(255, 0, 0, 0.7),
                0 0 80px rgba(139, 0, 0, 0.5),
                0 0 120px rgba(255, 0, 0, 0.3);
    animation: sectionEclipse 3s ease-in-out infinite;
  }

  @keyframes sectionEclipse {
    0%, 100% {
      box-shadow: 0 10px 50px rgba(255, 0, 0, 0.7),
                  0 0 80px rgba(139, 0, 0, 0.5),
                  0 0 120px rgba(255, 0, 0, 0.3);
    }
    50% {
      box-shadow: 0 15px 70px rgba(255, 0, 0, 1),
                  0 0 120px rgba(139, 0, 0, 0.8),
                  0 0 180px rgba(255, 0, 0, 0.6);
    }
  }

  .rarity-header {
    font-size: 28px;
    font-weight: 900;
    padding: 20px 32px;
    border-radius: 16px;
    margin-bottom: 24px;
    text-align: center;
    position: relative;
    overflow: hidden;
    border: 4px solid;
    text-shadow: 0 2px 10px rgba(0,0,0,0.5);
    z-index: 1;
  }

  .rarity-header::before,
  .rarity-header::after {
    z-index: -1;
  }

  .rarity-header > * {
    position: relative;
    z-index: 2;
  }

  .common-header {
    background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(22, 163, 74, 0.2));
    border-color: #22c55e;
    color: #22c55e;
  }

  .rare-header {
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.2));
    border-color: #3b82f6;
    color: #3b82f6;
    box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
  }

  .epic-header {
    background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(147, 51, 234, 0.2));
    border-color: #a855f7;
    color: #a855f7;
    animation: epicHeaderGlow 2s ease-in-out infinite;
  }

  @keyframes epicHeaderGlow {
    0%, 100% {
      box-shadow: 0 4px 20px rgba(168, 85, 247, 0.4), 0 0 30px rgba(168, 85, 247, 0.2);
    }
    50% {
      box-shadow: 0 6px 30px rgba(168, 85, 247, 0.7), 0 0 50px rgba(168, 85, 247, 0.4);
    }
  }

  .legendary-header {
    background: linear-gradient(135deg, rgba(245, 158, 11, 0.3), rgba(239, 68, 68, 0.3));
    border-color: #f59e0b;
    color: #f59e0b;
    animation: legendaryHeaderGlow 2s ease-in-out infinite;
    position: relative;
  }

  .legendary-header::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(245, 158, 11, 0.3), transparent);
    animation: shineMove 3s infinite;
  }

  @keyframes legendaryHeaderGlow {
    0%, 100% {
      box-shadow: 0 6px 30px rgba(245, 158, 11, 0.5), 0 0 40px rgba(239, 68, 68, 0.3);
    }
    50% {
      box-shadow: 0 8px 50px rgba(245, 158, 11, 0.8), 0 0 70px rgba(239, 68, 68, 0.6);
    }
  }

  .bearableguy123-header {
    background: linear-gradient(135deg, rgba(255, 0, 0, 0.4), rgba(139, 0, 0, 0.4));
    border-color: #ff0000;
    color: #ff0000;
    animation: bearableguy123HeaderGlow 2s ease-in-out infinite;
    position: relative;
    font-size: 32px;
  }

  .bearableguy123-header::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(255, 0, 0, 0.3), transparent 70%);
    animation: rotateBg 4s linear infinite;
  }

  .bearableguy123-header::after {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255, 0, 0, 0.5), transparent);
    animation: shineMove 2s infinite;
  }

  @keyframes bearableguy123HeaderGlow {
    0%, 100% {
      box-shadow: 0 8px 40px rgba(255, 0, 0, 0.7),
                  0 0 60px rgba(139, 0, 0, 0.5),
                  0 0 100px rgba(255, 0, 0, 0.3);
      border-color: #ff0000;
    }
    50% {
      box-shadow: 0 12px 60px rgba(255, 0, 0, 1),
                  0 0 100px rgba(139, 0, 0, 0.9),
                  0 0 150px rgba(255, 0, 0, 0.7),
                  0 0 200px rgba(139, 0, 0, 0.5);
      border-color: #ff4444;
    }
  }

  /* Shake animations */
  @keyframes shake {
    0%, 100% {
      transform: translateX(0) rotate(0deg);
    }
    10% {
      transform: translateX(-6px) rotate(-1deg);
    }
    20% {
      transform: translateX(6px) rotate(1deg);
    }
    30% {
      transform: translateX(-6px) rotate(-1deg);
    }
    40% {
      transform: translateX(6px) rotate(1deg);
    }
    50% {
      transform: translateX(-4px) rotate(-0.5deg);
    }
    60% {
      transform: translateX(4px) rotate(0.5deg);
    }
    70% {
      transform: translateX(-2px) rotate(-0.25deg);
    }
    80% {
      transform: translateX(2px) rotate(0.25deg);
    }
    90% {
      transform: translateX(-1px) rotate(0deg);
    }
  }

  @keyframes shake-medium {
    0%, 100% {
      transform: translate(0, 0) rotate(0deg);
    }
    10% {
      transform: translate(-10px, -5px) rotate(-2deg);
    }
    20% {
      transform: translate(10px, 5px) rotate(2deg);
    }
    30% {
      transform: translate(-10px, 3px) rotate(-1.5deg);
    }
    40% {
      transform: translate(10px, -3px) rotate(1.5deg);
    }
    50% {
      transform: translate(-8px, 2px) rotate(-1deg);
    }
    60% {
      transform: translate(8px, -2px) rotate(1deg);
    }
    70% {
      transform: translate(-5px, 1px) rotate(-0.5deg);
    }
    80% {
      transform: translate(5px, -1px) rotate(0.5deg);
    }
    90% {
      transform: translate(-2px, 0) rotate(0deg);
    }
  }

  @keyframes shake-heavy {
    0%, 100% {
      transform: translate(0, 0) rotate(0deg) scale(1);
    }
    10% {
      transform: translate(-15px, -8px) rotate(-3deg) scale(1.02);
    }
    20% {
      transform: translate(15px, 8px) rotate(3deg) scale(0.98);
    }
    30% {
      transform: translate(-15px, 5px) rotate(-2.5deg) scale(1.02);
    }
    40% {
      transform: translate(15px, -5px) rotate(2.5deg) scale(0.98);
    }
    50% {
      transform: translate(-12px, 3px) rotate(-2deg) scale(1.01);
    }
    60% {
      transform: translate(12px, -3px) rotate(2deg) scale(0.99);
    }
    70% {
      transform: translate(-8px, 2px) rotate(-1deg) scale(1.01);
    }
    80% {
      transform: translate(8px, -2px) rotate(1deg) scale(0.99);
    }
    90% {
      transform: translate(-3px, 0) rotate(0deg) scale(1);
    }
  }

  @keyframes shake-legendary {
    0%, 100% {
      transform: translate(0, 0) rotate(0deg) scale(1);
    }
    5% {
      transform: translate(-20px, -12px) rotate(-5deg) scale(1.05);
    }
    10% {
      transform: translate(20px, 12px) rotate(5deg) scale(0.95);
    }
    15% {
      transform: translate(-20px, 8px) rotate(-4deg) scale(1.05);
    }
    20% {
      transform: translate(20px, -8px) rotate(4deg) scale(0.95);
    }
    25% {
      transform: translate(-18px, 10px) rotate(-4deg) scale(1.04);
    }
    30% {
      transform: translate(18px, -10px) rotate(4deg) scale(0.96);
    }
    35% {
      transform: translate(-15px, 5px) rotate(-3deg) scale(1.03);
    }
    40% {
      transform: translate(15px, -5px) rotate(3deg) scale(0.97);
    }
    45% {
      transform: translate(-15px, 3px) rotate(-3deg) scale(1.03);
    }
    50% {
      transform: translate(15px, -3px) rotate(3deg) scale(0.97);
    }
    55% {
      transform: translate(-12px, 2px) rotate(-2deg) scale(1.02);
    }
    60% {
      transform: translate(12px, -2px) rotate(2deg) scale(0.98);
    }
    65% {
      transform: translate(-10px, 2px) rotate(-2deg) scale(1.02);
    }
    70% {
      transform: translate(10px, -2px) rotate(2deg) scale(0.98);
    }
    75% {
      transform: translate(-8px, 1px) rotate(-1deg) scale(1.01);
    }
    80% {
      transform: translate(8px, -1px) rotate(1deg) scale(0.99);
    }
    85% {
      transform: translate(-5px, 0) rotate(-0.5deg) scale(1.01);
    }
    90% {
      transform: translate(5px, 0) rotate(0.5deg) scale(0.99);
    }
    95% {
      transform: translate(-2px, 0) rotate(0deg) scale(1);
    }
  }

  @keyframes shake-bearableguy123 {
    0%, 100% {
      transform: translate(0, 0) rotate(0deg) scale(1);
    }
    3% {
      transform: translate(-30px, -18px) rotate(-8deg) scale(1.08);
    }
    6% {
      transform: translate(30px, 18px) rotate(8deg) scale(0.92);
    }
    9% {
      transform: translate(-28px, 15px) rotate(-7deg) scale(1.07);
    }
    12% {
      transform: translate(28px, -15px) rotate(7deg) scale(0.93);
    }
    15% {
      transform: translate(-26px, 12px) rotate(-6deg) scale(1.06);
    }
    18% {
      transform: translate(26px, -12px) rotate(6deg) scale(0.94);
    }
    21% {
      transform: translate(-24px, 10px) rotate(-6deg) scale(1.06);
    }
    24% {
      transform: translate(24px, -10px) rotate(6deg) scale(0.94);
    }
    27% {
      transform: translate(-22px, 8px) rotate(-5deg) scale(1.05);
    }
    30% {
      transform: translate(22px, -8px) rotate(5deg) scale(0.95);
    }
    33% {
      transform: translate(-20px, 6px) rotate(-4deg) scale(1.04);
    }
    36% {
      transform: translate(20px, -6px) rotate(4deg) scale(0.96);
    }
    39% {
      transform: translate(-18px, 5px) rotate(-4deg) scale(1.04);
    }
    42% {
      transform: translate(18px, -5px) rotate(4deg) scale(0.96);
    }
    45% {
      transform: translate(-16px, 4px) rotate(-3deg) scale(1.03);
    }
    48% {
      transform: translate(16px, -4px) rotate(3deg) scale(0.97);
    }
    51% {
      transform: translate(-14px, 3px) rotate(-3deg) scale(1.03);
    }
    54% {
      transform: translate(14px, -3px) rotate(3deg) scale(0.97);
    }
    57% {
      transform: translate(-12px, 2px) rotate(-2deg) scale(1.02);
    }
    60% {
      transform: translate(12px, -2px) rotate(2deg) scale(0.98);
    }
    63% {
      transform: translate(-10px, 2px) rotate(-2deg) scale(1.02);
    }
    66% {
      transform: translate(10px, -2px) rotate(2deg) scale(0.98);
    }
    69% {
      transform: translate(-8px, 1px) rotate(-1deg) scale(1.01);
    }
    72% {
      transform: translate(8px, -1px) rotate(1deg) scale(0.99);
    }
    75% {
      transform: translate(-6px, 1px) rotate(-1deg) scale(1.01);
    }
    78% {
      transform: translate(6px, -1px) rotate(1deg) scale(0.99);
    }
    81% {
      transform: translate(-4px, 0) rotate(-0.5deg) scale(1.005);
    }
    84% {
      transform: translate(4px, 0) rotate(0.5deg) scale(0.995);
    }
    87% {
      transform: translate(-3px, 0) rotate(-0.5deg) scale(1.005);
    }
    90% {
      transform: translate(3px, 0) rotate(0.5deg) scale(0.995);
    }
    93% {
      transform: translate(-2px, 0) rotate(0deg) scale(1.002);
    }
    96% {
      transform: translate(2px, 0) rotate(0deg) scale(0.998);
    }
  }

  /* Mobile responsive styles for cosmetics store */
  @media (max-width: 768px) {
    .store-modal-content {
      width: 98%;
      max-height: 95vh;
    }

    .store-header {
      padding: 12px 16px;
      flex-direction: column;
      gap: 8px;
    }

    .store-title {
      font-size: 20px;
    }

    .store-subtitle {
      font-size: 11px;
    }

    .store-balance-container {
      width: 100%;
      justify-content: space-between;
    }

    .store-balance {
      font-size: 18px;
      padding: 8px 14px;
    }

    .store-balance .hp-amount {
      font-size: 22px;
    }

    .store-close-btn {
      width: 32px;
      height: 32px;
      font-size: 22px;
    }

    .store-tabs {
      padding: 8px 12px;
      gap: 6px;
    }

    .store-tab {
      padding: 8px 14px;
      font-size: 13px;
      flex: 1;
    }

    .store-body {
      padding: 12px;
      max-height: calc(95vh - 180px);
    }

    .store-grid {
      grid-template-columns: 1fr;
      gap: 16px;
    }

    .store-item {
      padding: 14px;
    }

    .store-item-preview {
      height: 120px;
      margin-bottom: 12px;
    }

    .store-item-badge {
      font-size: 10px;
      padding: 5px 10px;
      top: 8px;
      right: 8px;
    }

    .store-item-name {
      font-size: 16px;
      margin-bottom: 8px;
    }

    .store-item-description {
      font-size: 12px;
      margin-bottom: 12px;
      min-height: auto;
      line-height: 1.4;
    }

    .store-item-footer {
      flex-direction: row;
      align-items: center;
      gap: 10px;
    }

    .store-item-price {
      font-size: 20px;
    }

    .store-item-btn {
      padding: 10px 18px;
      font-size: 14px;
      white-space: nowrap;
    }

    .ring-demo {
      width: 130px !important;
      height: 130px !important;
    }

    /* Smaller leaderboard avatars and rings on mobile */
    .leaderboard-avatar-ring {
      width: 42px !important;
      height: 42px !important;
      margin-right: 6px !important;
    }

    .leaderboard-avatar-ring.castle-ring-container {
      width: 50px !important;
      height: 50px !important;
    }

    .leaderboard-avatar-ring.ouroboros-ring-container {
      width: 45px !important;
      height: 45px !important;
    }

    .leaderboard-avatar-ring.waves-ring-container {
      width: 40px !important;
      height: 40px !important;
    }

    .leaderboard-avatar-simple {
      width: 30px !important;
      height: 30px !important;
      margin-right: 6px !important;
    }

    .leaderboard-avatar-img {
      width: 30px !important;
      height: 30px !important;
    }

    .leaderboard-ring-img {
      width: 42px !important;
      height: 42px !important;
    }

    .leaderboard-ring-img-castle {
      width: 50px !important;
      height: 50px !important;
    }

    .leaderboard-ring-img-ouroboros {
      width: 45px !important;
      height: 45px !important;
    }

    .leaderboard-ring-img-waves {
      width: 40px !important;
      height: 40px !important;
    }

    .celebration-icon {
      font-size: 80px;
    }

    .celebration-text {
      font-size: 32px;
    }

    .celebration-subtext {
      font-size: 18px;
    }

    .rarity-section {
      margin-bottom: 28px;
      padding: 16px;
      border-width: 3px;
    }

    .rarity-header {
      font-size: 20px;
      padding: 14px 18px;
      margin-bottom: 16px;
      border-width: 3px;
    }

    .bearableguy123-header {
      font-size: 22px;
    }
  }

  /* ===== MERCH STORE STYLES ===== */
  .merch-screen { width: 100%; }

  .merch-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    gap: 24px;
    margin-bottom: 24px;
  }

  .merch-product-card {
    background: linear-gradient(135deg, rgba(30,30,50,0.9), rgba(20,20,40,0.95));
    border-radius: 16px;
    border: 3px solid rgba(104,12,217,0.3);
    overflow: hidden;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .merch-product-card:hover {
    transform: translateY(-5px) scale(1.02);
    border-color: #680cd9;
    box-shadow: 0 15px 40px rgba(104,12,217,0.3);
  }

  .merch-product-card img {
    width: 100%;
    aspect-ratio: 1;
    object-fit: cover;
    background: rgba(104,12,217,0.2);
    border-bottom: 2px solid rgba(104,12,217,0.2);
    border-radius: 12px 12px 0 0;
  }

  .merch-product-info {
    padding: 16px;
  }

  .merch-product-info h3 {
    color: #fff;
    font-size: 18px;
    font-weight: 700;
    margin: 0 0 8px 0;
  }

  .merch-product-info .merch-price {
    color: #00ff88;
    font-size: 20px;
    font-weight: 900;
  }

  .merch-product-info .merch-stock-badge {
    display: inline-block;
    padding: 4px 10px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 700;
    margin-top: 8px;
  }

  .merch-stock-badge.in-stock { background: rgba(34,197,94,0.2); color: #22c55e; }
  .merch-stock-badge.low-stock { background: rgba(254,181,1,0.2); color: #feb501; }
  .merch-stock-badge.sold-out { background: rgba(239,68,68,0.2); color: #ef4444; }

  .merch-product-card.sold-out {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .merch-privacy-notice {
    background: rgba(104,12,217,0.1);
    border: 2px solid rgba(104,12,217,0.3);
    border-radius: 12px;
    padding: 16px 20px;
    color: #ccc;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .merch-privacy-notice span { font-size: 24px; }

  .merch-back-btn {
    background: rgba(255,255,255,0.1);
    border: none;
    color: #fff;
    padding: 8px 16px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.2s;
  }

  .merch-back-btn:hover { background: rgba(255,255,255,0.2); }

  .merch-detail-layout {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 32px;
  }

  @media (max-width: 768px) {
    .merch-detail-layout { grid-template-columns: 1fr; }
  }

  .merch-main-image {
    background: rgba(0,0,0,0.3);
    border-radius: 16px;
    overflow: hidden;
    border: 3px solid rgba(249,115,22,0.3);
  }

  .merch-main-image img {
    width: 100%;
    height: auto;
    display: block;
    border-radius: 12px;
  }

  .merch-thumbnails {
    display: flex;
    gap: 12px;
    margin-top: 12px;
  }

  .merch-thumbnail {
    width: 70px;
    height: 70px;
    border-radius: 8px;
    border: 2px solid rgba(255,255,255,0.2);
    cursor: pointer;
    overflow: hidden;
    transition: all 0.2s;
  }

  .merch-thumbnail:hover, .merch-thumbnail.active {
    border-color: #680cd9;
  }

  .merch-thumbnail img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 6px;
  }

  .merch-product-name {
    font-size: 28px;
    font-weight: 900;
    color: #fff;
    margin: 0 0 8px 0;
  }

  .merch-product-badge {
    display: inline-block;
    background: linear-gradient(135deg, rgba(254,181,1,0.2), rgba(0,255,136,0.2));
    border: 1px solid rgba(254,181,1,0.5);
    padding: 4px 12px;
    border-radius: 20px;
    color: #feb501;
    font-size: 12px;
    font-weight: 700;
    margin-bottom: 16px;
  }

  .merch-price-section {
    margin-bottom: 20px;
  }

  .merch-price-main {
    font-size: 32px;
    font-weight: 900;
    color: #22c55e;
  }

  .merch-price-xrp {
    color: #888;
    font-size: 14px;
    margin-top: 4px;
  }

  .merch-size-section {
    margin-bottom: 16px;
  }

  .merch-size-section label {
    display: block;
    color: #ccc;
    font-size: 14px;
    font-weight: 700;
    margin-bottom: 10px;
  }

  .merch-size-buttons {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
  }

  .merch-size-btn {
    width: 50px;
    height: 50px;
    border: 2px solid rgba(255,255,255,0.3);
    background: rgba(255,255,255,0.05);
    color: #fff;
    font-size: 14px;
    font-weight: 700;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .merch-size-btn:hover:not(:disabled) {
    border-color: #680cd9;
    background: rgba(104,12,217,0.1);
  }

  .merch-size-btn.selected {
    border-color: #680cd9;
    background: linear-gradient(135deg, rgba(104,12,217,0.3), rgba(0,255,136,0.3));
    box-shadow: 0 0 15px rgba(104,12,217,0.4);
  }

  .merch-size-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    text-decoration: line-through;
  }

  .merch-stock {
    color: #22c55e;
    font-size: 14px;
    margin-bottom: 16px;
  }

  .merch-buy-btn {
    width: 100%;
    padding: 16px 24px;
    font-size: 18px;
    font-weight: 900;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s;
    margin-bottom: 20px;
  }

  .merch-buy-btn:disabled {
    background: linear-gradient(135deg, #374151, #1f2937);
    color: #6b7280;
    cursor: not-allowed;
  }

  .merch-buy-btn:not(:disabled) {
    background: linear-gradient(135deg, #680cd9, #00ff88);
    color: #fff;
    box-shadow: 0 8px 25px rgba(104,12,217,0.4);
  }

  .merch-buy-btn:not(:disabled):hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 35px rgba(249,115,22,0.5);
  }

  .merch-description {
    color: #ccc;
    font-size: 14px;
    line-height: 1.6;
    margin-bottom: 16px;
  }

  .merch-features {
    color: #888;
    font-size: 13px;
    line-height: 1.8;
    margin-bottom: 20px;
  }

  .merch-shipping-notice {
    background: rgba(249,115,22,0.1);
    border: 2px solid rgba(249,115,22,0.3);
    border-radius: 12px;
    padding: 16px;
    color: #ccc;
    font-size: 13px;
    line-height: 1.6;
  }

  .merch-privacy-box {
    background: rgba(34,197,94,0.1);
    border: 2px solid rgba(34,197,94,0.3);
    border-radius: 16px;
    padding: 24px;
    text-align: left;
    margin-bottom: 20px;
  }

  .merch-privacy-box h4 {
    color: #22c55e;
    font-size: 18px;
    margin: 0 0 16px 0;
  }

  .merch-privacy-box ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .merch-privacy-box li {
    color: #ccc;
    padding: 8px 0;
    padding-left: 24px;
    position: relative;
  }

  .merch-privacy-box li::before {
    content: '‚úì';
    color: #22c55e;
    position: absolute;
    left: 0;
    font-weight: bold;
  }

  .merch-disclaimer-buttons {
    display: flex;
    gap: 16px;
    justify-content: center;
    margin-top: 30px;
  }

  .merch-btn-primary {
    background: linear-gradient(135deg, #22c55e, #16a34a);
    color: #fff;
    border: none;
    padding: 16px 32px;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s;
  }

  .merch-btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 30px rgba(34,197,94,0.4);
  }

  .merch-btn-secondary {
    background: rgba(255,255,255,0.1);
    color: #fff;
    border: 2px solid rgba(255,255,255,0.2);
    padding: 16px 32px;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s;
  }

  .merch-btn-secondary:hover {
    background: rgba(255,255,255,0.2);
  }

  .merch-shipping-form {}

  .merch-form-group {
    margin-bottom: 20px;
  }

  .merch-form-group label {
    display: block;
    color: #fff;
    font-size: 14px;
    font-weight: 700;
    margin-bottom: 8px;
  }

  .merch-form-group .required { color: #ef4444; }

  .merch-form-group input,
  .merch-form-group select {
    width: 100%;
    padding: 14px 16px;
    background: rgba(255,255,255,0.05);
    border: 2px solid rgba(255,255,255,0.2);
    border-radius: 10px;
    color: #fff;
    font-size: 16px;
    transition: all 0.2s;
  }

  .merch-form-group input:focus,
  .merch-form-group select:focus {
    outline: none;
    border-color: #680cd9;
    background: rgba(104,12,217,0.05);
  }

  .merch-form-group input::placeholder { color: #666; }

  .merch-form-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
  }

  @media (max-width: 600px) {
    .merch-form-row { grid-template-columns: 1fr; }
  }

  .merch-confirm-box {
    background: rgba(255,255,255,0.05);
    border: 2px solid rgba(249,115,22,0.3);
    border-radius: 16px;
    padding: 24px;
    margin-bottom: 24px;
  }

  .merch-confirm-label {
    color: #00ff88;
    font-size: 14px;
    font-weight: 700;
    margin-bottom: 12px;
  }

  .merch-confirm-address {
    color: #fff;
    font-size: 16px;
    line-height: 1.6;
    margin-bottom: 16px;
  }

  .merch-edit-btn {
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    color: #fff;
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .merch-edit-btn:hover {
    background: rgba(255,255,255,0.2);
  }

  .merch-order-summary {
    background: rgba(0,0,0,0.3);
    border-radius: 12px;
    padding: 20px;
  }

  .merch-summary-title {
    color: #fff;
    font-size: 16px;
    font-weight: 700;
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 1px solid rgba(255,255,255,0.1);
  }

  .merch-summary-row {
    display: flex;
    justify-content: space-between;
    color: #ccc;
    padding: 8px 0;
  }

  .merch-summary-divider {
    height: 1px;
    background: rgba(255,255,255,0.1);
    margin: 12px 0;
  }

  .merch-summary-total {
    color: #fff;
    font-size: 18px;
    font-weight: 700;
  }

  .merch-payment-options {
    display: flex;
    flex-direction: column;
    gap: 16px;
    margin-bottom: 24px;
  }

  .merch-payment-option {
    display: flex;
    align-items: flex-start;
    gap: 16px;
    background: rgba(255,255,255,0.05);
    border: 2px solid rgba(255,255,255,0.2);
    border-radius: 16px;
    padding: 20px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .merch-payment-option:has(input:checked) {
    border-color: #680cd9;
    background: rgba(104,12,217,0.1);
  }

  .merch-payment-option input {
    margin-top: 4px;
    accent-color: #680cd9;
    width: 20px;
    height: 20px;
  }

  .merch-payment-content { flex: 1; }

  .merch-payment-title {
    color: #fff;
    font-size: 18px;
    font-weight: 700;
    margin-bottom: 4px;
  }

  .merch-payment-amount {
    color: #22c55e;
    font-size: 16px;
    font-weight: 600;
  }

  .merch-payment-rate,
  .merch-payment-refresh {
    color: #888;
    font-size: 13px;
    margin-top: 4px;
  }

  .merch-payment-note {
    color: #22c55e;
    font-size: 13px;
    margin-top: 8px;
  }

  .merch-payment-info {
    background: rgba(59,130,246,0.1);
    border: 2px solid rgba(59,130,246,0.3);
    border-radius: 12px;
    padding: 16px;
    color: #ccc;
    font-size: 14px;
    line-height: 1.6;
  }

  .merch-success-box {
    background: rgba(34,197,94,0.1);
    border: 2px solid rgba(34,197,94,0.3);
    border-radius: 16px;
    padding: 24px;
    text-align: left;
    max-width: 400px;
    margin: 0 auto;
  }

  .merch-success-row {
    display: flex;
    justify-content: space-between;
    padding: 8px 0;
    color: #ccc;
  }

  .merch-success-row span:last-child {
    color: #fff;
    font-weight: 600;
  }

  .merch-success-divider {
    height: 1px;
    background: rgba(34,197,94,0.3);
    margin: 16px 0;
  }

  .merch-spinner {
    width: 60px;
    height: 60px;
    border: 4px solid rgba(104,12,217,0.2);
    border-top-color: #680cd9;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Shopping Cart Styles */
  .merch-cart-btn {
    position: relative;
    background: rgba(0,0,0,0.3);
    border: 2px solid rgba(255,255,255,0.2);
    border-radius: 10px;
    padding: 8px 14px;
    color: #fff;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .merch-cart-btn:hover {
    background: rgba(104,12,217,0.3);
    border-color: #680cd9;
  }

  .merch-cart-badge {
    position: absolute;
    top: -8px;
    right: -8px;
    background: linear-gradient(135deg, #ef4444, #f97316);
    color: #fff;
    font-size: 12px;
    font-weight: 900;
    min-width: 22px;
    height: 22px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(239,68,68,0.5);
    animation: cartBadgePop 0.3s ease-out;
  }

  .merch-cart-badge.hidden {
    display: none;
  }

  @keyframes cartBadgePop {
    0% { transform: scale(0); }
    50% { transform: scale(1.3); }
    100% { transform: scale(1); }
  }

  /* Add to Cart Animation */
  .cart-add-animation {
    position: fixed;
    pointer-events: none;
    z-index: 10000;
    animation: flyToCart 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
  }

  .cart-add-animation img {
    width: 60px;
    height: 60px;
    object-fit: cover;
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(104,12,217,0.6), 0 0 20px rgba(0,255,136,0.4);
  }

  @keyframes flyToCart {
    0% {
      opacity: 1;
      transform: scale(1) rotate(0deg);
    }
    50% {
      opacity: 1;
      transform: scale(0.6) rotate(15deg);
    }
    100% {
      opacity: 0;
      transform: scale(0.2) rotate(-10deg);
    }
  }

  .merch-cart-btn.cart-bounce {
    animation: cartBounce 0.5s ease-out;
  }

  @keyframes cartBounce {
    0% { transform: scale(1); }
    25% { transform: scale(1.3) rotate(-5deg); }
    50% { transform: scale(0.9) rotate(5deg); }
    75% { transform: scale(1.15) rotate(-2deg); }
    100% { transform: scale(1) rotate(0deg); }
  }

  .cart-success-flash {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #22c55e, #00ff88);
    color: #fff;
    padding: 16px 32px;
    border-radius: 16px;
    font-size: 18px;
    font-weight: 800;
    z-index: 10001;
    box-shadow: 0 10px 50px rgba(0,255,136,0.5);
    animation: flashIn 0.6s ease-out forwards;
    display: flex;
    align-items: center;
    gap: 12px;
  }

  @keyframes flashIn {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    40% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
    70% { transform: translate(-50%, -50%) scale(0.95); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
  }

  .merch-cart-modal {
    background: linear-gradient(135deg, rgba(30,30,50,0.98), rgba(20,20,40,0.99));
    border-radius: 20px;
    max-width: 600px;
    width: 95%;
    max-height: 85vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  .merch-cart-header {
    background: linear-gradient(135deg, #680cd9, #00ff88);
    padding: 16px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .merch-cart-header h3 {
    color: #fff;
    font-size: 20px;
    font-weight: 900;
    margin: 0;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .merch-cart-body {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
  }

  .merch-cart-empty {
    text-align: center;
    padding: 40px 20px;
  }

  .merch-cart-empty-icon {
    font-size: 60px;
    margin-bottom: 15px;
  }

  .merch-cart-item {
    display: flex;
    gap: 15px;
    background: rgba(0,0,0,0.3);
    border: 2px solid rgba(104,12,217,0.3);
    border-radius: 12px;
    padding: 15px;
    margin-bottom: 12px;
    transition: all 0.2s;
  }

  .merch-cart-item:hover {
    border-color: #680cd9;
  }

  .merch-cart-item-img {
    width: 80px;
    height: 80px;
    border-radius: 10px;
    object-fit: cover;
    flex-shrink: 0;
  }

  .merch-cart-item-info {
    flex: 1;
    min-width: 0;
  }

  .merch-cart-item-name {
    font-size: 16px;
    font-weight: 700;
    color: #fff;
    margin-bottom: 4px;
  }

  .merch-cart-item-size {
    font-size: 13px;
    color: #888;
    margin-bottom: 8px;
  }

  .merch-cart-item-price {
    font-size: 18px;
    font-weight: 900;
    color: #00ff88;
  }

  .merch-cart-item-actions {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: flex-end;
  }

  .merch-cart-remove-btn {
    background: rgba(239,68,68,0.2);
    border: none;
    color: #ef4444;
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .merch-cart-remove-btn:hover {
    background: #ef4444;
    color: #fff;
  }

  .merch-cart-qty {
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(0,0,0,0.3);
    border-radius: 8px;
    padding: 4px;
  }

  .merch-cart-qty-btn {
    width: 28px;
    height: 28px;
    border: none;
    border-radius: 6px;
    background: rgba(104,12,217,0.3);
    color: #fff;
    font-size: 16px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s;
  }

  .merch-cart-qty-btn:hover {
    background: #680cd9;
  }

  .merch-cart-qty-num {
    font-size: 16px;
    font-weight: 700;
    color: #fff;
    min-width: 24px;
    text-align: center;
  }

  .merch-cart-footer {
    background: rgba(0,0,0,0.4);
    padding: 20px;
    border-top: 2px solid rgba(104,12,217,0.3);
  }

  .merch-cart-subtotal {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
  }

  .merch-cart-subtotal-label {
    font-size: 16px;
    color: #888;
  }

  .merch-cart-subtotal-value {
    font-size: 28px;
    font-weight: 900;
    color: #00ff88;
  }

  .merch-cart-checkout-btn {
    width: 100%;
    padding: 16px;
    background: linear-gradient(135deg, #680cd9, #00ff88);
    border: none;
    border-radius: 12px;
    color: #fff;
    font-size: 18px;
    font-weight: 900;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
  }

  .merch-cart-checkout-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 30px rgba(104,12,217,0.4);
  }

  .merch-cart-checkout-btn:disabled {
    background: linear-gradient(135deg, #374151, #1f2937);
    color: #6b7280;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }

  .merch-cart-continue {
    width: 100%;
    padding: 12px;
    background: transparent;
    border: 2px solid rgba(255,255,255,0.2);
    border-radius: 10px;
    color: #888;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    margin-top: 10px;
    transition: all 0.2s;
  }

  .merch-cart-continue:hover {
    border-color: #680cd9;
    color: #fff;
  }
  /* ===== END MERCH STORE STYLES ===== */

  /* ===== END COSMETICS STORE STYLES ===== */

  /* ===== üêª MEME OF THE WEEK STYLES ===== */
  .meme-section {
    background: var(--card);
    border-radius: 24px;
    padding: 0;
    margin: 0;
    position: relative;
    overflow: hidden;
    box-shadow: var(--elev-strong);
  }

  /* Tri-color border animation */
  .meme-section::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 24px;
    padding: 6px;
    background: linear-gradient(135deg,
      var(--stripe-purple) 0%,
      var(--stripe-purple) 33.33%,
      var(--stripe-yellow) 33.33%,
      var(--stripe-yellow) 66.66%,
      var(--stripe-green) 66.66%,
      var(--stripe-green) 100%
    );
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    z-index: 1;
    animation: borderPulse 3s ease-in-out infinite;
  }

  @keyframes borderPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }

  /* Header */
  .meme-header {
    background: linear-gradient(135deg,
      rgba(104, 12, 217, 0.15) 0%,
      rgba(255, 174, 0, 0.15) 50%,
      rgba(7, 174, 8, 0.15) 100%
    );
    padding: 32px 40px;
    border-bottom: 4px solid transparent;
    border-image: var(--tri-gradient) 1;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 20px;
  }

  .meme-title {
    font-size: 48px;
    font-family: "Luckiest Guy", sans-serif;
    color: var(--gold);
    text-shadow: 0 4px 8px rgba(0,0,0,0.5), 0 0 20px rgba(255,174,0,0.4);
    margin: 0;
    letter-spacing: 2px;
    animation: titleFloat 3s ease-in-out infinite;
  }

  @keyframes titleFloat {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-8px); }
  }

  .meme-timer {
    display: flex;
    align-items: center;
    gap: 16px;
    background: var(--ink);
    padding: 16px 24px;
    border-radius: 16px;
    border: 3px solid var(--gold);
    box-shadow: 0 0 24px rgba(255,174,0,0.3);
  }

  .timer-icon {
    font-size: 42px;
    animation: timerPulse 1s ease-in-out infinite;
  }

  @keyframes timerPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.15); }
  }

  .timer-label {
    font-size: 14px;
    color: var(--honey);
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 4px;
  }

  .timer-countdown {
    font-size: 28px;
    font-weight: bold;
    color: var(--gold);
    font-family: "Luckiest Guy", sans-serif;
    letter-spacing: 2px;
  }

  .timer-countdown span {
    display: inline-block;
    min-width: 48px;
    text-align: center;
    background: rgba(255,174,0,0.1);
    border-radius: 8px;
    padding: 4px 8px;
    margin: 0 2px;
  }

  .timer-utc {
    font-size: 12px;
    color: rgba(255,239,179,0.7);
    margin-top: 4px;
  }

  /* Carousel Container */
  .meme-carousel-container {
    display: flex;
    flex-direction: column;
    gap: 32px;
    padding: 40px;
    background: var(--charcoal);
  }

  /* Leaderboard */
  .meme-leaderboard {
    background: var(--ink);
    border-radius: 20px;
    padding: 24px;
    border: 3px solid var(--gold);
    box-shadow: 0 0 32px rgba(255,174,0,0.2);
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
  }

  .leaderboard-title {
    font-size: 24px;
    color: var(--gold);
    text-align: center;
    margin: 0 0 20px 0;
    font-family: "Luckiest Guy", sans-serif;
    text-shadow: 0 2px 8px rgba(0,0,0,0.5);
  }

  .leaderboard-empty {
    text-align: center;
    color: rgba(255,255,255,0.5);
    padding: 40px 20px;
    font-size: 18px;
  }

  .leaderboard-item {
    background: var(--card);
    border-radius: 16px;
    padding: 20px;
    margin-bottom: 12px;
    display: flex;
    flex-direction: row;
    gap: 16px;
    align-items: center;
    cursor: pointer;
    transition: all 0.3s var(--ease-spring);
    border: 2px solid rgba(255,174,0,0.3);
    position: relative;
    overflow: visible;
  }

  .leaderboard-item:hover {
    transform: translateY(-8px) scale(1.05);
    border-color: var(--gold);
    box-shadow: 0 12px 32px rgba(255,174,0,0.4);
  }

  .rank-badge {
    font-size: 32px;
    text-align: center;
    animation: badgeBounce 2s ease-in-out infinite;
  }

  @keyframes badgeBounce {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
  }

  .leaderboard-thumb {
    width: 80px;
    height: 80px;
    object-fit: cover;
    border-radius: 12px;
    border: 2px solid var(--honey);
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  }

  .leaderboard-info {
    display: flex;
    flex-direction: column;
    gap: 8px;
    overflow: visible;
    align-items: center;
    text-align: center;
    width: 100%;
  }

  .leaderboard-rank {
    font-size: 40px;
    font-weight: bold;
    color: var(--gold);
    text-align: center;
    min-width: 50px;
  }

  .leaderboard-meme-thumb {
    width: 120px;
    height: 120px;
    object-fit: cover;
    border-radius: 12px;
    border: 2px solid var(--gold);
  }

  .leaderboard-user {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    overflow: visible;
  }

  .leaderboard-avatar-container {
    position: relative;
    width: 40px;
    height: 40px;
    flex-shrink: 0;
    overflow: visible;
  }

  .leaderboard-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid var(--gold);
  }

  .leaderboard-cosmetic-ring {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 1;
    width: auto !important;
    height: auto !important;
  }

  .leaderboard-cosmetic-ring.castle,
  .leaderboard-cosmetic-ring.castle-static {
    max-width: 60px !important;
    max-height: 60px !important;
  }

  .leaderboard-cosmetic-ring.ouroboros {
    max-width: 55px !important;
    max-height: 55px !important;
  }

  .leaderboard-cosmetic-ring.waves,
  .leaderboard-cosmetic-ring.waves-static {
    max-width: 48px !important;
    max-height: 48px !important;
  }

  .leaderboard-cosmetic-ring:not(.castle):not(.castle-static):not(.ouroboros):not(.waves):not(.waves-static):not(.purple):not(.green):not(.yellow):not(.bg123-red) {
    max-width: 52px !important;
    max-height: 52px !important;
  }

  /* Color rings 20% bigger in leaderboard */
  .leaderboard-cosmetic-ring.purple,
  .leaderboard-cosmetic-ring.green,
  .leaderboard-cosmetic-ring.yellow,
  .leaderboard-cosmetic-ring.bg123-red {
    max-width: 62px !important;
    max-height: 62px !important;
  }

  .leaderboard-username {
    font-size: 16px;
    font-weight: bold;
    color: var(--gold);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .leaderboard-stats {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-size: 16px;
  }

  .leaderboard-votes {
    color: var(--gold);
    font-weight: bold;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
  }

  .leaderboard-reward {
    color: var(--honey);
    font-weight: bold;
    text-shadow: 0 0 8px rgba(255,174,0,0.5);
  }

  .meme-submitter {
    font-size: 14px;
    color: var(--honey);
    font-weight: bold;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .meme-votes {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 18px;
    color: var(--gold);
    font-weight: bold;
  }

  .vote-icon {
    font-size: 20px;
  }

  /* Carousel */
  .meme-carousel {
    position: relative;
    display: flex;
    align-items: center;
    gap: 20px;
    background: var(--ink);
    border-radius: 20px;
    padding: 40px 20px;
    min-height: 600px;
  }

  .carousel-nav {
    width: 64px;
    height: 64px;
    border-radius: 50%;
    background: var(--gold);
    border: 4px solid var(--ink);
    color: var(--gold-ink);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: all 0.3s var(--ease-spring);
    box-shadow: 0 4px 16px rgba(0,0,0,0.3);
  }

  .carousel-nav:hover {
    transform: scale(1.15);
    background: var(--honey);
    box-shadow: 0 8px 24px rgba(255,174,0,0.5);
  }

  .carousel-nav:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    transform: scale(1);
  }

  .carousel-track-container {
    flex: 1;
    overflow: hidden;
    border-radius: 16px;
  }

  .carousel-track {
    display: block;
    position: relative;
  }

  .meme-slide {
    display: none;
    flex-direction: column;
    gap: 24px;
    width: 100%;
  }

  .meme-slide.active {
    display: flex;
    opacity: 1;
    transform: scale(1);
    pointer-events: all;
  }

  .empty-state {
    text-align: center;
    padding: 80px 40px;
    min-width: 100%;
  }

  .meme-image-container {
    position: relative;
    width: 100%;
    max-width: 900px;
    margin: 0 auto;
    border-radius: 20px;
    overflow: hidden;
    border: 4px solid var(--gold);
    box-shadow: var(--elev-strong);
    background: var(--charcoal);
  }

  .meme-image {
    width: 100%;
    height: auto;
    min-height: 500px !important;
    max-height: 800px !important;
    object-fit: contain;
    display: block;
  }

  .meme-vote-counter {
    position: absolute;
    bottom: 16px;
    right: 16px;
    background: rgba(11,13,14,0.9);
    border: 3px solid var(--gold);
    border-radius: 50px;
    padding: 12px 24px;
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 24px;
    font-weight: bold;
    color: var(--gold);
    box-shadow: 0 8px 32px rgba(0,0,0,0.6);
  }

  .meme-vote-counter .vote-number {
    font-family: "Luckiest Guy", sans-serif;
    font-size: 28px;
    text-shadow: 0 2px 8px rgba(0,0,0,0.8);
    min-width: 40px;
    text-align: center;
  }

  .meme-details {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 20px;
    padding: 0 20px;
    flex-wrap: wrap;
  }

  .meme-meta {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .meme-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
  }

  .meme-author {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    font-size: 18px;
    color: var(--honey);
    overflow: visible;
  }

  .meme-avatar-container {
    position: relative;
    width: 48px;
    height: 48px;
    flex-shrink: 0;
    overflow: visible;
  }

  .meme-avatar {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    object-fit: cover;
    border: 3px solid var(--gold);
  }

  .meme-cosmetic-ring {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 1;
    width: auto !important;
    height: auto !important;
  }

  .meme-cosmetic-ring.castle,
  .meme-cosmetic-ring.castle-static {
    max-width: 66px !important;
    max-height: 66px !important;
  }

  .meme-cosmetic-ring.ouroboros {
    max-width: 60px !important;
    max-height: 60px !important;
  }

  .meme-cosmetic-ring.waves,
  .meme-cosmetic-ring.waves-static {
    max-width: 53px !important;
    max-height: 53px !important;
  }

  .meme-cosmetic-ring:not(.castle):not(.castle-static):not(.ouroboros):not(.waves):not(.waves-static):not(.purple):not(.green):not(.yellow):not(.bg123-red) {
    max-width: 58px !important;
    max-height: 58px !important;
  }

  /* Color rings 20% bigger in meme section */
  .meme-cosmetic-ring.purple,
  .meme-cosmetic-ring.green,
  .meme-cosmetic-ring.yellow,
  .meme-cosmetic-ring.bg123-red {
    max-width: 70px !important;
    max-height: 70px !important;
  }

  .meme-username {
    font-weight: bold;
    color: var(--gold);
  }

  .meme-caption {
    font-size: 16px;
    color: var(--honey);
    text-align: center;
    margin: 0;
    padding: 0 20px;
  }

  .meme-actions {
    display: flex;
    justify-content: center;
    width: 100%;
  }

  .meme-vote-btn {
    background: linear-gradient(135deg, var(--gold) 0%, #ffc933 100%);
    color: var(--ink);
    font-size: 20px;
    font-weight: bold;
    font-family: "Luckiest Guy", sans-serif;
    padding: 14px 32px;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 10px;
    box-shadow: 0 6px 20px rgba(255,174,0,0.4), 0 0 0 3px var(--ink), 0 0 0 5px var(--gold);
    transition: all 0.3s var(--ease-spring);
  }

  .meme-vote-btn:hover:not(:disabled) {
    transform: scale(1.08) translateY(-3px);
    box-shadow: 0 10px 28px rgba(255,174,0,0.6), 0 0 0 3px var(--ink), 0 0 0 5px var(--gold);
  }

  .meme-vote-btn.voted {
    background: linear-gradient(135deg, var(--stripe-green) 0%, #09d40a 100%);
    color: #ffffff;
    box-shadow: 0 6px 20px rgba(7,174,8,0.5), 0 0 0 3px var(--ink), 0 0 0 5px var(--stripe-green);
  }

  .meme-vote-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .vote-icon {
    font-size: 24px;
  }

  .vote-count {
    font-size: 22px;
    min-width: 30px;
    text-align: center;
  }

  .meme-counter {
    text-align: center;
    font-size: 18px;
    font-weight: bold;
    color: var(--honey);
    padding: 8px 0;
  }

  .author-label {
    color: rgba(255,239,179,0.6);
    font-size: 14px;
    margin-right: 8px;
  }

  .author-name {
    color: var(--gold);
    font-weight: bold;
    font-size: 20px;
  }

  .meme-timestamp {
    font-size: 14px;
    color: rgba(255,255,255,0.5);
  }

  /* Vote Button */
  .vote-btn {
    background: linear-gradient(135deg, var(--gold) 0%, #ffc933 100%);
    color: var(--gold-ink);
    font-size: 24px;
    font-weight: bold;
    font-family: "Luckiest Guy", sans-serif;
    padding: 18px 48px;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 12px;
    box-shadow: 0 8px 24px rgba(255,174,0,0.4), 0 0 0 4px var(--ink), 0 0 0 6px var(--gold);
    transition: all 0.3s var(--ease-spring);
  }

  .vote-btn:hover {
    transform: scale(1.1) translateY(-4px);
    box-shadow: 0 12px 32px rgba(255,174,0,0.6), 0 0 0 4px var(--ink), 0 0 0 6px var(--gold), 0 0 40px rgba(255,174,0,0.4);
  }

  .vote-btn.voted {
    background: linear-gradient(135deg, var(--stripe-green) 0%, #09d40a 100%);
    color: #ffffff;
    box-shadow: 0 8px 24px rgba(7,174,8,0.5), 0 0 0 4px var(--ink), 0 0 0 6px var(--stripe-green);
    cursor: default;
  }

  .vote-btn-icon {
    font-size: 32px;
    animation: iconBounce 1.5s ease-in-out infinite;
  }

  @keyframes iconBounce {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
  }

  /* Upload Section */
  .meme-upload-section {
    grid-column: 2;
    display: flex;
    justify-content: center;
    padding: 20px 0 0 0;
  }

  .upload-meme-btn {
    background: linear-gradient(135deg, var(--accent) 0%, #ff7159 100%);
    color: #ffffff;
    font-size: 28px;
    font-weight: bold;
    font-family: "Luckiest Guy", sans-serif;
    padding: 24px 56px;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 16px;
    box-shadow: 0 12px 32px rgba(215,92,70,0.5), 0 0 0 4px var(--ink), 0 0 0 6px var(--accent);
    transition: all 0.3s var(--ease-spring);
  }

  .upload-meme-btn:hover {
    transform: scale(1.08) translateY(-6px);
    box-shadow: 0 16px 48px rgba(215,92,70,0.7), 0 0 0 4px var(--ink), 0 0 0 6px var(--accent);
  }

  .upload-icon {
    font-size: 36px;
    animation: uploadFloat 2s ease-in-out infinite;
  }

  @keyframes uploadFloat {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-8px); }
  }

  .upload-reward {
    background: rgba(255,239,179,0.2);
    padding: 6px 16px;
    border-radius: 20px;
    font-size: 22px;
    color: var(--honey);
    border: 2px solid var(--honey);
  }

  /* Bear Troll Floating Faces */
  .bear-troll-container {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 0;
  }

  .bear-troll-face {
    position: absolute;
    width: 80px;
    height: 80px;
    pointer-events: auto;
    cursor: grab;
    user-select: none;
    transition: transform 0.2s ease;
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
  }

  .bear-troll-face:active {
    cursor: grabbing;
  }

  .bear-troll-face:hover {
    transform: scale(1.1);
  }

  /* Ensure meme content is above bear faces */
  .meme-section {
    position: relative;
    z-index: 1;
  }

  /* Bear Heads Floating Animation - BEAR FRIENDS */
  .bear-heads-container {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 0;
  }

  .bear-head {
    position: absolute;
    width: 100px;
    height: 100px;
    pointer-events: auto;
    cursor: grab;
    user-select: none;
    will-change: transform;
    filter: drop-shadow(0 6px 12px rgba(0,0,0,0.4));
  }

  .bear-head:active {
    cursor: grabbing;
  }

  /* Simple spawn animation - just fade in */
  @keyframes bear-spawn {
    0% {
      opacity: 0;
    }
    100% {
      opacity: 1;
    }
  }

  /* Simple despawn animation - just fade out */
  @keyframes bear-despawn {
    0% {
      opacity: 1;
    }
    100% {
      opacity: 0;
    }
  }

  .bear-head.spawning {
    animation: bear-spawn 0.6s ease forwards;
    opacity: 0;
  }

  .bear-head.despawning {
    animation: bear-despawn 0.5s ease forwards;
  }

  /* Upload Modal */
  .meme-upload-modal {
    position: fixed;
    inset: 0;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
  }

  .modal-overlay {
    position: absolute;
    inset: 0;
    background: rgba(11,13,14,0.92);
    /* backdrop-filter removed for performance */
    animation: fadeIn 0.3s;
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  .modal-container {
    position: relative;
    background: var(--card);
    border-radius: 24px;
    max-width: 600px;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: var(--elev-strong);
    border: 4px solid transparent;
    animation: slideUp 0.4s var(--ease-spring);
  }

  .modal-container::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 24px;
    padding: 4px;
    background: linear-gradient(135deg, var(--stripe-purple) 0%, var(--stripe-purple) 33.33%, var(--stripe-yellow) 33.33%, var(--stripe-yellow) 66.66%, var(--stripe-green) 66.66%, var(--stripe-green) 100%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
    pointer-events: none;
    z-index: -1;
  }

  @keyframes slideUp {
    from { transform: translateY(50px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
  }

  .modal-close {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--ink);
    border: 2px solid var(--gold);
    color: var(--gold);
    font-size: 24px;
    cursor: pointer;
    transition: all 0.3s;
    z-index: 10;
  }

  .modal-close:hover {
    background: var(--gold);
    color: var(--ink);
    transform: rotate(90deg) scale(1.1);
  }

  .modal-header {
    padding: 40px 40px 24px 40px;
    text-align: center;
    border-bottom: 2px solid rgba(255,174,0,0.2);
  }

  .modal-title {
    font-size: 36px;
    color: var(--gold);
    margin: 0 0 12px 0;
    font-family: "Luckiest Guy", sans-serif;
    text-shadow: 0 4px 12px rgba(0,0,0,0.5);
  }

  .modal-subtitle {
    font-size: 18px;
    color: var(--honey);
    margin: 0;
  }

  .honey-highlight {
    color: var(--gold);
    font-size: 22px;
    font-weight: bold;
    animation: honeyGlow 2s ease-in-out infinite;
  }

  @keyframes honeyGlow {
    0%, 100% { text-shadow: 0 0 10px rgba(255,174,0,0.5); }
    50% { text-shadow: 0 0 20px rgba(255,174,0,0.8); }
  }

  .modal-body {
    padding: 40px;
  }

  .upload-dropzone {
    border: 4px dashed var(--gold);
    border-radius: 20px;
    background: var(--ink);
    padding: 48px 32px;
    text-align: center;
    transition: all 0.3s;
    cursor: pointer;
    min-height: 300px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .upload-dropzone:hover {
    border-color: var(--honey);
    background: rgba(255,174,0,0.05);
    transform: scale(1.02);
  }

  .upload-icon-large {
    font-size: 80px;
    margin-bottom: 20px;
  }

  .dropzone-text {
    font-size: 22px;
    color: var(--honey);
    margin: 0 0 8px 0;
    font-weight: bold;
  }

  .dropzone-subtext {
    font-size: 16px;
    color: rgba(255,255,255,0.5);
    margin: 8px 0 20px 0;
  }

  .browse-btn {
    background: var(--gold);
    color: var(--gold-ink);
    font-size: 20px;
    font-weight: bold;
    font-family: "Luckiest Guy", sans-serif;
    padding: 16px 40px;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 6px 20px rgba(255,174,0,0.4);
  }

  .browse-btn:hover {
    background: var(--honey);
    transform: scale(1.1);
  }

  .file-requirements {
    font-size: 14px;
    color: rgba(255,255,255,0.4);
    margin: 16px 0 0 0;
  }

  .upload-preview {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 20px;
    align-items: center;
  }

  #meme-preview-image {
    max-width: 100%;
    max-height: 400px;
    border-radius: 16px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.5);
    border: 3px solid var(--gold);
  }

  .change-image-btn {
    background: var(--accent);
    color: #ffffff;
    font-size: 16px;
    font-weight: bold;
    padding: 12px 28px;
    border: none;
    border-radius: 30px;
    cursor: pointer;
    transition: all 0.3s;
  }

  .change-image-btn:hover {
    background: #ff7159;
    transform: scale(1.05);
  }

  .file-info {
    display: flex;
    justify-content: space-between;
    padding: 16px 20px;
    background: rgba(255,174,0,0.1);
    border-radius: 12px;
    margin-top: 20px;
    border: 2px solid rgba(255,174,0,0.3);
  }

  .file-name {
    color: var(--honey);
    font-weight: bold;
  }

  .file-size {
    color: rgba(255,255,255,0.6);
  }

  .upload-error {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 16px 20px;
    background: rgba(215,92,70,0.2);
    border: 2px solid var(--accent);
    border-radius: 12px;
    margin-top: 20px;
  }

  .error-icon {
    font-size: 24px;
  }

  .error-text {
    color: #ff7159;
    font-weight: bold;
  }

  .upload-loading {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    padding: 40px 0;
  }

  .loading-spinner {
    width: 60px;
    height: 60px;
    border: 6px solid rgba(255,174,0,0.2);
    border-top-color: var(--gold);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .loading-text {
    font-size: 18px;
    color: var(--honey);
    font-weight: bold;
  }

  .modal-footer {
    padding: 24px 40px 40px 40px;
    display: flex;
    gap: 16px;
    justify-content: flex-end;
  }

  .modal-btn {
    font-size: 20px;
    font-weight: bold;
    font-family: "Luckiest Guy", sans-serif;
    padding: 16px 32px;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s var(--ease-spring);
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .cancel-btn {
    background: var(--ink);
    color: rgba(255,255,255,0.7);
    border: 2px solid rgba(255,255,255,0.2);
  }

  .cancel-btn:hover {
    background: var(--charcoal);
    color: #ffffff;
  }

  .submit-btn {
    background: linear-gradient(135deg, var(--stripe-green) 0%, #09d40a 100%);
    color: #ffffff;
    box-shadow: 0 8px 24px rgba(7,174,8,0.4);
  }

  .submit-btn:hover:not(:disabled) {
    transform: scale(1.08) translateY(-4px);
    box-shadow: 0 12px 32px rgba(7,174,8,0.6);
  }

  .submit-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }

  .submit-icon {
    font-size: 24px;
  }

  .submit-reward {
    background: rgba(255,239,179,0.2);
    padding: 4px 12px;
    border-radius: 16px;
  }

  /* Mobile Responsive */
  @media (max-width: 1200px) {
    .meme-carousel-container {
      grid-template-columns: 1fr;
      grid-template-rows: auto auto auto;
    }

    .meme-leaderboard {
      grid-row: 1;
      position: relative;
      top: 0;
    }

    .meme-carousel {
      grid-row: 2;
    }

    .meme-upload-section {
      grid-column: 1;
      grid-row: 3;
    }
  }

  @media (max-width: 768px) {
    .meme-header {
      flex-direction: column;
      text-align: center;
      padding: 24px 20px;
    }

    .meme-title {
      font-size: 36px;
    }

    .timer-countdown {
      font-size: 22px;
    }

    .carousel-nav {
      width: 48px;
      height: 48px;
    }

    .vote-btn {
      font-size: 20px;
      padding: 14px 32px;
    }

    .upload-meme-btn {
      font-size: 22px;
      padding: 18px 40px;
    }

    .modal-container {
      border-radius: 20px;
    }

    .modal-header {
      padding: 32px 24px 20px 24px;
    }

    .modal-title {
      font-size: 28px;
    }

    .modal-body {
      padding: 24px;
    }

    .modal-footer {
      flex-direction: column;
      padding: 20px 24px 32px 24px;
    }

    .modal-btn {
      width: 100%;
      justify-content: center;
    }
  }

  /* Enhanced Mobile Responsive Styles for iPhone 14 Pro Max & Others */
  @media (max-width: 430px) {
    .meme-section {
      border-radius: 16px;
      margin: 0 -10px;
    }

    .meme-header {
      padding: 20px 16px;
      gap: 16px;
    }

    .meme-title {
      font-size: 28px;
      letter-spacing: 1px;
    }

    .meme-timer {
      padding: 12px 16px;
      gap: 12px;
      width: 100%;
      box-sizing: border-box;
    }

    .timer-icon {
      font-size: 32px;
    }

    .timer-countdown {
      font-size: 20px;
    }

    .timer-countdown span {
      min-width: 36px;
      padding: 2px 4px;
      font-size: 18px;
    }

    .meme-carousel-container {
      padding: 20px 16px;
      gap: 24px;
    }

    .meme-carousel {
      padding: 20px 6px;
      min-height: auto;
      gap: 6px;
      flex-direction: row;
    }

    .carousel-nav {
      width: 32px;
      height: 32px;
      font-size: 16px;
      padding: 2px;
    }

    .carousel-track-container {
      flex: 1;
    }

    .meme-image-container {
      max-width: 100%;
      border-width: 3px;
    }

    .meme-image {
      min-height: 450px !important;
      max-height: 700px !important;
    }

    .meme-info {
      gap: 12px;
    }

    .meme-author {
      gap: 10px;
      font-size: 16px;
    }

    .meme-avatar-container {
      width: 48px;
      height: 48px;
    }

    .meme-avatar {
      width: 48px;
      height: 48px;
      border-width: 2px;
    }

    .meme-cosmetic-ring.castle,
    .meme-cosmetic-ring.castle-static {
      max-width: 58px !important;
      max-height: 58px !important;
    }

    .meme-cosmetic-ring.ouroboros {
      max-width: 54px !important;
      max-height: 54px !important;
    }

    .meme-cosmetic-ring.waves,
    .meme-cosmetic-ring.waves-static {
      max-width: 48px !important;
      max-height: 48px !important;
    }

    .meme-cosmetic-ring:not(.castle):not(.castle-static):not(.ouroboros):not(.waves):not(.waves-static) {
      max-width: 52px !important;
      max-height: 52px !important;
    }

    .meme-caption {
      font-size: 14px;
      padding: 0 16px;
    }

    .meme-vote-btn {
      font-size: 18px;
      padding: 12px 28px;
      border-radius: 40px;
    }

    .vote-icon {
      font-size: 20px;
    }

    .vote-count {
      font-size: 20px;
    }

    .meme-counter {
      font-size: 16px;
    }

    .meme-leaderboard {
      padding: 16px;
      border-width: 2px;
      max-width: 400px;
      margin: 0 auto;
    }

    .leaderboard-title {
      font-size: 22px;
      margin-bottom: 16px;
    }

    .leaderboard-item {
      padding: 16px;
      gap: 12px;
      border-radius: 12px;
      margin-bottom: 12px;
    }

    .leaderboard-item:hover {
      transform: translateY(-4px) scale(1.02);
    }

    .leaderboard-rank {
      font-size: 32px;
      min-width: 40px;
    }

    .leaderboard-meme-thumb {
      width: 100px;
      height: 100px;
      border-width: 2px;
    }

    .leaderboard-avatar-container {
      width: 40px;
      height: 40px;
    }

    .leaderboard-avatar {
      width: 40px;
      height: 40px;
      border-width: 2px;
    }

    .leaderboard-cosmetic-ring.castle,
    .leaderboard-cosmetic-ring.castle-static {
      max-width: 52px !important;
      max-height: 52px !important;
    }

    .leaderboard-cosmetic-ring.ouroboros {
      max-width: 48px !important;
      max-height: 48px !important;
    }

    .leaderboard-cosmetic-ring.waves,
    .leaderboard-cosmetic-ring.waves-static {
      max-width: 42px !important;
      max-height: 42px !important;
    }

    .leaderboard-cosmetic-ring:not(.castle):not(.castle-static):not(.ouroboros):not(.waves):not(.waves-static) {
      max-width: 46px !important;
      max-height: 46px !important;
    }

    .leaderboard-username {
      font-size: 14px;
    }

    .leaderboard-stats {
      font-size: 14px;
      gap: 6px;
    }

    .upload-meme-btn {
      font-size: 20px;
      padding: 16px 32px;
      gap: 12px;
      border-width: 3px;
      box-shadow: 0 8px 24px rgba(215,92,70,0.5), 0 0 0 3px var(--ink), 0 0 0 5px var(--accent);
    }

    .upload-meme-btn:hover {
      transform: scale(1.05) translateY(-4px);
      box-shadow: 0 12px 32px rgba(215,92,70,0.7), 0 0 0 3px var(--ink), 0 0 0 5px var(--accent);
    }

    .upload-icon {
      font-size: 28px;
    }

    .upload-reward {
      font-size: 18px;
      padding: 4px 12px;
    }

    .modal-container {
      max-width: calc(100vw - 32px);
      border-radius: 16px;
    }

    .modal-header {
      padding: 28px 20px 18px 20px;
    }

    .modal-title {
      font-size: 24px;
    }

    .modal-body {
      padding: 20px;
    }

    .modal-footer {
      padding: 18px 20px 28px 20px;
    }

    .modal-btn {
      font-size: 18px;
      padding: 12px 24px;
    }

    .empty-state {
      padding: 60px 20px;
      font-size: 16px;
    }
  }

  /* Extra small devices - iPhone SE, older phones */
  @media (max-width: 375px) {
    .meme-title {
      font-size: 24px;
    }

    .timer-countdown {
      font-size: 18px;
    }

    .timer-countdown span {
      min-width: 32px;
      font-size: 16px;
    }

    .meme-carousel {
      padding: 16px 4px;
      gap: 4px;
    }

    .carousel-nav {
      width: 28px;
      height: 28px;
      font-size: 14px;
      padding: 2px;
    }

    .meme-image {
      min-height: 400px !important;
      max-height: 600px !important;
    }

    .meme-vote-btn {
      font-size: 16px;
      padding: 10px 24px;
    }

    .leaderboard-meme-thumb {
      width: 80px;
      height: 80px;
    }

    .upload-meme-btn {
      font-size: 18px;
      padding: 14px 28px;
    }
  }

  /* Landscape mode adjustments */
  @media (max-width: 932px) and (orientation: landscape) {
    .meme-carousel {
      min-height: auto;
    }

    .meme-image {
      min-height: 400px !important;
      max-height: 600px !important;
    }

    .meme-carousel {
      flex-direction: row;
    }
  }
  /* ===== END MEME OF THE WEEK STYLES ===== */

  /* üî•üî•üî• ULTIMATE GLASSMORPHISM OVERRIDES - MUST BE LAST! üî•üî•üî• */

  /* Leaderboard Cards */
  .leaderboard-card {
    background: var(--glass-bg) !important;
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
    border: 1px solid var(--glass-border) !important;
    box-shadow: var(--elevation-2-glass);
    transition: all 0.4s var(--spring-butter);
    will-change: var(--will-change-transform);
    transform: var(--transform-gpu);
  }
  .leaderboard-card:hover {
    background: var(--glass-bg-heavy) !important;
    backdrop-filter: var(--glass-blur-heavy);
    -webkit-backdrop-filter: var(--glass-blur-heavy);
    border-color: var(--glass-border-hover) !important;
    box-shadow: var(--elevation-4-glass);
    transform: translateY(-4px) var(--transform-gpu);
  }

  /* Game Cards - Add glass background to inner divs */
  .game-card a > div {
    background: var(--glass-bg) !important;
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
    border: 1px solid var(--glass-border) !important;
    box-shadow: var(--elevation-2-glass);
    transition: all 0.4s var(--spring-butter);
    will-change: var(--will-change-transform);
    transform: var(--transform-gpu);
  }
  .game-card:hover a > div {
    background: var(--glass-bg-heavy) !important;
    backdrop-filter: var(--glass-blur-heavy);
    -webkit-backdrop-filter: var(--glass-blur-heavy);
    border-color: var(--glass-border-hover) !important;
    box-shadow: var(--elevation-5-glass), var(--glow-gold);
  }

  /* Bulletin Post Cards */
  .bulletin-post-card {
    background: var(--glass-bg) !important;
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
    border: 2px solid var(--glass-border) !important;
    box-shadow: var(--elevation-2-glass);
    transition: all 0.3s var(--spring-butter);
    will-change: var(--will-change-transform);
    transform: var(--transform-gpu);
  }
  .bulletin-post-card:hover {
    background: var(--glass-bg-heavy) !important;
    backdrop-filter: var(--glass-blur-heavy);
    -webkit-backdrop-filter: var(--glass-blur-heavy);
    border-color: var(--glass-border-hover) !important;
    box-shadow: var(--elevation-4-glass), var(--glow-honey);
  }

  /* Community User Cards (BEAR FRIENDS section) */
  .community-user-card {
    background: var(--glass-bg) !important;
    background-image: none !important;
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
    border: 3px solid var(--glass-border) !important;
    background-origin: padding-box;
    background-clip: padding-box;
    box-shadow: var(--elevation-2-glass);
    transition: all 0.35s var(--spring-butter);
    will-change: var(--will-change-transform);
    transform: var(--transform-gpu);
  }
  .community-user-card:hover {
    background: var(--glass-bg-heavy) !important;
    backdrop-filter: var(--glass-blur-heavy);
    -webkit-backdrop-filter: var(--glass-blur-heavy);
    border-color: var(--glass-border-hover) !important;
    box-shadow: var(--elevation-4-glass), var(--glow-gold);
  }

  /* Bear User Cards */
  .bear-user-card {
    background: var(--glass-bg) !important;
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
    border: 3px solid var(--glass-border) !important;
    box-shadow: var(--elevation-2-glass);
    transition: all 0.3s var(--spring-butter);
    will-change: var(--will-change-transform);
    transform: var(--transform-gpu);
  }
  .bear-user-card:hover {
    background: var(--glass-bg-heavy) !important;
    backdrop-filter: var(--glass-blur-heavy);
    -webkit-backdrop-filter: var(--glass-blur-heavy);
    border-color: var(--glass-border-hover) !important;
    box-shadow: var(--elevation-4-glass), var(--glow-gold);
  }

  /* Meme of the Week Container */
  .meme-leaderboard {
    background: var(--glass-bg) !important;
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
    border: 1px solid var(--glass-border) !important;
    box-shadow: var(--elevation-2-glass);
    border-radius: 16px;
    padding: 20px;
    transition: all 0.3s var(--spring-butter);
  }

  /* Modal Containers */
  .modal-container {
    background: var(--glass-bg-heavy) !important;
    backdrop-filter: var(--glass-blur-heavy);
    -webkit-backdrop-filter: var(--glass-blur-heavy);
    border: 4px solid var(--glass-border) !important;
    box-shadow: var(--elevation-5-glass), var(--glow-tri);
  }

  .profile-modal-content {
    background: var(--glass-bg-heavy) !important;
    background-image: none !important;
    backdrop-filter: var(--glass-blur-heavy);
    -webkit-backdrop-filter: var(--glass-blur-heavy);
    border: 4px solid var(--glass-border) !important;
    box-shadow: var(--elevation-5-glass), var(--glow-tri);
  }

  .bulletin-modal-content {
    background: var(--glass-bg-heavy) !important;
    backdrop-filter: var(--glass-blur-heavy);
    -webkit-backdrop-filter: var(--glass-blur-heavy);
    border: 3px solid var(--glass-border-hover) !important;
    box-shadow: var(--elevation-5-glass), var(--glow-gold);
  }

  /* Store Modal (already has glass from earlier, but ensure consistency) */
  .store-modal-content {
    backdrop-filter: var(--glass-blur-heavy) !important;
    -webkit-backdrop-filter: var(--glass-blur-heavy) !important;
  }

  /* Primary Buttons - Glass Enhancement */
  button.btn, .btn, button[class*="btn-"] {
    backdrop-filter: var(--glass-blur-light) !important;
    -webkit-backdrop-filter: var(--glass-blur-light) !important;
    transition: all 0.3s var(--spring-butter);
  }
  button.btn:hover, .btn:hover, button[class*="btn-"]:hover:not(:disabled) {
    backdrop-filter: var(--glass-blur) !important;
    -webkit-backdrop-filter: var(--glass-blur) !important;
    box-shadow: var(--elevation-3-glass);
    transform: translateY(-2px) var(--transform-gpu);
  }

  /* Input Fields - Glass Enhancement */
  input[type="text"],
  input[type="email"],
  input[type="password"],
  input[type="search"],
  textarea,
  select {
    background: var(--glass-bg-light) !important;
    backdrop-filter: var(--glass-blur-light) !important;
    -webkit-backdrop-filter: var(--glass-blur-light) !important;
    border: 1px solid var(--glass-border) !important;
    transition: all 0.3s var(--spring-smooth);
  }
  input[type="text"]:focus,
  input[type="email"]:focus,
  input[type="password"]:focus,
  input[type="search"]:focus,
  textarea:focus,
  select:focus {
    background: var(--glass-bg) !important;
    backdrop-filter: var(--glass-blur) !important;
    -webkit-backdrop-filter: var(--glass-blur) !important;
    border-color: var(--glass-border-hover) !important;
    box-shadow: var(--elevation-2-glass), var(--glow-honey);
  }

  /* Leaderboard Items - Glass Enhancement */
  .leaderboard-item {
    background: var(--glass-bg-light) !important;
    backdrop-filter: var(--glass-blur-light) !important;
    -webkit-backdrop-filter: var(--glass-blur-light) !important;
    border: 1px solid var(--glass-border) !important;
    transition: all 0.3s var(--spring-butter);
  }
  .leaderboard-item:hover {
    background: var(--glass-bg) !important;
    backdrop-filter: var(--glass-blur) !important;
    -webkit-backdrop-filter: var(--glass-blur) !important;
    border-color: var(--glass-border-hover) !important;
    box-shadow: var(--elevation-2-glass);
    transform: translateX(4px) var(--transform-gpu);
  }

  /* Raid Cards - Glass Enhancement */
  .raid-card {
    background: var(--glass-bg) !important;
    backdrop-filter: var(--glass-blur) !important;
    -webkit-backdrop-filter: var(--glass-blur) !important;
    border: 1px solid var(--glass-border) !important;
    box-shadow: var(--elevation-2-glass);
    transition: all 0.3s var(--spring-butter);
  }
  .raid-card:hover {
    background: var(--glass-bg-heavy) !important;
    backdrop-filter: var(--glass-blur-heavy) !important;
    -webkit-backdrop-filter: var(--glass-blur-heavy) !important;
    border-color: var(--glass-border-hover) !important;
    box-shadow: var(--elevation-4-glass), var(--glow-gold);
  }

  /* ===== END GLASSMORPHISM OVERRIDES ===== */

  </style>

  <!-- Twitter Widgets Script for Embedded Tweets -->
  <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

  <!-- PWA Push Notifications - PERFORMANCE: Added defer -->
  <script defer src="/frontend/push-notifications.js"></script>
</head>
<body>
  <!-- Fixed Top Navigation -->
  <div class="top-nav">
    <div class="top-nav-stripes">
      <div class="stripe-1"></div>
      <div class="stripe-2"></div>
      <div class="stripe-3"></div>
    </div>
    <div class="top-nav-bar">
      <button class="menu-btn" onclick="toggleMenu()" aria-label="Open menu">
        <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/1z14d9.jpg" alt="BEAR Park" width="52" height="52">
      </button>
      <div class="nav-buttons-container">
        <button class="notification-bell-btn" id="notificationBellBtn" onclick="toggleNotificationPanel()" aria-label="Notifications">
          <span id="bellIcon">üîî</span>
          <span class="notification-badge" id="notificationBadge" style="display: none;">0</span>
        </button>
        <button class="honey-points-btn" onclick="window.scrollTo({top: document.getElementById('honey-points').offsetTop - 80, behavior: 'smooth'})" title="Honey Points">
          <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="honey">
          <span id="welcomePoints">0</span>
        </button>
        <button class="welcome-profile-btn" id="welcomeBtn">
          <span id="welcomeUsername">WELCOME BEAR (click me!)</span>
          <div class="welcome-avatar-container" id="welcomeAvatarContainer" style="display: none;">
            <img class="welcome-avatar" id="welcomeAvatar" alt="Profile Avatar">
          </div>
        </button>

        <!-- Notification Panel -->
        <div class="notification-panel" id="notificationPanel">
          <div class="notification-panel-header">
            <h3>üîî NOTIFICATIONS</h3>
            <button class="notification-close-btn" onclick="toggleNotificationPanel()" aria-label="Close notifications">&times;</button>
          </div>
          <div class="notification-list" id="notificationList">
            <div class="notification-empty">
              <div class="notification-empty-icon">üîï</div>
              <p>No notifications yet!</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Menu Overlay -->
  <div class="menu-scrim" id="menuScrim" onclick="toggleMenu()"></div>
  <div class="menu-overlay" id="menuOverlay">
    <div class="menu-overlay-header">
      <h2><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/1z14d9.jpg" alt="BEAR PARK" style="height:2.5em; width:auto; border-radius:12px; display:inline-block;"></h2>
      <button class="menu-close-btn" onclick="toggleMenu()" aria-label="Close menu">&times;</button>
    </div>
    <div class="menu-items">
      <a href="#bear-overview" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">üìä</span>BEAR OVERVIEW
      </a>
      <a href="#honey-points" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="honey" style="height:1.2em; width:auto; display:inline-block;"></span>BEAR HONEY POINTS
      </a>
      <a href="#raids" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">ü™ñ</span>RAIDS
      </a>
      <a href="#cosmetics-store" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">üõçÔ∏è</span>BEAR STORE
      </a>
      <a href="#bearcade" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">üéÆ</span>BEARCADE
      </a>
      <a href="#leaderboards" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">üèÜ</span>LEADERBOARDS
      </a>
      <a href="#bulletin-board" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/25ekkd.png" alt="BEARpark" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"></span>BEAR BULLETIN BOARD
      </a>
      <a href="#meme-of-the-week" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">üé≠</span>MEME OF THE WEEK
      </a>
      <a href="#community" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">üêª</span>BEAR FRIENDS
      </a>
      <a href="#bg123" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">üìñ</span>BG123 LORE
      </a>
      <a href="#nfts" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">üñºÔ∏è</span>NFT COLLECTIONS
      </a>
      <a href="#community" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">üë•</span>COMMUNITY
      </a>
      <a href="#memes" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon">üé≠</span>5D MEMES
      </a>
      <a href="#network" class="menu-item" onclick="toggleMenu()">
        <span class="menu-item-icon"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png" alt="BEAR" style="height:1.2em; width:auto; display:inline-block;"></span>BUY $BEAR
      </a>
    </div>
  </div>

  <a class="skip-link" href="#bearcade">Skip to BEARcade</a>

  <!-- Sticky nav -->
  <div class="site-nav" role="navigation" aria-label="Primary">
    <div class="progress" id="progress"></div>
    <div class="bar">
      <a class="brand" href="#top" aria-label="BEAR Park Home">
        <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/25ekkd.png" width="72" height="72" alt="BEAR Park logo" loading="eager" decoding="sync" />
        <span>BEAR Park</span>
      </a>
      <nav class="links" aria-label="Sections">
        <a href="#honey-points"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"> Honey Points</a>
        <a href="#raids">ü™ñ Raids</a>
        <a href="#cosmetics-store">üõçÔ∏è Store</a>
        <a href="#bearcade">BEARcade</a>
        <a href="#leaderboards">üèÜ Leaderboards</a>
        <a href="#bulletin-board"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/25ekkd.png" alt="BEARpark" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"> Bulletin Board</a>
        <a href="#meme-of-the-week">üé≠ Meme of the Week</a>
        <a href="#bg123">BG123</a>
        <a href="#nfts">NFTs</a>
        <a href="#community">Community</a>
        <a href="#memes">5D Memes</a>
        <a href="#network">Network</a>
      </nav>
      <div class="nav-cta">
        <a class="btn gold" href="#network">Buy $BEAR</a>
      </div>
    </div>
  </div>

  <!-- HERO -->
  <header class="hero" role="banner" style="position: relative;">
    <!-- BEAR PARK SIGN -->
    <div id="woodenSignContainer">
      <img id="woodenSign" src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/25ekkd.png" alt="BEAR PARK wooden sign">
    </div>

    <!-- üéØ NAVIGATION BUTTON üéØ -->
    <div id="whereToGoBtn" onclick="openNavigationModal()">
      <div class="where-to-go-text">WHERE WOULD YOU LIKE TO GO?</div>
    </div>

    <!-- üêªüèôÔ∏è BEAR CITY INHABITANTS üèôÔ∏èüêª -->
    <div id="bearCityContainer" aria-hidden="true"></div>
  </header>

  <!-- BEAR OVERVIEW -->
  <section class="alt" id="bear-overview" style="padding-top:2px;">
    <div class="wrap reveal">
      <div style="text-align:center; margin-bottom:16px; margin-top:-20px;">
        <h2 class="h2" style="font-size:clamp(42px, 5vw, 64px); margin:0; display:flex; align-items:center; justify-content:center; gap:16px;">
          <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/khrawi.png" alt="BEAR Coin" style="width:clamp(50px, 6vw, 70px); height:auto;">
          OVERVIEW
        </h2>
      </div>
      <p style="text-align:center;margin:0 0 20px;opacity:0.9;font-size:clamp(18px, 2.5vw, 22px);font-weight:700;">Live $BEAR price, market stats, chart, and liquidity pool.</p>

      <!-- Main Chart Area -->
      <div class="honey-card" style="margin-bottom:20px; padding:20px 20px 0 20px; overflow:hidden;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
          <h3 class="honey-card-title" style="margin:0;">üìà Live Chart</h3>
          <a href="https://dexscreener.com/xrpl/4245415200000000000000000000000000000000.rbearguasyu7tuw53rufqzfdwmjhpjeqfw_xrp"
             target="_blank"
             rel="noopener noreferrer"
             style="display:inline-flex; align-items:center; gap:6px; padding:8px 16px; background:var(--gold); color:#000; border-radius:8px; font-size:12px; font-weight:900; text-transform:uppercase; transition:all 0.2s; border:2px solid transparent; border-image: var(--tri-gradient) 1;"
             onmouseover="this.style.background='#ffca3a'"
             onmouseout="this.style.background='var(--gold)'">
            <span>üìä View Transactions</span>
          </a>
        </div>
        <div class="chart-container">
          <div id="chart-error" style="display:none;">
            <div style="padding:40px; text-align:center; color:var(--gold); background:rgba(0,0,0,0.5); border-radius:12px; height:800px; display:flex; flex-direction:column; align-items:center; justify-content:center;">
              <div style="font-size:48px; margin-bottom:16px;">üìä</div>
              <div style="font-size:18px; font-weight:900; margin-bottom:12px;">Chart Loading Issue</div>
              <div style="opacity:0.8; margin-bottom:20px;">The embedded chart may be blocked by your browser settings.</div>
              <a href="https://dexscreener.com/xrpl/4245415200000000000000000000000000000000.rbearguasyu7tuw53rufqzfdwmjhpjeqfw_xrp"
                 target="_blank"
                 rel="noopener noreferrer"
                 class="btn gold">
                View Full Chart on DexScreener
              </a>
            </div>
          </div>
          <iframe
            id="dexscreener-embed"
            src="https://dexscreener.com/xrpl/4245415200000000000000000000000000000000.rbearguasyu7tuw53rufqzfdwmjhpjeqfw_xrp?embed=1&theme=dark&trades=0&info=0"
            style="width:100%; height:590px; border:0; border-radius:12px; background:#000; display:block;"
            title="DexScreener Chart"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowfullscreen
          ></iframe>
        </div>
      </div>

      <!-- Stats Grid Below Chart -->
      <div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:20px;" class="stats-grid-bottom">
        <!-- Stats Sidebar -->
          <!-- USD Metrics Card -->
          <div class="honey-card" style="margin-bottom:20px;">
            <h3 class="honey-card-title">üíµ USD METRICS</h3>
            <div class="stats-list">
              <div class="stat-item">
                <div class="stat-label" style="white-space: nowrap; display: inline-flex; align-items: center; gap: 4px;"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png" alt="BEAR" style="height:0.9em; width:auto; display:inline-block;">BEAR / üíµ USD</div>
                <div class="stat-value" id="honeyPriceUsd">‚Äî</div>
              </div>
              <div class="stat-item">
                <div class="stat-label">24H CHANGE</div>
                <div class="stat-value" id="honeyChange24h">‚Äî</div>
              </div>
              <div class="stat-item">
                <div class="stat-label">üíµ 24H VOLUME</div>
                <div class="stat-value" id="honeyVolume">‚Äî</div>
              </div>
              <div class="stat-item">
                <div class="stat-label">üíµ MARKET CAP</div>
                <div class="stat-value" id="honeyMcap">‚Äî</div>
              </div>
            </div>
          </div>

          <!-- XRP Metrics Card -->
          <div class="honey-card" style="margin-bottom:20px;">
            <h3 class="honey-card-title" style="display:inline-flex; align-items:center; gap:6px;"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/lufprf.png" alt="XRP" style="height:1em; width:auto; display:inline-block;">XRP METRICS</h3>
            <div class="stats-list">
              <div class="stat-item">
                <div class="stat-label" style="white-space: nowrap; display: inline-flex; align-items: center; gap: 4px;"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png" alt="BEAR" style="height:0.9em; width:auto; display:inline-block;">BEAR / <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/lufprf.png" alt="XRP" style="height:0.9em; width:auto; display:inline-block;">XRP</div>
                <div class="stat-value" id="honeyPriceXrp">‚Äî</div>
              </div>
              <div class="stat-item">
                <div class="stat-label">24H CHANGE</div>
                <div class="stat-value" id="honeyChange24hXrp">‚Äî</div>
              </div>
              <div class="stat-item">
                <div class="stat-label" style="white-space: nowrap; display: inline-flex; align-items: center; gap: 4px;"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/lufprf.png" alt="XRP" style="height:0.9em; width:auto; display:inline-block;">XRP 24H VOLUME</div>
                <div class="stat-value" id="honeyVolumeXrp">‚Äî</div>
              </div>
              <div class="stat-item">
                <div class="stat-label" style="white-space: nowrap; display: inline-flex; align-items: center; gap: 4px;"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/lufprf.png" alt="XRP" style="height:0.9em; width:auto; display:inline-block;">XRP MARKET CAP</div>
                <div class="stat-value" id="honeyMcapXrp">‚Äî</div>
              </div>
            </div>
          </div>

          <!-- Liquidity Pool -->
          <div class="honey-card">
            <h3 class="honey-card-title">üíß Liquidity Pool</h3>
            <div class="stats-list">
              <div class="stat-item">
                <div class="stat-label" style="white-space: nowrap; display: inline-flex; align-items: center; gap: 4px;"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png" alt="BEAR" style="height:0.9em; width:auto; display:inline-block;">BEAR Liquidity</div>
                <div class="stat-value" id="liquidityBear">‚Äî</div>
              </div>
              <div class="stat-item">
                <div class="stat-label" style="white-space: nowrap; display: inline-flex; align-items: center; gap: 4px;"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/lufprf.png" alt="XRP" style="height:0.9em; width:auto; display:inline-block;">XRP Liquidity</div>
                <div class="stat-value" id="liquidityXrp">‚Äî</div>
              </div>
              <div class="stat-item">
                <div class="stat-label" style="white-space: nowrap;">üíµ USD Value</div>
                <div class="stat-value" id="liquidityUsd">‚Äî</div>
              </div>
              <div class="stat-item">
                <div class="stat-label" style="white-space: nowrap;">üìä Liq/MCap Ratio</div>
                <div class="stat-value" id="liquidityMcapRatio">‚Äî</div>
              </div>
            </div>
          </div>
      </div>

      <style>
        .trading-activity-card {
          max-width: 100%;
        }
        .trading-activity-grid {
          display: flex;
          flex-direction: column;
          gap: 16px;
        }
        .trading-row {
          display: grid;
          grid-template-columns: repeat(3, 1fr);
          gap: 12px;
          padding: 12px;
          background: rgba(255,255,255,0.03);
          border-radius: 12px;
          border: 1px solid rgba(255,255,255,0.08);
        }
        .trading-stat {
          text-align: center;
        }
        .trading-label {
          font-size: 11px;
          color: rgba(255,255,255,0.5);
          text-transform: uppercase;
          letter-spacing: 0.5px;
          margin-bottom: 6px;
        }
        .trading-value {
          font-size: 16px;
          font-weight: 800;
          color: #fff;
        }
        .trading-value.green {
          color: #22c55e;
        }
        .trading-value.red {
          color: #ef4444;
        }
        .trading-progress {
          padding: 0 12px;
        }
        .trading-progress-bar {
          display: flex;
          height: 8px;
          background: rgba(0,0,0,0.3);
          border-radius: 4px;
          overflow: hidden;
        }
        .progress-buy {
          background: linear-gradient(90deg, #22c55e, #16a34a);
          transition: width 0.5s ease;
        }
        .progress-sell {
          background: linear-gradient(90deg, #ef4444, #dc2626);
          transition: width 0.5s ease;
        }
        @media (max-width: 1024px) {
          .stats-grid-bottom {
            grid-template-columns: 1fr !important;
          }
        }
        @media (max-width: 768px) {
          .stats-grid-bottom {
            grid-template-columns: 1fr !important;
          }
          .trading-row {
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
          }
          .trading-value {
            font-size: 14px;
          }
        }
      </style>
    </div>
  </section>

  <section class="dark" id="sec-m7">
    <div class="wrap reveal">
      <h2 class="h2" id="m7Title">?????</h2>
      <p style="text-align:center;margin:-6px 0 32px;opacity:0.9;" id="m7Sub">?????</p>

      <div class="honey-card m7-card">
        <div class="m7-grid">
          <div class="m7-item">
            <div class="m7-icon">?</div>
            <div class="m7-info">
              <div class="m7-label">?????</div>
              <div class="m7-val" id="m7v1">?????</div>
              <div class="m7-rew" id="m7r1">‚Üí ?????</div>
            </div>
          </div>

          <div class="m7-item">
            <div class="m7-icon">?</div>
            <div class="m7-info">
              <div class="m7-label">?????</div>
              <div class="m7-val" id="m7v2">?????</div>
              <div class="m7-rew" id="m7r2">‚Üí ?????</div>
            </div>
          </div>

          <div class="m7-item">
            <div class="m7-icon">?</div>
            <div class="m7-info">
              <div class="m7-label">?????</div>
              <div class="m7-val" id="m7v3">?????</div>
              <div class="m7-rew" id="m7r3">‚Üí ?????</div>
            </div>
          </div>
        </div>

        <div class="m7-tot">
          <div class="m7-tot-lbl">?????</div>
          <div class="m7-tot-val" id="m7Total">?????</div>
        </div>

        <div class="m7-prog">
          <div class="m7-prog-hdr">
            <span class="m7-prog-lbl">?????</span>
            <span class="m7-prog-cnt" id="m7ProgCnt">??/??</span>
          </div>
          <div class="m7-prog-bar">
            <div class="m7-prog-fill" id="m7ProgFill" style="width: 0%"></div>
          </div>
          <div class="m7-prog-hint" id="m7Hint">?????</div>
        </div>

        <button class="m7-btn" id="m7Btn" disabled>
          <span id="m7BtnTxt">?????????</span>
        </button>

        <div class="m7-timer" id="m7Timer" style="display: none;">
          <span id="m7TimerText">Next snapshot coming soon...</span>
        </div>

        <div class="m7-dropdown" id="m7Dropdown">
          <button class="m7-dropdown-toggle" id="m7InfoToggle" onclick="document.getElementById('m7InfoContent').classList.toggle('hidden'); this.querySelector('.m7-dropdown-arrow').classList.toggle('open');">
            <span>‚ùì How do $BEARdrops work?</span>
            <span class="m7-dropdown-arrow">‚ñº</span>
          </button>
          <div class="m7-dropdown-content hidden" id="m7InfoContent">
            <div class="m7-dropdown-section">
              <div class="m7-dropdown-header">üéÅ COMMUNITY APPRECIATION GIFTS</div>
              <div class="m7-dropdown-item" style="font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 8px;">These are personal, discretionary gifts from fellow community members' own holdings ‚Äî not from the $BEAR project, any token issuer, or any company.</div>
              <div class="m7-dropdown-item" style="font-size: 12px; color: rgba(255,255,255,0.7); margin-bottom: 4px;">Gift amounts may consider one or more signals (which can change over time), including:</div>
              <div class="m7-dropdown-item">üêª NFT holdings (e.g., Pixel Bears)</div>
              <div class="m7-dropdown-item">üíé Ultra Rare NFT holdings</div>
              <div class="m7-dropdown-item">üíß On-chain participation (including liquidity-related activity)</div>
              <div class="m7-dropdown-item">üéÆ Community participation signals</div>
            </div>
            <div class="m7-dropdown-section">
              <div class="m7-dropdown-header">ü§ù COMMUNITY PARTICIPATION</div>
              <div class="m7-dropdown-item">Gifts are available only to wallets showing genuine participation.</div>
              <div class="m7-dropdown-item" style="font-size: 12px; color: rgba(255,255,255,0.6);">Activity signals help reduce abuse ‚Äî they are not compensation for services.</div>
            </div>
            <div class="m7-dropdown-section m7-warning-section">
              <div class="m7-dropdown-header">üìã IMPORTANT</div>
              <div class="m7-dropdown-item">‚ö†Ô∏è This program may be <strong>modified, paused, or discontinued</strong> at any time</div>
              <div class="m7-dropdown-item">‚ö†Ô∏è Amounts are <strong>discretionary, not guaranteed</strong>, and may vary</div>
              <div class="m7-dropdown-item">‚ö†Ô∏è Past distributions do <strong>not guarantee</strong> future distributions</div>
              <div class="m7-dropdown-item">‚ö†Ô∏è Nothing here creates a <strong>contract, entitlement, or right</strong> to receive gifts</div>
              <div class="m7-dropdown-item">üé≤ Snapshots occur at <strong>random times</strong></div>
              <div class="m7-dropdown-item m7-danger">‚è∞ Unclaimed gifts <strong>expire after 24 hours</strong></div>
            </div>
            <div class="m7-dropdown-disclaimer">
              ‚öñÔ∏è <strong>DISCLAIMER:</strong> This is a community appreciation gesture ‚Äî not a yield program, staking reward, investment opportunity, or financial product. Please don't buy, hold, or provide liquidity expecting gifts; gifts are voluntary and may stop at any time.
            </div>
          </div>
        </div>

        <div class="m7-overlay" id="m7Overlay">
          <div class="m7-overlay-glow">?</div>
          <div class="m7-overlay-dots">?????</div>
        </div>
      </div>
    </div>

    <style>
      /* ===== BEARDROPS MATERIAL UI 6 LUXURY THEME ===== */

      /* Animations */
      @keyframes shimmer {
        0% { left: -100%; }
        100% { left: 100%; }
      }

      @keyframes pulse-glow {
        0%, 100% {
          box-shadow: 0 4px 0 #5B21B6, 0 8px 24px rgba(139, 92, 246, 0.4);
        }
        50% {
          box-shadow: 0 4px 0 #5B21B6, 0 8px 32px rgba(139, 92, 246, 0.6), 0 0 40px rgba(139, 92, 246, 0.3);
        }
      }

      @keyframes float {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-4px); }
      }

      @keyframes m7Pulse {
        0%, 100% {
          transform: scale(1);
          text-shadow:
            0 0 20px rgba(139,92,246,0.8),
            0 0 40px rgba(139,92,246,0.6),
            0 0 60px rgba(139,92,246,0.4),
            0 0 80px rgba(139,92,246,0.2);
        }
        50% {
          transform: scale(1.1);
          text-shadow:
            0 0 30px rgba(139,92,246,1),
            0 0 60px rgba(139,92,246,0.8),
            0 0 90px rgba(139,92,246,0.6),
            0 0 120px rgba(139,92,246,0.4);
        }
      }

      /* Main Card - Glassmorphism */
      .m7-card {
        max-width: 620px;
        margin: 0 auto;
        padding: 32px;
        position: relative;
        overflow: hidden;
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.12), rgba(168, 85, 247, 0.06));
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid rgba(139, 92, 246, 0.25);
        border-radius: 28px;
        box-shadow:
          0 8px 32px rgba(139, 92, 246, 0.2),
          0 0 80px rgba(139, 92, 246, 0.1),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }

      .m7-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-image:
          radial-gradient(circle, rgba(139,92,246,0.15) 1px, transparent 1px),
          radial-gradient(circle, rgba(139,92,246,0.1) 1px, transparent 1px);
        background-size: 50px 50px, 30px 30px;
        background-position: 0 0, 15px 15px;
        pointer-events: none;
        opacity: 0.4;
      }

      .m7-grid {
        display: flex;
        flex-direction: column;
        gap: 14px;
        margin-bottom: 24px;
      }

      /* Item Cards - Elevated Glass */
      .m7-item {
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 18px 20px;
        background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
        backdrop-filter: blur(10px);
        border: 1px solid rgba(139, 92, 246, 0.3);
        border-radius: 16px;
        box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .m7-item:hover {
        transform: translateY(-3px);
        border-color: rgba(139, 92, 246, 0.5);
        box-shadow: 0 8px 28px rgba(139, 92, 246, 0.3);
        background: linear-gradient(135deg, rgba(255,255,255,0.12), rgba(255,255,255,0.04));
      }

      .m7-icon {
        font-size: 36px;
        min-width: 55px;
        text-align: center;
        filter: drop-shadow(0 0 12px rgba(251, 191, 36, 0.6));
        animation: float 3s ease-in-out infinite;
      }

      .m7-info {
        flex: 1;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 8px;
      }

      .m7-label {
        font-size: 15px;
        font-weight: 600;
        color: rgba(255,255,255,0.8);
        min-width: 100px;
      }

      .m7-val {
        font-size: 22px;
        font-weight: 800;
        color: #FBBF24;
        text-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
      }

      .m7-rew {
        font-size: 14px;
        color: #A78BFA;
        font-weight: 700;
        text-shadow: 0 0 10px rgba(167, 139, 250, 0.4);
      }

      /* Total Gift Box - Premium Gradient with Shimmer */
      .m7-tot {
        text-align: center;
        padding: 28px;
        background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 50%, #6D28D9 100%);
        border-radius: 20px;
        border: 2px solid rgba(251, 191, 36, 0.5);
        margin-bottom: 24px;
        position: relative;
        overflow: hidden;
        box-shadow:
          0 8px 32px rgba(139, 92, 246, 0.4),
          0 0 60px rgba(139, 92, 246, 0.2),
          inset 0 2px 0 rgba(255,255,255,0.2);
      }

      .m7-tot::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.25), transparent);
        animation: shimmer 3s infinite;
      }

      .m7-tot-lbl {
        font-size: 13px;
        color: rgba(255,255,255,0.85);
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 8px;
        font-weight: 600;
        position: relative;
        z-index: 1;
      }

      .m7-tot-val {
        font-family: 'Luckiest Guy', cursive;
        font-size: 48px;
        font-weight: 400;
        color: #FBBF24;
        -webkit-text-stroke: 3px #000;
        paint-order: stroke fill;
        text-shadow:
          0 0 20px rgba(251, 191, 36, 0.9),
          0 0 40px rgba(251, 191, 36, 0.6),
          0 0 60px rgba(251, 191, 36, 0.4);
        position: relative;
        z-index: 1;
      }

      /* Progress Bar */
      .m7-prog {
        margin-bottom: 24px;
      }

      .m7-prog-hdr {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .m7-prog-lbl {
        font-size: 14px;
        color: rgba(255,255,255,0.8);
        font-weight: 600;
      }

      .m7-prog-cnt {
        font-size: 16px;
        font-weight: 800;
        color: #FBBF24;
        text-shadow: 0 0 10px rgba(251, 191, 36, 0.4);
      }

      .m7-prog-bar {
        height: 14px;
        background: rgba(139, 92, 246, 0.2);
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid rgba(139, 92, 246, 0.3);
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
      }

      .m7-prog-fill {
        height: 100%;
        background: linear-gradient(90deg, #8B5CF6, #A855F7, #FBBF24);
        border-radius: 10px;
        box-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
        transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
      }

      .m7-prog-fill::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
        animation: shimmer 2s infinite;
      }

      .m7-prog-hint {
        font-size: 13px;
        color: rgba(255,255,255,0.6);
        text-align: center;
        margin-top: 10px;
        font-weight: 500;
      }

      /* Button - Glowing CTA */
      .m7-btn {
        width: 100%;
        padding: 20px 32px;
        font-size: 18px;
        font-weight: 800;
        border: none;
        border-radius: 16px;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        text-transform: uppercase;
        letter-spacing: 1px;
        font-family: var(--font-body);
        position: relative;
        overflow: hidden;
      }

      .m7-btn:disabled {
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(139, 92, 246, 0.15));
        color: rgba(255,255,255,0.4);
        cursor: not-allowed;
        box-shadow: none;
      }

      .m7-btn:not(:disabled) {
        background: linear-gradient(135deg, #8B5CF6, #7C3AED);
        color: #fff;
        box-shadow: 0 4px 0 #5B21B6, 0 8px 24px rgba(139, 92, 246, 0.4);
        animation: pulse-glow 2s infinite;
      }

      .m7-btn:not(:disabled):hover {
        transform: translateY(-3px);
        box-shadow: 0 7px 0 #5B21B6, 0 14px 36px rgba(139, 92, 246, 0.5);
      }

      .m7-btn:not(:disabled):active {
        transform: translateY(2px);
        box-shadow: 0 2px 0 #5B21B6, 0 4px 12px rgba(139, 92, 246, 0.3);
      }

      .m7-btn.claimed {
        background: linear-gradient(135deg, #4B5563, #374151) !important;
        color: #9CA3AF !important;
        cursor: not-allowed !important;
        box-shadow: none !important;
        animation: none !important;
      }

      .m7-btn.claimed:hover {
        transform: none !important;
      }

      /* Timer */
      .m7-timer {
        text-align: center;
        padding: 14px 20px;
        margin-top: 14px;
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.15), rgba(139, 92, 246, 0.05));
        backdrop-filter: blur(10px);
        border: 1px solid rgba(139, 92, 246, 0.3);
        border-radius: 14px;
        color: #A78BFA;
        font-size: 14px;
        font-weight: 500;
      }

      .m7-timer-icon {
        margin-right: 6px;
      }

      .m7-timer strong {
        font-family: monospace;
        font-size: 16px;
        letter-spacing: 1px;
        color: #FBBF24;
      }

      /* Info styles */
      .m7-info-title {
        font-weight: 700;
        font-size: 14px;
        color: #A78BFA;
        margin-bottom: 12px;
      }

      .m7-info-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .m7-info-item {
        font-size: 13px;
        color: rgba(255,255,255,0.7);
        line-height: 1.4;
      }

      .m7-info-item strong {
        color: #fff;
      }

      /* Dropdown */
      .m7-dropdown {
        margin-top: 20px;
      }

      .m7-dropdown-toggle {
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px 20px;
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(139, 92, 246, 0.08));
        border: 1px solid rgba(139, 92, 246, 0.35);
        border-radius: 14px;
        color: #A78BFA;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .m7-dropdown-toggle:hover {
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(139, 92, 246, 0.15));
        border-color: rgba(139, 92, 246, 0.5);
        transform: translateY(-2px);
        box-shadow: 0 4px 16px rgba(139, 92, 246, 0.2);
      }

      .m7-dropdown-arrow {
        font-size: 12px;
        transition: transform 0.3s ease;
        color: #FBBF24;
      }

      .m7-dropdown-arrow.open {
        transform: rotate(180deg);
      }

      .m7-dropdown-content {
        margin-top: 12px;
        padding: 24px;
        background: linear-gradient(135deg, rgba(20, 10, 35, 0.95), rgba(30, 15, 50, 0.9));
        backdrop-filter: blur(20px);
        border-radius: 16px;
        border: 1px solid rgba(139, 92, 246, 0.3);
        box-shadow: 0 16px 48px rgba(0,0,0,0.4);
      }

      .m7-dropdown-content.hidden {
        display: none;
      }

      .m7-dropdown-section {
        margin-bottom: 20px;
        background: rgba(139, 92, 246, 0.08);
        border-radius: 12px;
        padding: 16px;
        border: 1px solid rgba(139, 92, 246, 0.15);
      }

      .m7-dropdown-section:last-child {
        margin-bottom: 0;
      }

      .m7-dropdown-header {
        font-size: 14px;
        font-weight: 700;
        color: #A78BFA;
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 1px solid rgba(139, 92, 246, 0.25);
      }

      .m7-dropdown-item {
        font-size: 13px;
        color: rgba(255,255,255,0.8);
        line-height: 1.6;
        margin-bottom: 8px;
      }

      .m7-dropdown-item:last-child {
        margin-bottom: 0;
      }

      .m7-dropdown-item strong {
        color: #FBBF24;
      }

      .m7-danger {
        color: #F87171 !important;
        font-weight: 600;
      }

      .m7-warning-section {
        background: rgba(239, 68, 68, 0.1) !important;
        border: 1px solid rgba(239, 68, 68, 0.3) !important;
        border-radius: 12px;
        padding: 16px;
        margin-top: 4px;
      }

      .m7-warning-section .m7-dropdown-header {
        color: #F87171;
        border-bottom-color: rgba(239, 68, 68, 0.3);
      }

      .m7-dropdown-disclaimer {
        margin-top: 16px;
        padding: 14px 16px;
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(139, 92, 246, 0.05));
        border-radius: 10px;
        border-left: 4px solid #8B5CF6;
        font-size: 12px;
        color: rgba(255,255,255,0.65);
        line-height: 1.6;
        font-style: italic;
      }

      .m7-dropdown-disclaimer strong {
        color: #FBBF24;
      }

      /* Overlay */
      .m7-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(15, 10, 25, 0.98), rgba(20, 12, 35, 0.98));
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        padding: 32px;
        border-radius: 28px;
      }

      .m7-overlay.hidden {
        display: none;
      }

      .m7-overlay-glow {
        font-size: 120px;
        font-weight: 900;
        color: #8B5CF6;
        text-shadow:
          0 0 20px rgba(139,92,246,0.8),
          0 0 40px rgba(139,92,246,0.6),
          0 0 60px rgba(139,92,246,0.4),
          0 0 80px rgba(139,92,246,0.2);
        animation: m7Pulse 2s ease-in-out infinite;
        margin-bottom: 16px;
      }

      .m7-overlay-dots {
        font-size: 32px;
        font-weight: 800;
        color: rgba(139, 92, 246, 0.5);
        letter-spacing: 8px;
      }

      /* Responsive */
      @media (max-width: 600px) {
        .m7-card {
          padding: 24px 20px;
          border-radius: 20px;
        }

        .m7-info {
          flex-direction: column;
          align-items: flex-start;
        }

        .m7-tot-val {
          font-size: 36px;
          -webkit-text-stroke: 2px #000;
        }

        .m7-btn {
          padding: 16px 24px;
          font-size: 16px;
        }
      }
    </style>
  </section>

  <!-- BEAR HONEY POINTS -->
  <section class="dark" id="honey-points">
    <div class="wrap reveal">
      <h2 class="h2"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"> BEAR HONEY POINTS</h2>
      <p style="text-align:center;margin:-6px 0 32px;opacity:0.9;">earn honey points by raiding, playing games, having your meme voted as the "meme of the week" and other fun giveaways!</p>

      <div class="honey-points-grid">
        <!-- My Points Card -->
        <div class="honey-card my-points-card">
            <h3 class="honey-card-title"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"> My Honey Points</h3>
            <div id="myPointsContent">
              <!-- Total Points Hero -->
              <div class="points-hero">
                <div class="points-hero-value" id="totalHoneyPoints">0</div>
                <div class="points-hero-label">TOTAL HONEY POINTS EARNED</div>
              </div>

              <!-- Points Breakdown -->
              <div class="points-breakdown">
                <div class="points-breakdown-item">
                  <div class="points-breakdown-icon">ü™ñ</div>
                  <div class="points-breakdown-content">
                    <div class="points-breakdown-label">Honey Earned from Raiding</div>
                    <div class="points-breakdown-value" id="raidingPoints">0 PTS</div>
                  </div>
                </div>

                <div class="points-breakdown-item">
                  <div class="points-breakdown-icon">üéÆ</div>
                  <div class="points-breakdown-content">
                    <div class="points-breakdown-label">Honey Earned from Games</div>
                    <div class="points-breakdown-value" id="gamesPoints">0 PTS</div>
                  </div>
                </div>
              </div>

              <!-- Daily Game Progress -->
              <div class="daily-game-progress">
                <div class="daily-progress-header">
                  <span class="daily-progress-title">üïπÔ∏èüÉè Today's Game Progress</span>
                  <span class="daily-progress-count" id="dailyGameCount">0/20</span>
                </div>
                <div class="daily-progress-bar-container">
                  <div class="daily-progress-bar" id="dailyProgressBar" style="width: 0%"></div>
                </div>
                <div class="daily-progress-info">
                  <span class="daily-progress-points" id="dailyGamePoints">0 pts earned today</span>
                  <span class="daily-progress-remaining" id="dailyGamesRemaining">20 mins left</span>
                </div>
                <div class="daily-reset-timer" id="dailyResetTimer" style="text-align: center; margin-top: 10px; font-size: 12px; color: rgba(237,183,35,0.8);">
                  ‚è∞ Resets in <span id="dailyResetCountdown">--:--:--</span> (00:00 UTC)
                </div>
              </div>

              <!-- Your Rank -->
              <div class="points-rank">
                <span>Your Rank: <strong id="myRank">‚Äî</strong></span>
              </div>
            </div>
          </div>

        <!-- Leaderboard -->
        <div class="honey-card leaderboard-card">
          <h3 class="honey-card-title">üèÜ Top Honey Earners</h3>
          <div class="leaderboard" id="honeyLeaderboard">
            <div class="leaderboard-loading">Loading leaderboard...</div>
          </div>
        </div>

      </div>
    </div>
  </section>

  <!-- RAIDS SECTION - GODMODE EDITION -->
  <section class="alt" id="raids">
    <div class="wrap reveal">
      <h2 class="h2">üêª ü™ñ RAIDS</h2>
      <p style="text-align:center;margin:-6px 0 32px;opacity:0.9;">Join active raids to earn honey points and support the BEAR community!</p>

      <!-- Raid Performance Stats -->
      <div class="raid-performance-stats" id="raidPerformanceStats" style="display:none;">
        <div class="honey-card" style="margin-bottom:24px;">
          <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:20px; text-align:center;">
            <div class="stat-box">
              <div class="stat-icon">üéØ</div>
              <div class="stat-value" id="userRaidsCompleted">0</div>
              <div class="stat-label">Raids Completed</div>
            </div>
            <div class="stat-box">
              <div class="stat-icon">üçØ</div>
              <div class="stat-value" id="userRaidPoints">0</div>
              <div class="stat-label">Points Earned</div>
            </div>
            <div class="stat-box">
              <div class="stat-icon">üî•</div>
              <div class="stat-value" id="userRaidStreak">0</div>
              <div class="stat-label">Current Streak</div>
            </div>
            <div class="stat-box">
              <div class="stat-icon">üèÜ</div>
              <div class="stat-value" id="userRaidRank">-</div>
              <div class="stat-label">Your Rank</div>
            </div>
          </div>
        </div>
      </div>

      <!-- TOP RAIDERS Leaderboard -->
      <div class="honey-card top-raiders-container">
        <div class="top-raiders-header">
          <div class="top-raiders-title">
            <span>üèÜ</span> TOP RAIDERS
          </div>
          <span style="font-size:12px; color:rgba(255,255,255,0.5);">All-time rankings</span>
        </div>
        <div class="top-raiders-scroll" id="topRaidersScroll">
          <div class="raiders-loading">Loading raiders...</div>
        </div>
      </div>

      <!-- Filter Controls -->
      <div class="honey-card" style="margin-bottom:24px;">
        <div style="display:flex; gap:16px; align-items:center; flex-wrap:wrap; justify-content:center;">
          <button class="raid-filter-btn active" data-filter="active" onclick="filterRaids('active')">
            ‚ö° ACTIVE RAIDS
          </button>
          <button class="raid-filter-btn" data-filter="completed" onclick="filterRaids('completed')">
            ‚úÖ MY COMPLETED
          </button>
          <button class="raid-filter-btn" data-filter="expired" onclick="filterRaids('expired')">
            ‚è∞ EXPIRED
          </button>
          <button class="admin-raid-btn" id="adminRaidBtn" style="display:none;" onclick="window.location.href='/admin-raids.html'">
            üéØ START RAID
          </button>
        </div>
      </div>

      <!-- Raids Grid -->
      <div class="raids-grid" id="raidsGrid">
        <div class="raids-loading">Loading raids...</div>
      </div>

      <!-- Expanded Tweet Modal -->
      <div id="raidTweetModal" class="raid-tweet-modal" style="display:none;" onclick="closeRaidModal()">
        <div class="raid-tweet-modal-content" onclick="event.stopPropagation()">
          <button class="raid-modal-close" onclick="closeRaidModal()">&times;</button>
          <div id="raidTweetContainer"></div>
        </div>
      </div>
    </div>
  </section>

  <!-- BEAR STORE -->
  <section class="dark" id="cosmetics-store" style="background: linear-gradient(rgba(0,0,0,0.65), rgba(0,0,0,0.65)), url('https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/v2jedg.png'); background-size: cover; background-position: center; background-repeat: no-repeat; padding: 80px 0;">
    <div class="wrap reveal">
      <h2 class="h2">üõçÔ∏è BEAR STORE</h2>
      <p style="text-align:center;margin:-6px 0 32px;opacity:0.9;">Customize your profile with legendary rings and banners using your Honey Points!</p>

      <div style="text-align:center; margin-bottom:32px; display:flex; gap:16px; justify-content:center; flex-wrap:wrap;">
        <button id="openMerchStoreBtn" class="btn" onclick="openMerchStoreModal()" style="background:linear-gradient(135deg, #680cd9, #00ff88); padding: 12px 20px; color:#fff;">
          üëï MERCH STORE
        </button>
        <button id="openStoreBtn" class="btn gold" onclick="openStoreModal()">
          üçØ DIGITAL STORE
        </button>
        <button id="openInventoryBtn" class="btn" onclick="openInventoryModal()" style="background:linear-gradient(135deg, #8b5cf6, #7c3aed); color:#fff;">
          üéí MY INVENTORY
        </button>
      </div>
    </div>
  </section>

  <!-- BEARCADE -->
  <section class="alt" id="bearcade">
    <div class="wrap reveal">
      <h2 class="h2">BEARCADE</h2>
      <p style="text-align:center;margin:-6px 0 32px;">PLAY GAMES AND EARN HONEY POINTS! PLAY ANY OF THE 4 BELOW <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"> üéÆ</p>

      <div class="grid-3" style="gap:24px;">
        <!-- Flappy Bear -->
        <div class="game-card">
          <a href="https://www.bearpark.xyz/flappybear" rel="noopener noreferrer" style="text-decoration:none;">
            <div style="border:4px solid transparent; border-radius:16px; overflow:hidden; box-shadow:0 8px 24px rgba(0,0,0,0.4); background-image: linear-gradient(#1a1a1a, #1a1a1a), linear-gradient(135deg, #680cd9, #feb501, #00ff88); background-origin: border-box; background-clip: padding-box, border-box; transition: transform 0.3s ease, box-shadow 0.3s ease;">
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/8k133u.png" alt="Flappy Bear" loading="lazy" style="width:100%; height:auto; display:block;">
              <div style="padding:20px; background:#1a1a1a;">
                <h3 style="color:var(--gold); font-size:24px; font-weight:900; margin:0 0 12px 0; text-align:center;">FLAPPY BEAR</h3>
                <p style="color:rgba(255,255,255,0.85); font-size:15px; line-height:1.5; margin:0; text-align:center;">Tap to flap and dodge obstacles! Test your reflexes in this addictive arcade classic.</p>
              </div>
            </div>
          </a>
        </div>

        <!-- Bear Ninja -->
        <div class="game-card">
          <a href="https://www.bearpark.xyz/bear-ninja" rel="noopener noreferrer" style="text-decoration:none;">
            <div style="border:4px solid transparent; border-radius:16px; overflow:hidden; box-shadow:0 8px 24px rgba(0,0,0,0.4); background-image: linear-gradient(#1a1a1a, #1a1a1a), linear-gradient(135deg, #680cd9, #feb501, #00ff88); background-origin: border-box; background-clip: padding-box, border-box; transition: transform 0.3s ease, box-shadow 0.3s ease;">
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/478y6f.png" alt="Bear Ninja" loading="lazy" style="width:100%; height:auto; display:block;">
              <div style="padding:20px; background:#1a1a1a;">
                <h3 style="color:var(--gold); font-size:24px; font-weight:900; margin:0 0 12px 0; text-align:center;">BEAR NINJA</h3>
                <p style="color:rgba(255,255,255,0.85); font-size:15px; line-height:1.5; margin:0; text-align:center;">Slice and dice your way through waves! Master the art of the ninja blade.</p>
              </div>
            </div>
          </a>
        </div>

        <!-- Bear Jumpventure -->
        <div class="game-card">
          <a href="https://www.bearpark.xyz/bear-jumpventure" rel="noopener noreferrer" style="text-decoration:none;">
            <div style="border:4px solid transparent; border-radius:16px; overflow:hidden; box-shadow:0 8px 24px rgba(0,0,0,0.4); background-image: linear-gradient(#1a1a1a, #1a1a1a), linear-gradient(135deg, #680cd9, #feb501, #00ff88); background-origin: border-box; background-clip: padding-box, border-box; transition: transform 0.3s ease, box-shadow 0.3s ease;">
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/njsz8n.png" alt="Bear Jumpventure" loading="lazy" style="width:100%; height:auto; display:block;">
              <div style="padding:20px; background:#1a1a1a;">
                <h3 style="color:var(--gold); font-size:24px; font-weight:900; margin:0 0 12px 0; text-align:center;">BEAR JUMPVENTURE</h3>
                <p style="color:rgba(255,255,255,0.85); font-size:15px; line-height:1.5; margin:0; text-align:center;">Jump across platforms and collect coins! Explore challenging levels in this platformer.</p>
              </div>
            </div>
          </a>
        </div>

        <!-- Bear Pong -->
        <div class="game-card">
          <a href="https://www.bearpark.xyz/bearpong" rel="noopener noreferrer" style="text-decoration:none;">
            <div style="border:4px solid transparent; border-radius:16px; overflow:hidden; box-shadow:0 8px 24px rgba(0,0,0,0.4); background-image: linear-gradient(#1a1a1a, #1a1a1a), linear-gradient(135deg, #680cd9, #feb501, #00ff88); background-origin: border-box; background-clip: padding-box, border-box; transition: transform 0.3s ease, box-shadow 0.3s ease;">
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/bs753i.png" alt="Bear Pong" loading="lazy" style="width:100%; height:auto; display:block;">
              <div style="padding:20px; background:#1a1a1a;">
                <h3 style="color:var(--gold); font-size:24px; font-weight:900; margin:0 0 12px 0; text-align:center;">BEAR PONG</h3>
                <p style="color:rgba(255,255,255,0.85); font-size:15px; line-height:1.5; margin:0; text-align:center;">Battle it out in classic pong action! Compete head-to-head in this timeless arcade showdown.</p>
              </div>
            </div>
          </a>
        </div>
      </div>
    </div>
  </section>

  <!-- LEADERBOARDS -->
  <section class="dark" id="leaderboards">
    <div class="wrap reveal">
      <h2 class="h2">üèÜ LEADERBOARDS üèÜ</h2>
      <p style="text-align:center;margin:-6px 0 32px;">Top players across all BEAR games ‚Äî wallet-verified high scores!</p>

      <div class="grid-2" style="gap:24px;">

        <!-- Flappy BEAR Leaderboard -->
        <div class="leaderboard-card">
          <h3 class="h3" style="text-align:center; margin-bottom:16px;">
            <span style="color:var(--gold);">FLAPPY</span> BEAR
          </h3>
          <div id="leaderboard-flappy" class="leaderboard-list">
            <div class="loading">Loading scores...</div>
          </div>
        </div>

        <!-- BEAR Ninja Leaderboard -->
        <div class="leaderboard-card">
          <h3 class="h3" style="text-align:center; margin-bottom:16px;">
            BEAR <span style="color:var(--gold);">NINJA</span>
          </h3>
          <div id="leaderboard-slice" class="leaderboard-list">
            <div class="loading">Loading scores...</div>
          </div>
        </div>

        <!-- BEAR Jump Leaderboard -->
        <div class="leaderboard-card">
          <h3 class="h3" style="text-align:center; margin-bottom:16px;">
            BEAR <span style="color:var(--gold);">JUMP</span>
          </h3>
          <div id="leaderboard-jumpventure" class="leaderboard-list">
            <div class="loading">Loading scores...</div>
          </div>
        </div>

        <!-- BEAR Pong Leaderboard -->
        <div class="leaderboard-card">
          <h3 class="h3" style="text-align:center; margin-bottom:16px;">
            BEAR <span style="color:var(--gold);">PONG</span>
          </h3>
          <div id="leaderboard-pong" class="leaderboard-list">
            <div class="loading">Loading scores...</div>
          </div>
        </div>

      </div>
    </div>
  </section>

  <!-- üêª MEME OF THE WEEK üèÜ -->
  <section class="alt" id="meme-of-the-week" style="padding: 0; position: relative; overflow: hidden;">
    <!-- Floating Bear Troll Faces -->
    <div class="bear-troll-container">
      <img class="bear-troll-face" src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/zqn2i1.png" alt="" loading="lazy" data-index="0">
      <img class="bear-troll-face" src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/zqn2i1.png" alt="" loading="lazy" data-index="1">
      <img class="bear-troll-face" src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/zqn2i1.png" alt="" loading="lazy" data-index="2">
      <img class="bear-troll-face" src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/zqn2i1.png" alt="" loading="lazy" data-index="3">
      <img class="bear-troll-face" src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/zqn2i1.png" alt="" loading="lazy" data-index="4">
    </div>
    <div class="wrap reveal">
      <div class="meme-section tri-border-rounded">
        <!-- Header -->
        <div class="meme-header">
          <h2 class="meme-title"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/zqn2i1.png" alt="" style="height:1.2em; width:auto; vertical-align:middle; display:inline-block;"> MEME OF THE WEEK üèÜ</h2>
          <div class="meme-timer">
            <div class="timer-icon">‚è∞</div>
            <div class="timer-text">
              <div class="timer-label">Voting Ends</div>
              <div class="timer-countdown" id="meme-timer">
                <span class="days">0d</span>
                <span class="hours">0h</span>
                <span class="mins">0m</span>
                <span class="secs">0s</span>
              </div>
              <div class="timer-utc">Sunday 00:00 UTC</div>
            </div>
          </div>
        </div>

        <!-- Main Content -->
        <div class="meme-carousel-container">
          <!-- Leaderboard -->
          <div class="meme-leaderboard">
            <h3 class="leaderboard-title">üèÜ TOP 3 MEMES</h3>
            <div class="leaderboard-list" id="meme-leaderboard-list">
              <div class="leaderboard-empty">No memes yet!</div>
            </div>
          </div>

          <!-- Carousel -->
          <div class="meme-carousel">
            <button class="carousel-nav prev" onclick="prevMemeSlide()" aria-label="Previous meme">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none">
                <path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
              </svg>
            </button>

            <div class="carousel-track-container">
              <div class="carousel-track" id="meme-track">
                <div class="empty-state">
                  <div style="font-size: 80px;">üé®</div>
                  <h3 style="color: var(--gold); font-size: 32px; margin: 20px 0;">No memes yet this week!</h3>
                  <p style="color: var(--honey); font-size: 20px;">Be the first to submit a meme and earn 50 honey points!</p>
                </div>
              </div>
            </div>

            <button class="carousel-nav next" onclick="nextMemeSlide()" aria-label="Next meme">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none">
                <path d="M9 18l6-6-6-6" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
              </svg>
            </button>
          </div>

          <!-- Upload Button -->
          <div class="meme-upload-section">
            <button class="upload-meme-btn" id="meme-upload-btn" onclick="openMemeUploadModal()">
              <span class="upload-icon">üì§</span>
              <span class="upload-text">ADD YOUR OWN MEME</span>
              <span class="upload-reward">+50 üçØ</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Upload Modal -->
  <div class="meme-upload-modal" id="meme-upload-modal" style="display: none;">
    <div class="modal-overlay" onclick="closeMemeUploadModal()"></div>
    <div class="modal-container">
      <button class="modal-close" onclick="closeMemeUploadModal()" aria-label="Close">‚úï</button>

      <div class="modal-header">
        <h3 class="modal-title">üé® UPLOAD YOUR MEME</h3>
        <p class="modal-subtitle">Earn <span class="honey-highlight">+50 üçØ</span> honey points instantly!</p>
      </div>

      <div class="modal-body">
        <div class="upload-dropzone" id="meme-dropzone">
          <input type="file" id="meme-file-input" accept="image/jpeg,image/png,image/gif,image/webp,video/mp4,video/webm,video/quicktime,video/x-msvideo,video/mpeg" hidden>
          <div class="dropzone-content" id="meme-dropzone-content">
            <div class="upload-icon-large">üé¨</div>
            <p class="dropzone-text">Drag & drop your meme here</p>
            <p class="dropzone-subtext">or</p>
            <button class="browse-btn" onclick="document.getElementById('meme-file-input').click()">BROWSE FILES</button>
            <p class="file-requirements">Images: JPG, PNG, GIF, WEBP (5MB)<br>Videos: MP4, WEBM, MOV, AVI, MPEG (50MB)</p>
          </div>

          <div class="upload-preview" id="meme-upload-preview" style="display: none;">
            <img id="meme-preview-image" src="" alt="Preview">
            <button class="change-image-btn" onclick="document.getElementById('meme-file-input').click()">
              üîÑ Change Image
            </button>
          </div>
        </div>

        <div class="file-info" id="meme-file-info" style="display: none;">
          <span class="file-name" id="meme-file-name">meme.jpg</span>
          <span class="file-size" id="meme-file-size">1.2 MB</span>
        </div>

        <div class="upload-error" id="meme-upload-error" style="display: none;">
          <span class="error-icon">‚ö†Ô∏è</span>
          <span class="error-text" id="meme-error-text">Error message here</span>
        </div>

        <div class="upload-loading" id="meme-upload-loading" style="display: none;">
          <div class="loading-spinner"></div>
          <p class="loading-text">Uploading your meme...</p>
        </div>
      </div>

      <div class="modal-footer">
        <button class="modal-btn cancel-btn" onclick="closeMemeUploadModal()">CANCEL</button>
        <button class="modal-btn submit-btn" id="meme-submit-btn" disabled onclick="submitMeme()">
          <span class="submit-icon">üöÄ</span>
          <span>SUBMIT MEME</span>
          <span class="submit-reward">+50 üçØ</span>
        </button>
      </div>
    </div>
  </div>

  <!-- BEAR BULLETIN BOARD -->
  <section class="dark" id="bulletin-board">
    <div class="wrap reveal">
      <h2 class="h2"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/25ekkd.png" alt="BEARpark" style="height:1.2em; width:auto; vertical-align:middle; display:inline-block;"> BEAR BULLETIN BOARD <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/25ekkd.png" alt="BEARpark" style="height:1.2em; width:auto; vertical-align:middle; display:inline-block;"></h2>
      <p style="text-align:center;margin:-6px 0 20px;">What are other BEARS up to?</p>

      <!-- Post Bulletin Button -->
      <div style="text-align:center; margin-bottom:32px;">
        <button id="postBulletinBtn" class="post-bulletin-btn" onclick="openPostBulletinHighlight()">
          ‚ú® Post Bulletin
        </button>
      </div>

      <!-- Bulletin Feed -->
      <div class="bulletin-feed-container">
        <div id="bulletinFeed" class="bulletin-feed">
          <div class="loading">Loading bulletin posts...</div>
        </div>
      </div>
    </div>
  </section>

  <!-- BEAR FRIENDS -->
  <section class="alt" id="community" style="position: relative; overflow: hidden;">
    <!-- Floating Bear Heads -->
    <div class="bear-heads-container"></div>
    <div class="wrap reveal">
      <h2 class="h2">BEAR FRIENDS</h2>
      <p style="text-align:center;margin:-6px 0 32px;">Discover all the BEARs in the park! Search and explore the growing community.</p>

      <!-- Community Container with Border -->
      <div class="community-bordered-container">
        <!-- Search Bar -->
        <div class="community-search-container">
          <div class="community-search-wrapper">
            <svg class="community-search-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
              <circle cx="11" cy="11" r="8"></circle>
              <path d="m21 21-4.35-4.35"></path>
            </svg>
            <input
              type="text"
              id="communitySearchInput"
              placeholder="Search for a BEAR by name..."
              class="community-search-input"
            >
          </div>
          <div class="community-count">
            <span id="communityUserCount">0</span> BEARs
          </div>
        </div>

        <!-- User Grid -->
        <div id="communityUserGrid" class="community-user-grid">
          <div class="community-loading">
            <div class="loading-spinner"></div>
            <p>Loading BEARs...</p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- BEARABLEGUY123 -->
  <section class="dark" id="bg123">
    <div class="wrap reveal">
      <h2 class="h2">BEARABLEGUY123</h2>
      <p class="center on-dark" style="opacity:.9;margin:-6px 0 20px;">Since 2018, Bearableguy posted riddles in images with a red masked bear. The community uncovered hints like ‚Äú589.‚Äù</p>

      <div class="card" role="region" aria-roledescription="carousel" aria-label="Bearableguy image gallery" aria-live="polite">
        <div class="carousel" id="carousel">
          <!-- LEFT ARROW -->
          <button class="carousel-arrow carousel-arrow-left" id="carouselPrev" aria-label="Previous slide">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M15 18L9 12L15 6" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>

          <!-- RIGHT ARROW -->
          <button class="carousel-arrow carousel-arrow-right" id="carouselNext" aria-label="Next slide">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M9 18L15 12L9 6" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>

          <div class="viewport" id="viewport" tabindex="0" aria-label="Carousel viewport (use left and right arrow keys)">
            <div class="slides" id="slides">
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/f6k3b1.jpg" alt="BG123 poster 1" width="1600" height="900" loading="lazy" decoding="async">
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/18vwoq.jpg" alt="BG123 poster 2" width="1600" height="900" loading="lazy" decoding="async">
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ruozs3.jpg" alt="BG123 poster 3" width="1600" height="900" loading="lazy" decoding="async">
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ha4uwj.jpg" alt="BG123 poster 4" width="1600" height="900" loading="lazy" decoding="async">
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/n0le0t.jpg" alt="BG123 poster 5" width="1600" height="900" loading="lazy" decoding="async">
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wbin3t.jpg" alt="BG123 poster 6" width="1600" height="900" loading="lazy" decoding="async">
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/lrtbxe.png" alt="BG123 poster 7" width="1600" height="900" loading="lazy" decoding="async">
            </div>
          </div>
        </div>
        <div class="dots" id="dots" role="tablist" aria-label="Choose slide"></div>
      </div>
    </div>
  </section>

  <!-- NFTs -->
  <section class="alt" id="nfts">
    <div class="wrap reveal">
      <h2 class="h2">BEAR NFTs</h2>
      <p style="text-align:center;margin:-6px 0 24px;">The BEAR community has collectible NFTs for profile pictures ‚Äî the <strong>Ultra Rare Collection</strong> and the <strong>Pixel Collection</strong>.</p>

      <div class="grid-2">
        <div class="card">
          <h3 class="h3">ULTRA RARE BEARS</h3>
          <p style="text-align:center;opacity:.95;">The BEAR Ultra Rare collection was the first mint and consists of 667 NFTs.</p>
          <div class="spacer"></div>
          <a class="nft-media" href="https://xrp.cafe/collection/bearxrpl" target="_blank" rel="noopener">
            <video src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ULTRA%20RARE%20VIDEO.mp4" autoplay loop muted playsinline style="width:100%;height:auto;border-radius:8px;"></video>
          </a>
          <div class="center" style="margin-top:16px;">
            <a class="btn gold" href="https://xrp.cafe/collection/bearxrpl" target="_blank" rel="noopener">Ultra Collection</a>
          </div>
        </div>

        <div class="card">
          <h3 class="h3">PIXEL BEARS</h3>
          <p style="text-align:center;opacity:.95;">There are 5880 Pixel BEARS to provide a profile picture for every $BEAR maxi.</p>
          <div class="spacer"></div>
          <a class="nft-media" href="https://xrp.cafe/collection/bear-pixel-collection" target="_blank" rel="noopener">
            <video src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/videos/babbn1.mp4" playsinline muted autoplay loop poster="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/babbn1.jpg"></video>
          </a>
          <div class="center" style="margin-top:16px;">
            <a class="btn gold" href="https://xrp.cafe/collection/bear-pixel-collection" target="_blank" rel="noopener">Pixel Collection</a>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- COMMUNITY -->
  <section class="dark" id="community">
    <div class="wrap reveal">
      <h2 class="h2">COMMUNITY</h2>

    <div class="community-banner" id="communityBanner" role="img" aria-label="$BEAR community montage with honey lighting">
        <img class="bg" id="communityBannerBg" src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/kgs8as.jpg" alt="" width="2000" height="1000" loading="lazy" decoding="async">

        <!-- Animated bear paw prints -->
        <div class="paw-prints">
          <span class="paw">üêæ</span>
          <span class="paw">üêæ</span>
          <span class="paw">üêæ</span>
          <span class="paw">üêæ</span>
        </div>

        <div class="overlay">
          <div class="community-content">
            <div class="community-badge">
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/98rugn.png" alt="BEAR Community" loading="lazy" style="width:100%; height:100%; object-fit:cover; border-radius:50%;">
            </div>
            <h3 style="font-family:'Luckiest Guy',cursive; font-size:clamp(24px, 5vw, 36px); color:var(--gold); text-shadow:3px 3px 0 #000, 0 0 20px rgba(237,183,35,0.4); margin:16px 0 8px; text-align:center;">OFFICIAL COMMUNITIES!</h3>
            <p class="on-dark" style="text-align:center; font-size:clamp(15px, 3vw, 18px); margin:0 0 24px; max-width:500px; line-height:1.4;">Come meet the $BEAR fam and join the most vibrant community in crypto!</p>
            <div class="community-buttons">
              <a class="btn gold community-btn" href="https://x.com/bearxrpl" target="_blank" rel="noopener">
                <span class="btn-icon">ùïè</span>
                <span class="btn-text">Join us on X</span>
              </a>
              <a class="btn gold community-btn" href="https://discord.com/invite/atGTNuzqH6" target="_blank" rel="noopener">
                <span class="btn-icon">üí¨</span>
                <span class="btn-text">Join Discord</span>
              </a>
            </div>
            <div class="community-stats">
              <div class="stat-item">
                <span class="stat-emoji">üí¨</span>
                <span class="stat-text">Discord Daily</span>
              </div>
              <div class="stat-item">
                <span class="stat-emoji">üéôÔ∏è</span>
                <span class="stat-text">Spaces Daily</span>
              </div>
              <div class="stat-item">
                <span class="stat-emoji">ü™ñ</span>
                <span class="stat-text">Raiding Daily</span>
              </div>
              <div class="stat-item">
                <span class="stat-emoji">üéâ</span>
                <span class="stat-text">Having Fun Daily</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- 5D MEMES -->
  <section class="alt" id="memes">
    <div class="wrap reveal">
      <h2 class="h2">5D MEMES</h2>
      <p style="text-align:center;margin:-6px 0 18px;color:var(--gold-ink)">Live stream from Kick</p>

      <div class="card">
        <div class="square" id="kickWrap">
          <!-- Lazy-loaded Kick embed with placeholder -->
          <button class="placeholder btn ghost" id="kickPlaceholder" aria-label="Load live Kick stream">
            ‚ñ∂ Load live Kick stream
          </button>
        </div>
        <div class="center" style="margin-top:14px;">
          <a class="btn ghost" href="https://kick.com/bearxrpl" target="_blank" rel="noopener">Open on Kick</a>
        </div>
      </div>
    </div>
  </section>

  <!-- NETWORK -->
  <section class="dark" id="network">
    <div class="wrap reveal">
      <h2 class="h2">NETWORK</h2>
      <p class="on-dark" style="text-align:center;margin:-6px 0 24px;">Buy $BEAR here</p>

      <div class="grid-2">
        <a class="tile" href="https://firstledger.net/token/rBEARGUAsyu7tUw53rufQzFdWmJHpJEqFW/4245415200000000000000000000000000000000" target="_blank" rel="noopener">
          <div class="face"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/du61x3.jpg" alt="First Ledger" width="300" height="64" loading="lazy" decoding="async"></div>
          <span class="lbl">First Ledger</span>
        </a>
        <a class="tile" href="https://xmagnetic.org/dex/BEAR+rBEARGUAsyu7tUw53rufQzFdWmJHpJEqFW_XRP+XRP?network=mainnet" target="_blank" rel="noopener">
          <div class="face"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/m9ck1m.png" alt="Magnetic DEX" width="300" height="64" loading="lazy" decoding="async"></div>
          <span class="lbl">Magnetic DEX</span>
        </a>
        <a class="tile" href="https://xpmarket.com/token/BEAR-rBEARGUAsyu7tUw53rufQzFdWmJHpJEqFW" target="_blank" rel="noopener">
          <div class="face"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/1dw0sy.png" alt="XPMarket" width="220" height="64" loading="lazy" decoding="async"></div>
          <span class="lbl">XPMarket</span>
        </a>
      </div>
    </div>
  </section>

  <!-- PWA Install & Notifications Controls -->
  <div id="pwaControls" style="display:none;position:fixed;bottom:100px;right:20px;z-index:9999;max-width:300px;">
    <button id="installAppBtn" style="display:none;width:100%;padding:14px 20px;margin-bottom:10px;background:linear-gradient(135deg,#8b5cf6,#ec4899);color:#fff;border:none;border-radius:12px;font-size:16px;font-weight:900;cursor:pointer;box-shadow:0 4px 12px rgba(139,92,246,0.5);text-shadow:0 1px 2px rgba(0,0,0,0.3);transition:all 0.2s;">
      üì± Install BEAR Park App
    </button>
  </div>

  <style>
    #pwaControls button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(139,92,246,0.7);
    }
    #pwaControls button:active:not(:disabled) {
      transform: translateY(0);
    }
    #pwaControls button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    @media (max-width: 768px) {
      #pwaControls {
        left: 20px;
        right: 20px;
        max-width: none;
        bottom: 80px;
      }
    }
  </style>

  <footer class="dark">
    <div class="wrap center" style="gap:14px;flex-wrap:wrap;">
      <span class="on-dark" style="opacity:.9;">¬© BEAR Park ‚Äî Defend the castle üè∞</span>
      <a class="btn ghost" href="#top">Back to Top</a>
    </div>
  </footer>

  <!-- Buy Drawer -->
  <aside id="buyDrawer" class="drawer" aria-hidden="true">
    <div class="drawer-head">
      <h3 class="h3" style="margin:0;"><span style="color:var(--gold);">BEAR</span> <span style="color:#fff;">HUB</span></h3>
      <button class="drawer-close-btn" data-close-drawer aria-label="Close BEAR HUB">
        &times;
      </button>
    </div>
    <div class="drawer-body">
      <!-- MY $BEAR PORTFOLIO -->
      <div id="portfolioSection" class="portfolio-card" style="display:none;">
        <h4 style="margin:0 0 16px 0; font-size:18px; font-weight:900; color:var(--gold); text-transform:uppercase; letter-spacing:0.5px;">üíº My $BEAR Portfolio</h4>
        <div class="portfolio-stats">
          <div class="stat-row" style="margin-bottom:16px;">
            <span class="stat-label" style="font-size:15px; display:inline-flex; align-items:center; gap:6px; white-space:nowrap;">
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png" alt="BEAR" width="18" height="18" style="display:inline-block;"> Total BEAR:
            </span>
            <span id="portfolioBearAmount" class="stat-value" style="font-size:24px; font-weight:900;">‚Äî</span>
          </div>
          <div class="stat-row" style="margin-bottom:12px;">
            <span class="stat-label" style="font-size:15px; white-space:nowrap;">üíµ USD Value:</span>
            <span id="portfolioUsdValue" class="stat-value" style="font-size:20px; font-weight:900;">‚Äî</span>
          </div>
          <div class="stat-row">
            <span class="stat-label" style="font-size:15px; display:inline-flex; align-items:center; gap:4px; white-space:nowrap;"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/lufprf.png" alt="XRP" width="18" height="18" style="display:inline-block;">XRP Value:</span>
            <span id="portfolioXrpValue" class="stat-value" style="font-size:20px; font-weight:900;">‚Äî</span>
          </div>
        </div>
        <div class="wallet-address" style="margin-top:16px; padding:10px; background:rgba(0,0,0,0.4); border-radius:8px; border:1px solid rgba(237,183,35,0.2); font-size:13px; font-family:monospace; word-break:break-all; text-align:center; color:rgba(255,255,255,0.8);">
          <span id="connectedWalletAddress">‚Äî</span>
        </div>
      </div>

      <!-- LIQUIDITY POOL POSITION -->
      <div id="lpSection" class="lp-card" style="display:none;">
        <h4 style="margin:0 0 16px 0; font-size:18px; font-weight:900; color:var(--gold); text-transform:uppercase; letter-spacing:0.5px;">üíß My Liquidity Position</h4>
        <div class="lp-stats">
          <div class="stat-row" style="margin-bottom:16px;">
            <span class="stat-label" style="font-size:14px; display:inline-flex; align-items:center; gap:6px; white-space:nowrap;">
              ü™ô LP Tokens:
            </span>
            <span id="lpTokenAmount" class="stat-value" style="font-size:18px; font-weight:900; word-break:break-all;">‚Äî</span>
          </div>
          <div class="stat-row" style="margin-bottom:12px;">
            <span class="stat-label" style="font-size:15px; white-space:nowrap;">üìä Pool Ownership:</span>
            <span id="lpPoolPercentage" class="stat-value" style="font-size:20px; font-weight:900; color:#5D3FD3;">‚Äî</span>
          </div>
          <div class="stat-row" style="margin-bottom:12px;">
            <span class="stat-label" style="font-size:15px; display:inline-flex; align-items:center; gap:4px; white-space:nowrap;">
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png" alt="BEAR" width="18" height="18" style="display:inline-block;"> BEAR Share:
            </span>
            <span id="lpBearAmount" class="stat-value" style="font-size:20px; font-weight:900;">‚Äî</span>
          </div>
          <div class="stat-row" style="margin-bottom:12px;">
            <span class="stat-label" style="font-size:15px; display:inline-flex; align-items:center; gap:4px; white-space:nowrap;">
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/lufprf.png" alt="XRP" width="18" height="18" style="display:inline-block;"> XRP Share:
            </span>
            <span id="lpXrpAmount" class="stat-value" style="font-size:20px; font-weight:900;">‚Äî</span>
          </div>
          <div class="stat-row" style="padding-top:12px; border-top:2px solid rgba(237,183,35,0.3);">
            <span class="stat-label" style="font-size:15px; white-space:nowrap;">üí∞ Total USD Value:</span>
            <span id="lpUsdValue" class="stat-value" style="font-size:24px; font-weight:900; color:#4CAF50;">‚Äî</span>
          </div>
        </div>
      </div>

      <!-- USER PROFILE CUSTOMIZATION -->
      <div id="profileSection" class="profile-card" style="display:none;">
        <div id="profileSetupSection">
          <h4 style="margin:0 0 16px 0; font-size:18px; font-weight:900; color:var(--gold); text-transform:uppercase; letter-spacing:0.5px;">üë§ Your Profile</h4>

          <!-- Helpful instruction banner -->
          <div id="profileInstructions" style="background:linear-gradient(135deg, rgba(237,183,35,0.2), rgba(237,183,35,0.1)); padding:16px; border-radius:12px; border:2px solid var(--gold); margin-bottom:20px; text-align:center; transition:all 0.5s ease;">
            <div style="font-size:16px; font-weight:900; color:var(--gold); margin-bottom:8px;">üëã SET UP YOUR PROFILE!</div>
            <div style="font-size:14px; line-height:1.6; color:rgba(255,255,255,0.9);">
              1Ô∏è‚É£ Enter your username below<br>
              2Ô∏è‚É£ Scroll down and pick an NFT from your collection<br>
              3Ô∏è‚É£ Click "Save Profile" when done!
            </div>
          </div>

        <div style="background:rgba(0,0,0,0.3); padding:20px; border-radius:12px; border:2px solid rgba(237,183,35,0.2); margin-bottom:16px;">
          <div style="margin-bottom:20px;">
            <label style="display:block; font-size:16px; font-weight:900; margin-bottom:10px; color:var(--gold);">‚úèÔ∏è Display Name</label>
            <input type="text" id="profileUsername" placeholder="Enter your username here..." maxlength="20" style="width:100%; padding:16px; background:rgba(0,0,0,0.5); border:3px solid rgba(237,183,35,0.5); border-radius:12px; color:#fff; font-size:18px; font-family:inherit; font-weight:700; transition:all 0.3s;">
          </div>

          <div>
            <label style="display:block; font-size:16px; font-weight:900; margin-bottom:10px; color:var(--gold);">üñºÔ∏è Profile Avatar</label>
            <div id="profileAvatarSelector" style="background:rgba(0,0,0,0.5); padding:16px; border-radius:12px; border:3px solid rgba(237,183,35,0.5); min-height:90px; display:flex; align-items:center; justify-content:center;">
              <div style="text-align:center; font-size:15px; font-weight:700; color:rgba(237,183,35,0.8);">
                üëá Scroll down and click an NFT to select it üëá
              </div>
            </div>
            <input type="hidden" id="profileAvatarNFT" value="">
          </div>
        </div>

        <button id="saveProfileBtn" class="btn gold" style="width:100%; font-size:20px; padding:20px; font-weight:900; letter-spacing:1px; background:linear-gradient(135deg, #edb723, #f4a623); box-shadow:0 6px 20px rgba(237,183,35,0.5);">üíæ SAVE PROFILE</button>

        <!-- MY INVENTORY BUTTON -->
        <button onclick="closeDrawer(); setTimeout(() => openInventoryModal(), 300);" class="btn" style="width:100%; font-size:20px; padding:20px; font-weight:900; letter-spacing:1px; background:linear-gradient(135deg, #8b5cf6, #7c3aed); box-shadow:0 6px 20px rgba(139,92,246,0.5); margin-top:16px; transition:all 0.2s ease;">‚öîÔ∏è MY INVENTORY</button>
        </div>
      </div>

      <!-- NFT VIEWING SECTION -->
      <div id="nftSection" style="display:none; flex-shrink:0; display:flex; flex-direction:column;">
        <h4 style="margin:0 0 16px 0; font-size:18px; font-weight:900; color:var(--gold); text-transform:uppercase; letter-spacing:0.5px;">üñºÔ∏è Your NFTs</h4>

        <!-- Helpful instruction for NFT selection -->
        <div id="nftInstructions" style="background:linear-gradient(135deg, rgba(237,183,35,0.15), rgba(237,183,35,0.05)); padding:14px; border-radius:10px; border:2px solid rgba(237,183,35,0.4); margin-bottom:16px; text-align:center; transition:all 0.5s ease;">
          <div style="font-size:15px; font-weight:900; color:var(--gold);">
            üëÜ SCROLL UP to see your selected avatar<br>
            üëá CLICK any NFT below to use it as your profile picture!
          </div>
        </div>

        <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-bottom:18px;">
          <button id="viewPixelBearsBtn" class="btn gold" style="font-size:15px; padding:14px; font-weight:900;">üêª Pixel Bears</button>
          <button id="viewUltraRaresBtn" class="btn gold" style="font-size:15px; padding:14px; font-weight:900;">üíé Ultra Rares</button>
        </div>

        <div id="nftGrid" style="display:none; max-height:600px; overflow-y:auto; background:rgba(0,0,0,0.3); padding:10px; border-radius:10px; border:2px solid rgba(237,183,35,0.2); margin-bottom:20px;">
          <div id="nftGridContent" style="display:grid; grid-template-columns:repeat(2, 1fr); gap:10px;">
            <!-- NFTs will be loaded here -->
          </div>
        </div>

        <div id="nftLoading" style="display:none; text-align:center; padding:20px; opacity:0.6;">
          Loading NFTs...
        </div>

        <div id="nftEmpty" style="display:none; text-align:center; padding:20px; opacity:0.6; font-size:12px;">
          No NFTs found in your wallet
        </div>
      </div>

      <!-- Disconnect button at bottom of drawer -->
      <div id="drawerDisconnectContainer"></div>
    </div>
  </aside>

  <!-- Profile Page Modal -->
  <div id="profileModal" class="profile-modal" aria-hidden="true">
    <div class="profile-modal-overlay" onclick="closeProfileModal()"></div>
    <div class="profile-modal-content">
      <!-- Header -->
      <div id="profileModalHeader" class="profile-modal-header">
        <h2 id="profileModalTitle" style="margin:0; color:var(--gold); font-size:28px;">MY PROFILE</h2>
        <div style="display: flex; align-items: center; gap: 12px;">
          <button id="profileBackBtn" class="profile-back-btn" onclick="goBackInProfile()" aria-label="Go back" style="display:none;">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
              <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
          </button>
          <button class="bear-search-btn" onclick="toggleBearSearch()" aria-label="BEAR Search">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="11" cy="11" r="8"></circle>
              <path d="m21 21-4.35-4.35"></path>
            </svg>
          </button>
          <button class="profile-close-btn" onclick="closeProfileModal()" aria-label="Close profile">&times;</button>
        </div>
      </div>

      <!-- BEAR Search Panel -->
      <div id="bearSearchPanel" class="bear-search-panel" style="display:none;">
        <div class="search-input-container">
          <input type="text" id="bearSearchInput" placeholder="üîç Search for a BEAR..." class="bear-search-input">
        </div>
        <div id="bearSearchResults" class="bear-search-results"></div>
      </div>

      <!-- Profile Body -->
      <div class="profile-modal-body">
        <!-- Profile Picture Section -->
        <div id="profilePictureSection" class="profile-picture-section" style="position: relative;">
          <div id="profilePictureContainer" class="profile-picture-container">
            <img id="profilePictureDisplay" src="" alt="Profile Picture" class="profile-picture">
            <div class="profile-picture-placeholder" id="profilePicturePlaceholder">
              <span style="font-size:48px;">üêª</span>
            </div>
          </div>
          <div class="profile-info-header">
            <h3 id="profileDisplayName" class="profile-name">Loading...</h3>
            <p id="profileWalletAddress" class="profile-wallet">Loading...</p>
          </div>
          <button id="editProfilePictureBtn" class="edit-profile-picture-btn" onclick="editProfileFromModal()" style="position: absolute !important; top: 12px !important; right: 12px !important; width: 40px; height: 40px; border-radius: 50%; background: var(--gold); border: 3px solid #000; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease; z-index: 10; box-shadow: 0 4px 12px rgba(0,0,0,0.4); margin: 0 !important;">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#000" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
            </svg>
          </button>
        </div>

        <!-- Follow Stats & Button -->
        <div class="profile-follow-section">
          <div class="follow-stats">
            <div class="follow-stat-item" onclick="showFollowersList(event)" style="cursor: pointer;">
              <div class="follow-stat-number" id="followersCount">0</div>
              <div class="follow-stat-label">Followers</div>
            </div>
            <div class="follow-stat-item" onclick="showFollowingList(event)" style="cursor: pointer;">
              <div class="follow-stat-number" id="followingCount">0</div>
              <div class="follow-stat-label">Following</div>
            </div>
          </div>
          <button id="followBtn" class="follow-btn" onclick="toggleFollow()" style="display:none;">
            <span class="follow-btn-text">Follow</span>
            <span class="follow-btn-icon">+</span>
          </button>
        </div>

        <!-- Bear Bulletin Post Section -->
        <div class="profile-section bulletin-post-section">
          <div class="bulletin-post-input-container">
            <textarea
              id="bulletinPostInput"
              class="bulletin-post-input"
              placeholder="What would you like to share with the BEARS?"
              maxlength="1000"
              rows="3"
            ></textarea>
            <div class="bulletin-post-actions">
              <button id="postToBulletinBtn" class="btn-post-bulletin" onclick="postToBulletin()">
                üì¢ Post to Bulletin Board
              </button>
            </div>
          </div>
        </div>

        <!-- Bio Section -->
        <div class="profile-section">
          <div class="profile-section-header">
            <h4>üìù Bio</h4>
            <button id="editBioBtn" class="edit-bio-btn">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
              </svg>
            </button>
          </div>
          <div id="bioDisplay" class="bio-display">No bio yet. Click Edit to add one!</div>
          <div id="bioEditor" class="bio-editor" style="display:none;">
            <textarea id="bioTextarea" maxlength="500" placeholder="Tell other BEARs about yourself..."></textarea>
            <div class="bio-editor-actions">
              <button id="saveBioBtn" class="btn-save-bio">Save</button>
              <button id="cancelBioBtn" class="btn-cancel-bio">Cancel</button>
            </div>
          </div>
        </div>

        <!-- Achievements Section -->
        <div class="profile-section">
          <h4>üèÜ Achievements</h4>
          <div id="achievementsDisplay" class="achievements-grid">
            <div class="achievement-placeholder">
              <span style="font-size:32px; opacity:0.3;">üîí</span>
              <p style="opacity:0.5; font-size:12px; margin-top:8px;">Coming Soon!</p>
            </div>
            <div class="achievement-placeholder">
              <span style="font-size:32px; opacity:0.3;">üîí</span>
              <p style="opacity:0.5; font-size:12px; margin-top:8px;">Coming Soon!</p>
            </div>
            <div class="achievement-placeholder">
              <span style="font-size:32px; opacity:0.3;">üîí</span>
              <p style="opacity:0.5; font-size:12px; margin-top:8px;">Coming Soon!</p>
            </div>
          </div>
        </div>

        <!-- NFT Collection Section (conditional) -->
        <div class="profile-section">
          <h4 id="nftCollectionHeader">üñºÔ∏è My NFT Collection</h4>

          <!-- Pixel BEARS Collection -->
          <div id="pixelBearsSection" class="nft-collection-section" style="display:none;">
            <button class="nft-collection-toggle" onclick="toggleNFTCollection('pixelBears')">
              <span class="nft-collection-title">üé® PIXEL BEARS</span>
              <span class="nft-collection-count" id="pixelBearsCount">0</span>
              <span class="nft-collection-arrow" id="pixelBearsArrow">‚ñº</span>
            </button>
            <div id="pixelBearsGrid" class="nft-collection-grid" style="display:none;"></div>
          </div>

          <!-- Ultra Rare BEARS Collection -->
          <div id="ultraRareBearsSection" class="nft-collection-section" style="display:none;">
            <button class="nft-collection-toggle" onclick="toggleNFTCollection('ultraRareBears')">
              <span class="nft-collection-title">üíé ULTRA RARE BEARS</span>
              <span class="nft-collection-count" id="ultraRareBearsCount">0</span>
              <span class="nft-collection-arrow" id="ultraRareBearsArrow">‚ñº</span>
            </button>
            <div id="ultraRareBearsGrid" class="nft-collection-grid" style="display:none;"></div>
          </div>

          <!-- No NFTs Message -->
          <div id="noNFTsMessage" class="no-nfts-message">
            <span style="font-size:48px; opacity:0.3;">üêª</span>
            <p>No BEAR NFTs found in this wallet</p>
          </div>
        </div>

        <!-- Comments Section -->
        <div class="profile-section">
          <h4>üí¨ Comments (<span id="commentsCount">0</span>)</h4>

          <!-- Add Comment Form -->
          <div class="comment-form">
            <textarea id="commentTextarea" placeholder="Leave a comment on this profile..." maxlength="500"></textarea>
            <button id="postCommentBtn" class="btn-post-comment">Post Comment</button>
          </div>

          <!-- Comments List -->
          <div id="commentsList" class="comments-list">
            <div class="comments-loading">Loading comments...</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <style>
    /* üêªüèôÔ∏è BEAR CITY INHABITANTS SYSTEM üèôÔ∏èüêª */
    #bearCityContainer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1; /* Behind UI but visible */
      overflow: visible;
    }

    .city-bear {
      position: absolute;
      width: 60px;
      height: auto;
      opacity: 1;
      filter: drop-shadow(2px 3px 6px rgba(0, 0, 0, 0.3));
      will-change: transform;
      transition: transform 0.1s linear;
      pointer-events: auto;
      cursor: pointer;
      z-index: 1;
    }

    .city-bear:hover {
      filter: drop-shadow(0 0 15px rgba(237, 183, 35, 0.8));
      transform: scale(1.15) !important;
    }

    .city-bear.walking-left {
      transform: scaleX(-1);
    }

    .city-bear.jumping {
      animation: bearJump 0.6s ease-out;
    }

    .city-bear.dancing {
      animation: bearDance 1s ease-in-out infinite;
    }

    .city-bear.waving {
      animation: bearWave 1.5s ease-in-out infinite;
    }

    @keyframes bearJump {
      0%, 100% { transform: translateY(0) scale(1); }
      50% { transform: translateY(-80px) scale(1.1) rotate(10deg); }
    }

    @keyframes bearDance {
      0%, 100% { transform: rotate(0deg) scale(1); }
      25% { transform: rotate(-15deg) scale(1.1); }
      50% { transform: rotate(0deg) scale(1.15); }
      75% { transform: rotate(15deg) scale(1.1); }
    }

    @keyframes bearWave {
      0%, 100% { transform: rotate(0deg); }
      25% { transform: rotate(-20deg); }
      75% { transform: rotate(20deg); }
    }

    @keyframes bearBounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-20px); }
    }

    /* MOBILE OPTIMIZATIONS */
    @media (max-width: 768px) {
      .city-bear {
        width: 40px;
      }
    }
  </style>

  <script>
    // Console logging enabled for debugging

    // üêªüèôÔ∏èüí• BEAR CITY INHABITANTS - LIVING ECOSYSTEM üí•üèôÔ∏èüêª
    (function() {
      const bearImages = [
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/a8yk6m.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/k3yx6x.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/2la74d.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/zkxfrs.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/sv9big.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/scs5nr.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/su97n8.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/rbz4k3.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/mglkoj.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/un18dl.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/0ftro9.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/s5w7wg.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/a2pgvw.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ecqtzu.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ku1n1u.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/yrf4b7.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/dj9a9s.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/l5xrps.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/r6myzr.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/kbjcbv.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/2weeov.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ijhbbj.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/6t4s3b.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/09oxkp.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/y72z5w.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/6a7p84.png',
        'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/qwh0mg.png'
      ];

      const container = document.getElementById('bearCityContainer');
      if (!container) return;

      const hero = document.querySelector('.hero');
      if (!hero) return;

      let cityBears = [];
      let containerWidth = hero.offsetWidth;
      let containerHeight = hero.offsetHeight;

      // Ground level - bears stay in bottom 60% (40% from top to 100%)
      const groundStart = containerHeight * 0.4;
      const groundEnd = containerHeight * 0.95;

      // üè†üíß NO-WALK ZONES - Bears avoid water only!
      const noWalkZones = [
        // üíßüíßüíß WATER ZONE - Bottom portion only
        {
          left: 0,
          right: containerWidth * 0.35,  // 35% from left
          top: containerHeight * 0.60,   // Start at 60% from top (increased by 5%)
          bottom: containerHeight,       // To the bottom
          name: 'WATER ZONE - ABSOLUTE NO ENTRY'
        }
      ];

      // Check if position is in any no-walk zone
      function isInNoWalkZone(x, y) {
        for (let zone of noWalkZones) {
          if (x >= zone.left && x <= zone.right && y >= zone.top && y <= zone.bottom) {
            return zone;
          }
        }
        return null;
      }

      // BEAR CLASS - Each bear is a living entity
      class CityBear {
        constructor(imageSrc, index) {
          this.element = document.createElement('img');
          this.element.src = imageSrc;
          this.element.className = 'city-bear';
          this.element.loading = 'lazy';

          // Random starting position on the ground (NOT in water!)
          do {
            this.x = Math.random() * (containerWidth - 80);
            this.y = groundStart + Math.random() * (groundEnd - groundStart);
          } while (isInNoWalkZone(this.x, this.y));

          this.speed = (0.3 + Math.random() * 1.2) * 0.75; // pixels per frame (25% slower)
          this.direction = Math.random() > 0.5 ? 1 : -1; // 1 = right, -1 = left
          this.state = 'walking'; // walking, standing, dancing, jumping
          this.stateTimer = Math.random() * 300;
          this.isActive = true;
          this.imageSrc = imageSrc;

          // Position the bear
          this.element.style.left = this.x + 'px';
          this.element.style.top = this.y + 'px';

          if (this.direction < 0) {
            this.element.classList.add('walking-left');
          }

          // Handle broken images - remove them
          this.element.onerror = () => {
            console.warn('üêª ‚ùå Broken bear image removed: ' + imageSrc);
            this.element.remove();
            this.isActive = false;
          };

          // Click interaction
          this.element.addEventListener('click', () => this.onClick());

          container.appendChild(this.element);
        }

        onClick() {
          const actions = ['jumping', 'dancing', 'waving'];
          const action = actions[Math.floor(Math.random() * actions.length)];

          this.element.classList.remove('jumping', 'dancing', 'waving');
          this.element.classList.add(action);

          setTimeout(() => {
            this.element.classList.remove(action);
          }, action === 'dancing' ? 3000 : action === 'waving' ? 4500 : 600);

          console.log('üêª Bear is ' + action + '!');
        }

        update() {
          if (!this.isActive) return; // Skip if bear is removed

          this.stateTimer--;

          // Randomly change states
          if (this.stateTimer <= 0) {
            const rand = Math.random();
            if (rand > 0.7) {
              this.state = 'standing';
              this.stateTimer = 60 + Math.random() * 120;
            } else if (rand > 0.5) {
              this.state = 'dancing';
              this.element.classList.add('dancing');
              this.stateTimer = 180 + Math.random() * 120;
              setTimeout(() => this.element.classList.remove('dancing'), this.stateTimer * 16);
            } else {
              this.state = 'walking';
              this.stateTimer = 180 + Math.random() * 300;
              // Randomly change direction
              if (Math.random() > 0.7) {
                this.direction *= -1;
                if (this.direction < 0) {
                  this.element.classList.add('walking-left');
                } else {
                  this.element.classList.remove('walking-left');
                }
              }
            }
          }

          // Move if walking
          if (this.state === 'walking') {
            this.move();
          }
        }

        move() {
          const nextX = this.x + this.speed * this.direction;

          // Check if next position would be in a no-walk zone
          const blockedZone = isInNoWalkZone(nextX, this.y);
          if (blockedZone) {
            // Don't walk into buildings or water! Turn around!
            this.direction *= -1;
            if (this.direction < 0) {
              this.element.classList.add('walking-left');
            } else {
              this.element.classList.remove('walking-left');
            }
            console.log('üêªüè† Bear avoided ' + blockedZone.name + '!');
          } else {
            this.x = nextX;
          }

          // Screen boundaries - mostly bounce, but 10% chance to walk off and despawn
          if (this.x < 0) {
            if (Math.random() < 0.1) {
              // 10% chance - let them walk off to despawn
              if (this.x < -100) {
                console.log('üêªüëã Bear walked off LEFT - despawning...');
                this.despawn();
                return;
              }
            } else {
              // 90% chance - bounce back
              this.x = 10;
              this.direction = 1;
              this.element.classList.remove('walking-left');
            }
          } else if (this.x >= containerWidth - 80) {
            if (Math.random() < 0.1) {
              // 10% chance - let them walk off to despawn
              if (this.x > containerWidth + 100) {
                console.log('üêªüëã Bear walked off RIGHT - despawning...');
                this.despawn();
                return;
              }
            } else {
              // 90% chance - bounce back
              this.x = containerWidth - 80;
              this.direction = -1;
              this.element.classList.add('walking-left');
            }
          }

          // Update position
          this.element.style.left = this.x + 'px';
        }

        despawn() {
          if (this.element && this.element.parentNode) {
            this.element.remove();
          }
          this.isActive = false;

          // Remove from cityBears array
          const index = cityBears.indexOf(this);
          if (index > -1) {
            cityBears.splice(index, 1);
          }

          // Return image to available pool
          availableBearImages.push(this.imageSrc);
        }
      }

      // Available bear images pool
      let availableBearImages = [...bearImages];

      // Get max bears based on screen size
      function getMaxBears() {
        const width = window.innerWidth;
        if (width < 768) return 5;        // Mobile: 5 bears
        if (width < 1024) return 10;      // Tablet: 10 bears
        if (width < 1440) return 15;      // Small desktop: 15 bears
        if (width < 1920) return 20;      // Desktop: 20 bears
        return 27;                        // Ultrawide: all 27 bears
      }

      // Spawn a new bear from off-screen
      function spawnRandomBear() {
        if (cityBears.length >= getMaxBears()) return;
        if (availableBearImages.length === 0) {
          availableBearImages = [...bearImages]; // Refill pool
        }

        // Pick random bear image
        const randomIndex = Math.floor(Math.random() * availableBearImages.length);
        const imageSrc = availableBearImages[randomIndex];
        availableBearImages.splice(randomIndex, 1);

        const bear = new CityBear(imageSrc, cityBears.length);

        // Pick safe Y position that's NOT in water zone
        // Spawn across the full ground area (40% to 95%) but avoid water zone
        const groundStart = containerHeight * 0.4;
        const groundEnd = containerHeight * 0.95;

        // Try to find a safe Y position (not in water zone)
        let attempts = 0;
        do {
          bear.y = groundStart + Math.random() * (groundEnd - groundStart);
          attempts++;
        } while (isInNoWalkZone(containerWidth * 0.5, bear.y) && attempts < 20);

        bear.element.style.top = bear.y + 'px';

        // Spawn off-screen (left or right)
        // IMPORTANT: Don't spawn from left if it would make them walk through water zone
        const waterZoneEnd = containerWidth * 0.35; // Water zone ends at 35%
        const canSpawnFromLeft = bear.y < (containerHeight * 0.60); // Only if Y is above water zone

        const spawnFromLeft = canSpawnFromLeft && (Math.random() > 0.5);
        if (spawnFromLeft) {
          bear.x = -80;
          bear.direction = 1; // Walk right
          bear.element.classList.remove('walking-left');
        } else {
          bear.x = containerWidth + 80;
          bear.direction = -1; // Walk left
          bear.element.classList.add('walking-left');
        }
        bear.state = 'walking';
        bear.element.style.left = bear.x + 'px';

        cityBears.push(bear);
      }

      // Initialize with responsive number of bears - SPAWN ON SCREEN!
      function initializeBears() {
        const maxBears = getMaxBears();
        // üêª‚ùÑÔ∏è COCAINE BEAR: Console logs removed for clean production

        // Spawn bears DIRECTLY ON SCREEN (not off-screen)
        for (let i = 0; i < maxBears; i++) {
          if (availableBearImages.length === 0) {
            availableBearImages = [...bearImages];
          }
          const randomIndex = Math.floor(Math.random() * availableBearImages.length);
          const imageSrc = availableBearImages[randomIndex];
          availableBearImages.splice(randomIndex, 1);

          const bear = new CityBear(imageSrc, i);

          // Position ON SCREEN - randomize across the full ground area (40% to 90%)
          bear.y = (containerHeight * 0.4) + Math.random() * (containerHeight * 0.5);

          // X position: if bear is in lower area (below 60%), avoid water zone on left
          const isInWaterYZone = bear.y > (containerHeight * 0.60);
          const safeXStart = isInWaterYZone ? (containerWidth * 0.35) : 0;
          bear.x = safeXStart + Math.random() * (containerWidth - safeXStart - 80);
          bear.element.style.left = bear.x + 'px';
          bear.element.style.top = bear.y + 'px';

          cityBears.push(bear);
        }
        // üêª‚ùÑÔ∏è All bears spawned silently
      }

      // Spawn new bears periodically
      setInterval(() => {
        if (cityBears.length < getMaxBears()) {
          spawnRandomBear();
        }
      }, 8000); // Try to spawn every 8 seconds

      // ANIMATION LOOP
      function animate() {
        cityBears.forEach(bear => bear.update());
        requestAnimationFrame(animate);
      }

      // HANDLE RESIZE
      function handleResize() {
        containerWidth = hero.offsetWidth;
        containerHeight = hero.offsetHeight;

        // Update water zone boundary only
        noWalkZones[0] = { // üíßüíßüíß WATER ZONE - Bottom portion only
          left: 0,
          right: containerWidth * 0.35,
          top: containerHeight * 0.60,   // Start at 60% from top (increased by 5%)
          bottom: containerHeight,
          name: 'WATER ZONE - ABSOLUTE NO ENTRY'
        };

        // Adjust bear count based on new screen size
        const maxBears = getMaxBears();
        if (cityBears.length > maxBears) {
          // Too many bears - remove excess
          const excess = cityBears.length - maxBears;
          console.log('üêªüìâ Screen got smaller - removing ' + excess + ' bears');
          for (let i = 0; i < excess; i++) {
            if (cityBears.length > 0) {
              const bear = cityBears[cityBears.length - 1];
              bear.despawn();
            }
          }
        }

      }

      window.addEventListener('resize', handleResize);

      // START THE CITY
      handleResize(); // Initialize zones
      initializeBears();
      animate();

      // üêª‚ùÑÔ∏è BEAR CITY initialized silently
    })();
  </script>

  <script>
    // Bear Park Sign - Simple & Clean
    (function() {
      const woodenSign = document.getElementById('woodenSign');
      const woodenSignContainer = document.getElementById('woodenSignContainer');

      if (!woodenSign || !woodenSignContainer) return;

      let clickCount = 0;
      let clickTimer = null;

      // Jester Bear Easter Egg - Click 5 times!
      woodenSign.addEventListener('click', () => {
        clickCount++;

        // Reset timer after 2 seconds of no clicks
        if (clickTimer) clearTimeout(clickTimer);
        clickTimer = setTimeout(() => clickCount = 0, 2000);

        // Quick bounce animation on click
        woodenSign.style.transform = 'scale(1.1)';
        setTimeout(() => woodenSign.style.transform = '', 150);

        // Spawn Jester Bear on 5th click!
        if (clickCount === 5) {
          spawnJesterBear();
          clickCount = 0;
          console.log('ü§°üêª JESTER BEAR HAS BEEN SUMMONED! üêªü§°');
        }
      });

      // Spawn Jester Bear running across screen
      function spawnJesterBear() {
        const jester = document.createElement('img');
        jester.src = 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/sv9big.png';
        jester.style.cssText = `
          position: fixed;
          bottom: 20%;
          left: -150px;
          width: 120px;
          height: auto;
          z-index: 99999;
          pointer-events: none;
          filter: drop-shadow(0 10px 30px rgba(0,0,0,0.5));
          transition: left 3s linear;
        `;

        document.body.appendChild(jester);

        // Animate across screen
        setTimeout(() => {
          jester.style.left = window.innerWidth + 'px';
          jester.style.transform = 'scaleX(-1)';
        }, 50);

        // Remove after animation
        setTimeout(() => jester.remove(), 3200);
      }

      // Simple fade out on scroll
      let scrollTicking = false;
      window.addEventListener('scroll', () => {
        if (scrollTicking) return;
        scrollTicking = true;

        requestAnimationFrame(() => {
          const scrollY = window.scrollY || window.pageYOffset;
          const opacity = Math.max(0, 1 - scrollY / 400);
          woodenSignContainer.style.opacity = opacity;
          scrollTicking = false;
        });
      });
    })();
  </script>

  <script>
    // üéØ FLOATING NAVIGATION BUTTONS WITH PARALLAX üéØ
    (function() {
      const floatingBtns = document.querySelectorAll('.floating-nav-btn');

      if (!floatingBtns.length) return;

      let mouseX = 0;
      let mouseY = 0;
      let mouseUpdateTicking = false;

      // Track mouse position
      document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;

        if (mouseUpdateTicking) return;
        mouseUpdateTicking = true;

        requestAnimationFrame(() => {
          const centerX = window.innerWidth / 2;
          const centerY = window.innerHeight / 2;

          // Calculate mouse offset from center
          const offsetX = (mouseX - centerX) / centerX;
          const offsetY = (mouseY - centerY) / centerY;

          floatingBtns.forEach(btn => {
            const depth = parseFloat(btn.getAttribute('data-depth')) || 0.8;

            // Apply parallax movement
            const moveX = offsetX * 20 * depth;
            const moveY = offsetY * 20 * depth;

            // Preserve centering for honey points button
            if (btn.id === 'honeyNavBtn') {
              btn.style.transform = `translateX(-50%) translate(${moveX}px, ${moveY}px)`;
            } else {
              btn.style.transform = `translate(${moveX}px, ${moveY}px)`;
            }
          });

          mouseUpdateTicking = false;
        });
      });

      // Add click handlers for smooth scrolling
      floatingBtns.forEach(btn => {
        const textElement = btn.querySelector('.floating-nav-text');
        if (!textElement) return;

        const sectionId = textElement.getAttribute('data-section');

        btn.addEventListener('click', () => {
          const targetSection = document.getElementById(sectionId);
          if (targetSection) {
            targetSection.scrollIntoView({
              behavior: 'smooth',
              block: 'start'
            });
          }
        });
      });

      // Scroll parallax - fade out as user scrolls
      let scrollTicking = false;
      window.addEventListener('scroll', () => {
        if (scrollTicking) return;
        scrollTicking = true;

        requestAnimationFrame(() => {
          const scrollY = window.scrollY || window.pageYOffset;
          const maxScroll = 800;
          const scrollProgress = Math.min(scrollY / maxScroll, 1);

          const opacity = Math.max(0, 1 - scrollProgress * 1.5);

          floatingBtns.forEach(btn => {
            btn.style.opacity = opacity;
          });

          scrollTicking = false;
        });
      });

      console.log('üéØ FLOATING NAV BUTTONS ACTIVE! Click to navigate! üéØ');
    })();
  </script>

  <style>
    @keyframes signGoNuts {
      0% { transform: scale(1) rotate(0deg); }
      10% { transform: scale(1.25) rotate(10deg); }
      20% { transform: scale(0.9) rotate(-10deg); }
      30% { transform: scale(1.15) rotate(8deg); }
      40% { transform: scale(0.95) rotate(-8deg); }
      50% { transform: scale(1.2) rotate(12deg); }
      60% { transform: scale(0.92) rotate(-5deg); }
      70% { transform: scale(1.1) rotate(5deg); }
      80% { transform: scale(0.97) rotate(-3deg); }
      90% { transform: scale(1.05) rotate(2deg); }
      100% { transform: scale(1) rotate(0deg); }
    }

    #woodenSignContainer {
      position: absolute;
      top: 38%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      animation: signFloat 4s ease-in-out infinite;
    }

    #woodenSign {
      width: 430px;
      height: auto;
      cursor: pointer;
      filter: drop-shadow(0 15px 30px rgba(0, 0, 0, 0.5));
      transition: transform 0.3s ease, filter 0.3s ease;
    }

    #woodenSign:hover {
      transform: scale(1.05);
      filter: drop-shadow(0 20px 40px rgba(0, 0, 0, 0.6));
    }

    @keyframes signFloat {
      0%, 100% { transform: translate(-50%, -50%) translateY(0); }
      50% { transform: translate(-50%, -50%) translateY(-8px); }
    }

    /* Responsive sizing */
    @media (max-width: 768px) {
      #woodenSign {
        width: 280px;
      }
      #woodenSignContainer {
        top: 35%;
      }
    }

    /* üéØ WHERE WOULD YOU LIKE TO GO BUTTON üéØ */
    #whereToGoBtn {
      position: absolute;
      bottom: 8%;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
    }

    .where-to-go-text {
      font-family: 'Luckiest Guy', cursive;
      font-size: clamp(18px, 2.5vw, 28px);
      color: #fff;
      padding: 16px 32px;
      background: rgba(10, 10, 15, 0.85);
      /* backdrop-filter removed for performance */
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      user-select: none;
      white-space: nowrap;
      text-align: center;
      position: relative;
      border: 3px solid transparent;
      background-clip: padding-box;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.5),
        0 0 40px rgba(139, 92, 246, 0.15),
        0 0 40px rgba(74, 222, 128, 0.1),
        0 0 40px rgba(237, 183, 35, 0.1);
    }

    .where-to-go-text::before {
      content: '';
      position: absolute;
      top: -3px;
      left: -3px;
      right: -3px;
      bottom: -3px;
      background: linear-gradient(135deg, #8b5cf6, #4ade80, #edb723, #8b5cf6);
      border-radius: 52px;
      z-index: -1;
      animation: navBtnBorderGlow 3s linear infinite;
      background-size: 300% 300%;
    }

    @keyframes navBtnBorderGlow {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .where-to-go-text:hover {
      transform: scale(1.05);
      background: rgba(10, 10, 15, 0.95);
      box-shadow:
        0 12px 40px rgba(0, 0, 0, 0.6),
        0 0 60px rgba(139, 92, 246, 0.25),
        0 0 60px rgba(74, 222, 128, 0.15),
        0 0 60px rgba(237, 183, 35, 0.15);
    }

    .where-to-go-text:active {
      transform: scale(0.98);
    }

    /* Navigation Modal Styles - BEAUTIFUL EDITION */
    .nav-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .nav-modal-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      /* backdrop-filter removed for performance */
    }

    .nav-modal-content {
      position: relative;
      background: linear-gradient(145deg, rgba(20, 20, 25, 0.98), rgba(10, 10, 15, 0.99));
      border: 4px solid transparent;
      border-radius: 24px;
      max-width: 700px;
      width: 92%;
      max-height: 85vh;
      overflow-y: auto;
      background-clip: padding-box;
      box-shadow:
        0 0 0 4px transparent,
        0 25px 80px rgba(0, 0, 0, 0.8),
        0 0 100px rgba(139, 92, 246, 0.15),
        0 0 100px rgba(74, 222, 128, 0.1),
        0 0 100px rgba(237, 183, 35, 0.1);
    }

    .nav-modal-content::before {
      content: '';
      position: absolute;
      top: -4px;
      left: -4px;
      right: -4px;
      bottom: -4px;
      background: linear-gradient(135deg, #8b5cf6, #4ade80, #edb723, #8b5cf6);
      border-radius: 26px;
      z-index: -1;
      animation: borderGlow 4s linear infinite;
      background-size: 300% 300%;
    }

    @keyframes borderGlow {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .nav-modal-header {
      padding: 24px 30px 20px;
      text-align: center;
      position: relative;
      background: linear-gradient(180deg, rgba(139, 92, 246, 0.1), transparent);
    }

    .nav-modal-title {
      font-family: 'Luckiest Guy', cursive;
      font-size: clamp(26px, 5vw, 38px);
      background: linear-gradient(135deg, #edb723, #f4d03f, #edb723);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin: 0;
      text-shadow: none;
      filter: drop-shadow(2px 2px 0 rgba(0,0,0,0.5));
    }

    .nav-modal-subtitle {
      color: #888;
      margin: 10px 0 0 0;
      font-size: 14px;
      font-weight: 500;
    }

    .nav-modal-close {
      position: absolute;
      top: 18px;
      right: 18px;
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(139, 92, 246, 0.1));
      border: 2px solid rgba(139, 92, 246, 0.5);
      color: #8b5cf6;
      font-size: 24px;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .nav-modal-close:hover {
      background: #8b5cf6;
      border-color: #8b5cf6;
      color: #fff;
      transform: rotate(90deg);
    }

    .nav-modal-body {
      padding: 10px 24px 28px;
    }

    .nav-modal-section {
      margin-bottom: 20px;
    }

    .nav-modal-section:last-child {
      margin-bottom: 0;
    }

    .nav-modal-section-title {
      font-family: 'Luckiest Guy', cursive;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin: 0 0 12px 4px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .nav-modal-section-title.purple { color: #8b5cf6; }
    .nav-modal-section-title.green { color: #4ade80; }
    .nav-modal-section-title.gold { color: #edb723; }
    .nav-modal-section-title.honey { color: #f59e0b; }

    .nav-modal-section-title::after {
      content: '';
      flex: 1;
      height: 1px;
      background: linear-gradient(90deg, currentColor, transparent);
      opacity: 0.3;
    }

    .nav-modal-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }

    @media (max-width: 550px) {
      .nav-modal-grid {
        grid-template-columns: 1fr;
        gap: 10px;
      }
    }

    .nav-modal-item {
      background: linear-gradient(135deg, rgba(40, 40, 50, 0.9), rgba(25, 25, 35, 0.95));
      border: 2px solid rgba(255, 255, 255, 0.08);
      border-radius: 14px;
      padding: 14px 18px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      gap: 14px;
    }

    .nav-modal-item:hover {
      transform: translateY(-3px) scale(1.02);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.4);
    }

    .nav-modal-item.purple:hover {
      border-color: #8b5cf6;
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(40, 40, 50, 0.95));
      box-shadow: 0 12px 30px rgba(139, 92, 246, 0.25);
    }

    .nav-modal-item.green:hover {
      border-color: #4ade80;
      background: linear-gradient(135deg, rgba(74, 222, 128, 0.2), rgba(40, 40, 50, 0.95));
      box-shadow: 0 12px 30px rgba(74, 222, 128, 0.25);
    }

    .nav-modal-item.gold:hover {
      border-color: #edb723;
      background: linear-gradient(135deg, rgba(237, 183, 35, 0.2), rgba(40, 40, 50, 0.95));
      box-shadow: 0 12px 30px rgba(237, 183, 35, 0.25);
    }

    .nav-modal-item.honey:hover {
      border-color: #f59e0b;
      background: linear-gradient(135deg, rgba(245, 158, 11, 0.25), rgba(40, 40, 50, 0.95));
      box-shadow: 0 12px 30px rgba(245, 158, 11, 0.3);
    }

    .nav-modal-icon {
      font-size: 26px;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .nav-modal-item-text {
      font-family: 'Luckiest Guy', cursive;
      font-size: 17px;
      color: #fff;
      letter-spacing: 0.5px;
    }

    /* Honey Decoration inside nav items */
    .nav-modal-item {
      position: relative;
    }

    .nav-item-honey {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      width: 28px;
      height: 28px;
      pointer-events: none;
      filter: drop-shadow(0 0 8px rgba(237, 183, 35, 0.6)) drop-shadow(0 0 16px rgba(237, 183, 35, 0.4));
      animation: honeyGlow 2s ease-in-out infinite;
      opacity: 0.9;
    }

    @keyframes honeyGlow {
      0%, 100% {
        filter: drop-shadow(0 0 8px rgba(237, 183, 35, 0.6)) drop-shadow(0 0 16px rgba(237, 183, 35, 0.4));
        transform: translateY(-50%) scale(1);
      }
      50% {
        filter: drop-shadow(0 0 12px rgba(237, 183, 35, 0.8)) drop-shadow(0 0 24px rgba(237, 183, 35, 0.6));
        transform: translateY(-50%) scale(1.05);
      }
    }

    /* Mobile: WHERE TO GO button */
    @media (max-width: 768px) {
      #whereToGoBtn {
        bottom: 5%;
      }
      .where-to-go-text {
        font-size: 14px !important;
        padding: 12px 24px;
      }
    }
  </style>

  <!-- Structured data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "name": "BEAR Park",
    "url": "https://bearpark.xyz/",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "https://bearpark.xyz/?q={search_term_string}",
      "query-input": "required name=search_term_string"
    }
  }
  </script>

  <script>
  // === VERSION CHECK - Force cache refresh ===
  (function checkVersion() {
    const CURRENT_VERSION = '2025-01-10-v2';
    const STORED_VERSION = localStorage.getItem('bearpark_site_version');

    if (STORED_VERSION !== CURRENT_VERSION) {
      console.log('üîÑ New version detected! Forcing cache refresh...');
      localStorage.setItem('bearpark_site_version', CURRENT_VERSION);

      // Force a hard reload if this is not the first visit
      if (STORED_VERSION !== null && !sessionStorage.getItem('bearpark_just_refreshed')) {
        sessionStorage.setItem('bearpark_just_refreshed', 'true');
        window.location.reload(true);
      }
    }
  })();

  // === API CONFIGURATION ===
  const API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
    ? 'http://localhost:3000'
    : '';

  // === SAFE STORAGE WRAPPER (Safari Private Mode Fix) ===
  // Safari Private Mode throws QuotaExceededError on localStorage.setItem()
  function safeStorage(action, key, value) {
    try {
      if (action === 'get') return localStorage.getItem(key);
      if (action === 'set') { localStorage.setItem(key, value); return true; }
      if (action === 'remove') { localStorage.removeItem(key); return true; }
    } catch (e) {
      console.warn('Storage unavailable (Private Mode?):', e.message);
      return action === 'get' ? null : false;
    }
  }

  // === FETCH WITH TIMEOUT (Safari/iOS Fix) ===
  // Safari aggressively times out slow requests - add explicit timeout handling
  async function fetchWithTimeout(url, options = {}, timeout = 15000) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    try {
      const response = await fetch(url, { ...options, signal: controller.signal });
      clearTimeout(id);
      return response;
    } catch (error) {
      clearTimeout(id);
      if (error.name === 'AbortError') {
        console.warn('Request timeout:', url);
        throw new Error('Request timeout - please try again');
      }
      throw error;
    }
  }

  // === INTERVAL MANAGER - Prevent memory leaks ===
  const IntervalManager = {
    intervals: new Map(),
    set(key, fn, ms) {
      // Clear existing interval with same key
      this.clear(key);
      // Set new interval and store reference
      const id = setInterval(fn, ms);
      this.intervals.set(key, id);
      return id;
    },
    clear(key) {
      if (this.intervals.has(key)) {
        clearInterval(this.intervals.get(key));
        this.intervals.delete(key);
      }
    },
    clearAll() {
      this.intervals.forEach(id => clearInterval(id));
      this.intervals.clear();
    }
  };

  // Clear all intervals when page unloads or user navigates away
  window.addEventListener('beforeunload', () => IntervalManager.clearAll());
  window.addEventListener('pagehide', () => IntervalManager.clearAll());

  // === AUTHENTICATION CHECK - Prevent bypass ===
  (function checkAuth(){
    // BACKWARDS COMPATIBILITY: Migrate sessionStorage to localStorage for old logins
    if (!localStorage.getItem('bearpark_wallet') && sessionStorage.getItem('bearpark_wallet')) {
      localStorage.setItem('bearpark_wallet', sessionStorage.getItem('bearpark_wallet'));
      localStorage.setItem('bearpark_auth', 'true');
      console.log('‚úÖ Migrated wallet from sessionStorage to localStorage');
    }

    const isAuthenticated = localStorage.getItem('bearpark_auth');
    const authenticatedWallet = localStorage.getItem('bearpark_wallet');

    // If not authenticated, redirect to login page
    if(isAuthenticated !== 'true' || !authenticatedWallet){
      window.location.href = 'index.html';
      return;
    }

    // Optional: Display wallet address in console for debugging
    console.log('Authenticated wallet:', authenticatedWallet);

    // Add logout button inside drawer
    const logoutBtn = document.createElement('button');
    logoutBtn.className = 'drawer-disconnect-btn';
    logoutBtn.innerHTML = '<span>disconnect</span>';
    logoutBtn.setAttribute('aria-label', 'Disconnect wallet and logout');
    logoutBtn.addEventListener('click', function(){
      if(confirm('Are you sure you want to disconnect your wallet?')){
        localStorage.removeItem('bearpark_auth');
        localStorage.removeItem('bearpark_wallet');
        window.location.href = 'index.html';
      }
    });
    const disconnectContainer = document.getElementById('drawerDisconnectContainer');
    if(disconnectContainer){
      disconnectContainer.appendChild(logoutBtn);
    }
  })();

  document.documentElement.classList.remove('no-js');

  /* Input modality hint */
  document.addEventListener('mousedown',()=>document.body.classList.add('using-mouse'));
  document.addEventListener('keydown',()=>document.body.classList.remove('using-mouse'));

  /* ===== Scroll reveal ===== */
  const io=new IntersectionObserver((entries)=>entries.forEach(e=>{
    if(e.isIntersecting){
      e.target.classList.add('in'); io.unobserve(e.target);
    }
  }),{threshold:.15});
  document.querySelectorAll('.reveal').forEach(el=>io.observe(el));

  /* ===== Sticky nav scroll progress + scrollspy ===== */
  (function(){
    const progress = document.getElementById('progress');
    const links = Array.from(document.querySelectorAll('.links a'));
    const sections = links.map(a => document.querySelector(a.getAttribute('href'))).filter(Boolean);

    function spy(){
      const de=document.documentElement;
      const scrollTop = de.scrollTop || document.body.scrollTop;
      const scrollHeight = de.scrollHeight - de.clientHeight;
      const pct = scrollHeight ? scrollTop / scrollHeight : 0;
      if(progress) progress.style.transform = `scaleX(${pct})`;

      let activeIndex = sections.findIndex((sec, i) => {
        const next = sections[i+1];
        const top = sec.offsetTop - 120;
        const bottom = next ? next.offsetTop - 120 : Infinity;
        return scrollTop >= top && scrollTop < bottom;
      });
      links.forEach((a,i)=> a.setAttribute('aria-current', i===activeIndex ? 'true' : 'false'));
    }
    document.addEventListener('scroll', spy, {passive:true});
    window.addEventListener('resize', spy);
    spy();
  })();

  /* ===== Hero parallax ===== */
  (function(){
    const plate=document.getElementById('heroPlate');
    if(!plate) return;
    if (matchMedia('(prefers-reduced-motion: reduce)').matches) return;

    function tilt(x,y){
      const rX = (y-0.5)*10;
      const rY = (x-0.5)*-10;
      plate.style.transform = `perspective(800px) rotateX(${rX}deg) rotateY(${rY}deg) translateZ(0)`;
    }
    function reset(){ plate.style.transform='perspective(800px) rotateX(0) rotateY(0)'; }

    window.addEventListener('mousemove',e=>{
      const r=plate.getBoundingClientRect();
      tilt((e.clientX-r.left)/r.width,(e.clientY-r.top)/r.height);
    });
    window.addEventListener('mouseleave',reset);
  })();

  /* ===== Magnetic buttons (skip on touch) ===== */
  (function(){
    if (matchMedia('(pointer: coarse)').matches) return;
    const strength = 14;
    const maxShift = 10;

    document.querySelectorAll('.btn').forEach(btn=>{
      let raf = null;
      function onMove(e){
        if (raf) cancelAnimationFrame(raf);
        raf = requestAnimationFrame(()=>{
          const rect = btn.getBoundingClientRect();
          const cx = rect.left + rect.width/2;
          const cy = rect.top + rect.height/2;
          const dx = Math.max(-maxShift, Math.min(maxShift, (e.clientX - cx)/strength));
          const dy = Math.max(-maxShift, Math.min(maxShift, (e.clientY - cy)/strength));
          btn.style.transform = `translate(${dx}px, ${dy}px)`;
        });
      }
      btn.addEventListener('mousemove', onMove);
      btn.addEventListener('mouseleave', ()=>{
        if (raf) cancelAnimationFrame(raf);
        btn.style.transform = 'translate(0,0)';
      });
    });
  })();

  /* ===== Carousel: a11y + keys + swipe + zoom/pan ===== */
  (function(){
    const slides = document.getElementById('slides');
    const viewport = document.getElementById('viewport');
    const prevBtn = document.getElementById('carouselPrev');
    const nextBtn = document.getElementById('carouselNext');
    if(!slides || !viewport) return;

    const imgs = slides.querySelectorAll('img');
    const dotsWrap = document.getElementById('dots');

    const Z_MIN = 1, Z_MAX = 4;
    let idx=0, n=imgs.length, timer=null, userPaused=false;
    let isDrag=false, startX=0, deltaX=0, dragged=false;
    let scale=1, panX=0, panY=0, pinchStartDist=0, startScale=1, lastX=0, lastY=0;
    let zoomGesture=false;

    imgs.forEach((_,i)=>{
      const b=document.createElement('button');
      b.type='button';
      b.className='dot'+(i===0?' active':'');
      b.setAttribute('role','tab');
      b.setAttribute('aria-selected', i===0 ? 'true' : 'false');
      b.setAttribute('aria-label', `Show slide ${i+1} of ${n}`);
      b.addEventListener('click', ()=>go(i,true));
      dotsWrap.appendChild(b);
    });
    const dots=[...dotsWrap.children];

    function applyZoom(){ imgs[idx].style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`; }
    function resetZoom(all=false){
      scale=1; panX=0; panY=0;
      (all?imgs:[imgs[idx]]).forEach(i=>{
        i.style.transition='transform .2s ease';
        i.style.transform='scale(1)';
        setTimeout(()=>i.style.transition='',200);
      });
    }
    function clampPan(){
      const vw=viewport.clientWidth, vh=viewport.clientHeight;
      const maxX=(vw*(scale-1))/2, maxY=(vh*(scale-1))/2;
      panX=Math.max(-maxX,Math.min(maxX,panX));
      panY=Math.max(-maxY,Math.min(maxY,panY));
    }
    function go(i, user){
      resetZoom(true);
      idx=(i+n)%n;
      slides.style.transition='transform .7s var(--ease-spring)';
      slides.style.transform=`translateX(-${idx*100}%)`;
      dots.forEach((d,k)=>{
        const active = k===idx;
        d.classList.toggle('active',active);
        d.setAttribute('aria-selected', active ? 'true' : 'false');
      });
      viewport.setAttribute('aria-label', `Carousel viewport ‚Äî slide ${idx+1} of ${n}`);
      if(user && !userPaused) restart();
    }
    function next(){ go(idx+1,false) }
    function restart(){
      clearInterval(timer);
      timer=setInterval(()=>{ if(!userPaused && scale===1) next(); },4000);
    }

    // Arrow button navigation
    if(prevBtn) {
      prevBtn.addEventListener('click', (e)=>{
        e.stopPropagation();
        go(idx-1, true);
      });
    }
    if(nextBtn) {
      nextBtn.addEventListener('click', (e)=>{
        e.stopPropagation();
        go(idx+1, true);
      });
    }

    viewport.addEventListener('mousedown',e=>{
      isDrag=true; dragged=false; startX=e.clientX; lastX=e.clientX; lastY=e.clientY;
      viewport.classList.add('grabbing'); clearInterval(timer);
    });
    window.addEventListener('mousemove',e=>{
      if(!isDrag) return;
      if(scale>1){
        const dx=e.clientX-lastX, dy=e.clientY-lastY;
        lastX=e.clientX; lastY=e.clientY; panX+=dx; panY+=dy; clampPan(); applyZoom(); dragged=true; return;
      }
      deltaX=e.clientX-startX;
      slides.style.transition='none';
      slides.style.transform=`translateX(${ -idx*100 + (deltaX/viewport.clientWidth)*100 }%)`;
      if(Math.abs(deltaX)>3) dragged=true;
    });
    window.addEventListener('mouseup',()=>{
      if(!isDrag) return;
      isDrag=false; viewport.classList.remove('grabbing');
      if(scale>1){ if(!userPaused) restart(); return; }
      const threshold = viewport.clientWidth*0.12;
      if(Math.abs(deltaX)>threshold){ go(idx + (deltaX<0?1:-1), true); } else { go(idx,false); }
      if(!userPaused) restart();
    });

    viewport.addEventListener('click',()=>{
      if(dragged || scale>1 || zoomGesture) return;
      userPaused=!userPaused;
      if(userPaused) clearInterval(timer); else restart();
    });
    viewport.addEventListener('keydown',e=>{
      if(e.key==='ArrowRight'){ go(idx+1,true); }
      else if(e.key==='ArrowLeft'){ go(idx-1,true); }
      else if(e.key===' '){ userPaused=!userPaused; if(userPaused) clearInterval(timer); else restart(); e.preventDefault(); }
    });

    viewport.addEventListener('touchstart',e=>{
      if(e.touches.length===2){
        zoomGesture=true; clearInterval(timer);
        const [a,b]=e.touches; pinchStartDist=Math.hypot(a.clientX-b.clientX,a.clientY-b.clientY); startScale=scale;
      } else if(e.touches.length===1){
        dragged=false; startX=e.touches[0].clientX; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY;
      }
    },{passive:false});

    viewport.addEventListener('touchmove',e=>{
      if(zoomGesture && e.touches.length===2){
        e.preventDefault();
        const [a,b]=e.touches; const dist=Math.hypot(a.clientX-b.clientX,a.clientY-b.clientY);
        scale=Math.max(Z_MIN,Math.min(Z_MAX, startScale * (dist/pinchStartDist)));
        clampPan(); applyZoom();
      } else if(scale>1 && e.touches.length===1){
        e.preventDefault();
        const t=e.touches[0]; const dx=t.clientX-lastX, dy=t.clientY-lastY;
        lastX=t.clientX; lastY=t.clientY; panX+=dx; panY+=dy; clampPan(); applyZoom(); dragged=true;
      } else if(scale===1 && e.touches.length===1){
        const x=e.touches[0].clientX; deltaX=x-startX;
        slides.style.transition='none';
        slides.style.transform=`translateX(${ -idx*100 + (deltaX/viewport.clientWidth)*100 }%)`;
      }
    },{passive:false});

    viewport.addEventListener('touchend',e=>{
      if(zoomGesture && e.touches.length<2){
        zoomGesture=false;
        if(scale<=1.01){ scale=1; panX=0; panY=0; applyZoom(); }
        restart(); return;
      }
      if(scale>1){ restart(); return; }
      const threshold = viewport.clientWidth*0.12;
      if(Math.abs(deltaX)>threshold){ go(idx + (deltaX<0?1:-1), true); } else { go(idx,false); }
    });

    viewport.addEventListener('wheel',e=>{
      e.preventDefault(); clearInterval(timer);
      const rect=viewport.getBoundingClientRect();
      const cx=e.clientX-rect.left - rect.width/2;
      const cy=e.clientY-rect.top - rect.height/2;
      const prevScale=scale;
      scale = Math.max(Z_MIN, Math.min(Z_MAX, scale * (e.deltaY>0 ? 0.9 : 1.1)));
      panX = (panX + cx) * (scale/prevScale) - cx;
      panY = (panY + cy) * (scale/prevScale) - cy;
      clampPan(); applyZoom();
    },{passive:false});

    go(0,false);
    restart();
    window.addEventListener('visibilitychange',()=>document.hidden?clearInterval(timer):(!userPaused&&restart()));
  })();

  /* ===== Lazy load Kick iframe ===== */
  function loadKick(){
    const wrap=document.getElementById('kickWrap');
    if(!wrap || wrap.dataset.loaded) return;
    const iframe=document.createElement('iframe');
    iframe.src='https://player.kick.com/bearxrpl?autoplay=true&muted=true';
    iframe.allow='autoplay; encrypted-media; picture-in-picture';
    iframe.title='Kick Stream';
    wrap.innerHTML='';
    wrap.appendChild(iframe);
    wrap.dataset.loaded='1';
  }
  const kickBtn=document.getElementById('kickPlaceholder');
  if(kickBtn){
    kickBtn.addEventListener('click', loadKick);
    const obs=new IntersectionObserver((es,o)=>{
      es.forEach(e=>{ if(e.isIntersecting){ loadKick(); o.disconnect(); } });
    },{rootMargin:'200px'});
    obs.observe(kickBtn);
  }

  /* ===== Ensure all imgs lazy/async if not set ===== */
  document.querySelectorAll('img:not([loading])').forEach(img=>{ img.loading='lazy'; img.decoding='async'; });

  /* ===== Drawer + Prices (consolidated) ===== */
  (function(){
    const PAIR_ID = '4245415200000000000000000000000000000000.rbearguasyu7tuw53rufqzfdwmjhpjeqfw_xrp';
    const DS_URL = `https://api.dexscreener.com/latest/dex/pairs/xrpl/${PAIR_ID}`;

    /* FAB + drawer wiring */
    const fab=document.createElement('button');
    fab.className='fab-buy';
    fab.innerHTML='<span class="txt"><span style="font-family: \'Luckiest Guy\', cursive; color: #edb723;">BEAR</span> HUB</span>';
    fab.setAttribute('aria-controls','buyDrawer');
    fab.setAttribute('aria-expanded','false');
    fab.setAttribute('aria-label','Open BEAR HUB panel');
    document.body.appendChild(fab);

    const scrim=document.createElement('div');
    scrim.className='drawer-scrim';
    scrim.hidden=true;
    document.body.appendChild(scrim);

    const drawer=document.getElementById('buyDrawer');
    const closeBtn=drawer.querySelector('[data-close-drawer]');

    function openDrawer(){
      drawer.classList.add('open'); scrim.hidden=false;
      fab.setAttribute('aria-expanded','true'); drawer.setAttribute('aria-hidden','false');
      document.body.style.overflow='hidden';
      // Hide the "Where would you like to go?" button when drawer opens
      const whereBtn = document.getElementById('whereToGoBtn');
      if (whereBtn) whereBtn.style.display = 'none';
      loadPortfolioData(); // Load wallet portfolio data
      initializeProfileAndNFTs(); // Load profile data and NFTs

      // Hide instruction boxes if user has completed first-time setup OR already has a profile
      const setupComplete = localStorage.getItem('bearpark_profile_setup_complete') === 'true';

      // Check if user already has a profile
      const walletAddress = localStorage.getItem('bearpark_wallet');
      let hasProfile = false;
      if (walletAddress) {
        const profileKey = `bearpark_profile_${walletAddress}`;
        const localProfile = localStorage.getItem(profileKey);
        if (localProfile) {
          try {
            const profile = JSON.parse(localProfile);
            hasProfile = profile.display_name && (profile.avatar_nft || profile.avatar_url);
          } catch (e) {
            hasProfile = false;
          }
        }
      }

      if (setupComplete || hasProfile) {
        setTimeout(() => {
          const profileInstructionsBanner = document.getElementById('profileInstructions');
          const nftInstructionsBanner = document.getElementById('nftInstructions');
          if (profileInstructionsBanner) {
            profileInstructionsBanner.style.display = 'none';
          }
          if (nftInstructionsBanner) {
            nftInstructionsBanner.style.display = 'none';
          }
        }, 100); // Small delay to ensure elements are rendered
      }
    }
    function closeDrawer(){
      drawer.classList.remove('open'); scrim.hidden=true;
      fab.setAttribute('aria-expanded','false'); drawer.setAttribute('aria-hidden','true');
      document.body.style.overflow='';
      // Show the "Where would you like to go?" button again
      const whereBtn = document.getElementById('whereToGoBtn');
      if (whereBtn) whereBtn.style.display = '';
    }

    function openProfileSetup(){
      console.log('üî• [openProfileSetup] Function called!');
      const walletAddress = localStorage.getItem('bearpark_wallet');
      console.log('üî• [openProfileSetup] Wallet:', walletAddress);
      if (!walletAddress) {
        console.log('üî• [openProfileSetup] No wallet, opening drawer');
        openDrawer();
        return;
      }

      // Check if profile is already set
      const profileKey = `bearpark_profile_${walletAddress}`;
      const localProfile = localStorage.getItem(profileKey);

      let hasProfile = false;
      if (localProfile) {
        try {
          const profile = JSON.parse(localProfile);
          // Profile is considered "set" if it has both display_name and avatar
          hasProfile = profile.display_name && (profile.avatar_nft || profile.avatar_url);
        } catch (e) {
          hasProfile = false;
        }
      }

      // Check if user has completed first-time setup OR already has a profile (hide instruction boxes)
      const setupComplete = localStorage.getItem('bearpark_profile_setup_complete') === 'true';
      if (setupComplete || hasProfile) {
        // Hide instruction boxes immediately for returning users
        const profileInstructionsBanner = document.getElementById('profileInstructions');
        const nftInstructionsBanner = document.getElementById('nftInstructions');
        if (profileInstructionsBanner) {
          profileInstructionsBanner.style.display = 'none';
        }
        if (nftInstructionsBanner) {
          nftInstructionsBanner.style.display = 'none';
        }
      }

      if (!hasProfile) {
        console.log('üêª Opening profile setup for new user...');
        // Open drawer and scroll to profile section
        openDrawer();
        setTimeout(() => {
          const profileSection = document.getElementById('profileSection');
          const drawerBody = drawer.querySelector('.drawer-body');

          console.log('üêª Drawer opened, scrolling to profile section...', { profileSection, drawerBody });

          if (profileSection && drawerBody) {
            drawerBody.scrollTo({
              top: profileSection.offsetTop - 20,
              behavior: 'smooth'
            });

            // Add pulsing highlight effect to make it obvious
            profileSection.classList.add('profile-highlight-pulse');

            // Remove highlight after 5 seconds
            setTimeout(() => {
              profileSection.classList.remove('profile-highlight-pulse');
            }, 5000);

            console.log('‚úÖ Profile section highlighted and scrolled into view!');
          } else {
            console.error('‚ùå Could not find profileSection or drawerBody elements!');
          }
        }, 600); // Wait longer for drawer to fully open and render
      } else {
        // Wallet not connected - do nothing
        console.log('‚ö†Ô∏è Wallet not connected. Please connect wallet to access profile.');
      }
    }

    // Make function globally accessible for inline onclick handler
    window.openProfileSetup = openProfileSetup;

    function showBearSpaceTeaser(){
      // Create popup element
      const popup = document.createElement('div');
      popup.className = 'bear-space-popup';
      popup.innerHTML = `
        <div class="bear-space-popup-content">
          <div class="bear-space-icon">üêªüöÄ</div>
          <div class="bear-space-title">BEAR SPACE</div>
          <div class="bear-space-subtitle">Coming Soon</div>
          <div class="bear-space-description">Your personal BEAR universe is being prepared...</div>
        </div>
      `;

      // Add to body
      document.body.appendChild(popup);

      // Trigger animation
      setTimeout(() => popup.classList.add('show'), 10);

      // Auto-remove after 3 seconds
      setTimeout(() => {
        popup.classList.remove('show');
        setTimeout(() => popup.remove(), 300);
      }, 3000);

      // Click to dismiss
      popup.addEventListener('click', () => {
        popup.classList.remove('show');
        setTimeout(() => popup.remove(), 300);
      });
    }

    function showSuccessPopup(message, emoji = 'üéâ') {
      // Create bubbly success popup
      const popup = document.createElement('div');
      popup.className = 'bear-success-popup';
      popup.innerHTML = `
        <div class="bear-success-popup-content">
          <div class="bear-success-icon">${emoji}</div>
          <div class="bear-success-title">BEARISH SUCCESS!</div>
          <div class="bear-success-message">${message}</div>
          <div class="bear-success-sub">TO THE MOON! üöÄüêª</div>
        </div>
      `;

      // Add to body
      document.body.appendChild(popup);

      // Trigger animation
      setTimeout(() => popup.classList.add('show'), 10);

      // Auto-remove after 4 seconds
      setTimeout(() => {
        popup.classList.remove('show');
        setTimeout(() => popup.remove(), 500);
      }, 4000);

      // Click to dismiss
      popup.addEventListener('click', () => {
        popup.classList.remove('show');
        setTimeout(() => popup.remove(), 500);
      });
    }

    // ===== CONFETTI CELEBRATION SYSTEM üéâ =====
    function createConfetti(options = {}) {
      const {
        x = window.innerWidth / 2,
        y = window.innerHeight / 2,
        count = 50,
        spread = 360,
        colors = ['#edb723', '#680cd9', '#feb501', '#07ae08', '#d75c46', '#fff']
      } = options;

      const confettiContainer = document.createElement('div');
      confettiContainer.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 9999;
      `;
      document.body.appendChild(confettiContainer);

      for (let i = 0; i < count; i++) {
        const confetti = document.createElement('div');
        const color = colors[Math.floor(Math.random() * colors.length)];
        const size = Math.random() * 10 + 5;
        const angle = (spread / count) * i + (Math.random() - 0.5) * 30;
        const velocity = Math.random() * 300 + 200;
        const rotation = Math.random() * 360;
        const rotationSpeed = (Math.random() - 0.5) * 720;

        confetti.style.cssText = `
          position: absolute;
          left: ${x}px;
          top: ${y}px;
          width: ${size}px;
          height: ${size}px;
          background: ${color};
          opacity: 1;
          transform: rotate(${rotation}deg);
          border-radius: ${Math.random() > 0.5 ? '50%' : '2px'};
        `;

        confettiContainer.appendChild(confetti);

        const rad = (angle * Math.PI) / 180;
        const vx = Math.cos(rad) * velocity;
        const vy = Math.sin(rad) * velocity - 100;

        let posX = x;
        let posY = y;
        let velX = vx;
        let velY = vy;
        let rot = rotation;
        let opacity = 1;
        let startTime = Date.now();

        function animate() {
          const elapsed = (Date.now() - startTime) / 1000;
          if (elapsed > 3 || opacity <= 0) {
            confetti.remove();
            return;
          }

          velY += 500 * 0.016; // gravity
          velX *= 0.99; // air resistance
          posX += velX * 0.016;
          posY += velY * 0.016;
          rot += rotationSpeed * 0.016;
          opacity = Math.max(0, 1 - elapsed / 3);

          confetti.style.transform = `translate(${posX - x}px, ${posY - y}px) rotate(${rot}deg)`;
          confetti.style.opacity = opacity;

          requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);
      }

      setTimeout(() => confettiContainer.remove(), 3500);
    }

    // Confetti presets
    window.celebrateRaidWin = function() {
      createConfetti({ count: 100, spread: 360, y: window.innerHeight * 0.4 });
      setTimeout(() => createConfetti({ count: 50, spread: 180, y: window.innerHeight * 0.3 }), 200);
    };

    window.celebrateGameWin = function() {
      createConfetti({ count: 80, spread: 120, y: window.innerHeight * 0.5 });
    };

    window.celebrateAchievement = function() {
      createConfetti({ count: 60, spread: 90 });
    };

    window.celebrateProfileSave = function() {
      createConfetti({ count: 40, spread: 60, colors: ['#edb723', '#fff', '#680cd9'] });
    };

    // ===== ANIMATED COUNTER SYSTEM üî¢ =====
    function animateCounter(element, start, end, duration = 1000, suffix = '') {
      if (!element) return;

      const startTime = Date.now();
      const range = end - start;

      function update() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Ease out cubic
        const easeProgress = 1 - Math.pow(1 - progress, 3);
        const current = Math.floor(start + range * easeProgress);

        element.textContent = current.toLocaleString() + suffix;
        element.style.transform = `scale(${1 + (1 - progress) * 0.2})`;

        if (progress < 1) {
          requestAnimationFrame(update);
        } else {
          element.style.transform = 'scale(1)';
        }
      }

      element.style.transition = 'transform 0.3s ease';
      requestAnimationFrame(update);
    }

    window.animateCounter = animateCounter;

    // Expose functions to global scope for onclick handlers
    window.openProfileSetup = openProfileSetup;
    window.showBearSpaceTeaser = showBearSpaceTeaser;
    window.closeDrawer = closeDrawer;

    fab.addEventListener('click', openDrawer);
    closeBtn.addEventListener('click', closeDrawer);
    scrim.addEventListener('click', closeDrawer);
    window.addEventListener('keydown', e=>{ if(e.key==='Escape') closeDrawer(); });

    const navBuy=document.querySelector('.nav-cta a[href="#network"]');
    if(navBuy){
      navBuy.addEventListener('click', (e)=>{ e.preventDefault(); openDrawer(); });
    }

    /* Build big duo metric lines (XRP first) */
    const priceCard = document.querySelector('.price-card');
    const metric = priceCard?.querySelector('.metric');
    const legacyUsdEl = document.getElementById('priceUsd');
    const volUsdEl = document.getElementById('vol24');
    const mcapUsdEl = document.getElementById('mcapUsd'); // NEW

    if (metric && !document.getElementById('bearXrpBig')) {
      metric.classList.add('duo');
      if (legacyUsdEl) legacyUsdEl.style.display='none';
      const usdSmall = legacyUsdEl && legacyUsdEl.nextElementSibling?.tagName==='SMALL' ? legacyUsdEl.nextElementSibling : null;
      if (usdSmall) usdSmall.style.display='none';

      const wrap=document.createElement('div');
      wrap.innerHTML =
        `<div class="line"><span class="label" style="white-space: nowrap; display: inline-flex; align-items: center; gap: 4px;"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png" alt="BEAR" style="height:0.9em; width:auto; display:inline-block;">BEAR / <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/lufprf.png" alt="XRP" style="height:0.9em; width:auto; display:inline-block;">XRP</span><span id="bearXrpBig" class="price">‚Äî</span></div>
         <div class="line"><span class="label" style="white-space: nowrap; display: inline-flex; align-items: center; gap: 4px;"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png" alt="BEAR" style="height:0.9em; width:auto; display:inline-block;">BEAR / üíµ USD</span><span id="bearUsdBig" class="price">‚Äî</span></div>`;
      metric.prepend(wrap);

      const st=document.createElement('style');
      st.textContent=
        `.price-card .metric.duo{flex-direction:column;align-items:flex-start;gap:.4rem}
         .price-card .metric .line{display:flex;align-items:baseline;gap:.6rem;flex-wrap:wrap}
         .price-card .metric .label{color:var(--gold);font-weight:900;letter-spacing:.3px}
         .price-card .metric .price{color:#fff;font-weight:900}`;
      document.head.appendChild(st);
    }

    function $id(id){ return document.getElementById(id); }
    const fmt = (n, min=2, max=8) => Number(n).toLocaleString(undefined,{minimumFractionDigits:min, maximumFractionDigits:max});
    const fmt0 = (n) => Number(n).toLocaleString(undefined,{maximumFractionDigits:0});

    async function fetchDex(){
      const r=await fetch(DS_URL,{cache:'no-store'});
      if(!r.ok) throw new Error('Price API HTTP '+r.status);
      const j=await r.json();
      const p=j?.pairs?.[0];
      if(!p) throw new Error('Pair not found');
      return {
        priceNative: Number(p.priceNative),
        priceUsd: p.priceUsd!=null?Number(p.priceUsd):NaN,
        vol24Usd: Number(p.volume?.h24 ?? p.volume24h ?? 0),
        // NEW: Prefer marketCap; fallback to fdv
        mcapUsd: Number((p.marketCap ?? p.fdv) ?? NaN),
        // Add liquidity data
        liquidityUsd: Number(p.liquidity?.usd ?? 0),
        // Add 24h price change
        priceChange24h: Number(p.priceChange?.h24 ?? 0),
        // Add transaction data
        txns: p.txns || {}
      };
    }

    // XRP/USD price - using static value (removed CoinGecko to eliminate console spam)
    async function fetchXrpPrice(){
      return 2.5; // Static price - update manually if needed
    }

    async function updatePrices(){
      try{
        const {priceNative, priceUsd, vol24Usd, mcapUsd, liquidityUsd, priceChange24h, txns} = await fetchDex();
        const xrpPrice = await fetchXrpPrice();
        const xrpLine = $id('bearXrpBig');
        const usdLine = $id('bearUsdBig');

        if (Number.isFinite(priceNative) && xrpLine){
          const d = priceNative >= 1 ? {min:3,max:6} : {min:4,max:8};
          xrpLine.textContent = fmt(priceNative, d.min, d.max);
        }
        const usdVal = Number.isFinite(priceUsd) ? priceUsd : NaN;
        if (Number.isFinite(usdVal) && usdLine){
          usdLine.textContent = fmt(usdVal, 5, 8);
        }
        if (volUsdEl){
          const vol = Number.isFinite(vol24Usd) ? vol24Usd : NaN;
          if (Number.isFinite(vol)) volUsdEl.textContent = '$' + fmt0(vol);
        }
        // NEW: Market Cap update
        if (mcapUsdEl && Number.isFinite(mcapUsd)){
          mcapUsdEl.textContent = '$' + fmt0(mcapUsd);
        }

        if (legacyUsdEl && legacyUsdEl.textContent.trim()==='‚Äî' && Number.isFinite(usdVal)){
          legacyUsdEl.textContent = fmt(usdVal, 5, 8);
        }

        // Update Honey Points section
        updateHoneyPrices(priceNative, priceUsd, vol24Usd, mcapUsd, liquidityUsd, priceChange24h, xrpPrice, txns);
      }catch(err){
        console.debug('Price update failed', err);
      }
    }

    function updateHoneyPrices(priceNative, priceUsd, vol24Usd, mcapUsd, liquidityUsd, priceChange24h, xrpPrice, txns){
      // Update price stats
      const honeyPriceXrp = $id('honeyPriceXrp');
      const honeyPriceUsd = $id('honeyPriceUsd');
      const honeyVolume = $id('honeyVolume');
      const honeyVolumeXrp = $id('honeyVolumeXrp');
      const honeyMcap = $id('honeyMcap');
      const honeyMcapXrp = $id('honeyMcapXrp');
      const honeyChange24h = $id('honeyChange24h');
      const honeyChange24hXrp = $id('honeyChange24hXrp');
      const liquidityBear = $id('liquidityBear');
      const liquidityXrp = $id('liquidityXrp');
      const liquidityUsdEl = $id('liquidityUsd');
      const liquidityMcapRatio = $id('liquidityMcapRatio');

      if (honeyPriceXrp && Number.isFinite(priceNative)){
        const d = priceNative >= 1 ? {min:3,max:6} : {min:4,max:8};
        honeyPriceXrp.textContent = fmt(priceNative, d.min, d.max) + ' XRP';
      }

      if (honeyPriceUsd && Number.isFinite(priceUsd)){
        honeyPriceUsd.textContent = '$' + fmt(priceUsd, 5, 8);
      }

      if (honeyVolume && Number.isFinite(vol24Usd)){
        honeyVolume.textContent = '$' + fmt0(vol24Usd);

        // Update USD DEXScreener volume total to match
        const usdVolumeTotal = $id('usdVolumeTotal');
        if (usdVolumeTotal) {
          usdVolumeTotal.textContent = '$' + fmt0(vol24Usd);
        }
      }

      // Calculate XRP 24h volume
      if (honeyVolumeXrp && Number.isFinite(vol24Usd) && Number.isFinite(xrpPrice)){
        const vol24Xrp = vol24Usd / xrpPrice;
        honeyVolumeXrp.textContent = fmt0(vol24Xrp) + ' XRP';

        // Update XRP DEXScreener volume total to match
        const xrpVolumeTotal = $id('xrpVolumeTotal');
        if (xrpVolumeTotal) {
          xrpVolumeTotal.textContent = fmt0(vol24Xrp) + ' XRP';
        }
      }

      if (honeyMcap && Number.isFinite(mcapUsd)){
        honeyMcap.textContent = '$' + fmt0(mcapUsd);
      }

      // Calculate XRP market cap
      if (honeyMcapXrp && Number.isFinite(mcapUsd) && Number.isFinite(xrpPrice)){
        const mcapXrp = mcapUsd / xrpPrice;
        honeyMcapXrp.textContent = fmt0(mcapXrp) + ' XRP';
      }

      // Update 24h change with color coding (same for both USD and XRP)
      if (honeyChange24h && Number.isFinite(priceChange24h)){
        const sign = priceChange24h >= 0 ? '+' : '';
        honeyChange24h.textContent = sign + priceChange24h.toFixed(2) + '%';
        honeyChange24h.style.color = priceChange24h >= 0 ? '#4ade80' : '#f87171';
      }

      // Update XRP 24h change (same percentage as USD)
      if (honeyChange24hXrp && Number.isFinite(priceChange24h)){
        const sign = priceChange24h >= 0 ? '+' : '';
        honeyChange24hXrp.textContent = sign + priceChange24h.toFixed(2) + '%';
        honeyChange24hXrp.style.color = priceChange24h >= 0 ? '#4ade80' : '#f87171';
      }

      // Calculate liquidity values
      if (liquidityUsdEl && Number.isFinite(liquidityUsd)){
        liquidityUsdEl.textContent = '$' + fmt0(liquidityUsd);
      }

      // Calculate BEAR liquidity (half of total liquidity USD / BEAR price)
      if (liquidityBear && Number.isFinite(liquidityUsd) && Number.isFinite(priceUsd)){
        const bearLiq = (liquidityUsd / 2) / priceUsd;
        liquidityBear.textContent = fmt0(bearLiq) + ' BEAR';
      }

      // Calculate XRP liquidity using real XRP price
      if (liquidityXrp && Number.isFinite(liquidityUsd) && Number.isFinite(xrpPrice)){
        // Assume roughly half of liquidity is in XRP
        const xrpLiq = (liquidityUsd / 2) / xrpPrice;
        liquidityXrp.textContent = fmt0(xrpLiq) + ' XRP';
      }

      // Calculate Liquidity to Market Cap Ratio
      if (liquidityMcapRatio && Number.isFinite(liquidityUsd) && Number.isFinite(mcapUsd) && mcapUsd > 0){
        const ratio = (liquidityUsd / mcapUsd) * 100;
        liquidityMcapRatio.textContent = ratio.toFixed(2) + '%';
      }

      // Update DEXScreener-style stats with real transaction data
      if (txns && txns.h24) {
        const h24 = txns.h24;
        const buys = Number(h24.buys || 0);
        const sells = Number(h24.sells || 0);
        const totalTxns = buys + sells;

        // Calculate volume split based on transaction ratio
        const buyRatio = totalTxns > 0 ? buys / totalTxns : 0.5;
        const sellRatio = totalTxns > 0 ? sells / totalTxns : 0.5;

        // Update Trading Activity card
        const tradingVolXrp = $id('tradingVolXrp');
        const tradingBuyVol = $id('tradingBuyVol');
        const tradingSellVol = $id('tradingSellVol');

        if (tradingVolXrp && Number.isFinite(vol24Usd) && Number.isFinite(xrpPrice)) {
          const vol24Xrp = vol24Usd / xrpPrice;
          tradingVolXrp.textContent = fmt0(vol24Xrp) + ' XRP';
        }

        // Estimate buy/sell volume based on transaction ratio
        if (Number.isFinite(vol24Usd) && Number.isFinite(priceUsd) && totalTxns > 0) {
          const totalVolBear = vol24Usd / priceUsd;
          const buyVolBear = totalVolBear * buyRatio;
          const sellVolBear = totalVolBear * sellRatio;

          if (tradingBuyVol) tradingBuyVol.textContent = fmt0(buyVolBear) + ' BEAR';
          if (tradingSellVol) tradingSellVol.textContent = fmt0(sellVolBear) + ' BEAR';
        }

        // Update TXNS for both USD and XRP (same transaction count)
        if (totalTxns > 0) {
          // USD TXNS
          const usdTxnsTotal = $id('usdTxnsTotal');
          const usdBuys = $id('usdBuys');
          const usdSells = $id('usdSells');
          const usdBuysBar = $id('usdBuysBar');
          const usdSellsBar = $id('usdSellsBar');

          if (usdTxnsTotal) usdTxnsTotal.textContent = totalTxns;
          if (usdBuys) usdBuys.textContent = buys;
          if (usdSells) usdSells.textContent = sells;
          if (usdBuysBar && usdSellsBar) {
            const buyPct = (buys / totalTxns) * 100;
            const sellPct = (sells / totalTxns) * 100;
            usdBuysBar.style.width = buyPct + '%';
            usdSellsBar.style.width = sellPct + '%';
          }

          // XRP TXNS (same as USD)
          const xrpTxnsTotal = $id('xrpTxnsTotal');
          const xrpBuys = $id('xrpBuys');
          const xrpSells = $id('xrpSells');
          const xrpBuysBar = $id('xrpBuysBar');
          const xrpSellsBar = $id('xrpSellsBar');

          if (xrpTxnsTotal) xrpTxnsTotal.textContent = totalTxns;
          if (xrpBuys) xrpBuys.textContent = buys;
          if (xrpSells) xrpSells.textContent = sells;
          if (xrpBuysBar && xrpSellsBar) {
            const buyPct = (buys / totalTxns) * 100;
            const sellPct = (sells / totalTxns) * 100;
            xrpBuysBar.style.width = buyPct + '%';
            xrpSellsBar.style.width = sellPct + '%';
          }
        }

        // Update MAKERS (unique buyers/sellers)
        const buyers = Number(h24.buyers || 0);
        const sellers = Number(h24.sellers || 0);
        const totalMakers = buyers + sellers;

        if (totalMakers > 0) {
          // USD MAKERS
          const usdMakersTotal = $id('usdMakersTotal');
          const usdBuyers = $id('usdBuyers');
          const usdSellers = $id('usdSellers');
          const usdBuyersBar = $id('usdBuyersBar');
          const usdSellersBar = $id('usdSellersBar');

          if (usdMakersTotal) usdMakersTotal.textContent = totalMakers;
          if (usdBuyers) usdBuyers.textContent = buyers;
          if (usdSellers) usdSellers.textContent = sellers;
          if (usdBuyersBar && usdSellersBar) {
            const buyersPct = (buyers / totalMakers) * 100;
            const sellersPct = (sellers / totalMakers) * 100;
            usdBuyersBar.style.width = buyersPct + '%';
            usdSellersBar.style.width = sellersPct + '%';
          }

          // XRP MAKERS (same as USD)
          const xrpMakersTotal = $id('xrpMakersTotal');
          const xrpBuyers = $id('xrpBuyers');
          const xrpSellers = $id('xrpSellers');
          const xrpBuyersBar = $id('xrpBuyersBar');
          const xrpSellersBar = $id('xrpSellersBar');

          if (xrpMakersTotal) xrpMakersTotal.textContent = totalMakers;
          if (xrpBuyers) xrpBuyers.textContent = buyers;
          if (xrpSellers) xrpSellers.textContent = sellers;
          if (xrpBuyersBar && xrpSellersBar) {
            const buyersPct = (buyers / totalMakers) * 100;
            const sellersPct = (sellers / totalMakers) * 100;
            xrpBuyersBar.style.width = buyersPct + '%';
            xrpSellersBar.style.width = sellersPct + '%';
          }
        }
      }
    }
    updatePrices();
    IntervalManager.set('updatePrices', updatePrices, 60000); // Use IntervalManager to prevent memory leaks
    document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) updatePrices(); });

    // ===== XRPL Direct Trading Stats (from XRPL Meta + OnTheDEX) =====
    async function fetchXRPLTradingStats() {
      try {
        const response = await fetch((window.API_BASE_URL || '') + '/api/xrpl/trading-stats');
        if (!response.ok) {
          console.warn('‚ö†Ô∏è XRPL trading stats API returned:', response.status);
          return;
        }
        const data = await response.json();
        if (!data.success || !data.stats) return;

        const stats = data.stats;
        console.log('üìä XRPL Trading Stats loaded (source: ' + data.source + '):', stats);

        // Update Trading Activity card with XRPL data (overrides DexScreener)
        const tradingVolXrp = $id('tradingVolXrp');
        const tradingBuyVol = $id('tradingBuyVol');
        const tradingSellVol = $id('tradingSellVol');
        const usdTxnsTotal = $id('usdTxnsTotal');
        const usdBuys = $id('usdBuys');
        const usdSells = $id('usdSells');
        const usdBuysBar = $id('usdBuysBar');
        const usdSellsBar = $id('usdSellsBar');

        // XRP Volume
        if (tradingVolXrp) {
          const volDisplay = stats.volume24hXRP >= 1000
            ? (stats.volume24hXRP / 1000).toFixed(1) + 'K XRP'
            : fmt0(stats.volume24hXRP) + ' XRP';
          tradingVolXrp.textContent = volDisplay;
        }

        // BEAR Volume - use buy/sell breakdown from API (DexScreener ratio applied to volume)
        const buyVol = stats.buyVolumeBEAR || 0;
        const sellVol = stats.sellVolumeBEAR || 0;

        const formatBearVol = (vol) => vol >= 1000000
          ? (vol / 1000000).toFixed(1) + 'M BEAR'
          : vol >= 1000
          ? Math.round(vol / 1000) + 'K BEAR'
          : fmt0(vol) + ' BEAR';

        if (tradingBuyVol) tradingBuyVol.textContent = formatBearVol(buyVol);
        if (tradingSellVol) tradingSellVol.textContent = formatBearVol(sellVol);

        // Traders count - use totalTrades (exchanges_24h from XRPL Meta)
        const totalTrades = stats.totalTrades || 0;

        // Display total traders
        if (usdTxnsTotal) usdTxnsTotal.textContent = totalTrades;

        // Use actual buy/sell transaction counts from DexScreener
        const buys24h = stats.buys24h || 0;
        const sells24h = stats.sells24h || 0;

        if (usdBuys) {
          usdBuys.textContent = buys24h;
          usdBuys.style.color = ''; // Reset color
        }
        if (usdSells) {
          usdSells.textContent = sells24h;
          usdSells.style.color = ''; // Reset color
        }

        // Progress bar based on buy/sell ratio
        if (usdBuysBar && usdSellsBar) {
          const total = buys24h + sells24h;
          const buyPct = total > 0 ? (buys24h / total) * 100 : 50;
          usdBuysBar.style.width = buyPct + '%';
          usdSellsBar.style.width = (100 - buyPct) + '%';
        }

      } catch (error) {
        console.warn('‚ö†Ô∏è Failed to fetch XRPL trading stats:', error.message);
        // Falls back to DexScreener data which is already loaded
      }
    }

    // Fetch XRPL stats on load and every 30 seconds
    fetchXRPLTradingStats();
    IntervalManager.set('fetchXRPLTradingStats', fetchXRPLTradingStats, 30000);

    /* ===== Chart Loading Detection ===== */
    const chartIframe = document.getElementById('dexscreener-embed');
    const chartError = document.getElementById('chart-error');

    if (chartIframe && chartError) {
      // Check if iframe loaded after 10 seconds
      setTimeout(() => {
        try {
          // Try to access iframe - if it fails, it might be blocked
          const iframeDoc = chartIframe.contentDocument || chartIframe.contentWindow.document;
          if (!iframeDoc || iframeDoc.readyState !== 'complete') {
            console.warn('Chart iframe may not have loaded properly');
          }
        } catch (e) {
          // CORS error is expected and means it's loading from external source (good)
          // Do nothing - this is normal for cross-origin iframes
        }
      }, 10000);

      // Handle iframe errors
      chartIframe.onerror = () => {
        console.error('Chart iframe failed to load');
        chartIframe.style.display = 'none';
        chartError.style.display = 'flex';
      };
    }

    /* ===== Portfolio & Points Functions ===== */
    async function loadPortfolioData() {
      console.log('üî• loadPortfolioData() CALLED!');
      const walletAddress = localStorage.getItem('bearpark_wallet');
      const isAuthenticated = localStorage.getItem('bearpark_auth') === 'true';
      console.log('üî• Wallet:', walletAddress, 'Auth:', isAuthenticated);

      const portfolioSection = document.getElementById('portfolioSection');
      const connectedWalletAddress = document.getElementById('connectedWalletAddress');

      if (!isAuthenticated || !walletAddress) {
        portfolioSection.style.display = 'none';
        return;
      }

      // Show portfolio section
      portfolioSection.style.display = 'block';
      connectedWalletAddress.textContent = walletAddress;

      // Check if xrpl library is loaded
      if (typeof xrpl === 'undefined') {
        console.error('[Portfolio] XRPL library not loaded!');
        document.getElementById('portfolioBearAmount').textContent = 'Error: Library not loaded';
        return;
      }

      try {
        // Set loading states
        document.getElementById('portfolioBearAmount').textContent = 'Loading...';
        document.getElementById('portfolioUsdValue').textContent = 'Loading...';
        document.getElementById('portfolioXrpValue').textContent = 'Loading...';

        // Connect to XRPL with fallback nodes
        const xrplNodes = [
          'wss://xrplcluster.com',
          'wss://s1.ripple.com',
          'wss://s2.ripple.com'
        ];

        let client = null;
        let lastError = null;

        for (const node of xrplNodes) {
          try {
            client = new xrpl.Client(node);
            await client.connect();
            break;
          } catch (err) {
            lastError = err;
            if (client) {
              try { await client.disconnect(); } catch(e) {}
            }
            client = null;
          }
        }

        if (!client) {
          console.error('[Portfolio] Unable to connect to any XRPL node');
          throw new Error('Unable to connect to XRPL nodes');
        }

        // Get $BEAR balance
        const accountLines = await client.request({
          command: 'account_lines',
          account: walletAddress,
          ledger_index: 'validated'
        });

        const BEAR_ISSUER = 'rBEARGUAsyu7tUw53rufQzFdWmJHpJEqFW';
        const BEAR_CURRENCY = 'BEAR';
        const BEAR_CURRENCY_HEX = '4245415200000000000000000000000000000000'; // "BEAR" in hex

        const bearLine = accountLines.result.lines.find(line =>
          line.account === BEAR_ISSUER &&
          (line.currency === BEAR_CURRENCY || line.currency === BEAR_CURRENCY_HEX)
        );

        const bearBalance = bearLine ? parseFloat(bearLine.balance) : 0;

        // Update BEAR amount immediately
        document.getElementById('portfolioBearAmount').textContent = bearBalance.toLocaleString('en-US', { maximumFractionDigits: 2 });

        // Fetch fresh price data from API
        try {
          const {priceNative, priceUsd} = await fetchDex();

          // Calculate values
          const usdValue = bearBalance * priceUsd;
          const xrpValue = bearBalance * priceNative;

          // Update UI with calculated values
          if (priceUsd > 0) {
            document.getElementById('portfolioUsdValue').textContent = '$' + usdValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
          } else {
            document.getElementById('portfolioUsdValue').textContent = 'Loading...';
          }

          if (priceNative > 0) {
            document.getElementById('portfolioXrpValue').textContent = xrpValue.toLocaleString('en-US', { maximumFractionDigits: 4 }) + ' XRP';
          } else {
            document.getElementById('portfolioXrpValue').textContent = 'Loading...';
          }
        } catch (priceErr) {
          console.error('[Portfolio] Error fetching prices:', priceErr);
          document.getElementById('portfolioUsdValue').textContent = 'N/A';
          document.getElementById('portfolioXrpValue').textContent = 'N/A';
        }

        await client.disconnect();

      } catch (err) {
        console.error('[Portfolio] ERROR loading portfolio:', err);
        console.error('[Portfolio] Error stack:', err.stack);
        document.getElementById('portfolioBearAmount').textContent = 'Error: ' + err.message;
        document.getElementById('portfolioUsdValue').textContent = 'Error';
        document.getElementById('portfolioXrpValue').textContent = 'Error';
      }

      // Load points data (will be implemented with backend)
      loadPointsData(walletAddress);

      // Load LP position data
      loadLPData(walletAddress);
    }

    async function loadLPData(walletAddress) {
      const lpSection = document.getElementById('lpSection');
      if (!lpSection) return;

      const AMM_POOL_ACCOUNT = 'rwE86ARLXfyKYCVmFpk511ddYfs5Fh6Vcp'; // BEAR/XRP AMM Pool Account

      try {
        // Set loading states
        document.getElementById('lpTokenAmount').textContent = 'Loading...';
        document.getElementById('lpPoolPercentage').textContent = 'Loading...';
        document.getElementById('lpBearAmount').textContent = 'Loading...';
        document.getElementById('lpXrpAmount').textContent = 'Loading...';
        document.getElementById('lpUsdValue').textContent = 'Loading...';

        // Connect to XRPL
        const client = new xrpl.Client('wss://xrplcluster.com');
        await client.connect();

        // Get account lines to find LP tokens from the AMM pool
        const accountLines = await client.request({
          command: 'account_lines',
          account: walletAddress,
          ledger_index: 'validated'
        });

        // Find LP tokens from the AMM pool account (LP tokens have 40-char hex currency)
        const lpLine = accountLines.result.lines.find(line =>
          line.account === AMM_POOL_ACCOUNT && line.currency.length === 40
        );

        if (!lpLine || parseFloat(lpLine.balance) === 0) {
          lpSection.style.display = 'none';
          await client.disconnect();
          return;
        }

        // Get AMM info using the pool account directly
        const ammInfoRequest = await client.request({
          command: 'amm_info',
          amm_account: AMM_POOL_ACCOUNT
        });

        if (!ammInfoRequest || !ammInfoRequest.result || !ammInfoRequest.result.amm) {
          lpSection.style.display = 'none';
          await client.disconnect();
          return;
        }

        const ammData = ammInfoRequest.result.amm;

        // Show LP section
        lpSection.style.display = 'block';

        const userLPTokens = parseFloat(lpLine.balance);
        const totalLPTokens = parseFloat(ammData.lp_token.value);
        const poolOwnershipPercent = (userLPTokens / totalLPTokens) * 100;

        // Get pool reserves - handle both XRP and token formats
        let bearReserve = 0;
        let xrpReserve = 0;

        // amount could be XRP (string in drops) or token (object with value)
        if (typeof ammData.amount === 'string') {
          xrpReserve = parseFloat(ammData.amount) / 1000000;
          bearReserve = parseFloat(ammData.amount2.value);
        } else if (typeof ammData.amount2 === 'string') {
          xrpReserve = parseFloat(ammData.amount2) / 1000000;
          bearReserve = parseFloat(ammData.amount.value);
        } else {
          bearReserve = parseFloat(ammData.amount.value);
          xrpReserve = parseFloat(ammData.amount2.value);
        }

        // Calculate user's share
        const userBearShare = bearReserve * (userLPTokens / totalLPTokens);
        const userXrpShare = xrpReserve * (userLPTokens / totalLPTokens);

        // Get prices
        const {priceNative, priceUsd} = await fetchDex();

        // Calculate USD value
        const bearUsdValue = userBearShare * priceUsd;
        const xrpUsdValue = userXrpShare * 2.50; // Approximate XRP price
        const totalUsdValue = bearUsdValue + xrpUsdValue;

        // Update UI
        document.getElementById('lpTokenAmount').textContent = userLPTokens.toLocaleString('en-US', { maximumFractionDigits: 6 });
        document.getElementById('lpPoolPercentage').textContent = poolOwnershipPercent.toFixed(4) + '%';
        document.getElementById('lpBearAmount').textContent = userBearShare.toLocaleString('en-US', { maximumFractionDigits: 2 });
        document.getElementById('lpXrpAmount').textContent = userXrpShare.toLocaleString('en-US', { maximumFractionDigits: 2 }) + ' XRP';
        document.getElementById('lpUsdValue').textContent = '$' + totalUsdValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

        await client.disconnect();

      } catch (err) {
        console.error('[LP] Error loading LP data:', err);
        lpSection.style.display = 'none';
      }
    }

    // Global P&L state
    let plChartInstance = null;
    let plData = null;
    let plFullData = null; // Store full unfiltered data
    let currentPLCurrency = 'XRP';

    // Switch P&L currency display
    window.switchPLCurrency = function(currency) {
      currentPLCurrency = currency;
      document.getElementById('plToggleXRP').classList.toggle('active', currency === 'XRP');
      document.getElementById('plToggleUSD').classList.toggle('active', currency === 'USD');
      if (plData) {
        updatePLDisplay(plData);
      }
    };



    async function loadPLChart(walletAddress) {
      const plSection = document.getElementById('plSection');
      if (!plSection) {
        console.error('üìä [P&L] ERROR: plSection element not found!');
        return;
      }

      // Demo mode for testing
      const FORCE_DEMO = false; // Set to true for demo data
      if (FORCE_DEMO) {
        console.log('üìä [P&L] DEMO MODE ACTIVATED');
        plSection.style.display = 'block';

        // Generate fake data points
        const demoDataPoints = [];
        const startDate = new Date('2024-04-13').getTime();
        const now = Date.now();
        let currentPL = -500;

        for (let i = 0; i < 30; i++) {
          const timestamp = startDate + (i * (now - startDate) / 30);
          currentPL += Math.random() * 200 - 50; // Random walk
          demoDataPoints.push({
            timestamp: timestamp,
            date: new Date(timestamp),
            totalPLXRP: currentPL,
            totalPLUSD: currentPL * 2.50,
            unrealizedXRP: currentPL * 0.7,
            unrealizedUSD: currentPL * 0.7 * 2.50,
            realizedXRP: currentPL * 0.3,
            realizedUSD: currentPL * 0.3 * 2.50
          });
        }

        plFullData = {
          dataPoints: demoDataPoints,
          totalPLXRP: currentPL,
          totalPLUSD: currentPL * 2.50,
          unrealizedXRP: currentPL * 0.7,
          unrealizedUSD: currentPL * 0.7 * 2.50,
          realizedXRP: currentPL * 0.3,
          realizedUSD: currentPL * 0.3 * 2.50,
          roiPercent: 25.5,
          totalBought: 1500000,
          totalSold: 300000
        };

        plData = plFullData;
        updatePLDisplay(plData);
        createPLChart(demoDataPoints);
        console.log('üìä [P&L] DEMO chart created!');
        return;
      }

      const BEAR_ISSUER = 'rKkkYMCvC63HEgxjQHmayKADaxYqnsMUkT';
      const BEAR_CURRENCY = '4245415200000000000000000000000000000000';

      try {
        console.log('üìä [P&L] Starting genius-level P&L analysis...');
        plSection.style.display = 'block';

        // Show loading indicator
        const loadingIndicator = document.getElementById('plLoadingIndicator');
        const loadingProgress = document.getElementById('plLoadingProgress');
        if (loadingIndicator) loadingIndicator.style.display = 'block';

        // Connect to XRPL
        const client = new xrpl.Client('wss://xrplcluster.com');
        await client.connect();
        console.log('üìä [P&L] Connected to XRPL');
        if (loadingProgress) loadingProgress.textContent = 'Connected to XRPL...';

        // Fetch ALL account transactions
        console.log('üìä [P&L] Fetching account transactions...');
        const allTransactions = [];
        let marker = undefined;
        let pageCount = 0;
        const maxPages = 20; // Limit for performance (20 pages = ~4000 transactions)

        while (pageCount < maxPages) {
          try {
            const txRequest = {
              command: 'account_tx',
              account: walletAddress,
              ledger_index_min: -1,
              ledger_index_max: -1,
              limit: 200
            };
            if (marker) txRequest.marker = marker;

            console.log(`üìä [P&L] Fetching page ${pageCount + 1}...`);
            if (loadingProgress) loadingProgress.textContent = `Fetching page ${pageCount + 1}/${maxPages}...`;
            const txResponse = await client.request(txRequest);
            allTransactions.push(...txResponse.result.transactions);

            marker = txResponse.result.marker;
            pageCount++;

            if (!marker) break;
          } catch (pageErr) {
            console.error(`üìä [P&L] Error fetching page ${pageCount + 1}:`, pageErr);
            break; // Stop pagination on error
          }
        }

        console.log(`üìä [P&L] Fetched ${allTransactions.length} total transactions across ${pageCount} pages`);
        if (loadingProgress) loadingProgress.textContent = `Analyzing ${allTransactions.length} transactions...`;

        // Filter for BEAR token transactions
        const bearTxs = allTransactions.filter(item => {
          const tx = item.tx;
          const meta = item.meta;

          // Check if transaction involves BEAR token
          if (tx.TransactionType === 'Payment') {
            const amount = tx.Amount;
            if (typeof amount === 'object' &&
                amount.currency === BEAR_CURRENCY &&
                amount.issuer === BEAR_ISSUER) {
              return true;
            }
          }

          // Check balance changes in metadata
          if (meta && meta.AffectedNodes) {
            for (const node of meta.AffectedNodes) {
              const fields = node.ModifiedNode?.FinalFields || node.CreatedNode?.NewFields;
              if (fields && fields.Balance && typeof fields.Balance === 'object' &&
                  fields.Balance.currency === BEAR_CURRENCY) {
                return true;
              }
            }
          }

          return false;
        });

        console.log(`üìä [P&L] Found ${bearTxs.length} BEAR transactions`);

        if (bearTxs.length === 0) {
          console.log('üìä [P&L] No BEAR transactions found - hiding P&L section');
          plSection.style.display = 'none';
          await client.disconnect();
          return;
        }

        // Sort transactions by date FIRST so we can debug
        bearTxs.sort((a, b) => a.tx.date - b.tx.date);

        // DEBUG: Log first and last transaction dates to find the timestamp issue
        const firstTx = bearTxs[0];
        const lastTx = bearTxs[bearTxs.length - 1];
        console.log('üîç [DEBUG] First TX raw XRPL date:', firstTx.tx.date);
        console.log('üîç [DEBUG] First TX converted:', new Date((firstTx.tx.date + 946684800) * 1000).toISOString());
        console.log('üîç [DEBUG] Last TX raw XRPL date:', lastTx.tx.date);
        console.log('üîç [DEBUG] Last TX converted:', new Date((lastTx.tx.date + 946684800) * 1000).toISOString());
        console.log('üîç [DEBUG] Current time:', new Date().toISOString());

        console.log('üìä [P&L] Showing P&L section and starting analysis...');

        // Show section
        plSection.style.display = 'block';

        // Get current prices
        console.log('üìä [P&L] Fetching current BEAR price...');
        const {priceNative, priceUsd} = await fetchDex();
        console.log('üìä [P&L] Current BEAR price:', priceNative, 'XRP,', priceUsd, 'USD');
        const xrpUsdPrice = 2.50; // Should fetch real XRP price
        console.log('üìä [P&L] Starting FIFO analysis...');

        // Analyze transactions with FIFO cost basis
        const costBasis = []; // Queue for FIFO
        const dataPoints = [];
        let totalBought = 0;
        let totalSold = 0;
        let realizedGainXRP = 0;
        let realizedGainUSD = 0;

        // Transactions already sorted above, start FIFO loop
        for (const item of bearTxs) {
          const tx = item.tx;
          const meta = item.meta;
          const timestamp = (tx.date + 946684800) * 1000; // Ripple epoch to Unix
          const date = new Date(timestamp);

          // Determine if this is a buy or sell
          let bearAmount = 0;
          let xrpCost = 0;
          let isBuy = false;

          if (tx.TransactionType === 'Payment') {
            const amount = tx.Amount;
            const deliveredAmount = meta.delivered_amount || amount;

            if (typeof deliveredAmount === 'object' && deliveredAmount.currency === BEAR_CURRENCY) {
              // Received BEAR (BUY)
              if (tx.Destination === walletAddress) {
                bearAmount = parseFloat(deliveredAmount.value);
                isBuy = true;

                // Calculate XRP cost (from SendMax or Amount)
                if (typeof tx.SendMax === 'string') {
                  xrpCost = parseInt(tx.SendMax) / 1000000;
                } else if (typeof tx.Amount === 'string') {
                  xrpCost = parseInt(tx.Amount) / 1000000;
                }
              }
              // Sent BEAR (SELL)
              else if (tx.Account === walletAddress) {
                bearAmount = parseFloat(deliveredAmount.value);
                isBuy = false;

                // Calculate XRP received
                if (typeof meta.delivered_amount === 'string') {
                  xrpCost = parseInt(meta.delivered_amount) / 1000000;
                } else if (typeof tx.SendMax === 'object' && !tx.SendMax.currency) {
                  xrpCost = parseInt(tx.SendMax) / 1000000;
                }
              }
            }
          }

          if (bearAmount === 0) continue;

          const costPerToken = xrpCost / bearAmount;

          if (isBuy) {
            // Add to cost basis queue
            costBasis.push({
              amount: bearAmount,
              costPerToken: costPerToken,
              timestamp: timestamp
            });
            totalBought += bearAmount;
          } else {
            // SELL - Calculate realized gain using FIFO
            let remainingToSell = bearAmount;
            let sellGainXRP = 0;

            while (remainingToSell > 0 && costBasis.length > 0) {
              const lot = costBasis[0];
              const sellFromThisLot = Math.min(remainingToSell, lot.amount);

              const soldForXRP = sellFromThisLot * costPerToken;
              const boughtForXRP = sellFromThisLot * lot.costPerToken;
              sellGainXRP += (soldForXRP - boughtForXRP);

              lot.amount -= sellFromThisLot;
              remainingToSell -= sellFromThisLot;

              if (lot.amount <= 0.0001) {
                costBasis.shift();
              }
            }

            realizedGainXRP += sellGainXRP;
            realizedGainUSD += sellGainXRP * xrpUsdPrice;
            totalSold += bearAmount;
          }

          // Calculate unrealized gain on remaining tokens
          const currentHoldings = costBasis.reduce((sum, lot) => sum + lot.amount, 0);
          const avgCostBasis = costBasis.length > 0
            ? costBasis.reduce((sum, lot) => sum + (lot.amount * lot.costPerToken), 0) / currentHoldings
            : 0;

          const unrealizedXRP = currentHoldings * (priceNative - avgCostBasis);
          const unrealizedUSD = unrealizedXRP * xrpUsdPrice;

          const totalPLXRP = realizedGainXRP + unrealizedXRP;
          const totalPLUSD = realizedGainUSD + unrealizedUSD;

          dataPoints.push({
            date: date,
            timestamp: timestamp,
            totalPLXRP: totalPLXRP,
            totalPLUSD: totalPLUSD,
            unrealizedXRP: unrealizedXRP,
            unrealizedUSD: unrealizedUSD,
            realizedXRP: realizedGainXRP,
            realizedUSD: realizedGainUSD,
            holdings: currentHoldings
          });
        }

        await client.disconnect();

        // Calculate final stats
        const currentHoldings = costBasis.reduce((sum, lot) => sum + lot.amount, 0);
        const avgCostBasis = costBasis.length > 0
          ? costBasis.reduce((sum, lot) => sum + (lot.amount * lot.costPerToken), 0) / currentHoldings
          : 0;

        const unrealizedXRP = currentHoldings * (priceNative - avgCostBasis);
        const unrealizedUSD = unrealizedXRP * xrpUsdPrice;
        const totalPLXRP = realizedGainXRP + unrealizedXRP;
        const totalPLUSD = realizedGainUSD + unrealizedUSD;
        const totalInvestedXRP = costBasis.reduce((sum, lot) => sum + (lot.amount * lot.costPerToken), 0);
        const roiPercent = totalInvestedXRP > 0 ? (totalPLXRP / totalInvestedXRP) * 100 : 0;

        plFullData = {
          dataPoints,
          totalPLXRP,
          totalPLUSD,
          unrealizedXRP,
          unrealizedUSD,
          realizedXRP: realizedGainXRP,
          realizedUSD: realizedGainUSD,
          roiPercent,
          totalBought,
          totalSold
        };

        plData = plFullData;

        console.log('üìä [P&L] FIFO analysis complete! Data points:', dataPoints.length);
        console.log('üìä [P&L] Total P&L:', totalPLXRP, 'XRP');

        if (loadingProgress) loadingProgress.textContent = 'Creating chart...';

        // Use all data (no timeframe filtering)
        plData = plFullData;

        // Update display
        console.log('üìä [P&L] Updating display...');
        updatePLDisplay(plFullData);

        // Create chart
        console.log('üìä [P&L] Creating chart with', plFullData.dataPoints.length, 'data points...');
        createPLChart(plFullData.dataPoints);

        // Hide loading indicator
        if (loadingIndicator) loadingIndicator.style.display = 'none';

        console.log('üìä [P&L] ‚úÖ Chart created successfully!');

      } catch (err) {
        console.error('[P&L] Error loading P&L chart:', err);
        console.error('[P&L] Error stack:', err.stack);
        plSection.style.display = 'none';
      }
    }

    function updatePLDisplay(data) {
      const isXRP = currentPLCurrency === 'XRP';
      const symbol = isXRP ? ' XRP' : ' USD';
      const prefix = isXRP ? '' : '$';

      const total = isXRP ? data.totalPLXRP : data.totalPLUSD;
      const unrealized = isXRP ? data.unrealizedXRP : data.unrealizedUSD;
      const realized = isXRP ? data.realizedXRP : data.realizedUSD;

      // Update stat boxes
      const totalEl = document.getElementById('plTotalValue');
      const unrealizedEl = document.getElementById('plUnrealizedValue');
      const realizedEl = document.getElementById('plRealizedValue');
      const roiEl = document.getElementById('plROIValue');

      totalEl.textContent = prefix + total.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + symbol;
      totalEl.className = 'pl-stat-value ' + (total >= 0 ? 'positive' : 'negative');

      unrealizedEl.textContent = prefix + unrealized.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + symbol;
      unrealizedEl.className = 'pl-stat-value ' + (unrealized >= 0 ? 'positive' : 'negative');

      realizedEl.textContent = prefix + realized.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + symbol;
      realizedEl.className = 'pl-stat-value ' + (realized >= 0 ? 'positive' : 'negative');

      roiEl.textContent = (data.roiPercent >= 0 ? '+' : '') + data.roiPercent.toFixed(2) + '%';
      roiEl.className = 'pl-stat-value ' + (data.roiPercent >= 0 ? 'positive' : 'negative');


      // Update chart if it exists
      if (plChartInstance) {
        plChartInstance.data.datasets[0].data = data.dataPoints.map(d => ({
          x: d.date,
          y: isXRP ? d.totalPLXRP : d.totalPLUSD
        }));
        plChartInstance.options.plugins.tooltip.callbacks.label = function(context) {
          const value = context.parsed.y;
          return prefix + value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + symbol;
        };
        plChartInstance.update();
      }
    }

    function createPLChart(dataPoints) {
      console.log('üìä [CHART] createPLChart() called with', dataPoints.length, 'data points');
      const canvas = document.getElementById('plChart');
      const noDataIndicator = document.getElementById('plNoDataIndicator');

      console.log('üìä [CHART] Canvas element:', canvas);
      if (!canvas) {
        console.error('üìä [CHART] ERROR: Canvas not found!');
        return;
      }

      // Check if we have enough data points to draw a line chart
      if (dataPoints.length < 2) {
        console.warn('üìä [CHART] Insufficient data points (<2), showing no-data message');
        const loadingIndicator = document.getElementById('plLoadingIndicator');
        if (loadingIndicator) loadingIndicator.style.display = 'none';
        if (noDataIndicator) noDataIndicator.style.display = 'block';
        canvas.style.display = 'none';

        // Destroy existing chart instance if it exists
        if (plChartInstance) {
          plChartInstance.destroy();
          plChartInstance = null;
        }
        return;
      }

      // Hide no-data indicator and loading indicator, show canvas
      const loadingIndicator = document.getElementById('plLoadingIndicator');
      if (loadingIndicator) loadingIndicator.style.display = 'none';
      if (noDataIndicator) noDataIndicator.style.display = 'none';
      canvas.style.display = 'block';

      // Destroy existing chart instance if it exists
      if (plChartInstance) {
        console.log('üìä [CHART] Destroying existing chart instance');
        plChartInstance.destroy();
        plChartInstance = null;
      }

      // Get a fresh context
      const ctx = canvas.getContext('2d');
      console.log('üìä [CHART] Canvas context:', ctx);
      if (!ctx) {
        console.error('üìä [CHART] ERROR: Could not get canvas context!');
        return;
      }

      const isXRP = currentPLCurrency === 'XRP';
      console.log('üìä [CHART] Creating Chart.js instance... Currency:', isXRP ? 'XRP' : 'USD');

      try {
        plChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [{
            label: 'P&L Over Time',
            data: dataPoints.map(d => ({
              x: d.timestamp,
              y: isXRP ? d.totalPLXRP : d.totalPLUSD
            })),
            segment: {
              borderColor: ctx => {
                // Use segment styling to color based on y value
                const p0 = ctx.p0;
                const p1 = ctx.p1;
                if (!p0 || !p1) return '#4CAF50';
                const avg = (p0.parsed.y + p1.parsed.y) / 2;
                return avg >= 0 ? '#4CAF50' : '#f44336';
              }
            },
            borderColor: '#4CAF50', // Default color
            backgroundColor: function(context) {
              const chart = context.chart;
              const {ctx, chartArea} = chart;
              if (!chartArea) return 'rgba(76, 175, 80, 0.1)';

              const gradient = ctx.createLinearGradient(0, chartArea.top, 0, chartArea.bottom);
              gradient.addColorStop(0, 'rgba(76, 175, 80, 0.3)');
              gradient.addColorStop(1, 'rgba(76, 175, 80, 0.0)');
              return gradient;
            },
            borderWidth: 3,
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            pointHoverRadius: 6,
            pointHoverBackgroundColor: '#edb723',
            pointHoverBorderColor: '#fff',
            pointHoverBorderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(0,0,0,0.8)',
              titleColor: '#edb723',
              bodyColor: '#fff',
              borderColor: '#edb723',
              borderWidth: 2,
              padding: 12,
              displayColors: false,
              callbacks: {
                title: function(context) {
                  return new Date(context[0].parsed.x).toLocaleDateString();
                },
                label: function(context) {
                  const value = context.parsed.y;
                  const prefix = isXRP ? '' : '$';
                  const symbol = isXRP ? ' XRP' : '';
                  return 'P&L: ' + prefix + value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + symbol;
                }
              }
            }
          },
          scales: {
            x: {
              type: 'linear',
              grid: {
                color: 'rgba(255,255,255,0.05)',
                drawBorder: false
              },
              ticks: {
                color: 'rgba(255,255,255,0.6)',
                maxRotation: 0,
                callback: function(value, index, ticks) {
                  // Convert timestamp back to date for display
                  const date = new Date(value);
                  const month = date.toLocaleDateString('en-US', { month: 'short' });
                  const day = date.getDate();
                  return month + ' ' + day;
                },
                maxTicksLimit: 8
              }
            },
            y: {
              grid: {
                color: 'rgba(255,255,255,0.05)',
                drawBorder: false
              },
              ticks: {
                color: 'rgba(255,255,255,0.6)',
                callback: function(value) {
                  const prefix = isXRP ? '' : '$';
                  return prefix + value.toFixed(0);
                }
              }
            }
          },
          interaction: {
            intersect: false,
            mode: 'index'
          }
        }
      });
      console.log('üìä [CHART] ‚úÖ Chart.js instance created successfully!', plChartInstance);
    } catch (error) {
      console.error('üìä [CHART] ‚ùå ERROR creating Chart.js instance:', error);
      console.error('üìä [CHART] Error stack:', error.stack);
    }
  }

    async function loadPointsData(walletAddress) {
      try {
        const response = await fetch(`${API_BASE_URL}/api/points/${walletAddress}`);
        if (!response.ok) {
          console.debug('Points API not available');
          return;
        }
        const data = await response.json();

        if (data.twitter_connected) {
          // Show connected state (with defensive checks)
          const pointsConnected = document.getElementById('pointsConnected');
          const pointsNotConnected = document.getElementById('pointsNotConnected');
          const totalPoints = document.getElementById('totalPoints');
          const connectedTwitter = document.getElementById('connectedTwitter');

          if (pointsConnected) pointsConnected.style.display = 'block';
          if (pointsNotConnected) pointsNotConnected.style.display = 'none';
          if (totalPoints) totalPoints.textContent = data.total_points;
          if (connectedTwitter) connectedTwitter.textContent = data.twitter_username;

          // Load activity (with defensive checks)
          const activityList = document.getElementById('activityList');
          if (activityList) {
            if (data.recent_activity && data.recent_activity.length > 0) {
              activityList.innerHTML = data.recent_activity.map(activity => {
                const date = new Date(activity.created_at);
                const timeAgo = getTimeAgo(date);
                const points = activity.points_change > 0 ? `+${activity.points_change}` : activity.points_change;
                return `
                  <div style="display:flex; justify-content:space-between; padding:8px; background:rgba(255,255,255,0.05); border-radius:6px; margin-bottom:6px;">
                    <span style="font-size:12px;">${activity.description || activity.transaction_type}</span>
                    <span style="color:var(--gold); font-weight:900; font-size:12px;">${points} pts</span>
                  </div>
                `;
              }).join('');
            } else {
              activityList.innerHTML = '<div style="opacity:0.6; padding:12px; text-align:center;">No recent activity</div>';
            }
          }

          // Load active raids
          loadActiveRaids();
        } else {
          // Show not connected state (with defensive checks)
          const pointsConnected = document.getElementById('pointsConnected');
          const pointsNotConnected = document.getElementById('pointsNotConnected');
          if (pointsConnected) pointsConnected.style.display = 'none';
          if (pointsNotConnected) pointsNotConnected.style.display = 'block';
        }
      } catch (err) {
        console.error('Error loading points:', err);
        // Show not connected state on error (with defensive checks)
        const pointsConnected = document.getElementById('pointsConnected');
        const pointsNotConnected = document.getElementById('pointsNotConnected');
        if (pointsConnected) pointsConnected.style.display = 'none';
        if (pointsNotConnected) pointsNotConnected.style.display = 'block';
      }
    }

    async function loadActiveRaids() {
      try {
        const response = await fetch('/api/raids/active');
        const data = await response.json();

        const activeRaidsSection = document.getElementById('activeRaids');
        const raidInfo = document.getElementById('raidInfo');
        const viewRaidBtn = document.getElementById('viewRaidBtn');

        if (data.success && data.raids && data.raids.length > 0) {
          const raid = data.raids[0]; // Show first active raid
          activeRaidsSection.style.display = 'block';

          raidInfo.innerHTML = `
            <div style="font-weight:900; margin-bottom:4px;">${raid.raid_title}</div>
            <div style="opacity:0.8; font-size:12px;">Target: ${raid.target_account}</div>
            <div style="opacity:0.8; font-size:12px;">Reward: ${raid.points_per_participation} points</div>
          `;

          viewRaidBtn.onclick = () => {
            window.open(raid.raid_url, '_blank');
          };
        } else {
          activeRaidsSection.style.display = 'none';
        }
      } catch (err) {
        console.error('Error loading raids:', err);
        document.getElementById('activeRaids').style.display = 'none';
      }
    }

    /* ===== Honey Points Section Functions ===== */
    async function loadHoneyPoints() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      const isAuthenticated = localStorage.getItem('bearpark_auth') === 'true';

      // ‚ùå localStorage no longer used for honey points - backend is ONLY source of truth

      // Show loading state initially - fetch from backend only
      // This prevents stale cached data from being displayed after admin resets
      const navHoneyPoints = document.getElementById('navHoneyPoints');
      const welcomePoints = document.getElementById('welcomePoints');

      if (navHoneyPoints) {
        navHoneyPoints.textContent = 'Loading...';
      }
      if (welcomePoints) {
        welcomePoints.textContent = '...';
      }

      // Fetch from backend FIRST - backend is the ONLY source of truth
      try {
        // Add cache-busting timestamp to force fresh data
        const response = await fetch(`${API_BASE_URL}/api/points/${walletAddress}?_t=${Date.now()}`, {
          cache: 'no-store',
          headers: {
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache'
          }
        });
        if (response.ok) {
          const data = await response.json();

          const backendTotal = data.total_points || 0;
          const backendRaiding = data.raiding_points || 0;
          const backendGames = data.games_points || 0;

          // üîí ALWAYS trust backend as source of truth to prevent multi-tab exploits
          // If local is higher, it might be stale data from an old tab before a purchase
          // Backend is the single source of truth - always use backend value
          console.log('üì• Using backend as source of truth:', backendTotal);

          updatePointsDisplay(backendTotal, backendRaiding, backendGames);
          if (navHoneyPoints) navHoneyPoints.textContent = backendTotal.toFixed(1) + ' PTS';

          // Update compact honey button
          const welcomePoints = document.getElementById('welcomePoints');
          if (welcomePoints) {
            welcomePoints.textContent = backendTotal.toFixed(1);
          }

          // ‚ùå REMOVED localStorage caching - backend is ONLY source of truth
          // Never cache honey points locally to prevent stale data exploits
        }

        // Load leaderboard to get rank
        loadHoneyLeaderboard(walletAddress);
      } catch (err) {
        console.error('Backend not available:', err);
        // ‚ùå NO localStorage fallback - if backend is down, show offline state
        // NEVER use cached points to prevent exploits and stale data
        updatePointsDisplay(0, 0, 0);
        if (navHoneyPoints) navHoneyPoints.textContent = 'Offline';
        if (welcomePoints) welcomePoints.textContent = '0.0';
      }
    }

    /* ===== Daily Game Progress ===== */
    async function loadDailyGameProgress() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) return;

      try {
        // Fetch daily game status from ALL games and sum them up
        const response = await fetch(`${API_BASE_URL}/api/games/daily-status/${walletAddress}/all-games`);

        if (!response.ok) {
          console.debug('Daily game status not available');
          return;
        }

        const data = await response.json();

        if (data.success) {
          const minutesToday = data.minutes_today || 0;
          const maxMinutes = data.max_minutes || 20;
          const remainingMinutes = typeof data.remaining_minutes === 'number' ? data.remaining_minutes : 20;
          const pointsToday = data.points_earned_today || 0;

          // Update UI
          document.getElementById('dailyGameCount').textContent = `${minutesToday.toFixed(1)}/${maxMinutes}`;
          document.getElementById('dailyGamePoints').textContent = `${pointsToday.toFixed(1)} pts earned today`;

          // Show countdown timer when limit reached
          if (remainingMinutes === 0) {
            updateGameResetCountdown();
            startGameResetCountdown(); // Start the interval to update every second
          } else {
            document.getElementById('dailyGamesRemaining').textContent = `${remainingMinutes.toFixed(1)} mins left`;
            document.getElementById('dailyGamesRemaining').style.color = '#ffffff';
          }

          // Update progress bar
          const progressPercent = (minutesToday / maxMinutes) * 100;
          const progressBar = document.getElementById('dailyProgressBar');
          progressBar.style.width = progressPercent + '%';

          // Change color when limit reached
          if (remainingMinutes === 0) {
            progressBar.style.background = 'linear-gradient(90deg, #ff6b6b 0%, #ee5a6f 50%, #ff6b6b 100%)';
            document.getElementById('dailyGamesRemaining').style.color = '#ff6b6b';
          }
        }
      } catch (err) {
        console.debug('Error loading daily game progress:', err);
      }
    }

    // TEST MODE: Set to true to simulate 10 seconds before reset
    window.TEST_COUNTDOWN_MODE = false;

    // Update countdown timer to next UTC midnight
    function updateGameResetCountdown() {
      const now = new Date();
      const tomorrow = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + 1, 0, 0, 0));

      // TEST MODE: Simulate being 10 seconds before midnight
      let diff = window.TEST_COUNTDOWN_MODE ? 10000 : (tomorrow - now);

      // Decrease test countdown each second
      if (window.TEST_COUNTDOWN_MODE && window.testCountdownSeconds !== undefined) {
        window.testCountdownSeconds--;
        if (window.testCountdownSeconds <= 0) {
          // Reset happened! Clear daily games in database
          console.log('üîÑ TEST: Countdown reached 0! Resetting daily games...');
          window.TEST_COUNTDOWN_MODE = false;

          // Clear today's game plays from database
          const walletAddress = localStorage.getItem('bearpark_wallet');
          if (walletAddress) {
            fetch(`${API_BASE_URL}/api/games/reset-daily/${walletAddress}`, {
              method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
              console.log('‚úÖ Daily games reset:', data);
              // Reload game progress and points to show reset
              loadDailyGameProgress();
              loadHoneyPoints();
              const wallet = localStorage.getItem('bearpark_wallet');
              if (wallet) loadHoneyLeaderboard(wallet);
            })
            .catch(err => console.error('Error resetting daily games:', err));
          }
          return;
        }
        diff = window.testCountdownSeconds * 1000;
      } else if (window.TEST_COUNTDOWN_MODE) {
        window.testCountdownSeconds = 10;
        diff = 10000;
      }

      const hours = Math.floor(diff / (1000 * 60 * 60));
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((diff % (1000 * 60)) / 1000);

      // Format with leading zeros
      const hh = hours.toString().padStart(2, '0');
      const mm = minutes.toString().padStart(2, '0');
      const ss = seconds.toString().padStart(2, '0');

      // Update the always-visible reset countdown
      const resetCountdownEl = document.getElementById('dailyResetCountdown');
      if (resetCountdownEl) {
        resetCountdownEl.textContent = `${hh}h ${mm}m ${ss}s`;
      }

      // Only update dailyGamesRemaining if game limit was reached (already showing "Resets in")
      const remainingEl = document.getElementById('dailyGamesRemaining');
      if (remainingEl && remainingEl.textContent.includes('Resets in')) {
        remainingEl.textContent = `Resets in ${hours}h ${minutes}m ${seconds}s`;

        // Dynamic color based on time remaining
        const totalHours = diff / (1000 * 60 * 60);
        let color;

        if (totalHours > 18) {
          color = '#50fa7b'; // Green - lots of time
        } else if (totalHours > 12) {
          color = '#9aff6e'; // Yellow-green
        } else if (totalHours > 6) {
          color = '#f1fa8c'; // Yellow
        } else if (totalHours > 3) {
          color = '#ffb86c'; // Orange
        } else if (totalHours > 1) {
          color = '#ff8c42'; // Dark orange
        } else {
          color = '#ff6b6b'; // Red - almost reset!
        }

        remainingEl.style.color = color;
        remainingEl.style.textShadow = `0 0 10px ${color}`;
      }
    }

    // Start countdown interval when page loads
    let countdownInterval;
    function startGameResetCountdown() {
      if (countdownInterval) clearInterval(countdownInterval);
      // Update immediately
      updateGameResetCountdown();
      // Then update every second
      countdownInterval = setInterval(() => {
        updateGameResetCountdown();
      }, 1000);
    }

    // Auto-start the daily reset countdown when page loads
    document.addEventListener('DOMContentLoaded', () => {
      startGameResetCountdown();
    });

    function updatePointsDisplay(total, raiding, games, animate = false) {
      const totalEl = document.getElementById('totalHoneyPoints');
      const raidingEl = document.getElementById('raidingPoints');
      const gamesEl = document.getElementById('gamesPoints');

      if (totalEl) {
        if (animate) {
          const oldValue = parseFloat(totalEl.textContent) || 0;
          animateCounter(totalEl, oldValue, total, 800, '');
        } else {
          totalEl.textContent = total.toFixed(1);
        }
      }
      if (raidingEl) raidingEl.textContent = raiding.toFixed(1) + ' PTS';
      if (gamesEl) gamesEl.textContent = games.toFixed(1) + ' PTS';
    }

    async function loadHoneyLeaderboard(currentWallet = null) {
      const leaderboardEl = document.getElementById('honeyLeaderboard');
      if (!leaderboardEl) return;

      try {
        // Include wallet address in request to get rank
        const url = currentWallet
          ? `${API_BASE_URL}/api/leaderboard?limit=15&wallet=${currentWallet}`
          : `${API_BASE_URL}/api/leaderboard?limit=15`;

        const response = await fetch(url);
        if (!response.ok) {
          console.debug('Leaderboard API not available');
          leaderboardEl.innerHTML = '<div class="leaderboard-empty">Leaderboard coming soon!</div>';
          return;
        }
        const data = await response.json();

        // Update user's rank from backend response
        if (currentWallet && data.userRank) {
          const myRankEl = document.getElementById('myRank');
          if (myRankEl) myRankEl.textContent = `#${data.userRank}`;
        }

        if (data.success && data.leaderboard && data.leaderboard.length > 0) {
          // Fetch equipped cosmetics for all users in leaderboard
          const walletAddresses = data.leaderboard.map(e => e.wallet_address);
          const equippedCosmetics = {};

          await Promise.all(walletAddresses.map(async (wallet) => {
            try {
              const cosmeticRes = await fetch(`${API_BASE_URL}/api/cosmetics/equipped/${wallet}`);
              const cosmeticData = await cosmeticRes.json();
              if (cosmeticData.success && cosmeticData.equipped) {
                equippedCosmetics[wallet] = cosmeticData.equipped;
              }
            } catch (e) {
              // Ignore errors for individual users
            }
          }));

          leaderboardEl.innerHTML = data.leaderboard.map((entry, index) => {
            const rank = index + 1;
            const isCurrentUser = currentWallet && entry.wallet_address === currentWallet;
            const rankClass = rank <= 3 ? `rank-${rank}` : '';
            const trophy = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : rank;

            // Use custom display name or show abbreviated wallet
            const displayName = entry.display_name || `${entry.wallet_address.substring(0, 6)}...${entry.wallet_address.substring(entry.wallet_address.length - 4)}`;

            // Get avatar URL
            let avatarUrl = 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png'; // default
            if (entry.avatar_nft) {
              try {
                const avatarData = JSON.parse(entry.avatar_nft);
                avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl || avatarUrl;
              } catch (e) {
                // If not JSON, try using it directly as NFT ID
                avatarUrl = `https://nft.xrpl-labs.com/${entry.avatar_nft}`;
              }
            }

            // Show avatar with ring if equipped
            let avatarHTML = '';
            const equipped = equippedCosmetics[entry.wallet_address];
            const equippedRing = equipped?.ring;

            if (equippedRing && equippedRing.image_url) {
              const spinAnimation = equippedRing.rarity === 'bearableguy123' ? 'animation: spinRingImage 3s linear infinite;' : '';
              const ouroborosRotation = equippedRing.ring_type === 'ouroboros' ? ' rotate(180deg)' : '';

              // Different sizes for different ring types
              const isCastle = equippedRing.ring_type === 'castle' || equippedRing.ring_type === 'castle-static';
              const isOuroboros = equippedRing.ring_type === 'ouroboros';
              const isWaves = equippedRing.ring_type === 'waves' || equippedRing.ring_type === 'waves-static';

              let ringSize, containerSize, ringClass;
              if (isCastle) {
                ringSize = '72px';
                containerSize = '72px';
                ringClass = 'leaderboard-ring-img-castle';
              } else if (isOuroboros) {
                ringSize = '65px';
                containerSize = '65px';
                ringClass = 'leaderboard-ring-img-ouroboros';
              } else if (isWaves) {
                ringSize = '57px';
                containerSize = '57px';
                ringClass = 'leaderboard-ring-img-waves';
              } else {
                ringSize = '60px';
                containerSize = '60px';
                ringClass = 'leaderboard-ring-img';
              }
              const avatarSize = '43px';

              const containerClass = isCastle ? 'castle-ring-container' : (isOuroboros ? 'ouroboros-ring-container' : (isWaves ? 'waves-ring-container' : ''));

              avatarHTML = `
                <div class="leaderboard-avatar-ring ${containerClass}" style="width:${containerSize}; height:${containerSize}; margin-right:8px; flex-shrink:0; position:relative;">
                  <img src="${avatarUrl}"
                       alt="${displayName} avatar"
                       class="leaderboard-avatar-img"
                       style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:1; width:${avatarSize}; height:${avatarSize}; border-radius:50%; object-fit:cover;"
                       onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png'">
                  <img src="${equippedRing.image_url}"
                       alt="Ring"
                       class="${ringClass}"
                       style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%)${ouroborosRotation}; width:${ringSize}; height:${ringSize}; object-fit:contain; z-index:2; pointer-events:none; ${spinAnimation}">
                </div>
              `;
            } else {
              // No ring, just avatar
              avatarHTML = `<img src="${avatarUrl}"
                   style="width:40px; height:40px; border-radius:50%; object-fit:cover; margin-right:8px;"
                   alt="${displayName} avatar"
                   onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png'">`;
            }

            return `
              <div class="leaderboard-item ${rankClass}" onclick="openProfileModal('${entry.wallet_address}')" style="display:flex; align-items:center; gap:12px; cursor:pointer;">
                <div class="leaderboard-rank ${rank <= 3 ? 'top-3' : ''}">${trophy}</div>
                ${avatarHTML}
                <div class="leaderboard-user" style="flex:1; min-width:0;">
                  <div class="leaderboard-username">${displayName}</div>
                  <div class="leaderboard-wallet">${entry.wallet_address.substring(0, 8)}...${entry.wallet_address.substring(entry.wallet_address.length - 6)}</div>
                </div>
                <div class="leaderboard-points">${entry.total_points.toLocaleString()} <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"></div>
              </div>
            `;
          }).join('');
        } else {
          leaderboardEl.innerHTML = '<div class="leaderboard-loading">No leaderboard data yet. Start playing to earn points!</div>';
        }
      } catch (err) {
        console.error('Error loading leaderboard:', err);
        leaderboardEl.innerHTML = '<div class="leaderboard-loading">Failed to load leaderboard</div>';
      }
    }

    // Initialize honey points section
    loadHoneyPoints();
    loadDailyGameProgress();
    const walletAddress = localStorage.getItem('bearpark_wallet');
    loadHoneyLeaderboard(walletAddress);
    // Load persisted raid timers before loading raids
    loadProcessingRaids();
    loadRaids();
    loadTopRaiders();
    startGameResetCountdown();

    // Listen for game points being awarded to refresh progress widget
    window.addEventListener('gamePointsAwarded', () => {
      loadDailyGameProgress();
      loadHoneyPoints(); // Also refresh total points
    });

    // Debounce mechanism to prevent constant refreshing
    let lastRefreshTime = 0;
    const REFRESH_COOLDOWN = 5000; // 5 seconds minimum between refreshes

    function refreshPointsIfNeeded(reason) {
      const now = Date.now();
      if (now - lastRefreshTime < REFRESH_COOLDOWN) {
        console.log(`‚è≠Ô∏è Skipping refresh (${reason}) - cooldown active`);
        return;
      }
      console.log(`üîÑ Refreshing honey points data (${reason})`);
      lastRefreshTime = now;
      loadDailyGameProgress();
      loadHoneyPoints();
      const wallet = localStorage.getItem('bearpark_wallet');
      if (wallet) loadHoneyLeaderboard(wallet);
    }

    // Refresh data when page becomes visible (e.g., returning from game page)
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        refreshPointsIfNeeded('page visible');
      }
    });

    // Also refresh when window gains focus
    window.addEventListener('focus', () => {
      refreshPointsIfNeeded('window focus');
    });

    // Show admin button if user is admin
    const ADMIN_WALLET = 'rKkkYMCvC63HEgxjQHmayKADaxYqnsMUkT';
    if (walletAddress === ADMIN_WALLET) {
      const adminBtn = document.getElementById('adminRaidBtn');
      if (adminBtn) {
        adminBtn.style.display = 'block';
      }
    }

    // Refresh leaderboard and raids every 30 seconds (skip if tab hidden)
    setInterval(() => {
      if (document.hidden) return; // Skip polling when tab not visible
      const walletAddress = localStorage.getItem('bearpark_wallet');
      loadHoneyLeaderboard(walletAddress);
      if (!showingPreviousRaids) {
        loadRaids(); // Only refresh if showing current raids
      }
    }, 30000);

    function getTimeAgo(date) {
      const seconds = Math.floor((new Date() - date) / 1000);
      if (seconds < 60) return 'just now';
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m ago`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h ago`;
      const days = Math.floor(hours / 24);
      return `${days}d ago`;
    }

    // Twitter integration removed - points now earned through games and raids only

    /* ===== Raids System ===== */
    let raidTimerIntervals = [];
    let showingPreviousRaids = false;
    let currentRaidsData = {}; // Store raid data by ID for easy access
    let processingRaids = new Set(); // Track which raids are currently being processed
    let processingRaidTimers = {}; // Track active processing raids with their start times
    let pendingDeepLinkRaidId = null; // Track if we're handling a deep link

    /* ===== Deep Link Handling for Discord Raid Links ===== */
    function checkRaidDeepLink() {
      const urlParams = new URLSearchParams(window.location.search);
      const raidId = urlParams.get('raid');
      console.log('üîó [DeepLink] Checking URL params:', window.location.search, 'raidId:', raidId);
      if (raidId) {
        return parseInt(raidId, 10);
      }
      return null;
    }

    function showRaidToast(message, type = 'info') {
      // Remove existing toast if any
      const existingToast = document.querySelector('.raid-toast');
      if (existingToast) existingToast.remove();

      const toast = document.createElement('div');
      toast.className = `raid-toast raid-toast-${type}`;
      toast.innerHTML = message;
      toast.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 16px 24px;
        border-radius: 12px;
        font-weight: 700;
        font-size: 16px;
        z-index: 10000;
        animation: slideDown 0.3s ease;
        max-width: 90%;
        text-align: center;
        ${type === 'error' ? 'background: linear-gradient(135deg, #ff4444, #cc0000); color: white; border: 2px solid #ff6666;' : ''}
        ${type === 'success' ? 'background: linear-gradient(135deg, #07ae08, #05850f); color: white; border: 2px solid #0bd00b;' : ''}
        ${type === 'info' ? 'background: linear-gradient(135deg, #680cd9, #feb501); color: white; border: 2px solid #feb501;' : ''}
      `;
      document.body.appendChild(toast);

      // Auto-remove after 4 seconds
      setTimeout(() => {
        toast.style.animation = 'slideUp 0.3s ease';
        setTimeout(() => toast.remove(), 300);
      }, 4000);
    }

    function handleRaidDeepLink(raidId) {
      console.log('üîó [DeepLink] handleRaidDeepLink called with raidId:', raidId);
      const walletAddress = localStorage.getItem('bearpark_wallet');
      console.log('üîó [DeepLink] walletAddress:', walletAddress);

      // Wait for raids to be rendered
      setTimeout(() => {
        const raidCard = document.querySelector(`.raid-item[data-raid-id="${raidId}"]`);
        console.log('üîó [DeepLink] Found raid card:', raidCard);

        if (!raidCard) {
          // Raid not found - might be expired or invalid
          showRaidToast('Raid not found or has expired', 'error');
          // Clean URL
          window.history.replaceState({}, document.title, window.location.pathname);
          return;
        }

        // Check if already completed
        const completedRaids = JSON.parse(localStorage.getItem(`completed_raids_${walletAddress}`) || '[]');
        if (completedRaids.includes(raidId)) {
          showRaidToast('You already completed this raid!', 'info');
          window.history.replaceState({}, document.title, window.location.pathname);
          return;
        }

        // Check if wallet connected
        if (!walletAddress) {
          showRaidToast('Connect your wallet first to earn honey points!', 'error');
          // Still scroll to section
          document.getElementById('honey-points').scrollIntoView({
            behavior: 'smooth',
            block: 'start'
          });
          // Highlight the raid card
          raidCard.style.boxShadow = '0 0 30px var(--stripe-yellow)';
          setTimeout(() => raidCard.style.boxShadow = '', 3000);
          window.history.replaceState({}, document.title, window.location.pathname);
          return;
        }

        // Scroll to honey-points section
        document.getElementById('honey-points').scrollIntoView({
          behavior: 'smooth',
          block: 'start'
        });

        // Wait for scroll to complete, then trigger the raid
        setTimeout(() => {
          const raidBtn = raidCard.querySelector('.raid-btn');
          if (raidBtn && !raidBtn.disabled && raidBtn.style.pointerEvents !== 'none') {
            // Highlight briefly then click
            raidCard.style.boxShadow = '0 0 30px var(--stripe-yellow)';
            setTimeout(() => {
              raidBtn.click();
              raidCard.style.boxShadow = '';
            }, 500);
          }
        }, 800);

        // Clean URL to prevent re-trigger on refresh
        window.history.replaceState({}, document.title, window.location.pathname);
      }, 600); // Wait for DOM to render
    }

    // Persist processing raids to localStorage
    function saveProcessingRaids() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) return;
      localStorage.setItem(`processing_raids_${walletAddress}`, JSON.stringify(processingRaidTimers));
    }

    // Load processing raids from localStorage and restore them
    function loadProcessingRaids() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) return;

      const stored = localStorage.getItem(`processing_raids_${walletAddress}`);
      if (!stored) return;

      try {
        const storedTimers = JSON.parse(stored);
        const now = Date.now();

        Object.keys(storedTimers).forEach(raidId => {
          const timerData = storedTimers[raidId];
          const elapsed = Math.floor((now - timerData.startTime) / 1000);
          const secondsLeft = 60 - elapsed;

          if (secondsLeft > 0) {
            // Timer still active - mark for resumption
            processingRaids.add(raidId);
            processingRaidTimers[raidId] = {
              ...timerData,
              secondsLeft,
              needsResume: true
            };
          } else {
            // Timer expired - auto-complete
            console.log('‚è∞ Processing raid timer expired during refresh, will complete:', raidId);
            processingRaidTimers[raidId] = {
              ...timerData,
              secondsLeft: 0,
              needsComplete: true
            };
          }
        });
      } catch (e) {
        console.error('Error loading processing raids:', e);
      }
    }

    // ===== GODMODE RAIDS SYSTEM =====
    let allRaidsData = [];
    let currentFilter = 'active';
    let currentSort = 'expiring';
    let userCompletedRaids = [];
    let raidCompletionTimers = {}; // Track active completion timers {raidId: {timer, secondsLeft, button}}
    const RAID_COMPLETION_TIME = 120; // 120 seconds to complete

    // Persist active raid timers to localStorage so they survive page refresh
    function saveActiveRaidTimers() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) return;

      const activeTimers = {};
      Object.keys(raidCompletionTimers).forEach(raidId => {
        const timerInfo = raidCompletionTimers[raidId];
        if (timerInfo && timerInfo.startTime) {
          // Store reward so we don't need allRaidsData when resuming
          const raid = allRaidsData.find(r => r.id == raidId);
          activeTimers[raidId] = {
            startTime: timerInfo.startTime,
            duration: RAID_COMPLETION_TIME,
            reward: raid?.reward || 20
          };
        }
      });
      localStorage.setItem(`active_raid_timers_${walletAddress}`, JSON.stringify(activeTimers));
    }

    // Load persisted raid timers from localStorage and resume them
    function loadPersistedRaidTimers() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) return;

      const stored = localStorage.getItem(`active_raid_timers_${walletAddress}`);
      if (!stored) return;

      try {
        const activeTimers = JSON.parse(stored);
        const now = Date.now();

        Object.keys(activeTimers).forEach(raidId => {
          const timerData = activeTimers[raidId];
          const elapsed = Math.floor((now - timerData.startTime) / 1000);
          const secondsLeft = timerData.duration - elapsed;

          if (secondsLeft > 0) {
            // Timer still has time - will be resumed after raids load
            raidCompletionTimers[raidId] = {
              timer: null,
              secondsLeft,
              button: null,
              startTime: timerData.startTime,
              reward: timerData.reward,
              needsResume: true
            };
          } else {
            // Timer expired while page was closed - complete the raid now
            console.log('‚è∞ Raid timer expired during refresh, completing raid:', raidId);
            // Remove from stored timers
            delete activeTimers[raidId];
            // Complete the raid with stored reward
            const storedReward = timerData.reward;
            setTimeout(() => completeRaid(raidId, storedReward), 100);
          }
        });

        // Update storage with only valid timers
        localStorage.setItem(`active_raid_timers_${walletAddress}`, JSON.stringify(activeTimers));
      } catch (e) {
        console.error('Error loading persisted raid timers:', e);
      }
    }

    // Load and render GODMODE raids
    async function loadGodmodeRaids() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      const raidsGrid = document.getElementById('raidsGrid');

      try {
        // Fetch raids and completed raids
        const [raidsResponse, completedResponse] = await Promise.all([
          fetch(`${API_BASE_URL}/api/raids/current`),
          walletAddress ? fetch(`${API_BASE_URL}/api/raids/completed/${walletAddress}`).catch(() => null) : Promise.resolve(null)
        ]);

        if (!raidsResponse.ok) {
          raidsGrid.innerHTML = '<div class="raids-empty">Unable to load raids. Please try again later.</div>';
          return;
        }

        const raidsData = await raidsResponse.json();
        if (!raidsData.success || !raidsData.raids) {
          raidsGrid.innerHTML = '<div class="raids-empty">No raids available</div>';
          return;
        }

        // Get completed raids
        userCompletedRaids = [];
        if (completedResponse && completedResponse.ok) {
          const completedData = await completedResponse.json();
          if (completedData.success && completedData.completedRaids) {
            userCompletedRaids = completedData.completedRaids.map(r => r.raid_id);
          }
        }

        // Store all raids
        allRaidsData = raidsData.raids.map(raid => ({
          ...raid,
          isCompleted: userCompletedRaids.includes(raid.id),
          isExpired: new Date(raid.expires_at) < new Date(),
          participantCount: Math.floor(Math.random() * 100) + 10 // Mock for now
        }));

        // Load user stats
        loadUserRaidStats(walletAddress);

        // Render raids
        filterRaids(currentFilter);

      } catch (error) {
        console.error('Error loading GODMODE raids:', error);
        raidsGrid.innerHTML = '<div class="raids-empty">Error loading raids</div>';
      }
    }

    // Render compact raid card
    function renderRaidCardCompact(raid) {
      const now = new Date();
      const expiresAt = new Date(raid.expires_at);
      const timeLeft = expiresAt - now;
      const hoursLeft = timeLeft / (1000 * 60 * 60);

      // Calculate urgency
      let urgencyClass = 'urgency-low';
      let timerClass = 'safe';
      if (hoursLeft < 2) {
        urgencyClass = 'urgency-high';
        timerClass = 'urgent';
      } else if (hoursLeft < 12) {
        urgencyClass = 'urgency-medium';
        timerClass = 'medium';
      }

      // Format time left
      const formatTimeLeft = () => {
        if (timeLeft < 0) return 'EXPIRED';
        const hours = Math.floor(timeLeft / (1000 * 60 * 60));
        const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
        if (hours > 24) return `${Math.floor(hours/24)}d ${hours%24}h`;
        if (hours > 0) return `${hours}h ${minutes}m`;
        return `${minutes}m`;
      };

      // Extract tweet info from URL or description
      let tweetText = raid.description || 'Join this raid!';
      let tweetAuthor = raid.profile_handle || '@BearXRPL';

      // Try to extract username from Twitter URL
      if (raid.twitter_url) {
        const urlMatch = raid.twitter_url.match(/(?:twitter\.com|x\.com)\/([^\/]+)/);
        if (urlMatch) {
          tweetAuthor = '@' + urlMatch[1];
        }
      }

      // Calculate time progress for bar
      const totalTime = new Date(raid.expires_at) - new Date(raid.created_at);
      const elapsed = now - new Date(raid.created_at);
      const progressPercent = Math.min(100, (elapsed / totalTime) * 100);

      // Button state
      let buttonHTML = '';
      let buttonClass = '';
      let buttonText = '';

      if (raid.isCompleted) {
        buttonClass = 'completed';
        buttonText = '‚úÖ COMPLETED';
      } else if (raid.isExpired) {
        buttonClass = 'expired';
        buttonText = '‚è∞ EXPIRED';
      } else {
        buttonClass = 'join';
        buttonText = `üéØ JOIN RAID`;
      }

      const card = document.createElement('div');
      let cardClasses = `raid-card-compact ${urgencyClass}`;

      // Add greyed-out class for completed or expired
      if (raid.isCompleted) {
        cardClasses += ' completed-raid';
      } else if (raid.isExpired) {
        cardClasses += ' expired-raid';
      }

      card.className = cardClasses;
      card.setAttribute('data-raid-id', raid.id);
      card.setAttribute('data-expires', raid.expires_at);
      card.setAttribute('data-points', raid.reward);
      card.setAttribute('data-participants', raid.participantCount);

      card.innerHTML = `
        ${hoursLeft < 2 && !raid.isExpired && !raid.isCompleted ? '<div class="raid-badge expiring-soon">‚ö° EXPIRING SOON</div>' : ''}

        <div class="raid-card-header">
          <div class="raid-points-badge">üéØ ${raid.reward} PTS</div>
          <div class="raid-timer-badge ${timerClass}" data-raid-timer="${raid.id}">
            ‚è∞ ${formatTimeLeft()}
          </div>
        </div>

        <div class="raid-progress-bar">
          <div class="raid-progress-fill" style="width: ${progressPercent}%"></div>
        </div>

        <div class="raid-tweet-preview-compact" data-raid-id="${raid.id}">
          ${(() => {
            // Check if image_url is valid (not a Twitter emoji SVG or other bad URL)
            const badImagePatterns = ['twimg.com/emoji', 'abs-0.twimg.com', '/emoji/v2/'];
            const isValidImage = raid.image_url && !badImagePatterns.some(p => raid.image_url.includes(p));
            const defaultImage = 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/llg3eb.png'; // BEAR raid default
            const imgSrc = isValidImage ? raid.image_url : defaultImage;
            return `
            <img src="${imgSrc}"
                 alt="Tweet preview"
                 class="raid-tweet-thumbnail"
                 onerror="this.src='${defaultImage}'">
          `;
          })()}
          <div class="raid-tweet-author">${tweetAuthor}</div>
          <div class="raid-tweet-text">${tweetText}</div>
          <a href="${raid.twitter_url}" target="_blank" class="raid-twitter-link" data-raid-id="${raid.id}"
             style="display:inline-block; margin-top:12px; font-size:14px; color:var(--gold); text-decoration:none; opacity:0.9; font-weight:600;">
            üîó View on Twitter/X ‚Üí
          </a>
        </div>

        <div class="raid-card-footer">
          <div class="raid-participants">
            üë• <span class="raid-participants-count">${raid.participantCount}</span> raiders
          </div>
          <button class="raid-action-btn ${buttonClass}"
                  data-raid-id="${raid.id}"
                  data-twitter-url="${raid.twitter_url.replace(/"/g, '&quot;')}"
                  ${raid.isCompleted || raid.isExpired ? 'disabled' : ''}>
            ${buttonText}
          </button>
        </div>
      `;

      // Add event listeners after creating the card
      // Modal disabled - entire card is now clickable to open Twitter and start timer

      // Add click handler to Twitter link to also start timer
      const twitterLink = card.querySelector('.raid-twitter-link');
      if (twitterLink && !raid.isCompleted && !raid.isExpired) {
        twitterLink.addEventListener('click', (e) => {
          e.stopPropagation();
          // Start the timer when clicking the link
          const button = card.querySelector('.raid-action-btn');
          if (button) {
            startRaidCompletionTimer(raid.id, button);
          }
        });
      }

      const button = card.querySelector('.raid-action-btn');
      if (button && !raid.isCompleted && !raid.isExpired) {
        button.addEventListener('click', (e) => {
          e.stopPropagation();
          handleRaidAction(raid.id, raid.twitter_url);
        });
      }

      // Make entire card clickable to open Twitter and activate raid
      if (!raid.isCompleted && !raid.isExpired) {
        card.style.cursor = 'pointer';
        card.addEventListener('click', () => handleRaidAction(raid.id, raid.twitter_url));
      }

      return card;
    }

    // Filter raids
    function filterRaids(filter) {
      currentFilter = filter;

      // Update button states
      document.querySelectorAll('.raid-filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.getAttribute('data-filter') === filter);
      });

      let filtered = [];
      if (filter === 'active') {
        filtered = allRaidsData.filter(r => !r.isExpired && !r.isCompleted);
      } else if (filter === 'completed') {
        filtered = allRaidsData.filter(r => r.isCompleted);
      } else if (filter === 'expired') {
        filtered = allRaidsData.filter(r => r.isExpired && !r.isCompleted);
      }

      // Apply current sort
      filtered = applySorting(filtered, currentSort);

      // Render
      const raidsGrid = document.getElementById('raidsGrid');

      // Make completed and expired sections scrollable
      if (filter === 'completed' || filter === 'expired') {
        raidsGrid.classList.add('scrollable');
      } else {
        raidsGrid.classList.remove('scrollable');
      }

      if (filtered.length === 0) {
        let emptyMessage = '';
        if (filter === 'active') {
          emptyMessage = 'üéØ NO ACTIVE RAIDS<br><br>Check back soon for new raids!';
        } else if (filter === 'completed') {
          emptyMessage = '‚úÖ ALL RAIDS COMPLETED!<br><br>Great job! Wait for new raids to appear.';
        } else if (filter === 'expired') {
          emptyMessage = '‚è∞ NO EXPIRED RAIDS<br><br>All raids are still active or completed.';
        }
        raidsGrid.innerHTML = `<div class="raids-empty" style="font-size:32px; font-weight:900; line-height:1.8; color:#ffffff;">${emptyMessage}</div>`;
      } else {
        raidsGrid.innerHTML = '';
        filtered.forEach(raid => {
          raidsGrid.appendChild(renderRaidCardCompact(raid));
        });
      }

      // Start timers
      updateRaidTimers();

      // Restore completion timer states for any raids in progress
      restoreCompletionTimerStates();
    }

    // Restore the UI state for raids that have active completion timers
    function restoreCompletionTimerStates() {
      Object.keys(raidCompletionTimers).forEach(raidId => {
        const timerInfo = raidCompletionTimers[raidId];
        if (timerInfo) {
          // Find the new button element after re-render
          const newButton = document.querySelector(`[data-raid-id="${raidId}"].raid-action-btn`);
          if (newButton) {
            // If this timer was loaded from localStorage and needs to be resumed
            if (timerInfo.needsResume) {
              console.log('üîÑ Resuming raid timer after page refresh:', raidId, 'with', timerInfo.secondsLeft, 'seconds left');
              // Clear the placeholder and start a real timer
              delete raidCompletionTimers[raidId];
              startRaidCompletionTimer(raidId, newButton, timerInfo.secondsLeft);
            } else {
              // Just update button reference (tab switch scenario)
              timerInfo.button = newButton;

              // Restore button UI state
              newButton.textContent = `‚è≥ COMPLETING... ${timerInfo.secondsLeft}s`;
              newButton.disabled = true;
              newButton.classList.remove('join');
              newButton.classList.add('completing');
            }
          }
        }
      });
    }

    // Apply sorting - always sort by expiring soon
    function applySorting(raids, sortType) {
      const sorted = [...raids];
      // Always sort by expiring soon (most urgent first)
      sorted.sort((a, b) => new Date(a.expires_at) - new Date(b.expires_at));
      return sorted;
    }

    // Update countdown timers
    function updateRaidTimers() {
      const timers = document.querySelectorAll('[data-raid-timer]');
      timers.forEach(timer => {
        const raidId = timer.getAttribute('data-raid-timer');
        const card = document.querySelector(`[data-raid-id="${raidId}"]`);
        const expiresAt = card ? new Date(card.getAttribute('data-expires')) : null;

        if (expiresAt) {
          const now = new Date();
          const timeLeft = expiresAt - now;

          if (timeLeft < 0) {
            timer.textContent = '‚è∞ EXPIRED';
            timer.className = 'raid-timer-badge urgent';
          } else {
            const hours = Math.floor(timeLeft / (1000 * 60 * 60));
            const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));

            let text = '';
            if (hours > 24) text = `‚è∞ ${Math.floor(hours/24)}d ${hours%24}h`;
            else if (hours > 0) text = `‚è∞ ${hours}h ${minutes}m`;
            else text = `‚è∞ ${minutes}m`;

            timer.textContent = text;

            // Update urgency class
            if (hours < 2) timer.className = 'raid-timer-badge urgent';
            else if (hours < 12) timer.className = 'raid-timer-badge medium';
            else timer.className = 'raid-timer-badge safe';
          }
        }
      });
    }

    // Calculate raid streak from consecutive days
    function calculateRaidStreak(completedRaids) {
      if (completedRaids.length === 0) return 0;

      // Sort by completion date (most recent first)
      const sorted = [...completedRaids].sort((a, b) =>
        new Date(b.completed_at) - new Date(a.completed_at)
      );

      // Get unique dates (ignore time, just date)
      const uniqueDates = [...new Set(sorted.map(r => {
        const date = new Date(r.completed_at);
        return `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
      }))];

      let streak = 0;
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // Check consecutive days starting from today
      for (let i = 0; i < uniqueDates.length; i++) {
        const checkDate = new Date(today);
        checkDate.setDate(checkDate.getDate() - i);
        const checkDateStr = `${checkDate.getFullYear()}-${checkDate.getMonth()}-${checkDate.getDate()}`;

        if (uniqueDates.includes(checkDateStr)) {
          streak++;
        } else {
          break; // Streak broken
        }
      }

      return streak;
    }

    // Load user raid stats
    async function loadUserRaidStats(walletAddress) {
      if (!walletAddress) return;

      try {
        const response = await fetch(`${API_BASE_URL}/api/raids/completed/${walletAddress}`);
        if (!response.ok) return;

        const data = await response.json();
        if (!data.success) return;

        const completedRaids = data.completedRaids || [];
        const totalCompleted = completedRaids.length;
        const totalPoints = completedRaids.reduce((sum, r) => sum + (r.points_awarded || 0), 0);

        // Calculate streak from consecutive days
        const streak = calculateRaidStreak(completedRaids);

        // Fetch leaderboard to calculate rank
        let rank = '-';
        try {
          const leaderboardResponse = await fetch(`${API_BASE_URL}/api/raids/leaderboard`);
          if (leaderboardResponse.ok) {
            const leaderboardData = await leaderboardResponse.json();
            if (leaderboardData.success && leaderboardData.leaderboard) {
              const userIndex = leaderboardData.leaderboard.findIndex(
                u => u.wallet_address.toLowerCase() === walletAddress.toLowerCase()
              );
              if (userIndex !== -1) {
                rank = `#${userIndex + 1}`;
              }
            }
          }
        } catch (error) {
          console.error('Error fetching rank:', error);
        }

        // Show stats
        document.getElementById('raidPerformanceStats').style.display = 'block';
        document.getElementById('userRaidsCompleted').textContent = totalCompleted;
        document.getElementById('userRaidPoints').textContent = totalPoints;
        document.getElementById('userRaidStreak').textContent = streak;
        document.getElementById('userRaidRank').textContent = rank;

      } catch (error) {
        console.error('Error loading raid stats:', error);
      }
    }

    // Load TOP RAIDERS leaderboard
    async function loadTopRaiders() {
      const container = document.getElementById('topRaidersScroll');
      if (!container) return;

      const currentWallet = localStorage.getItem('bearpark_wallet');

      try {
        const response = await fetch(`${API_BASE_URL}/api/raids/leaderboard`);
        if (!response.ok) throw new Error('Failed to fetch leaderboard');

        const data = await response.json();
        if (!data.success || !data.leaderboard || data.leaderboard.length === 0) {
          container.innerHTML = '<div class="raiders-empty">No raiders yet. Be the first to complete a raid!</div>';
          return;
        }

        const leaderboard = data.leaderboard;

        // Fetch equipped cosmetics for all raiders
        const walletAddresses = leaderboard.map(r => r.wallet_address);
        const equippedCosmetics = {};

        await Promise.all(walletAddresses.map(async (wallet) => {
          try {
            const cosmeticRes = await fetch(`${API_BASE_URL}/api/cosmetics/equipped/${wallet}`);
            const cosmeticData = await cosmeticRes.json();
            if (cosmeticData.success && cosmeticData.equipped) {
              equippedCosmetics[wallet] = cosmeticData.equipped;
            }
          } catch (e) {
            // Ignore errors for individual users
          }
        }));

        let html = '';

        leaderboard.forEach((raider, index) => {
          const rank = index + 1;
          const isCurrentUser = currentWallet && raider.wallet_address.toLowerCase() === currentWallet.toLowerCase();
          const isTop3 = rank <= 3;

          // Rank styling
          let rankClass = '';
          if (rank === 1) rankClass = 'gold';
          else if (rank === 2) rankClass = 'silver';
          else if (rank === 3) rankClass = 'bronze';

          // Row styling
          let rowClass = 'raider-row';
          if (isTop3) rowClass += ' top-3';
          if (isCurrentUser) rowClass += ' current-user';

          // Display name or truncated wallet
          const displayName = raider.display_name || truncateWallet(raider.wallet_address);
          const truncatedWallet = truncateWallet(raider.wallet_address);

          // Parse avatar URL from avatar_nft JSON
          let avatarUrl = 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/pxcklj.png'; // default bear
          if (raider.avatar_nft) {
            try {
              const avatarData = JSON.parse(raider.avatar_nft);
              avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl || avatarUrl;
            } catch (e) {
              // If not JSON, try using it directly as NFT ID
              avatarUrl = `https://nft.xrpl-labs.com/${raider.avatar_nft}`;
            }
          }

          // Check for equipped ring
          const equipped = equippedCosmetics[raider.wallet_address];
          const equippedRing = equipped?.ring;

          let avatarHTML = '';
          if (equippedRing && equippedRing.image_url) {
            const spinAnimation = equippedRing.rarity === 'bearableguy123' ? 'animation: spinRingImage 3s linear infinite;' : '';
            const ouroborosRotation = equippedRing.ring_type === 'ouroboros' ? ' rotate(180deg)' : '';

            // Different sizes for different ring types
            const isCastle = equippedRing.ring_type === 'castle' || equippedRing.ring_type === 'castle-static';
            const isOuroboros = equippedRing.ring_type === 'ouroboros';
            const isWaves = equippedRing.ring_type === 'waves' || equippedRing.ring_type === 'waves-static';

            let ringSize, containerSize;
            if (isCastle) {
              ringSize = '60px';
              containerSize = '60px';
            } else if (isOuroboros) {
              ringSize = '55px';
              containerSize = '55px';
            } else if (isWaves) {
              ringSize = '50px';
              containerSize = '50px';
            } else {
              ringSize = '52px';
              containerSize = '52px';
            }
            const avatarSize = '36px';

            avatarHTML = `
              <div style="width:${containerSize}; height:${containerSize}; position:relative; flex-shrink:0;">
                <img src="${avatarUrl}"
                     alt="Avatar"
                     style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:1; width:${avatarSize}; height:${avatarSize}; border-radius:50%; object-fit:cover;"
                     onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/pxcklj.png'">
                <img src="${equippedRing.image_url}"
                     alt="Ring"
                     style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%)${ouroborosRotation}; width:${ringSize}; height:${ringSize}; object-fit:contain; z-index:2; pointer-events:none; ${spinAnimation}">
              </div>
            `;
          } else {
            // No ring, just avatar
            avatarHTML = `<img src="${avatarUrl}" alt="Avatar" class="raider-avatar" onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/pxcklj.png'">`;
          }

          html += `
            <div class="${rowClass}">
              <div class="raider-rank ${rankClass}">${rank}</div>
              ${avatarHTML}
              <div class="raider-info">
                <div class="raider-name">${escapeHtml(displayName)}${isCurrentUser ? ' <span style="color:var(--gold);font-size:12px;">(You)</span>' : ''}</div>
                <div class="raider-wallet">${truncatedWallet}</div>
              </div>
              <div class="raider-stats">
                <div class="raider-stat">
                  <div class="raider-stat-value">${raider.total_points.toLocaleString()}</div>
                  <div class="raider-stat-label">Points</div>
                </div>
                <div class="raider-stat">
                  <div class="raider-stat-value">${raider.total_raids}</div>
                  <div class="raider-stat-label">Raids</div>
                </div>
              </div>
            </div>
          `;
        });

        container.innerHTML = html;

      } catch (error) {
        console.error('Error loading top raiders:', error);
        container.innerHTML = '<div class="raiders-empty">Unable to load leaderboard</div>';
      }
    }

    // Helper: truncate wallet address
    function truncateWallet(wallet) {
      if (!wallet) return 'Unknown';
      return wallet.slice(0, 6) + '...' + wallet.slice(-4);
    }

    // Handle raid action
    async function handleRaidAction(raidId, twitterUrl) {
      console.log('üéØ JOIN RAID clicked:', { raidId, twitterUrl });

      // Check if already completing
      if (raidCompletionTimers[raidId]) {
        console.log('‚ö†Ô∏è Raid already in progress');
        return;
      }

      // Open Twitter link in new tab
      const twitterWindow = window.open(twitterUrl, '_blank');

      if (!twitterWindow) {
        alert('‚ùå Pop-up blocked! Please allow pop-ups for this site to join raids.');
        return;
      }

      // Get button reference
      const button = document.querySelector(`[data-raid-id="${raidId}"].raid-action-btn`);
      if (!button) return;

      // Start completion timer
      startRaidCompletionTimer(raidId, button);
    }

    // Start 120 second completion timer (or resume with remaining time)
    function startRaidCompletionTimer(raidId, button, resumeSecondsLeft = null) {
      const startTime = resumeSecondsLeft ? (Date.now() - (RAID_COMPLETION_TIME - resumeSecondsLeft) * 1000) : Date.now();
      let secondsLeft = resumeSecondsLeft || RAID_COMPLETION_TIME;

      // Update button immediately
      button.textContent = `‚è≥ COMPLETING... ${secondsLeft}s`;
      button.disabled = true;
      button.classList.remove('join');
      button.classList.add('completing');

      // Store timer info first so we can update secondsLeft
      raidCompletionTimers[raidId] = {
        timer: null,
        secondsLeft,
        button,
        startTime
      };

      // Persist to localStorage so timer survives page refresh
      saveActiveRaidTimers();

      // Create countdown interval
      const timer = setInterval(() => {
        raidCompletionTimers[raidId].secondsLeft--;
        const currentSeconds = raidCompletionTimers[raidId].secondsLeft;

        if (currentSeconds <= 0) {
          clearInterval(timer);
          delete raidCompletionTimers[raidId];
          saveActiveRaidTimers(); // Remove from localStorage
          completeRaid(raidId);
        } else {
          // Update the current button reference (may have changed after tab switch)
          const currentButton = raidCompletionTimers[raidId].button;
          if (currentButton) {
            currentButton.textContent = `‚è≥ COMPLETING... ${currentSeconds}s`;
          }
        }
      }, 1000);

      // Store the timer reference
      raidCompletionTimers[raidId].timer = timer;
    }

    // Complete raid and award points
    async function completeRaid(raidId, storedReward = null) {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) {
        alert('‚ùå Please connect your wallet to complete raids');
        return;
      }

      const raid = allRaidsData.find(r => r.id == raidId);
      const reward = storedReward || raid?.reward || 20;

      console.log('‚úÖ Completing raid:', raidId, 'with reward:', reward);

      try {
        // Call API to complete raid and award points
        const response = await fetch(`${API_BASE_URL}/api/raids/complete`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet_address: walletAddress,
            raid_id: raidId,
            completed_at: new Date().toISOString(),
            points_awarded: reward
          })
        });

        const result = await response.json();

        if (response.ok && result.success) {
          console.log('üéâ Raid completed successfully! Points awarded:', reward);

          // Update local state
          if (raid) raid.isCompleted = true;
          userCompletedRaids.push(raidId);

          // Show success message
          showRaidCompletionAnimation(raidId, reward);

          // Reload user stats and leaderboard
          const wallet = localStorage.getItem('bearpark_wallet');
          if (wallet) {
            loadUserRaidStats(wallet);
          }
          loadTopRaiders();

          // Dispatch event to update BEARdrops honey points in real-time
          window.dispatchEvent(new CustomEvent('honeyPointsUpdated'));

          // Update the view after a delay for animation
          setTimeout(() => {
            filterRaids(currentFilter);
          }, 2000);

        } else {
          console.error('Failed to complete raid:', result.error);
          alert(`‚ùå Failed to complete raid: ${result.error || 'Unknown error'}`);

          // Reset button
          const button = document.querySelector(`[data-raid-id="${raidId}"].raid-action-btn`);
          if (button) {
            button.textContent = 'üéØ JOIN RAID';
            button.disabled = false;
            button.classList.remove('completing');
            button.classList.add('join');
          }
        }
      } catch (error) {
        console.error('Error completing raid:', error);
        alert(`‚ùå Error completing raid: ${error.message}`);
      }
    }

    // Show completion animation
    function showRaidCompletionAnimation(raidId, points) {
      const card = document.querySelector(`[data-raid-id="${raidId}"].raid-card-compact`);
      if (!card) return;

      // Create floating points animation
      const pointsEl = document.createElement('div');
      pointsEl.textContent = `+${points} PTS! üéâ`;
      pointsEl.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 32px;
        font-weight: 900;
        color: var(--gold);
        text-shadow: 0 0 20px rgba(237,183,35,0.8);
        animation: floatUp 2s ease-out forwards;
        pointer-events: none;
        z-index: 100;
      `;
      card.style.position = 'relative';
      card.appendChild(pointsEl);

      // Add completion animation to card
      card.style.animation = 'raidComplete 2s ease-out forwards';

      // Remove after animation
      setTimeout(() => {
        pointsEl.remove();
      }, 2000);
    }

    // Modal functions
    function openRaidModal(raidId) {
      const raid = allRaidsData.find(r => r.id === raidId);
      if (!raid) return;

      const modal = document.getElementById('raidTweetModal');
      const container = document.getElementById('raidTweetContainer');

      // Embed tweet
      container.innerHTML = `
        <blockquote class="twitter-tweet" data-theme="dark">
          <a href="${raid.twitter_url}"></a>
        </blockquote>
      `;

      // Load Twitter widget
      if (window.twttr && window.twttr.widgets) {
        window.twttr.widgets.load(container);
      }

      modal.style.display = 'flex';
    }

    function closeRaidModal() {
      document.getElementById('raidTweetModal').style.display = 'none';
    }

    // Update timers every minute
    setInterval(updateRaidTimers, 60000);

    // Initialize GODMODE raids on page load
    if (document.getElementById('raidsGrid')) {
      // Load any persisted raid timers from localStorage first
      loadPersistedRaidTimers();
      loadGodmodeRaids();
    }

    // Expose functions globally for onclick handlers
    window.filterRaids = filterRaids;
    window.openRaidModal = openRaidModal;
    window.closeRaidModal = closeRaidModal;

    // ===== END GODMODE RAIDS SYSTEM =====

    async function loadRaids() {
      const walletAddress = localStorage.getItem('bearpark_wallet');

      // Check for deep link on first load
      if (pendingDeepLinkRaidId === null) {
        pendingDeepLinkRaidId = checkRaidDeepLink();
        console.log('üîó [DeepLink] First load check, pendingDeepLinkRaidId:', pendingDeepLinkRaidId);
      }

      try {
        // Fetch current raids and user's completed raids in parallel
        const [raidsResponse, completedResponse] = await Promise.all([
          fetch(`${API_BASE_URL}/api/raids/current`),
          walletAddress ? fetch(`${API_BASE_URL}/api/raids/completed/${walletAddress}`).catch(() => null) : Promise.resolve(null)
        ]);

        if (!raidsResponse.ok) {
          console.debug('Raids API not available');
          displayMockRaids(); // Show mock data for now
          return;
        }

        const raidsData = await raidsResponse.json();

        if (raidsData.success && raidsData.raids) {
          // Get server-side completed raids if available
          let serverCompletedRaids = [];
          if (completedResponse && completedResponse.ok) {
            const completedData = await completedResponse.json();
            if (completedData.success && completedData.completedRaids) {
              serverCompletedRaids = completedData.completedRaids.map(r => r.raid_id);
              console.log('üîµ [Raids] Server-side completed raids:', serverCompletedRaids);
            }
          }

          // Merge server-side completed raids with localStorage
          const localCompleted = JSON.parse(localStorage.getItem(`completed_raids_${walletAddress}`) || '[]');
          const allCompletedRaids = [...new Set([...serverCompletedRaids, ...localCompleted])];

          // Update localStorage with merged data
          if (walletAddress && allCompletedRaids.length > 0) {
            localStorage.setItem(`completed_raids_${walletAddress}`, JSON.stringify(allCompletedRaids));
          }

          // Filter out completed raids entirely
          const activeRaids = raidsData.raids.filter(raid => !allCompletedRaids.includes(raid.id));
          console.log('üîµ [Raids] Total raids:', raidsData.raids.length, 'Active:', activeRaids.length, 'Completed:', allCompletedRaids.length);

          displayCurrentRaids(activeRaids, walletAddress);

          // Handle deep link after raids are displayed
          console.log('üîó [DeepLink] After displayCurrentRaids, pendingDeepLinkRaidId:', pendingDeepLinkRaidId);
          if (pendingDeepLinkRaidId) {
            console.log('üîó [DeepLink] Calling handleRaidDeepLink now!');
            handleRaidDeepLink(pendingDeepLinkRaidId);
            pendingDeepLinkRaidId = false; // Mark as handled
          }
        }
      } catch (err) {
        console.error('Error loading raids:', err);
        displayMockRaids(); // Show mock data on error
        // Handle deep link even with mock data
        if (pendingDeepLinkRaidId) {
          handleRaidDeepLink(pendingDeepLinkRaidId);
          pendingDeepLinkRaidId = false; // Mark as handled
        }
      }
    }

    function displayMockRaids() {
      // Mock raid data for demonstration
      const mockRaids = [
        {
          id: 101,
          description: "Like and retweet the latest @BearXRPL announcement about the new BEAR SLICE game! üéÆ<img src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png' alt='honey' style='height:1em; width:auto; vertical-align:middle; display:inline-block;'>",
          twitter_url: "https://x.com/BearXRPL/status/1986706939775181224",
          reward: 20,
          expires_at: new Date(Date.now() + 18 * 60 * 60 * 1000).toISOString(), // 18 hours from now
          profile_name: "BearXRPL",
          profile_handle: "@BearXRPL",
          profile_emoji: "üêª"
        },
        {
          id: 102,
          description: "Join the BEAR community space happening NOW! Come discuss the future of BEARpark üêª",
          twitter_url: "https://twitter.com/i/spaces/1234567890",
          reward: 20,
          expires_at: new Date(Date.now() + 3 * 60 * 60 * 1000).toISOString(), // 3 hours from now
          profile_name: "BearXRPL",
          profile_handle: "@BearXRPL",
          profile_emoji: "üêª"
        }
      ];

      displayCurrentRaids(mockRaids, localStorage.getItem('bearpark_wallet'));
    }

    function displayCurrentRaids(raids, walletAddress) {
      const currentList = document.getElementById('currentRaidsList');
      if (!currentList) return;

      // Clear existing timers
      raidTimerIntervals.forEach(interval => clearInterval(interval));
      raidTimerIntervals = [];

      if (!raids || raids.length === 0) {
        currentList.innerHTML = '<div class="raids-empty">No active raids right now. Check back soon! <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"></div>';
        return;
      }

      // Store raids data for later use
      raids.forEach(raid => {
        currentRaidsData[raid.id] = raid;
      });

      // Get completed raids from localStorage
      const completedRaids = JSON.parse(localStorage.getItem(`completed_raids_${walletAddress}`) || '[]');

      // SECURITY: Save processing raid cards BEFORE rebuilding to preserve countdown state
      // We save the actual DOM elements (not clones) to preserve event handlers and intervals
      const processingCards = [];
      processingRaids.forEach(raidId => {
        const card = currentList.querySelector(`.raid-item[data-raid-id="${raidId}"]`);
        if (card) {
          card.remove(); // Remove from DOM temporarily
          processingCards.push(card); // Save reference to actual element
        }
      });

      // OPTIMIZATION: Save existing raid cards with loaded tweets to prevent reload
      const existingCards = {};
      Array.from(currentList.querySelectorAll('.raid-item')).forEach(card => {
        const raidId = parseInt(card.getAttribute('data-raid-id'));
        const preview = card.querySelector('.raid-tweet-preview');
        // Only save cards that have loaded tweet previews
        if (preview && (preview.querySelector('.twitter-tweet') || preview.querySelector('.raid-tweet-click-overlay'))) {
          card.remove(); // Remove from DOM temporarily
          existingCards[raidId] = card;
        }
      });

      currentList.innerHTML = raids.map(raid => {
        const isCompleted = completedRaids.includes(raid.id);
        const isProcessing = processingRaids.has(raid.id); // Check if currently processing
        const expiresAt = new Date(raid.expires_at);
        const now = new Date();
        const isExpired = expiresAt < now;

        // SECURITY: Don't re-render raids that are completed OR currently processing
        // Re-rendering processing raids would destroy the countdown state and UI references
        if (isCompleted || isProcessing) {
          return ''; // Don't render these raids
        }

        // OPTIMIZATION: Don't re-render raids with loaded tweet previews
        if (existingCards[raid.id]) {
          return ''; // Will be restored from saved element
        }

        return `
          <div class="raid-item ${isExpired ? 'expired' : ''}" data-raid-id="${raid.id}">
            ${raid.profile_name ? `
              <div class="raid-profile-header">
                <div class="raid-profile-emoji">${raid.profile_emoji || 'üêª'}</div>
                <div class="raid-profile-info">
                  <div class="raid-profile-name">${raid.profile_name}</div>
                  <div class="raid-profile-handle">${raid.profile_handle || ''}</div>
                </div>
              </div>
            ` : ''}
            <div class="raid-header">
              <span class="raid-timer ${isExpired ? 'expired' : ''}" id="timer-${raid.id}">
                ${isExpired ? 'EXPIRED' : 'Calculating...'}
              </span>
            </div>
            <div class="raid-description">${raid.description}</div>
            <div class="raid-tweet-preview" id="tweet-preview-${raid.id}">
              <div class="raid-preview-loading">Loading tweet preview...</div>
            </div>
            <div class="raid-footer">
              <span class="raid-reward"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"> HONEY EARNED FROM RAID: ${raid.reward}</span>
              <a href="javascript:void(0)"
                 class="raid-btn"
                 data-twitter-url="${raid.twitter_url}"
                 onclick="trackRaidClick(${raid.id}, event)"
                 ${isExpired ? 'style="pointer-events:none;opacity:0.5;"' : ''}>
                ${isExpired ? 'EXPIRED' : 'RAID NOW'}
              </a>
            </div>
          </div>
        `;
      }).join('');

      // OPTIMIZATION: Restore existing cards with loaded previews (appended at the end)
      raids.forEach(raid => {
        if (existingCards[raid.id]) {
          currentList.appendChild(existingCards[raid.id]);
          // Restart timer for this existing card
          if (new Date(raid.expires_at) > new Date()) {
            startRaidTimer(raid.id, raid.expires_at);
          }
        }
      });

      // Start countdown timers and load tweet previews for NEW raids only
      raids.forEach(raid => {
        // Skip if this is an existing card we just restored
        if (existingCards[raid.id]) {
          return; // Already has timer and preview
        }

        if (new Date(raid.expires_at) > new Date()) {
          startRaidTimer(raid.id, raid.expires_at);
        }
        // Load tweet preview only for new raids
        if (!completedRaids.includes(raid.id) && !processingRaids.has(raid.id)) {
          loadTweetPreview(raid.id, raid.twitter_url);
        }
      });

      // SECURITY: Re-append saved processing cards to preserve countdown state
      processingCards.forEach(card => {
        currentList.prepend(card); // Add at the beginning to keep them visible
      });

      // Resume any persisted timers that need resumption after page refresh
      resumePersistedTimers(walletAddress);
    }

    // Resume timers that were persisted before page refresh
    function resumePersistedTimers(walletAddress) {
      Object.keys(processingRaidTimers).forEach(raidId => {
        const timerData = processingRaidTimers[raidId];
        if (timerData.needsResume || timerData.needsComplete) {
          const raidCard = document.querySelector(`.raid-item[data-raid-id="${raidId}"]`);
          const raidBtn = raidCard?.querySelector('.raid-btn');

          if (timerData.needsComplete) {
            // Timer expired during refresh - complete the raid now
            console.log('‚è∞ Auto-completing expired raid timer:', raidId);
            delete processingRaidTimers[raidId];
            saveProcessingRaids();

            // Mark as completed in localStorage
            const currentCompleted = JSON.parse(localStorage.getItem(`completed_raids_${walletAddress}`) || '[]');
            if (!currentCompleted.includes(raidId)) {
              currentCompleted.push(raidId);
              localStorage.setItem(`completed_raids_${walletAddress}`, JSON.stringify(currentCompleted));

              // Send to backend
              fetch(`${API_BASE_URL}/api/raids/complete`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  wallet_address: walletAddress,
                  raid_id: raidId,
                  completed_at: new Date().toISOString(),
                  points_awarded: timerData.pointsAwarded || 20
                })
              }).then(r => r.json()).then(data => {
                if (data.success) {
                  console.log('‚úÖ Auto-completed raid synced with backend:', raidId);
                  loadRaids(); // Refresh to update UI
                }
              }).catch(err => console.error('Error auto-completing raid:', err));
            }
          } else if (timerData.needsResume && raidCard && raidBtn) {
            // Timer still has time - resume it
            console.log('üîÑ Resuming raid timer after page refresh:', raidId, 'with', timerData.secondsLeft, 'seconds left');
            delete processingRaidTimers[raidId].needsResume;
            startRaidCompletion(raidId, walletAddress, raidCard, raidBtn, null, timerData.secondsLeft);
          }
        }
      });
    }

    async function loadTweetPreview(raidId, twitterUrl) {
      const previewEl = document.getElementById(`tweet-preview-${raidId}`);
      if (!previewEl) return;

      // Check if preview is already loaded (not just the loading message)
      if (previewEl.querySelector('.twitter-tweet') || previewEl.querySelector('.raid-tweet-click-overlay')) {
        console.log(`Tweet preview already loaded for raid ${raidId}, skipping reload`);
        return;
      }

      try {
        const response = await fetch(`${API_BASE_URL}/api/twitter/oembed?url=${encodeURIComponent(twitterUrl)}`);
        const data = await response.json();

        if (data.success && data.embed && data.embed.html) {
          // Just display the full Twitter embed HTML
          previewEl.innerHTML = data.embed.html;

          // Add click overlay on top of the embed
          const overlay = document.createElement('div');
          overlay.className = 'raid-tweet-click-overlay';
          overlay.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            // Find the raid button and click it
            const raidBtn = document.querySelector(`.raid-item[data-raid-id="${raidId}"] .raid-btn`);
            if (raidBtn && !raidBtn.disabled) {
              console.log('Tweet preview clicked, triggering raid button');
              raidBtn.click();
            }
          };
          previewEl.appendChild(overlay);

          // Load Twitter widgets script if not already loaded
          if (!window.twttr) {
            const script = document.createElement('script');
            script.src = 'https://platform.twitter.com/widgets.js';
            script.async = true;
            document.body.appendChild(script);
          } else {
            // Reload widgets for this element
            window.twttr.widgets.load(previewEl);
          }
        } else {
          previewEl.innerHTML = '<div class="raid-preview-error">Preview unavailable</div>';
        }
      } catch (error) {
        console.error('Error loading tweet preview:', error);
        previewEl.innerHTML = '<div class="raid-preview-error">Preview unavailable</div>';
      }
    }

    function startRaidTimer(raidId, expiresAt) {
      const timerEl = document.getElementById(`timer-${raidId}`);
      if (!timerEl) return;

      const updateTimer = () => {
        const now = new Date().getTime();
        const end = new Date(expiresAt).getTime();
        const distance = end - now;

        if (distance < 0) {
          timerEl.textContent = 'EXPIRED';
          timerEl.classList.add('expired');
          return;
        }

        const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((distance % (1000 * 60)) / 1000);

        timerEl.textContent = `‚è∞ ${hours}h ${minutes}m ${seconds}s left`;
      };

      updateTimer(); // Update immediately
      const interval = setInterval(updateTimer, 1000);
      raidTimerIntervals.push(interval);
    }

    // Make function globally accessible
    window.trackRaidClick = function(raidId, event) {
      console.log('trackRaidClick called with raidId:', raidId);

      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) {
        console.log('No wallet address found');
        return true; // Allow link to open
      }

      // SECURITY: Check if already completed in localStorage (fast check)
      const completedRaids = JSON.parse(localStorage.getItem(`completed_raids_${walletAddress}`) || '[]');
      if (completedRaids.includes(raidId)) {
        console.log('‚ùå SECURITY: Raid already completed in localStorage!');
        return false; // Don't allow reopening
      }

      // SECURITY: Check if already being processed on THIS device
      if (processingRaids.has(raidId)) {
        console.log('‚ùå SECURITY: Raid already being processed on this device!');
        return false; // Prevent duplicate processing
      }

      // SECURITY: Mark as being processed IMMEDIATELY on this device
      processingRaids.add(raidId);

      // CRITICAL SECURITY: Check backend BEFORE starting countdown
      // This prevents race condition exploit across multiple devices
      console.log('üîí SECURITY: Checking backend for existing completion...');

      // Show checking state
      const raidCard = document.querySelector(`.raid-item[data-raid-id="${raidId}"]`);
      const raidBtn = event ? event.currentTarget : document.querySelector(`.raid-item[data-raid-id="${raidId}"] .raid-btn`);

      if (!raidCard || !raidBtn) {
        console.error('Could not find raid card or button');
        processingRaids.delete(raidId);
        return true;
      }

      // Disable button immediately while checking
      raidBtn.style.pointerEvents = 'none';
      raidBtn.style.opacity = '0.5';
      const originalText = raidBtn.textContent;
      raidBtn.textContent = 'CHECKING...';

      // Check backend for existing completion
      fetch(`${API_BASE_URL}/api/raids/check-completion`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          wallet_address: walletAddress,
          raid_id: raidId
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.alreadyCompleted) {
          console.log('‚ùå SECURITY: Backend says raid already completed! Blocking exploit attempt.');
          raidBtn.textContent = 'ALREADY COMPLETED';
          raidBtn.style.backgroundColor = '#ff0000';

          // Mark as completed locally
          completedRaids.push(raidId);
          localStorage.setItem(`completed_raids_${walletAddress}`, JSON.stringify(completedRaids));

          processingRaids.delete(raidId);

          // Remove raid from view after 2 seconds
          setTimeout(() => {
            raidCard.classList.add('fade-out');
            setTimeout(() => raidCard.remove(), 500);
          }, 2000);

          return;
        }

        // Backend approved - proceed with raid
        console.log('‚úÖ SECURITY: Backend approved raid completion');
        startRaidCompletion(raidId, walletAddress, raidCard, raidBtn, event);
      })
      .catch(err => {
        console.error('‚ùå SECURITY: Backend check failed:', err);
        raidBtn.textContent = 'ERROR - TRY AGAIN';
        raidBtn.style.pointerEvents = '';
        raidBtn.style.opacity = '';
        processingRaids.delete(raidId);
      });

      return false; // Prevent default link behavior
    };

    // Separate function for the actual raid completion flow
    function startRaidCompletion(raidId, walletAddress, raidCard, raidBtn, event, resumeSecondsLeft = null) {

      // SECURITY: Capture raid reward IMMEDIATELY before any async operations
      // This ensures we have the correct reward value even if raids refresh during countdown
      const raidData = currentRaidsData[raidId];
      const pointsAwarded = raidData?.reward || 20;
      console.log(`üéØ Raid reward captured: ${pointsAwarded} points for raid ${raidId}`);

      // Only open Twitter if this is a new raid start (not a resume)
      if (!resumeSecondsLeft) {
        // Open Twitter URL in browser (bypass Windows X app handler)
        let twitterUrl = raidBtn.getAttribute('data-twitter-url') || raidData?.twitter_url;
        if (twitterUrl) {
          twitterUrl = twitterUrl.replace('https://x.com/', 'https://twitter.com/');

          // Workaround for Windows opening X app: open blank tab first, then navigate
          const newTab = window.open('about:blank', '_blank');
          if (newTab) {
            // Small delay to ensure tab is ready, then navigate
            setTimeout(() => {
              newTab.location.href = twitterUrl;
            }, 100);
          }
        }
      }

      // SECURITY: Prevent ANY re-rendering of this raid
      raidCard.setAttribute('data-processing', 'true');
      raidCard.style.pointerEvents = 'none'; // Disable entire card

      // SECURITY: Disable button immediately and make changes PERMANENT
      raidBtn.style.pointerEvents = 'none';
      raidBtn.style.opacity = '0.5';
      raidBtn.style.cursor = 'not-allowed';
      raidBtn.onclick = null; // Remove click handler entirely

      // Add completing state
      raidCard.classList.add('completing');
      raidBtn.classList.add('completing');

      // Start countdown (use resumed time or 60 seconds for new)
      const startTime = resumeSecondsLeft ? (Date.now() - (60 - resumeSecondsLeft) * 1000) : Date.now();
      let secondsLeft = resumeSecondsLeft || 60;
      raidBtn.textContent = `COMPLETING... ‚è≥ ${secondsLeft}s`;

      // Store in processingRaidTimers for persistence
      processingRaidTimers[raidId] = {
        startTime,
        pointsAwarded,
        raidData
      };
      saveProcessingRaids();

      // Store original button content to prevent overwrites
      const processingText = `COMPLETING... ‚è≥`;

      const countdownInterval = setInterval(() => {
        secondsLeft--;
        if (secondsLeft > 0) {
          // SECURITY: Force button text to stay as countdown - CANNOT be overwritten
          raidBtn.textContent = `COMPLETING... ‚è≥ ${secondsLeft}s`;
          raidBtn.style.pointerEvents = 'none'; // Re-enforce every second
          raidBtn.onclick = null; // Re-enforce every second
        } else {
          // Countdown finished - mark as completed and fade out
          clearInterval(countdownInterval);

          // Remove from processing timers and save
          delete processingRaidTimers[raidId];
          saveProcessingRaids();

          // SECURITY: Double-check not already completed
          const currentCompleted = JSON.parse(localStorage.getItem(`completed_raids_${walletAddress}`) || '[]');
          if (currentCompleted.includes(raidId)) {
            console.log('‚ùå SECURITY: Raid was already completed during countdown!');
            processingRaids.delete(raidId);
            return;
          }

          // Mark raid as completed in localStorage
          currentCompleted.push(raidId);
          localStorage.setItem(`completed_raids_${walletAddress}`, JSON.stringify(currentCompleted));

          // Save full raid data for previous raids section
          const completedRaidsData = JSON.parse(localStorage.getItem(`completed_raids_data_${walletAddress}`) || '[]');

          // Use the raidData and pointsAwarded we captured at the start
          if (raidData && !completedRaidsData.find(r => r.id === raidId)) {
            completedRaidsData.push({
              ...raidData,
              completed_at: new Date().toISOString()
            });
            localStorage.setItem(`completed_raids_data_${walletAddress}`, JSON.stringify(completedRaidsData));
          }

          // CRITICAL SECURITY: Send to backend FIRST and ONLY award points if backend approves
          // This prevents the double-reward exploit
          raidBtn.textContent = 'SYNCING WITH SERVER...';

          fetch(`${API_BASE_URL}/api/raids/complete`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              wallet_address: walletAddress,
              raid_id: raidId,
              completed_at: new Date().toISOString(),
              points_awarded: pointsAwarded
            })
          })
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
          })
          .then(data => {
            console.log('üîí SECURITY: Backend response:', data);

            // CRITICAL: Only award points if backend says success AND not already completed
            if (data.success && !data.alreadyCompleted) {
              console.log('‚úÖ SECURITY: Backend approved points award');

              // ‚ùå REMOVED localStorage updates - backend is ONLY source of truth
              // Points are updated in backend database, UI will refresh from backend

              console.log(`‚úÖ Points awarded! +${pointsAwarded} New balance:`, currentPoints);

              // Update all points displays immediately
              updatePointsDisplay(currentPoints.total, currentPoints.raiding, currentPoints.games);
              updateWelcomeButton();

              const navHoneyPoints = document.getElementById('navHoneyPoints');
              if (navHoneyPoints) {
                navHoneyPoints.textContent = currentPoints.total.toFixed(1) + ' PTS';
              }

              const welcomePoints = document.getElementById('welcomePoints');
              if (welcomePoints) {
                welcomePoints.textContent = currentPoints.total.toFixed(1);
              }

              // Reload to sync with backend
              loadHoneyPoints();
              loadDailyGameProgress();
              loadHoneyLeaderboard(walletAddress);

              raidBtn.textContent = `‚úì COMPLETED +${pointsAwarded} PTS`;
            } else if (data.alreadyCompleted) {
              console.log('‚ùå SECURITY: Backend rejected - raid already completed! EXPLOIT BLOCKED!');
              raidBtn.textContent = 'ALREADY COMPLETED - NO POINTS';
              raidBtn.style.backgroundColor = '#ff0000';
            } else {
              console.warn('‚ö†Ô∏è SECURITY: Backend returned unexpected response');
              raidBtn.textContent = 'ERROR - NO POINTS AWARDED';
              raidBtn.style.backgroundColor = '#ff6600';
            }
          })
          .catch(err => {
            console.error('‚ùå SECURITY: Backend sync FAILED - NO POINTS AWARDED:', err);
            raidBtn.textContent = 'ERROR - TRY AGAIN LATER';
            raidBtn.style.backgroundColor = '#ff0000';
            processingRaids.delete(raidId);
            return; // Don't continue if backend fails
          })
          .finally(() => {
            // Clean up UI regardless of success or failure
            raidBtn.classList.remove('completing');
            raidCard.classList.remove('completing');
            raidCard.classList.add('completed');

            // SECURITY: Remove from processing set
            processingRaids.delete(raidId);

            // Fade out and remove after animation
            setTimeout(() => {
              raidCard.classList.add('fade-out');

              // Remove from DOM after animation completes
              setTimeout(() => {
                raidCard.remove();

                // Check if there are no more raids
                const currentList = document.getElementById('currentRaidsList');
                if (currentList && currentList.children.length === 0) {
                  currentList.innerHTML = '<div class="raids-empty">No active raids right now. Check back soon! <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"></div>';
                }
              }, 1000);
            }, 1500);
          });
        }
      }, 1000);

      return true; // Allow link to open in new tab
    };

    async function loadPreviousRaids() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      const previousList = document.getElementById('previousRaidsList');
      if (!previousList) return;

      // Load from localStorage
      const completedRaidsData = JSON.parse(localStorage.getItem(`completed_raids_data_${walletAddress}`) || '[]');

      if (completedRaidsData.length > 0) {
        previousList.innerHTML = completedRaidsData.map(raid => {
          return `
            <div class="raid-item completed">
              ${raid.profile_name ? `
                <div class="raid-profile-header">
                  <div class="raid-profile-emoji">${raid.profile_emoji || 'üêª'}</div>
                  <div class="raid-profile-info">
                    <div class="raid-profile-name">${raid.profile_name}</div>
                    <div class="raid-profile-handle">${raid.profile_handle || ''}</div>
                  </div>
                </div>
              ` : ''}
              <div class="raid-header">
                <span class="raid-timer expired">‚úì COMPLETED</span>
              </div>
              <div class="raid-description">${raid.description}</div>
              <div class="raid-footer">
                <span class="raid-reward">‚úì Earned ${raid.reward} PTS <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"></span>
                <a href="${raid.twitter_url}" target="_blank" rel="noopener noreferrer" class="raid-btn" style="pointer-events:all;opacity:1;">
                  VIEW POST
                </a>
              </div>
            </div>
          `;
        }).join('');
      } else {
        previousList.innerHTML = '<div class="raids-empty">No previous raids yet! Complete some raids to see them here. <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="honey" style="height:1em; width:auto; vertical-align:middle; display:inline-block;"></div>';
      }

      // Try to sync with backend (optional)
      try {
        const response = await fetch(`/api/raids/previous?wallet=${walletAddress}`);
        if (response.ok) {
          const data = await response.json();
          // Could merge backend data here if needed
        }
      } catch (err) {
        console.debug('Backend not available - using local data');
      }
    }

    // Toggle between current and previous raids
    document.getElementById('raidsToggleBtn')?.addEventListener('click', function() {
      const currentList = document.getElementById('currentRaidsList');
      const previousList = document.getElementById('previousRaidsList');
      const raidsTitle = document.getElementById('raidsTitle');

      showingPreviousRaids = !showingPreviousRaids;

      if (showingPreviousRaids) {
        currentList.style.display = 'none';
        previousList.style.display = 'flex';
        this.textContent = 'Show Current Raids';
        if (raidsTitle) raidsTitle.textContent = 'üìú Previous Raids';
        loadPreviousRaids();
      } else {
        currentList.style.display = 'flex';
        previousList.style.display = 'none';
        this.textContent = 'Show Previous Raids';
        if (raidsTitle) raidsTitle.textContent = 'üêª ü™ñ Current Raids';
      }
    });

    /* ===== NFT & Profile Management ===== */
    const PIXEL_BEARS_ISSUER = 'rBEARbo4Prn33894evmvYcAf9yAQjp4VJF';
    const PIXEL_BEARS_TAXON = 1;
    const ULTRA_RARES_ISSUER = 'rBEARbo4Prn33894evmvYcAf9yAQjp4VJF';
    const ULTRA_RARES_TAXON = 2;

    let currentNFTs = [];
    let selectedAvatarNFT = null;
    let nftImageCache = {}; // Store NFT images and metadata

    // Helper function to convert hex string to regular string
    function hexToString(hex) {
      const hexString = hex.startsWith('0x') ? hex.slice(2) : hex;
      let str = '';
      for (let i = 0; i < hexString.length; i += 2) {
        const charCode = parseInt(hexString.substr(i, 2), 16);
        if (charCode) str += String.fromCharCode(charCode);
      }
      return str;
    }

    // Show profile and NFT sections when authenticated
    async function initializeProfileAndNFTs() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      const isAuthenticated = localStorage.getItem('bearpark_auth') === 'true';

      if (!isAuthenticated || !walletAddress) {
        document.getElementById('profileSection').style.display = 'none';
        document.getElementById('nftSection').style.display = 'none';
        return;
      }

      // Show sections
      document.getElementById('profileSection').style.display = 'block';
      document.getElementById('nftSection').style.display = 'block';

      // Load existing profile data
      let profileLoaded = false;

      // Try to load from backend first
      try {
        const response = await fetch(`${API_BASE_URL}/api/profile/${walletAddress}`);
        if (response.ok) {
          const data = await response.json();

          if (data.success && data.profile) {
            document.getElementById('profileUsername').value = data.profile.display_name || '';
            if (data.profile.avatar_nft) {
              selectedAvatarNFT = data.profile.avatar_nft;
              document.getElementById('profileAvatarNFT').value = data.profile.avatar_nft;
              // Display selected avatar
              displaySelectedAvatar(data.profile.avatar_nft);
            }
            profileLoaded = true;
          }
        }
      } catch (err) {
        console.debug('Backend profile not available, checking localStorage:', err.message);
      }

      // Fallback to localStorage if backend didn't load
      if (!profileLoaded) {
        const profileKey = `bearpark_profile_${walletAddress}`;
        const localProfile = localStorage.getItem(profileKey);
        if (localProfile) {
          try {
            const profile = JSON.parse(localProfile);
            document.getElementById('profileUsername').value = profile.display_name || '';
            if (profile.avatar_nft) {
              selectedAvatarNFT = profile.avatar_nft;
              document.getElementById('profileAvatarNFT').value = profile.avatar_nft;
              // Display selected avatar
              displaySelectedAvatar(profile.avatar_nft);
            }
            console.log('‚úÖ Loaded profile from localStorage');
          } catch (e) {
            console.error('Error parsing local profile:', e);
          }
        }
      }
    }

    function displaySelectedAvatar(nftIdOrData) {
      const selector = document.getElementById('profileAvatarSelector');
      let imageData;

      // Handle both NFT ID string and JSON avatar data
      if (typeof nftIdOrData === 'string') {
        // Try to parse as JSON first (from database)
        try {
          imageData = JSON.parse(nftIdOrData);
        } catch (e) {
          // If not JSON, it's an NFT ID - look it up in cache
          imageData = nftImageCache[nftIdOrData];
        }
      } else {
        // Already an object
        imageData = nftIdOrData;
      }

      if (imageData && imageData.imageUrl) {
        // Build fallback chain: animated -> fallback image -> error placeholder
        const fallbackSrc = imageData.fallbackImageUrl || 'data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27100%27 height=%27100%27%3E%3Crect fill=%27%23333%27 width=%27100%27 height=%27100%27/%3E%3Ctext fill=%27%23edb723%27 x=%2750%25%27 y=%2750%25%27 text-anchor=%27middle%27 dy=%27.3em%27%3ENFT%3C/text%3E%3C/svg%3E';

        // Use img element for all content types
        // Browsers handle GIFs natively, and can show video thumbnails
        selector.innerHTML = `
          <img src="${imageData.imageUrl}"
               style="width:100%; max-width:120px; border-radius:8px;"
               alt="Selected avatar"
               crossorigin="anonymous"
               onerror="if(this.src!=='${fallbackSrc.replace(/'/g, "\\'")}'){console.log('[Avatar] Trying fallback image');this.src='${fallbackSrc.replace(/'/g, "\\'")}';}">
        `;
      } else {
        selector.innerHTML = `
          <div style="width:100%; max-width:120px; aspect-ratio:1; background:rgba(237,183,35,0.1); border-radius:8px; display:flex; align-items:center; justify-content:center; color:var(--gold);">
            Loading...
          </div>
        `;
      }
    }

    // Load NFTs from wallet
    async function loadNFTs(taxon, type) {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) return;

      const nftLoading = document.getElementById('nftLoading');
      const nftGrid = document.getElementById('nftGrid');
      const nftEmpty = document.getElementById('nftEmpty');
      const nftGridContent = document.getElementById('nftGridContent');

      // Show loading
      nftLoading.style.display = 'block';
      nftGrid.style.display = 'none';
      nftEmpty.style.display = 'none';

      try {
        // Use HTTP JSON-RPC - only xrplcluster.com supports CORS for browser requests
        // s1.ripple.com:51234 and s2.ripple.com:51234 DON'T support CORS and cause tab spinner issues
        const xrplEndpoints = [
          'https://xrplcluster.com/'
        ];

        // Get ALL account NFTs with pagination
        let allNFTs = [];
        let marker = undefined;
        let pageCount = 0;
        const maxPages = 20; // Safety limit

        console.log('[NFT] Fetching all NFTs from wallet (with pagination via HTTP)...');

        do {
          let response = null;
          let lastError = null;

          // Try each endpoint until one works
          for (const endpoint of xrplEndpoints) {
            try {
              console.log(`[NFT] Trying endpoint: ${endpoint}`);
              response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  method: 'account_nfts',
                  params: [{
                    account: walletAddress,
                    ledger_index: 'validated',
                    limit: 400,
                    ...(marker && { marker })
                  }]
                })
              });
              if (response.ok) {
                console.log(`[NFT] Success with endpoint: ${endpoint}`);
                break;
              }
            } catch (err) {
              console.log(`[NFT] Endpoint ${endpoint} failed:`, err.message);
              lastError = err;
            }
          }

          if (!response || !response.ok) {
            console.error('[NFT] All XRPL endpoints failed');
            throw new Error('All XRPL endpoints failed');
          }

          const data = await response.json();
          const pageNfts = data.result?.account_nfts || [];

          if (pageNfts.length > 0) {
            allNFTs = allNFTs.concat(pageNfts);
            console.log(`[NFT] Page ${pageCount + 1}: Found ${pageNfts.length} NFTs`);
          }

          marker = data.result?.marker;
          pageCount++;

        } while (marker && pageCount < maxPages);

        console.log(`[NFT] Total NFTs found across ${pageCount} page(s):`, allNFTs.length);

        // Log each NFT for debugging
        allNFTs.forEach((nft, i) => {
          const nftTaxon = parseInt(nft.NFTokenID.substring(48, 56), 16);
          console.log(`[NFT ${i}] Issuer:`, nft.Issuer, 'Taxon:', nftTaxon, 'ID:', nft.NFTokenID);
        });

        // Filter NFTs by issuer AND URI pattern
        const targetIssuer = 'rBEARbo4Prn33894evmvYcAf9yAQjp4VJF';
        const filteredNFTs = allNFTs.filter(nft => {
          const issuerMatch = nft.Issuer === targetIssuer;
          if (!issuerMatch) return false;

          // Check URI to distinguish Pixel Bears from Ultra Rares
          if (nft.URI) {
            const uriString = hexToString(nft.URI);
            const isPixelBear = uriString.includes('Pixel BEAR') || uriString.includes('Pixel%20BEAR');

            // If looking for Pixel Bears (taxon 1), include Pixel Bears
            // If looking for Ultra Rares (taxon 2), exclude Pixel Bears
            const typeMatch = (taxon === PIXEL_BEARS_TAXON) ? isPixelBear : !isPixelBear;

            console.log('[NFT Filter]', nft.NFTokenID, 'Issuer:', issuerMatch, 'Type:', isPixelBear ? 'Pixel BEAR' : 'Ultra Rare', 'Match:', typeMatch);
            return typeMatch;
          }

          return false;
        });

        console.log('[NFT] Filtered NFTs:', filteredNFTs.length);

        currentNFTs = filteredNFTs;

        if (filteredNFTs.length === 0) {
          nftLoading.style.display = 'none';
          nftEmpty.style.display = 'block';
          nftEmpty.textContent = `No ${type} found in your wallet. Total NFTs: ${allNFTs.length}`;
          return;
        }

        // Display NFTs with loading placeholders
        nftGridContent.innerHTML = filteredNFTs.map(nft => `
          <div class="nft-item" data-nft-id="${nft.NFTokenID}"
               style="position:relative; border-radius:12px; overflow:hidden; border:3px solid rgba(237,183,35,0.3); background:linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,20,20,0.9)); transition:all 0.3s ease; box-shadow:0 4px 15px rgba(0,0,0,0.5);"
               onmouseover="this.style.transform='translateY(-5px) scale(1.02)'; this.style.borderColor='var(--gold)'; this.style.boxShadow='0 8px 25px rgba(237,183,35,0.4)';"
               onmouseout="this.style.transform=''; this.style.borderColor='rgba(237,183,35,0.3)'; this.style.boxShadow='0 4px 15px rgba(0,0,0,0.5)';">
            <div style="width:100%; aspect-ratio:1; position:relative; background:rgba(237,183,35,0.05);">
              <img src="" data-nft-id="${nft.NFTokenID}" class="nft-image-loading"
                   style="width:100%; height:100%; display:block; object-fit:contain; image-rendering:pixelated;"
                   alt="${type} NFT">
              <a href="https://xrp.cafe/nft/${nft.NFTokenID}" target="_blank" rel="noopener noreferrer"
                 style="position:absolute; top:8px; left:8px; width:32px; height:32px; border-radius:50%; background:#fff; display:flex; align-items:center; justify-content:center; box-shadow:0 2px 8px rgba(0,0,0,0.3); transition:all 0.2s; z-index:10; border:3px solid transparent; background-image: linear-gradient(#fff, #fff), var(--tri-gradient); background-origin: padding-box, border-box; background-clip: padding-box, border-box;"
                 onmouseover="this.style.transform='scale(1.15)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.5)';"
                 onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.3)';"
                 title="View on XRP.cafe">
                <img src="https://avatars.githubusercontent.com/u/109316848?s=280&v=4"
                     alt="XRP.cafe"
                     style="width:20px; height:20px; border-radius:50%; object-fit:cover;">
              </a>
              <div class="loading-overlay" data-nft-id="${nft.NFTokenID}" style="position:absolute; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.85); display:flex; align-items:center; justify-content:center; color:var(--gold); font-size:14px; font-weight:900;">
                Loading...
              </div>
            </div>
            <div class="nft-info" data-nft-id="${nft.NFTokenID}" style="padding:12px; background:rgba(0,0,0,0.85); display:none;">
              <div style="text-align:center; margin-bottom:8px;">
                <div style="color:var(--gold); font-weight:900; font-size:14px; margin-bottom:4px;">Loading...</div>
                <div style="color:rgba(255,255,255,0.7); font-size:11px;">Please wait...</div>
              </div>
            </div>
            <div style="padding:8px; background:rgba(0,0,0,0.9);">
              <button class="nft-select-btn" data-nft-id="${nft.NFTokenID}"
                      style="font-size:12px; padding:10px; background:#5D3FD3; color:#fff; border:3px solid transparent; border-radius:20px; font-weight:900; cursor:pointer; width:100%; transition:all 0.2s; text-transform:uppercase; letter-spacing:1px; box-shadow:0 4px 0 #000,0 4px 12px rgba(0,0,0,0.8); background-image:linear-gradient(#5D3FD3, #5D3FD3), var(--tri-gradient); background-origin:padding-box, border-box; background-clip:padding-box, border-box;"
                      onmouseover="this.style.backgroundImage='linear-gradient(#6D4FE3, #6D4FE3), var(--tri-gradient)'; this.style.transform='translateY(-2px)';"
                      onmouseout="this.style.backgroundImage='linear-gradient(#5D3FD3, #5D3FD3), var(--tri-gradient)'; this.style.transform='translateY(0)';">
                Select Avatar
              </button>
              <button class="nft-save-btn" data-nft-id="${nft.NFTokenID}"
                      style="font-size:11px; padding:8px; background:#07ae08; color:#fff; border:3px solid transparent; border-radius:20px; font-weight:900; cursor:pointer; margin-top:6px; width:100%; transition:all 0.2s; text-transform:uppercase; letter-spacing:0.5px; box-shadow:0 4px 0 #000,0 4px 12px rgba(0,0,0,0.8); background-image:linear-gradient(#07ae08, #07ae08), var(--tri-gradient); background-origin:padding-box, border-box; background-clip:padding-box, border-box;"
                      onmouseover="this.style.backgroundImage='linear-gradient(#08d509, #08d509), var(--tri-gradient)'; this.style.transform='translateY(-2px)';"
                      onmouseout="this.style.backgroundImage='linear-gradient(#07ae08, #07ae08), var(--tri-gradient)'; this.style.transform='translateY(0)';">
                Save Image
              </button>
            </div>
          </div>
        `).join('');

        // Load NFT images using backend API (handles IPFS encoding properly)
        console.log('%c[NFT IMAGE LOADING STARTING] ' + filteredNFTs.length + ' NFTs', 'background: red; color: white; font-size: 20px;');

        const imageLoadPromises = filteredNFTs.map(async (nft) => {
          try {
            // Check if NFT has a URI field (hex-encoded)
            if (!nft.URI) {
              console.log('[NFT Image] No URI found for', nft.NFTokenID);
              return;
            }

            console.log('%c[NFT Image] Fetching: ' + nft.NFTokenID.substring(0, 16), 'background: blue; color: white;');

            // Use backend API to get properly encoded image URL
            let imageUrl = '';
            let fallbackImageUrl = null;
            let isAnimated = false;
            let metadata = null;

            try {
              const apiResponse = await fetch(`${API_BASE_URL}/api/nft/image/${nft.URI}`);
              const apiData = await apiResponse.json();

              if (apiData.success && apiData.imageUrl) {
                imageUrl = apiData.imageUrl;
                fallbackImageUrl = apiData.fallbackUrl || null;
                isAnimated = apiData.isAnimated || false;
                metadata = { name: apiData.name };
                console.log('[NFT Image] API success:', apiData.name, '->', imageUrl.substring(0, 60) + '...');
              } else {
                console.log('[NFT Image] API failed, trying direct fetch...');
                // Fallback to direct IPFS fetch
                const uriString = hexToString(nft.URI);
                let metadataUrl = '';
                if (uriString.startsWith('ipfs://')) {
                  const ipfsPath = uriString.replace('ipfs://', '');
                  const pathParts = ipfsPath.split('/');
                  const encodedPath = pathParts.map(part => encodeURIComponent(part)).join('/');
                  metadataUrl = `https://ipfs.io/ipfs/${encodedPath}`;
                } else if (uriString.startsWith('http')) {
                  metadataUrl = uriString;
                }

                if (metadataUrl) {
                  const metadataResponse = await fetch(metadataUrl);
                  if (metadataResponse.ok) {
                    metadata = await metadataResponse.json();
                    isAnimated = !!metadata.animation;
                    const imgField = metadata.animation || metadata.image || metadata.image_url || '';
                    if (imgField.startsWith('ipfs://')) {
                      const imgPath = imgField.replace('ipfs://', '');
                      const imgParts = imgPath.split('/');
                      const encodedImg = imgParts.map(part => encodeURIComponent(part)).join('/');
                      imageUrl = `https://ipfs.io/ipfs/${encodedImg}`;
                    } else {
                      imageUrl = imgField;
                    }
                    if (metadata.animation && metadata.image) {
                      const fallbackField = metadata.image;
                      if (fallbackField.startsWith('ipfs://')) {
                        const fbPath = fallbackField.replace('ipfs://', '');
                        const fbParts = fbPath.split('/');
                        const encodedFb = fbParts.map(part => encodeURIComponent(part)).join('/');
                        fallbackImageUrl = `https://ipfs.io/ipfs/${encodedFb}`;
                      } else {
                        fallbackImageUrl = fallbackField;
                      }
                    }
                  }
                }
              }
            } catch (apiErr) {
              console.error('[NFT Image] API error:', apiErr.message);
            }

            console.log('[NFT Image]', isAnimated ? 'Animation' : 'Image', 'URL for', nft.NFTokenID, ':', imageUrl);
            if (fallbackImageUrl) {
              console.log('[NFT Image] Fallback URL:', fallbackImageUrl);
            }

            // Extract BEAR number and rarity from metadata
            const bearName = metadata.name || 'Unknown BEAR';

            // Extract bear number from name (e.g., "BEAR #36" -> 36)
            const bearNumberMatch = bearName.match(/#(\d+)/);
            const bearNumber = bearNumberMatch ? parseInt(bearNumberMatch[1]) : null;

            // Hardcoded rarity mapping for Ultra Rare Bears
            // This data is not stored in the NFT metadata
            const ultraRareRarityMap = {
              9: 10,
              12: 12,
              14: 14,
              18: 18,
              36: 37,
              451: 273
            };

            let rarityNumber = '';
            if (bearNumber && ultraRareRarityMap[bearNumber]) {
              rarityNumber = `#${ultraRareRarityMap[bearNumber]}`;
              console.log('[NFT Image] Mapped rarity for', bearName, ':', rarityNumber);
            } else {
              console.log('[NFT Image] No rarity mapping found for', bearName);
              rarityNumber = '';
            }

            console.log('[NFT Image] Extracted:', bearName, 'Rarity:', rarityNumber);

            // Store in cache
            nftImageCache[nft.NFTokenID] = {
              imageUrl,
              fallbackImageUrl,
              metadata,
              bearName,
              rarityNumber,
              isAnimated
            };

            // Update media element (use img for all content types for reliability)
            const imgElement = document.querySelector(`img.nft-image-loading[data-nft-id="${nft.NFTokenID}"]`);
            console.log('[NFT Image] imgElement found:', !!imgElement, 'imageUrl:', imageUrl ? imageUrl : 'NONE');

            // ALWAYS remove loading overlay immediately - don't wait for image
            const loadingOverlay = document.querySelector(`.loading-overlay[data-nft-id="${nft.NFTokenID}"]`);
            if (loadingOverlay) {
              loadingOverlay.style.display = 'none';
              console.log('[NFT Image] Overlay hidden for', nft.NFTokenID);
            }

            if (imgElement && imageUrl) {
              console.log('%c[NFT Image] SETTING SRC: ' + imageUrl.substring(0, 80), 'background: green; color: white; font-size: 14px;');
              imgElement.src = imageUrl;
              imgElement.classList.remove('nft-image-loading');

              // Set up error handler with fallback
              imgElement.onerror = function() {
                console.error('[NFT Image] ‚ùå Image FAILED for', bearName, 'URL:', imageUrl);
                // Try fallback if available
                if (fallbackImageUrl && this.src !== fallbackImageUrl) {
                  console.log('[NFT Image] Trying fallback:', fallbackImageUrl);
                  this.src = fallbackImageUrl;
                } else {
                  // Show placeholder on error
                  this.style.background = 'linear-gradient(135deg, #1a1a2e 0%, #16213e 100%)';
                  this.alt = bearName;
                }
              };

              imgElement.onload = function() {
                console.log('[NFT Image] ‚úÖ LOADED:', bearName);
              };

              console.log('[NFT Image] ‚úÖ Image src SET for', bearName);
            } else if (imgElement) {
              // No imageUrl - show placeholder
              console.warn('[NFT Image] No imageUrl for', nft.NFTokenID);
              imgElement.style.background = 'linear-gradient(135deg, #1a1a2e 0%, #16213e 100%)';
            }

            // Update NFT info section (always, even if no image)
            const infoSection = document.querySelector(`.nft-info[data-nft-id="${nft.NFTokenID}"]`);
            if (infoSection) {
              infoSection.style.display = 'block';
              infoSection.innerHTML = `
                <div style="text-align:center; margin-bottom:0;">
                  <div style="color:var(--gold); font-weight:900; font-size:14px; margin-bottom:2px; text-shadow:0 2px 4px rgba(0,0,0,0.5);">${bearName}</div>
                  <div style="color:rgba(255,255,255,0.8); font-size:12px; font-weight:700;">Rarity ${rarityNumber}</div>
                </div>
              `;
            }
          } catch (err) {
            console.error('[NFT Image] Failed to load image for', nft.NFTokenID, err);
            // Hide overlay even on error
            const loadingOverlay = document.querySelector(`.loading-overlay[data-nft-id="${nft.NFTokenID}"]`);
            if (loadingOverlay) {
              loadingOverlay.style.display = 'none';
            }
          }
        });

        // Wait for all images to load
        await Promise.all(imageLoadPromises);
        console.log('[NFT] All images loaded');

        // Wire up NFT buttons
        document.querySelectorAll('.nft-select-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const nftId = btn.getAttribute('data-nft-id');
            selectNFTAsAvatar(nftId);
          });
        });

        document.querySelectorAll('.nft-save-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const nftId = btn.getAttribute('data-nft-id');
            saveNFTImage(nftId);
          });
        });

        nftLoading.style.display = 'none';
        nftGrid.style.display = 'block';

        // Auto-scroll to NFT grid after loading
        setTimeout(() => {
          nftGrid.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }, 100);

      } catch (err) {
        console.error('Error loading NFTs:', err);
        nftLoading.style.display = 'none';
        nftEmpty.style.display = 'block';
        nftEmpty.textContent = 'Failed to load NFTs. Please try again.';
      }
    }

    function selectNFTAsAvatar(nftId) {
      selectedAvatarNFT = nftId;
      document.getElementById('profileAvatarNFT').value = nftId;
      displaySelectedAvatar(nftId);
      // Scroll to profile setup section to see avatar
      const profileSection = document.getElementById('profileSetupSection');
      if (profileSection) {
        profileSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    function saveNFTImage(nftId) {
      const imageData = nftImageCache[nftId];
      if (imageData && imageData.imageUrl) {
        const link = document.createElement('a');
        link.href = imageData.imageUrl;
        link.download = `${imageData.bearName || 'BEAR-NFT'}-${nftId.substring(0, 8)}.png`;
        link.target = '_blank';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      } else {
        alert('Image not yet loaded. Please wait a moment and try again.');
      }
    }

    // Save profile
    document.getElementById('saveProfileBtn')?.addEventListener('click', async () => {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) return;

      const username = document.getElementById('profileUsername').value.trim();
      const avatarNFT = document.getElementById('profileAvatarNFT').value;

      if (!username) {
        showSuccessPopup('Please enter a display name first!', '‚ö†Ô∏è');
        return;
      }

      // Get the full image data from cache
      let avatarData = null;
      let avatarUrl = null;
      if (avatarNFT && nftImageCache[avatarNFT]) {
        // Store the full image data as JSON
        avatarData = JSON.stringify({
          nftId: avatarNFT,
          imageUrl: nftImageCache[avatarNFT].imageUrl,
          fallbackImageUrl: nftImageCache[avatarNFT].fallbackImageUrl,
          bearName: nftImageCache[avatarNFT].bearName,
          isAnimated: nftImageCache[avatarNFT].isAnimated
        });
        avatarUrl = nftImageCache[avatarNFT].imageUrl;
      }

      // IMMEDIATELY save to localStorage (works without backend)
      const profileKey = `bearpark_profile_${walletAddress}`;
      const localProfile = {
        display_name: username,
        avatar_nft: avatarData,
        avatar_url: avatarUrl,
        updated_at: new Date().toISOString()
      };
      localStorage.setItem(profileKey, JSON.stringify(localProfile));
      console.log('‚úÖ Profile saved locally!', localProfile);

      // Mark that user has completed first-time profile setup
      localStorage.setItem('bearpark_profile_setup_complete', 'true');

      // Hide BOTH instruction banners with fade out effect
      const profileInstructionsBanner = document.getElementById('profileInstructions');
      const nftInstructionsBanner = document.getElementById('nftInstructions');

      if (profileInstructionsBanner) {
        profileInstructionsBanner.style.opacity = '0';
        profileInstructionsBanner.style.transform = 'scale(0.8)';
        setTimeout(() => {
          profileInstructionsBanner.style.display = 'none';
        }, 500);
      }

      if (nftInstructionsBanner) {
        nftInstructionsBanner.style.opacity = '0';
        nftInstructionsBanner.style.transform = 'scale(0.8)';
        setTimeout(() => {
          nftInstructionsBanner.style.display = 'none';
        }, 500);
      }

      // Update welcome button immediately with local data
      updateWelcomeButton();

      // Try to sync with backend (optional)
      try {
        const response = await fetch(`${API_BASE_URL}/api/profile`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            wallet_address: walletAddress,
            display_name: username,
            avatar_nft: avatarData
          })
        });

        if (response.ok) {
          const data = await response.json();
          if (data.success) {
            console.log('‚úÖ Profile synced with backend!');
            celebrateProfileSave();
            showSuccessPopup('Your profile is looking BEARISH! üêª‚ú® Your custom username and avatar will appear on the leaderboard!', 'üéâ');
            // Refresh leaderboard to show new profile
            loadHoneyLeaderboard(walletAddress);
          } else {
            celebrateProfileSave();
            showSuccessPopup('Profile saved to the moon! üöÄ (Backend sync pending but you\'re good to go!)', '‚úÖ');
          }
        } else {
          console.log('Backend not available - profile saved locally only');
          celebrateProfileSave();
          showSuccessPopup('You\'re officially a BEAR now! üêªüí™ Your profile is saved and ready to roar!', 'üéä');
        }
      } catch (error) {
        console.log('Backend not available - profile saved locally only');
        celebrateProfileSave();
        showSuccessPopup('You\'re officially a BEAR now! üêªüí™ Your profile is saved and ready to roar!', 'üéä');
      }
    });

    // View Pixel Bears button
    document.getElementById('viewPixelBearsBtn')?.addEventListener('click', () => {
      loadNFTs(PIXEL_BEARS_TAXON, 'Pixel Bears');
    });

    // View Ultra Rares button
    document.getElementById('viewUltraRaresBtn')?.addEventListener('click', () => {
      loadNFTs(ULTRA_RARES_TAXON, 'Ultra Rares');
    });

    // Initialize on load
    initializeProfileAndNFTs();

    // ===== TOP NAVIGATION FUNCTIONS =====

    // Toggle hamburger menu
    window.toggleMenu = function() {
      const menuOverlay = document.getElementById('menuOverlay');
      const menuScrim = document.getElementById('menuScrim');

      menuOverlay.classList.toggle('open');
      menuScrim.classList.toggle('open');

      // Prevent body scroll when menu is open
      if (menuOverlay.classList.contains('open')) {
        document.body.style.overflow = 'hidden';
      } else {
        document.body.style.overflow = '';
      }
    };

    // Open profile setup - opens drawer and scrolls to profile section
    window.openProfileSetup = function() {
      console.log('üî• [openProfileSetup] Function called!');
      const walletAddress = localStorage.getItem('bearpark_wallet');
      console.log('üî• [openProfileSetup] Wallet:', walletAddress);

      if (!walletAddress) {
        console.log('üî• [openProfileSetup] No wallet, opening drawer');
        // Use the correct openDrawer function
        if (typeof openDrawer === 'function') {
          openDrawer();
        } else {
          // Fallback to direct DOM manipulation
          const drawer = document.getElementById('buyDrawer');
          if (drawer) {
            drawer.style.display = 'flex';
            setTimeout(() => drawer.classList.add('visible'), 10);
          }
        }
        return;
      }

      console.log('üêª Opening profile setup for new user...');
      // Use the correct openDrawer function
      if (typeof openDrawer === 'function') {
        openDrawer();
      } else {
        // Fallback to direct DOM manipulation
        const drawer = document.getElementById('buyDrawer');
        if (drawer) {
          drawer.style.display = 'flex';
          setTimeout(() => drawer.classList.add('visible'), 10);
        }
      }

      // Wait for drawer to open and PNL content to load, then scroll to profile section
      setTimeout(() => {
        const profileSection = document.getElementById('profileSection');
        const drawer = document.getElementById('buyDrawer');
        const drawerBody = drawer ? drawer.querySelector('.drawer-body') : null;

        console.log('üêª Drawer opened, scrolling to profile section...', { profileSection, drawerBody });

        if (profileSection && drawerBody) {
          drawerBody.scrollTo({
            top: profileSection.offsetTop - 20,
            behavior: 'smooth'
          });

          // Add pulsing highlight effect to make it obvious
          profileSection.classList.add('profile-highlight-pulse');

          // Remove highlight after 5 seconds
          setTimeout(() => {
            profileSection.classList.remove('profile-highlight-pulse');
          }, 5000);

          console.log('‚úÖ Profile section highlighted and scrolled into view!');
        } else {
          console.error('‚ùå Could not find profileSection or drawerBody elements!', { profileSection, drawerBody });
        }
      }, 1500);
    };

    // Update welcome button with points and username
    async function updateWelcomeButton() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      const welcomePoints = document.getElementById('welcomePoints');
      const welcomeUsername = document.getElementById('welcomeUsername');
      const navHoneyPoints = document.getElementById('navHoneyPoints');

      if (!walletAddress) {
        welcomePoints.textContent = '0.0';
        welcomeUsername.textContent = 'WELCOME BEAR (click me!)';
        if (navHoneyPoints) navHoneyPoints.textContent = '0.0 PTS';
        return;
      }

      // ‚ùå REMOVED localStorage caching - show loading state instead
      // Backend is ONLY source of truth, never use cached values
      welcomePoints.textContent = 'Loading...';
      if (navHoneyPoints) navHoneyPoints.textContent = 'Loading...';

      // Load username from localStorage
      const profileKey = `bear_profile_${walletAddress}`;
      const localProfile = JSON.parse(localStorage.getItem(profileKey) || '{}');

      if (localProfile.display_name) {
        welcomeUsername.textContent = `WELCOME ${localProfile.display_name.toUpperCase()}`;
      } else {
        welcomeUsername.textContent = 'WELCOME BEAR (click me!)';
      }

      // Update avatar if available, or show default bear avatar
      const welcomeAvatar = document.getElementById('welcomeAvatar');
      const welcomeAvatarContainer = document.getElementById('welcomeAvatarContainer');

      if (localProfile.avatar_url) {
        welcomeAvatar.src = localProfile.avatar_url;
        welcomeAvatarContainer.style.display = 'block';
        welcomeAvatar.onerror = function() {
          this.src = 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png';
        };
      } else {
        // Show default bear avatar if no avatar is set
        welcomeAvatar.src = 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png';
        welcomeAvatarContainer.style.display = 'block';
      }

      // Try to sync with backend (optional)
      try {
        const pointsResponse = await fetch(`${API_BASE_URL}/api/points/${walletAddress}`);
        if (pointsResponse.ok) {
          const pointsData = await pointsResponse.json();
          const totalPoints = pointsData.total_points || 0;
          const raidingPoints = pointsData.raiding_points || 0;
          const gamesPoints = pointsData.games_points || 0;

          welcomePoints.textContent = totalPoints.toFixed(1);
          if (navHoneyPoints) navHoneyPoints.textContent = `${totalPoints.toFixed(1)} PTS`;

          // Update honey points section if it exists
          const totalEl = document.getElementById('totalHoneyPoints');
          const raidingEl = document.getElementById('raidingPoints');
          const gamesEl = document.getElementById('gamesPoints');
          if (totalEl) totalEl.textContent = totalPoints.toFixed(1);
          if (raidingEl) raidingEl.textContent = raidingPoints.toFixed(1) + ' PTS';
          if (gamesEl) gamesEl.textContent = gamesPoints.toFixed(1) + ' PTS';

          // ‚ùå REMOVED localStorage caching - backend is ONLY source of truth
        }
      } catch (error) {
        console.log('[Welcome] Backend not available - using local points');
      }

      // Try to load profile from backend
      try {
        const profileResponse = await fetch(`${API_BASE_URL}/api/profile/${walletAddress}`);
        if (profileResponse.ok) {
          const profileData = await profileResponse.json();
          if (profileData.success && profileData.profile) {
            const profile = profileData.profile;

            // Update username from backend
            if (profile.display_name) {
              welcomeUsername.textContent = `WELCOME ${profile.display_name.toUpperCase()}`;
              // Save to localStorage
              localProfile.display_name = profile.display_name;
              localStorage.setItem(profileKey, JSON.stringify(localProfile));
            }

            // Update avatar from backend
            if (profile.avatar_nft) {
              try {
                const avatarData = JSON.parse(profile.avatar_nft);
                if (avatarData.imageUrl) {
                  welcomeAvatar.src = avatarData.imageUrl;
                  welcomeAvatarContainer.style.display = 'block';
                  localProfile.avatar_url = avatarData.imageUrl;
                  localStorage.setItem(profileKey, JSON.stringify(localProfile));

                  welcomeAvatar.onerror = function() {
                    if (avatarData.fallbackImageUrl && this.src !== avatarData.fallbackImageUrl) {
                      this.src = avatarData.fallbackImageUrl;
                    } else {
                      this.src = 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png';
                    }
                  };
                }
              } catch (e) {
                console.log('[Welcome] Could not parse avatar data');
              }
            }
          }
        }
      } catch (error) {
        console.log('[Welcome] Backend not available - using local profile');
      }

      // Load and apply equipped cosmetics (ring)
      try {
        const cosmeticResponse = await fetch(`${API_BASE_URL}/api/cosmetics/equipped/${walletAddress}`);
        if (cosmeticResponse.ok) {
          const cosmeticData = await cosmeticResponse.json();
          if (cosmeticData.success && cosmeticData.equipped) {
            const equippedRing = cosmeticData.equipped.ring;

            // Remove any existing ring
            const existingRing = welcomeAvatarContainer.querySelector('.welcome-cosmetic-ring');
            if (existingRing) existingRing.remove();

            // Apply ring if equipped
            if (equippedRing && equippedRing.image_url) {
              const ring = document.createElement('img');
              ring.className = `welcome-cosmetic-ring ${equippedRing.ring_type}`;
              ring.src = equippedRing.image_url;
              ring.alt = equippedRing.name;
              ring.style.objectFit = 'contain';
              if (equippedRing.rarity === 'bearableguy123') {
                ring.style.animation = 'spinRingImage 3s linear infinite';
              }
              welcomeAvatarContainer.appendChild(ring);
              console.log('‚úÖ [Welcome] Applied ring:', equippedRing.name, 'ring_type:', equippedRing.ring_type, 'className:', ring.className);
            }
          }
        }
      } catch (error) {
        console.log('[Welcome] Could not load equipped cosmetics');
      }
    }

    // Update welcome button when profile is loaded
    updateWelcomeButton();

    // Refresh welcome button when wallet connects
    window.addEventListener('storage', (e) => {
      if (e.key === 'bearpark_wallet') {
        updateWelcomeButton();
      }
    });

    // ===== LEADERBOARDS =====
    async function loadLeaderboards() {
      const games = [
        { id: 'flappy-bear', elementId: 'leaderboard-flappy' },
        { id: 'bear-slice', elementId: 'leaderboard-slice' },
        { id: 'bear-jumpventure', elementId: 'leaderboard-jumpventure' },
        { id: 'bear-pong', elementId: 'leaderboard-pong' }
      ];

      for (const game of games) {
        try {
          const response = await fetch(`${API_BASE_URL}/api/leaderboard/${game.id}?limit=100`);
          const data = await response.json();

          const container = document.getElementById(game.elementId);
          if (!container) continue;

          if (data.success && data.leaderboard && data.leaderboard.length > 0) {
            // Fetch equipped cosmetics for all users in leaderboard
            const walletAddresses = data.leaderboard.map(e => e.wallet_address);
            const equippedCosmetics = {};

            // Batch fetch equipped items for all users
            await Promise.all(walletAddresses.map(async (wallet) => {
              try {
                const cosmeticRes = await fetch(`${API_BASE_URL}/api/cosmetics/equipped/${wallet}`);
                const cosmeticData = await cosmeticRes.json();
                if (cosmeticData.success && cosmeticData.equipped) {
                  equippedCosmetics[wallet] = cosmeticData.equipped;
                }
              } catch (e) {
                // Ignore errors for individual users
              }
            }));

            container.innerHTML = data.leaderboard.map((entry, index) => {
              const medal = index === 0 ? 'ü•á' : (index === 1 ? 'ü•à' : (index === 2 ? 'ü•â' : ''));
              const rankClass = index === 0 ? 'rank-1' : (index === 1 ? 'rank-2' : (index === 2 ? 'rank-3' : ''));
              const displayName = entry.display_name || 'Anonymous';
              const equippedRing = equippedCosmetics[entry.wallet_address]?.ring;

              // Get avatar URL
              let avatarUrl = 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png';
              if (entry.avatar_nft) {
                try {
                  const avatarData = JSON.parse(entry.avatar_nft);
                  avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl || avatarUrl;
                } catch (e) {
                  avatarUrl = `https://nft.xrpl-labs.com/${entry.avatar_nft}`;
                }
              }

              // Build avatar HTML with ring if equipped
              let avatarHTML = '';
              if (equippedRing && equippedRing.image_url) {
                const spinAnimation = equippedRing.rarity === 'bearableguy123' ? 'animation: spinRingImage 3s linear infinite;' : '';
                const ouroborosRotation = equippedRing.ring_type === 'ouroboros' ? ' rotate(180deg)' : '';

                // Different sizes for different ring types
                const isCastle = equippedRing.ring_type === 'castle' || equippedRing.ring_type === 'castle-static';
                const isOuroboros = equippedRing.ring_type === 'ouroboros';
                const isWaves = equippedRing.ring_type === 'waves' || equippedRing.ring_type === 'waves-static';

                let ringSize, containerSize, ringClass;
                if (isCastle) {
                  ringSize = '72px';
                  containerSize = '72px';
                  ringClass = 'leaderboard-ring-img-castle';
                } else if (isOuroboros) {
                  ringSize = '65px';
                  containerSize = '65px';
                  ringClass = 'leaderboard-ring-img-ouroboros';
                } else if (isWaves) {
                  ringSize = '57px';
                  containerSize = '57px';
                  ringClass = 'leaderboard-ring-img-waves';
                } else {
                  ringSize = '60px';
                  containerSize = '60px';
                  ringClass = 'leaderboard-ring-img';
                }
                const avatarSize = '43px';

                const containerClass = isCastle ? 'castle-ring-container' : (isOuroboros ? 'ouroboros-ring-container' : (isWaves ? 'waves-ring-container' : ''));

                avatarHTML = `
                  <div class="leaderboard-avatar-ring ${containerClass}" style="width:${containerSize}; height:${containerSize}; margin-right:8px; flex-shrink:0; position:relative;">
                    <img src="${avatarUrl}"
                         alt="${displayName} avatar"
                         class="leaderboard-avatar-img"
                         style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:1; width:${avatarSize}; height:${avatarSize}; border-radius:50%; object-fit:cover;"
                         onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png'">
                    <img src="${equippedRing.image_url}"
                         alt="Ring"
                         class="${ringClass}"
                         style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%)${ouroborosRotation}; width:${ringSize}; height:${ringSize}; object-fit:contain; z-index:2; pointer-events:none; ${spinAnimation}">
                  </div>
                `;
              } else {
                avatarHTML = `<img src="${avatarUrl}"
                     class="leaderboard-avatar-simple"
                     style="width:40px; height:40px; border-radius:50%; object-fit:cover; margin-right:8px;"
                     alt="${displayName} avatar"
                     onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png'">`;
              }

              // For BEAR PONG, show weighted score + W/L stats
              let scoreDisplay;
              if (game.id === 'bear-pong') {
                const wins = entry.wins || entry.score || 0;
                const losses = entry.losses || 0;
                const weightedScore = entry.weighted_score || entry.score || 0;
                const winRate = entry.win_rate ? (entry.win_rate * 100).toFixed(0) : '0';

                scoreDisplay = `
                  <div style="text-align:right;">
                    <div style="font-size:16px; font-weight:700; color:var(--gold);">${weightedScore}</div>
                    <div style="font-size:12px; color:#888; margin-top:2px;">${wins}W ${losses}L (${winRate}%)</div>
                  </div>
                `;
              } else {
                scoreDisplay = `${entry.score.toLocaleString()}`;
              }

              return `
                <div class="leaderboard-entry ${rankClass}" onclick="openProfileModal('${entry.wallet_address}')" style="cursor:pointer;">
                  <div class="leaderboard-rank">${medal || `#${index + 1}`}</div>
                  <div class="leaderboard-name" style="display:flex; align-items:center;">
                    ${avatarHTML}
                    <div>
                      ${displayName}
                      ${entry.wallet_address ? `<div class="leaderboard-wallet">${entry.wallet_address.substring(0, 8)}...</div>` : ''}
                    </div>
                  </div>
                  <div class="leaderboard-score">${scoreDisplay}</div>
                </div>
              `;
            }).join('');
          } else {
            container.innerHTML = '<div class="loading">No scores yet! Be the first!</div>';
          }
        } catch (error) {
          console.error(`Error loading ${game.id} leaderboard:`, error);
          const container = document.getElementById(game.elementId);
          if (container) {
            container.innerHTML = '<div class="loading">Unable to load scores</div>';
          }
        }
      }
    }

    // Load leaderboards on page load
    loadLeaderboards();

    // Refresh leaderboards every 30 seconds
    IntervalManager.set('loadLeaderboards', loadLeaderboards, 30000); // Use IntervalManager to prevent memory leaks

    // ===== COMMUNITY BANNER PARALLAX =====
    (function initCommunityParallax() {
      const banner = document.getElementById('communityBanner');
      const bg = document.getElementById('communityBannerBg');

      if (!banner || !bg) return;

      let mouseX = 0;
      let mouseY = 0;
      let currentX = 0;
      let currentY = 0;

      // Mouse parallax
      banner.addEventListener('mousemove', (e) => {
        const rect = banner.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        // Calculate offset from center (-1 to 1)
        mouseX = (e.clientX - centerX) / (rect.width / 2);
        mouseY = (e.clientY - centerY) / (rect.height / 2);
      });

      banner.addEventListener('mouseleave', () => {
        mouseX = 0;
        mouseY = 0;
      });

      // Touch parallax
      let touchActive = false;
      banner.addEventListener('touchmove', (e) => {
        touchActive = true;
        const rect = banner.getBoundingClientRect();
        const touch = e.touches[0];
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        mouseX = (touch.clientX - centerX) / (rect.width / 2);
        mouseY = (touch.clientY - centerY) / (rect.height / 2);
      });

      banner.addEventListener('touchend', () => {
        touchActive = false;
        mouseX = 0;
        mouseY = 0;
      });

      // Smooth animation loop
      function animate() {
        // Smoothly interpolate towards target
        currentX += (mouseX - currentX) * 0.05;
        currentY += (mouseY - currentY) * 0.05;

        // Apply parallax transform (subtle movement)
        const offsetX = currentX * 20; // Max 20px movement
        const offsetY = currentY * 15; // Max 15px movement

        // Maintain center positioning with parallax offset
        bg.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px))`;

        requestAnimationFrame(animate);
      }

      animate();
    })();

    // ===== BEAR FRIENDS =====
    let allCommunityUsers = [];

    async function loadCommunityUsers() {
      const communityUserGrid = document.getElementById('communityUserGrid');
      const communityUserCount = document.getElementById('communityUserCount');

      try {
        const response = await fetch(`${API_BASE_URL}/api/users`);
        if (response.ok) {
          const data = await response.json();
          if (data.success && data.users) {
            // Sort users alphabetically by display_name
            allCommunityUsers = data.users.sort((a, b) => {
              const nameA = (a.display_name || 'Anonymous BEAR').toLowerCase();
              const nameB = (b.display_name || 'Anonymous BEAR').toLowerCase();
              return nameA.localeCompare(nameB);
            });

            communityUserCount.textContent = allCommunityUsers.length;
            renderCommunityUsers(allCommunityUsers);
          }
        }
      } catch (error) {
        console.error('Error loading community users:', error);
        communityUserGrid.innerHTML = `
          <div class="community-empty">
            <div class="community-empty-icon">üòî</div>
            <p>Failed to load community. Please try again later.</p>
          </div>
        `;
      }
    }

    async function renderCommunityUsers(users) {
      const communityUserGrid = document.getElementById('communityUserGrid');
      const currentWallet = localStorage.getItem('bearpark_wallet');

      if (users.length === 0) {
        communityUserGrid.innerHTML = `
          <div class="community-empty">
            <div class="community-empty-icon">üêª</div>
            <p>No BEARs found matching your search.</p>
          </div>
        `;
        return;
      }

      // Fetch follower counts and follow status for each user
      const usersWithCounts = await Promise.all(users.map(async (user) => {
        try {
          // Get follower/following counts
          const countsResponse = await fetch(`${API_BASE_URL}/api/follow/counts/${user.wallet_address}`);
          let followers = 0, following = 0;
          if (countsResponse.ok) {
            const countsData = await countsResponse.json();
            followers = countsData.success ? countsData.followers : 0;
            following = countsData.success ? countsData.following : 0;
          }

          // Get follow status (are we following this user?)
          let isFollowing = false;
          if (currentWallet && currentWallet !== user.wallet_address) {
            const statusResponse = await fetch(`${API_BASE_URL}/api/follow/status?follower_wallet=${currentWallet}&following_wallet=${user.wallet_address}`);
            if (statusResponse.ok) {
              const statusData = await statusResponse.json();
              isFollowing = statusData.success ? statusData.isFollowing : false;
            }
          }

          return { ...user, followers, following, isFollowing };
        } catch (error) {
          console.error('Error fetching data for user:', error);
          return { ...user, followers: 0, following: 0, isFollowing: false };
        }
      }));

      const userCards = usersWithCounts.map(user => {
        const displayName = user.display_name || 'Anonymous BEAR';
        const walletShort = `${user.wallet_address.substring(0, 6)}...${user.wallet_address.substring(user.wallet_address.length - 4)}`;
        const isSelf = currentWallet === user.wallet_address;

        let avatarHTML = '';
        if (user.avatar_nft) {
          try {
            const avatarData = JSON.parse(user.avatar_nft);
            const avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl;
            avatarHTML = `<img src="${avatarUrl}" class="community-user-avatar" alt="${displayName}" onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png'">`;
          } catch (e) {
            avatarHTML = `<img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png" class="community-user-avatar" alt="${displayName}">`;
          }
        } else {
          avatarHTML = `<img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png" class="community-user-avatar" alt="${displayName}">`;
        }

        // Follow button (only show if not viewing own profile and user is logged in)
        let followButtonHTML = '';
        if (!isSelf && currentWallet) {
          const buttonClass = user.isFollowing ? 'community-follow-btn following' : 'community-follow-btn';
          const buttonText = user.isFollowing ? 'Following' : 'Follow';
          followButtonHTML = `<button class="${buttonClass}" data-wallet="${user.wallet_address}" onclick="event.stopPropagation(); toggleCommunityFollow('${user.wallet_address}')">${buttonText}</button>`;
        }

        return `
          <div class="community-user-card" onclick="viewUserProfileFromCommunity('${user.wallet_address}')">
            <div class="community-user-avatar-wrapper">
              ${avatarHTML}
            </div>
            <div class="community-user-info">
              <div class="community-user-name-section">
                <h3 class="community-user-name">${displayName}</h3>
                <p class="community-user-wallet">${walletShort}</p>
              </div>
              <div class="community-user-stats">
                <div class="community-user-stat">
                  <div class="community-user-stat-value" data-wallet="${user.wallet_address}" data-type="followers">${user.followers}</div>
                  <div class="community-user-stat-label">Followers</div>
                </div>
                <div class="community-user-stat">
                  <div class="community-user-stat-value" data-wallet="${user.wallet_address}" data-type="following">${user.following}</div>
                  <div class="community-user-stat-label">Following</div>
                </div>
              </div>
              ${followButtonHTML}
            </div>
          </div>
        `;
      }).join('');

      communityUserGrid.innerHTML = userCards;
    }

    // Toggle follow/unfollow in community view
    let isTogglingCommunityFollow = false; // Guard against multiple simultaneous clicks

    window.toggleCommunityFollow = async function(targetWallet) {
      console.log('üîµ [Community Follow] toggleCommunityFollow called for:', targetWallet);

      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        console.log('‚ùå [Community Follow] No wallet connected');
        alert('Please connect your wallet first!');
        return;
      }

      // Prevent multiple simultaneous operations
      if (isTogglingCommunityFollow) {
        console.log('‚è∏Ô∏è [Community Follow] Already processing a follow/unfollow action');
        return;
      }

      isTogglingCommunityFollow = true;
      console.log('üîµ [Community Follow] Starting follow toggle operation');

      try {
        const response = await fetch(`${API_BASE_URL}/api/follow`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            follower_wallet: currentWallet,
            following_wallet: targetWallet
          })
        });

        console.log('üîµ [Community Follow] Response status:', response.status);

        if (response.ok) {
          const data = await response.json();
          console.log('üîµ [Community Follow] Response data:', data);
          const action = data.action; // 'followed' or 'unfollowed'
          console.log('üîµ [Community Follow] Action:', action);

          // Update the follow button
          const btn = document.querySelector(`.community-follow-btn[data-wallet="${targetWallet}"]`);
          console.log('üîµ [Community Follow] Found button:', btn);
          if (btn) {
            console.log('üîµ [Community Follow] Button classes before:', btn.classList.toString());
            if (action === 'followed') {
              btn.classList.add('following');
              btn.textContent = 'Following';
              console.log('‚úÖ [Community Follow] Updated button to: Following');
            } else {
              btn.classList.remove('following');
              btn.textContent = 'Follow';
              console.log('‚úÖ [Community Follow] Updated button to: Follow');
            }
            console.log('üîµ [Community Follow] Button classes after:', btn.classList.toString());
          } else {
            console.error('‚ùå [Community Follow] Button not found for wallet:', targetWallet);
          }

          // Update the follower count for the target user
          const followerCountEl = document.querySelector(`.community-user-stat-value[data-wallet="${targetWallet}"][data-type="followers"]`);
          if (followerCountEl) {
            let currentCount = parseInt(followerCountEl.textContent) || 0;
            if (action === 'followed') {
              followerCountEl.textContent = currentCount + 1;
            } else {
              followerCountEl.textContent = Math.max(0, currentCount - 1);
            }
          }

          // Update the following count for the current user (if their card is visible)
          const followingCountEl = document.querySelector(`.community-user-stat-value[data-wallet="${currentWallet}"][data-type="following"]`);
          if (followingCountEl) {
            let currentCount = parseInt(followingCountEl.textContent) || 0;
            if (action === 'followed') {
              followingCountEl.textContent = currentCount + 1;
            } else {
              followingCountEl.textContent = Math.max(0, currentCount - 1);
            }
          }

          // SYNC: Also update the profile modal follow button if it's open for this user
          console.log('üîµ [Community Follow Sync] Checking profile modal sync...');
          console.log('üîµ [Community Follow Sync] window.currentProfileWallet:', window.currentProfileWallet);
          console.log('üîµ [Community Follow Sync] targetWallet:', targetWallet);

          const profileFollowBtn = document.getElementById('followBtn');
          console.log('üîµ [Community Follow Sync] Found profile follow button:', !!profileFollowBtn);

          if (profileFollowBtn && window.currentProfileWallet === targetWallet) {
            console.log('üîµ [Community Follow Sync] Wallets match! Syncing profile modal...');
            console.log('üîµ [Community Follow Sync] Button classes before:', profileFollowBtn.className);
            console.log('üîµ [Community Follow Sync] Button text before:', profileFollowBtn.querySelector('.follow-btn-text')?.textContent);

            if (action === 'followed') {
              profileFollowBtn.classList.add('following');
              profileFollowBtn.querySelector('.follow-btn-text').textContent = 'Following';
              profileFollowBtn.querySelector('.follow-btn-icon').textContent = '‚úì';
              console.log('‚úÖ [Community Follow Sync] Set profile button to: Following');
            } else {
              profileFollowBtn.classList.remove('following');
              profileFollowBtn.querySelector('.follow-btn-text').textContent = 'Follow';
              profileFollowBtn.querySelector('.follow-btn-icon').textContent = '+';
              console.log('‚úÖ [Community Follow Sync] Set profile button to: Follow');
            }

            // Mark that we just synced, so loadFollowData doesn't overwrite this
            lastFollowSyncTimestamp = Date.now();
            console.log('üîµ [Community Follow Sync] Set lastFollowSyncTimestamp to prevent database overwrite');

            console.log('üîµ [Community Follow Sync] Button classes after:', profileFollowBtn.className);
            console.log('üîµ [Community Follow Sync] Button text after:', profileFollowBtn.querySelector('.follow-btn-text')?.textContent);

            // Also update the profile modal follower count
            const profileFollowersCount = document.getElementById('followersCount');
            console.log('üîµ [Community Follow Sync] Looking for followersCount element:', !!profileFollowersCount);
            if (profileFollowersCount) {
              let currentCount = parseInt(profileFollowersCount.textContent) || 0;
              console.log('üîµ [Community Follow Sync] Current count:', currentCount, 'Action:', action);
              if (action === 'followed') {
                profileFollowersCount.textContent = currentCount + 1;
              } else {
                profileFollowersCount.textContent = Math.max(0, currentCount - 1);
              }
              console.log('‚úÖ [Community Follow Sync] Updated follower count to:', profileFollowersCount.textContent);
              // Add animation for visual feedback
              profileFollowersCount.style.transform = action === 'followed' ? 'scale(1.3)' : 'scale(0.9)';
              profileFollowersCount.style.color = action === 'followed' ? 'var(--gold)' : '';
              setTimeout(() => {
                profileFollowersCount.style.transform = '';
                profileFollowersCount.style.color = '';
              }, 300);
            } else {
              console.log('‚ö†Ô∏è [Community Follow Sync] followersCount element not found - profile modal may not be open');
            }
          } else {
            console.log('‚è∏Ô∏è [Community Follow Sync] Not syncing - profile modal not open for this user or button not found');
          }
          console.log('‚úÖ [Community Follow] Profile modal sync completed');
        } else {
          console.error('‚ùå [Community Follow] Response not OK:', response.status, response.statusText);
          alert('Failed to update follow status. Please try again.');
        }
      } catch (error) {
        console.error('‚ùå [Community Follow] Error toggling follow:', error);
        alert('Failed to update follow status. Please try again.');
      } finally {
        isTogglingCommunityFollow = false;
        console.log('üîµ [Community Follow] Operation complete, unlocked');
      }
    };

    // Search functionality
    const communitySearchInput = document.getElementById('communitySearchInput');
    if (communitySearchInput) {
      communitySearchInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase().trim();

        if (searchTerm === '') {
          renderCommunityUsers(allCommunityUsers);
        } else {
          const filtered = allCommunityUsers.filter(user => {
            const displayName = (user.display_name || 'Anonymous BEAR').toLowerCase();
            const walletAddress = user.wallet_address.toLowerCase();
            return displayName.includes(searchTerm) || walletAddress.includes(searchTerm);
          });
          renderCommunityUsers(filtered);
        }
      });
    }

    // Function to view user profile from community (opens profile modal)
    window.viewUserProfileFromCommunity = function(wallet) {
      // Open the profile modal with the user's wallet
      if (typeof openProfileModal === 'function') {
        openProfileModal(wallet);
      } else if (typeof window.openProfileModal === 'function') {
        window.openProfileModal(wallet);
      }
    };

    // Load community users on page load
    loadCommunityUsers();

  })();
  </script>

  <!-- Emergency FAB Button Fix -->
  <script>
  (function() {
    // Check if FAB already exists
    if (document.querySelector('.fab-buy')) return;

    console.log('Creating emergency FAB button...');

    // Create FAB button
    const fab = document.createElement('button');
    fab.className = 'fab-buy';
    fab.innerHTML = '<span class="txt"><span style="font-family: \'Luckiest Guy\', cursive; color: #edb723;">BEAR</span> HUB</span>';
    fab.setAttribute('aria-controls', 'buyDrawer');
    fab.setAttribute('aria-expanded', 'false');
    fab.setAttribute('aria-label', 'Open BEAR HUB panel');
    document.body.appendChild(fab);

    // Create scrim
    const scrim = document.createElement('div');
    scrim.className = 'drawer-scrim';
    scrim.hidden = true;
    document.body.appendChild(scrim);

    const drawer = document.getElementById('buyDrawer');
    const closeBtn = drawer ? drawer.querySelector('[data-close-drawer]') : null;

    if (!drawer) {
      console.error('buyDrawer not found!');
      return;
    }

    function openDrawer() {
      drawer.classList.add('open');
      scrim.hidden = false;
      fab.setAttribute('aria-expanded', 'true');
      drawer.setAttribute('aria-hidden', 'false');
      document.body.style.overflow = 'hidden';
    }

    function closeDrawer() {
      drawer.classList.remove('open');
      scrim.hidden = true;
      fab.setAttribute('aria-expanded', 'false');
      drawer.setAttribute('aria-hidden', 'true');
      document.body.style.overflow = '';
    }

    fab.addEventListener('click', openDrawer);
    if (closeBtn) closeBtn.addEventListener('click', closeDrawer);
    scrim.addEventListener('click', closeDrawer);

    console.log('Emergency FAB button created successfully!');
  })();

  // ===== PROFILE MODAL SYSTEM =====
  (function initProfileModal() {
    const profileModal = document.getElementById('profileModal');
    const profilePictureDisplay = document.getElementById('profilePictureDisplay');
    const profilePicturePlaceholder = document.getElementById('profilePicturePlaceholder');
    const profileDisplayName = document.getElementById('profileDisplayName');
    const profileWalletAddress = document.getElementById('profileWalletAddress');
    const bioDisplay = document.getElementById('bioDisplay');
    const bioEditor = document.getElementById('bioEditor');
    const bioTextarea = document.getElementById('bioTextarea');
    const editBioBtn = document.getElementById('editBioBtn');
    const saveBioBtn = document.getElementById('saveBioBtn');
    const cancelBioBtn = document.getElementById('cancelBioBtn');
    const commentsList = document.getElementById('commentsList');
    const commentTextarea = document.getElementById('commentTextarea');
    const postCommentBtn = document.getElementById('postCommentBtn');
    const commentsCount = document.getElementById('commentsCount');
    const bearSearchPanel = document.getElementById('bearSearchPanel');
    const bearSearchInput = document.getElementById('bearSearchInput');
    const bearSearchResults = document.getElementById('bearSearchResults');
    const profileModalTitle = document.getElementById('profileModalTitle');
    const profileModalBody = document.querySelector('.profile-modal-body');

    window.currentProfileWallet = null; // Make it global so community follow can access it
    let currentUserWallet = null;
    let allUsers = [];
    let isSearchMode = false;
    let profileNavigationHistory = []; // Track navigation history for back button
    let lastFollowSyncTimestamp = 0; // Track when we last manually synced the follow button

    // Open Profile Modal
    window.openProfileModal = async function(walletAddress = null, addToHistory = true, options = {}) {
      currentUserWallet = localStorage.getItem('bearpark_wallet');
      if (!currentUserWallet) {
        alert('Please connect your wallet first!');
        return;
      }

      // Add current profile to history before navigating (if there is one and we're adding to history)
      if (addToHistory && window.currentProfileWallet && window.currentProfileWallet !== walletAddress) {
        profileNavigationHistory.push(window.currentProfileWallet);
        updateBackButton();
      }

      // If a wallet address is provided, view that profile; otherwise view own profile
      window.currentProfileWallet = walletAddress || currentUserWallet;
      profileModal.style.display = 'flex';
      setTimeout(() => profileModal.classList.add('visible'), 10);

      // Hide the "Where would you like to go" button when modal opens
      const whereBtn = document.getElementById('whereToGoBtn');
      if (whereBtn) whereBtn.style.display = 'none';

      // Scroll to top of profile modal (unless we're scrolling to a specific comment)
      if (profileModalBody && !options.scrollToCommentId) {
        profileModalBody.scrollTop = 0;
      }

      await loadProfileData();
      await loadComments();
      await loadProfileNFTs();

      // Update back button visibility
      updateBackButton();

      // If a specific comment should be scrolled to, do it after everything loads
      if (options.scrollToCommentId) {
        scrollToComment(options.scrollToCommentId);
      }
    };

    // Close Profile Modal
    window.closeProfileModal = function() {
      profileModal.classList.remove('visible');
      setTimeout(() => {
        profileModal.style.display = 'none';
        // Reset to profile view when closing
        if (isSearchMode) {
          toggleBearSearch();
        }
        // Clear navigation history
        profileNavigationHistory = [];
        updateBackButton();

        // Show the "Where would you like to go" button again
        const whereBtn = document.getElementById('whereToGoBtn');
        if (whereBtn) whereBtn.style.display = '';
      }, 300);
    };

    // Scroll to a specific comment
    function scrollToComment(commentId) {
      console.log('üìç Attempting to scroll to comment:', commentId);
      // Give a small delay to ensure DOM is fully rendered
      setTimeout(() => {
        const commentElement = document.querySelector(`.comment-thread[data-comment-id="${commentId}"]`);
        console.log('üìç Comment element found:', !!commentElement);
        if (commentElement) {
          // Scroll the profile modal body to the comment
          const modalBody = document.querySelector('.profile-modal-body');
          console.log('üìç Modal body found:', !!modalBody);
          if (modalBody) {
            // Calculate position relative to modal body
            const commentPosition = commentElement.offsetTop;
            console.log('üìç Scrolling to position:', commentPosition);
            modalBody.scrollTo({
              top: commentPosition - 100, // Offset for better visibility
              behavior: 'smooth'
            });
          }

          // Add gold glow highlight effect (same as bulletin board)
          commentElement.style.backgroundColor = 'rgba(237, 183, 35, 0.3)';
          commentElement.style.boxShadow = '0 0 20px rgba(237, 183, 35, 0.5)';
          commentElement.style.transition = 'all 0.3s ease';
          setTimeout(() => {
            commentElement.style.backgroundColor = '';
            commentElement.style.boxShadow = '';
          }, 2500);
        } else {
          console.warn('‚ùå Comment not found:', commentId);
          // Log all comment IDs to help debug
          const allComments = document.querySelectorAll('.comment-thread[data-comment-id]');
          console.log('Available comment IDs:', Array.from(allComments).map(c => c.getAttribute('data-comment-id')));
        }
      }, 300);
    }

    // Go Back in Profile Navigation
    window.goBackInProfile = function() {
      if (profileNavigationHistory.length > 0) {
        const previousWallet = profileNavigationHistory.pop();
        // Open previous profile without adding to history
        openProfileModal(previousWallet, false);
      }
    };

    // Update Back Button Visibility
    function updateBackButton() {
      const backBtn = document.getElementById('profileBackBtn');
      if (backBtn) {
        if (profileNavigationHistory.length > 0) {
          backBtn.style.display = 'flex';
        } else {
          backBtn.style.display = 'none';
        }
      }
    }

    // Edit profile from modal - close modal and open BEAR HUB to profile section
    window.editProfileFromModal = function() {
      console.log('üé® Edit profile button clicked!');

      // Close the profile modal
      closeProfileModal();

      // Wait for modal to close, then open profile setup
      setTimeout(() => {
        if (typeof window.openProfileSetup === 'function') {
          console.log('üé® Opening profile setup...');
          window.openProfileSetup();
        } else {
          console.error('‚ùå openProfileSetup function not found');
        }
      }, 350);
    };

    // Toggle BEAR Search
    window.toggleBearSearch = async function() {
      isSearchMode = !isSearchMode;

      if (isSearchMode) {
        // Switch to search mode
        profileModalTitle.textContent = 'BEAR SEARCH';
        profileModalBody.style.display = 'none';
        bearSearchPanel.style.display = 'block';
        bearSearchInput.value = '';

        // Load all users
        await loadAllUsers();
        renderUserList(allUsers);
      } else {
        // Switch back to profile mode - restore proper title
        const currentDisplayName = profileDisplayName.textContent;
        if (window.currentProfileWallet === currentUserWallet) {
          profileModalTitle.textContent = 'MY PROFILE';
        } else {
          profileModalTitle.textContent = `${currentDisplayName.toUpperCase()}'S PROFILE`;
        }
        profileModalBody.style.display = 'block';
        bearSearchPanel.style.display = 'none';
      }
    };

    // Load All Users
    async function loadAllUsers() {
      try {
        const response = await fetch(`${API_BASE_URL}/api/users`);
        if (!response.ok) throw new Error('Failed to load users');

        const data = await response.json();
        allUsers = data.users || [];
      } catch (error) {
        console.error('Error loading users:', error);
        allUsers = [];
      }
    }

    // Render User List
    function renderUserList(users) {
      if (users.length === 0) {
        bearSearchResults.innerHTML = `
          <div class="bear-search-empty">
            <div class="bear-search-empty-icon">üêª</div>
            <p>No BEARs found in the park yet!</p>
          </div>
        `;
        return;
      }

      const userCards = users.map(user => {
        const displayName = user.display_name || 'Anonymous BEAR';
        const friendCount = 0; // Placeholder for now

        let avatarHTML = '';
        if (user.avatar_nft) {
          try {
            const avatarData = JSON.parse(user.avatar_nft);
            const avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl;
            avatarHTML = `<img src="${avatarUrl}" class="bear-user-avatar" alt="${displayName}" onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png'">`;
          } catch (e) {
            avatarHTML = `<img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png" class="bear-user-avatar" alt="${displayName}">`;
          }
        } else {
          avatarHTML = `<img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png" class="bear-user-avatar" alt="${displayName}">`;
        }

        return `
          <div class="bear-user-card" onclick="viewUserProfile('${user.wallet_address}')">
            <div class="bear-user-avatar-container">
              <div class="bear-user-avatar-border"></div>
              ${avatarHTML}
            </div>
            <div class="bear-user-info">
              <h3 class="bear-user-name">${displayName}</h3>
              <p class="bear-user-friends">${friendCount} BEARfriends</p>
            </div>
          </div>
        `;
      }).join('');

      bearSearchResults.innerHTML = userCards;
    }

    // View User Profile from Search
    window.viewUserProfile = async function(walletAddress) {
      // Switch back to profile mode and load the selected user's profile
      isSearchMode = false;
      profileModalBody.style.display = 'block';
      bearSearchPanel.style.display = 'none';

      // Load the selected user's profile (title will be set by loadProfileData)
      window.currentProfileWallet = walletAddress;
      await loadProfileData();
      await loadComments();
      await loadProfileNFTs();
    };

    // Search Input Handler
    bearSearchInput.addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase().trim();

      if (!searchTerm) {
        renderUserList(allUsers);
        return;
      }

      const filteredUsers = allUsers.filter(user => {
        const displayName = (user.display_name || '').toLowerCase();
        const wallet = (user.wallet_address || '').toLowerCase();
        return displayName.includes(searchTerm) || wallet.includes(searchTerm);
      });

      renderUserList(filteredUsers);
    });

    // Load Profile Data
    async function loadProfileData() {
      try {
        const profileKey = `bearpark_profile_${window.currentProfileWallet}`;
        const localProfile = localStorage.getItem(profileKey);
        let profileData = null;

        if (localProfile) {
          try {
            profileData = JSON.parse(localProfile);
          } catch (e) {
            console.error('Error parsing local profile:', e);
          }
        }

        try {
          const response = await fetch(`${API_BASE_URL}/api/profile/${window.currentProfileWallet}`);
          if (response.ok) {
            const data = await response.json();
            if (data.success && data.profile) {
              profileData = data.profile;
            }
          }
        } catch (error) {
          console.log('Backend not available, using local profile');
        }

        if (profileData) {
          const displayName = profileData.display_name || 'Anonymous BEAR';
          profileDisplayName.textContent = displayName;
          profileWalletAddress.textContent = window.currentProfileWallet;

          // Update modal title based on whose profile is being viewed
          if (window.currentProfileWallet === currentUserWallet) {
            profileModalTitle.textContent = 'MY PROFILE';
          } else {
            profileModalTitle.textContent = `${displayName.toUpperCase()}'S PROFILE`;
          }

          // Update NFT Collection header based on whose profile is being viewed
          const nftCollectionHeader = document.getElementById('nftCollectionHeader');
          if (nftCollectionHeader) {
            if (window.currentProfileWallet === currentUserWallet) {
              nftCollectionHeader.textContent = 'üñºÔ∏è My NFT Collection';
            } else {
              nftCollectionHeader.textContent = `üñºÔ∏è ${displayName}'s NFT Collection`;
            }
          }

          let avatarUrl = profileData.avatar_url;

          if (!avatarUrl && profileData.avatar_nft) {
            try {
              const avatarData = JSON.parse(profileData.avatar_nft);
              avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl;
            } catch (e) {
              avatarUrl = `https://nft.xrpl-labs.com/${profileData.avatar_nft}`;
            }
          }

          // If no avatar set, use default bear avatar
          if (!avatarUrl) {
            avatarUrl = 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png';
          }

          profilePictureDisplay.src = avatarUrl;
          profilePictureDisplay.onerror = function() {
            this.src = 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png';
          };
          profilePictureDisplay.classList.add('loaded');
          profilePicturePlaceholder.style.display = 'none';

          if (profileData.bio) {
            bioDisplay.textContent = profileData.bio;
          } else {
            if (window.currentProfileWallet === currentUserWallet) {
              bioDisplay.textContent = 'No bio yet. Click Edit to add one!';
            } else {
              bioDisplay.textContent = 'No bio yet.';
            }
          }

          // Show/hide edit buttons based on ownership
          const editProfilePictureBtn = document.getElementById('editProfilePictureBtn');
          if (window.currentProfileWallet === currentUserWallet) {
            editBioBtn.style.display = 'block';
            if (editProfilePictureBtn) editProfilePictureBtn.style.display = 'flex';
          } else {
            editBioBtn.style.display = 'none';
            if (editProfilePictureBtn) editProfilePictureBtn.style.display = 'none';
          }
        } else {
          profileDisplayName.textContent = 'Anonymous BEAR';
          profileWalletAddress.textContent = window.currentProfileWallet;

          // Update modal title for anonymous profiles
          if (window.currentProfileWallet === currentUserWallet) {
            profileModalTitle.textContent = 'MY PROFILE';
          } else {
            profileModalTitle.textContent = 'ANONYMOUS BEAR\'S PROFILE';
          }

          // Update NFT Collection header for anonymous profiles
          const nftCollectionHeader = document.getElementById('nftCollectionHeader');
          if (nftCollectionHeader) {
            if (window.currentProfileWallet === currentUserWallet) {
              nftCollectionHeader.textContent = 'üñºÔ∏è My NFT Collection';
            } else {
              nftCollectionHeader.textContent = 'üñºÔ∏è Anonymous BEAR\'s NFT Collection';
            }
          }

          // Show/hide edit buttons based on ownership
          const editProfilePictureBtn = document.getElementById('editProfilePictureBtn');
          if (window.currentProfileWallet === currentUserWallet) {
            editBioBtn.style.display = 'block';
            if (editProfilePictureBtn) editProfilePictureBtn.style.display = 'flex';
          } else {
            editBioBtn.style.display = 'none';
            if (editProfilePictureBtn) editProfilePictureBtn.style.display = 'none';
          }
        }
      } catch (error) {
        console.error('Error loading profile:', error);
      }

      // Apply equipped cosmetics to profile
      await applyProfileCosmetics();

      // Load follow counts and button state
      await loadFollowData();
    }

    // Apply equipped cosmetics to the profile modal
    async function applyProfileCosmetics() {
      try {
        const walletAddress = window.currentProfileWallet;
        if (!walletAddress) return;

        console.log('üé® Loading cosmetics for profile:', walletAddress);

        // Fetch equipped cosmetics
        const response = await fetch(`${API_BASE_URL}/api/cosmetics/equipped/${walletAddress}`);
        if (!response.ok) return;

        const data = await response.json();
        if (!data.success || !data.equipped) return;

        const equippedRing = data.equipped.ring;
        const equippedBanner = data.equipped.banner;

        // Apply banner if equipped
        if (equippedBanner && (equippedBanner.css_gradient || equippedBanner.image_url)) {
          const section = document.getElementById('profilePictureSection');
          if (section) {
            // Ensure section allows overflow for ring
            section.style.overflow = 'hidden'; // Changed to hidden for image banners
            section.style.position = 'relative';

            // Remove any existing banner image
            const existingBannerImg = section.querySelector('.profile-banner-image');
            if (existingBannerImg) existingBannerImg.remove();

            // Remove any existing banner overlay
            const existingOverlay = section.querySelector('.profile-banner-overlay');
            if (existingOverlay) existingOverlay.remove();

            // Apply image-based banner (legendary and bearableguy123)
            if (equippedBanner.image_url) {
              // Create image element
              const bannerImg = document.createElement('img');
              bannerImg.className = 'profile-banner-image';
              bannerImg.src = equippedBanner.image_url;
              bannerImg.alt = equippedBanner.name;

              // Add panning animation for bearableguy123 rarity
              if (equippedBanner.rarity === 'bearableguy123') {
                bannerImg.style.cssText = `
                  position: absolute;
                  top: 50%;
                  left: 50%;
                  width: 140%;
                  height: 140%;
                  min-width: 140%;
                  min-height: 140%;
                  object-fit: cover;
                  z-index: 0;
                  will-change: transform;
                  animation: profile-banner-pan 60s ease-in-out infinite;
                  transform: translate(-50%, -50%);
                `;
              } else {
                // Static centered banner for legendary
                bannerImg.style.cssText = `
                  position: absolute;
                  top: 50%;
                  left: 50%;
                  width: 100%;
                  height: 100%;
                  min-width: 100%;
                  min-height: 100%;
                  object-fit: cover;
                  z-index: 0;
                  transform: translate(-50%, -50%);
                `;
              }

              section.insertBefore(bannerImg, section.firstChild);

              // Add darkness overlay for text readability
              const overlay = document.createElement('div');
              overlay.className = 'profile-banner-overlay';
              overlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: radial-gradient(circle at center, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.6) 100%);
                z-index: 1;
                pointer-events: none;
              `;
              section.insertBefore(overlay, bannerImg.nextSibling);

              // Set section background to preserve gradient border
              section.style.backgroundImage = 'linear-gradient(#000, #000), linear-gradient(135deg, #8b5cf6, #22c55e, #edb723, #8b5cf6)';
              section.style.backgroundOrigin = 'padding-box, border-box';
              section.style.backgroundClip = 'padding-box, border-box';

              // Ensure content is above the overlay
              const container = document.getElementById('profilePictureContainer');
              const infoHeader = section.querySelector('.profile-info-header');
              const editBtn = document.getElementById('editProfilePictureBtn');
              if (container) container.style.position = 'relative';
              if (container) container.style.zIndex = '2';
              if (infoHeader) infoHeader.style.position = 'relative';
              if (infoHeader) infoHeader.style.zIndex = '2';
              if (editBtn) editBtn.style.zIndex = '10';

              console.log(`‚úÖ Applied ${equippedBanner.rarity} banner:`, equippedBanner.name);
            }
            // Apply CSS gradient banner (common, rare, epic)
            else if (equippedBanner.css_gradient) {
              section.style.backgroundImage = `${equippedBanner.css_gradient}, linear-gradient(135deg, #8b5cf6, #22c55e, #edb723, #8b5cf6)`;
              section.style.backgroundOrigin = 'padding-box, border-box';
              section.style.backgroundClip = 'padding-box, border-box';
              console.log('‚úÖ Applied gradient banner:', equippedBanner.name);
            }
          }
        } else {
          // Reset to default if no banner
          const section = document.getElementById('profilePictureSection');
          if (section) {
            // Remove any existing banner image and overlay
            const existingBannerImg = section.querySelector('.profile-banner-image');
            if (existingBannerImg) existingBannerImg.remove();
            const existingOverlay = section.querySelector('.profile-banner-overlay');
            if (existingOverlay) existingOverlay.remove();

            // Ensure section allows overflow for ring
            section.style.overflow = 'visible';
            section.style.backgroundImage = 'linear-gradient(#141619, #141619), linear-gradient(135deg, #8b5cf6, #22c55e, #edb723, #8b5cf6)';
            section.style.backgroundOrigin = 'padding-box, border-box';
            section.style.backgroundClip = 'padding-box, border-box';
          }
        }

        // Apply ring if equipped
        if (equippedRing && equippedRing.image_url) {
          const container = document.getElementById('profilePictureContainer');
          if (container) {
            // Ensure container allows ring to overflow
            container.style.overflow = 'visible';

            // Remove any existing ring
            const existingRing = container.querySelector('.profile-cosmetic-ring');
            if (existingRing) existingRing.remove();

            // Create ring element
            const ring = document.createElement('img');
            ring.className = `profile-cosmetic-ring ${equippedRing.ring_type}`;
            ring.src = equippedRing.image_url;
            ring.alt = equippedRing.name;

            // Castle ring gets special size (210px), all others are 180px
            const isCastleRing = equippedRing.ring_type === 'castle' || equippedRing.ring_type === 'castle-static';
            const ringSize = isCastleRing ? '210px' : '180px';

            ring.style.cssText = `
              position: absolute;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%) ${equippedRing.ring_type === 'ouroboros' ? 'rotate(180deg)' : ''};
              width: ${ringSize} !important;
              height: ${ringSize} !important;
              max-width: ${ringSize} !important;
              max-height: ${ringSize} !important;
              object-fit: contain;
              pointer-events: none;
              z-index: 1;
              ${equippedRing.rarity === 'bearableguy123' ? 'animation: spinRingImage 3s linear infinite;' : ''}
            `;

            container.appendChild(ring);
            console.log('‚úÖ Applied ring:', equippedRing.name);
          }
        } else {
          // Remove ring if none equipped
          const container = document.getElementById('profilePictureContainer');
          if (container) {
            const existingRing = container.querySelector('.profile-cosmetic-ring');
            if (existingRing) existingRing.remove();
          }
        }

      } catch (error) {
        console.error('‚ùå Error applying profile cosmetics:', error);
      }
    }

    // Follow System Functions
    async function loadFollowData() {
      try {
        // Load follower/following counts
        const countsResponse = await fetch(`${API_BASE_URL}/api/follow/counts/${window.currentProfileWallet}`);
        if (countsResponse.ok) {
          const countsData = await countsResponse.json();
          if (countsData.success) {
            document.getElementById('followersCount').textContent = countsData.followers;
            document.getElementById('followingCount').textContent = countsData.following;
          }
        }

        // Show/hide follow button and check follow status
        const followBtn = document.getElementById('followBtn');
        if (window.currentProfileWallet === currentUserWallet) {
          // Don't show follow button on own profile
          followBtn.style.display = 'none';
        } else {
          followBtn.style.display = 'flex';

          // Check if we recently synced the button manually (within last 2 seconds)
          const timeSinceLastSync = Date.now() - lastFollowSyncTimestamp;
          if (timeSinceLastSync < 2000) {
            console.log(`‚è∏Ô∏è [LoadFollowData] Skipping database check - button was manually synced ${timeSinceLastSync}ms ago`);
            return;
          }

          // CHECK COMMUNITY LIST BUTTON FIRST - it's the source of truth!
          const communityBtn = document.querySelector(`.community-follow-btn[data-wallet="${window.currentProfileWallet}"]`);
          if (communityBtn) {
            const communityBtnIsFollowing = communityBtn.classList.contains('following');
            console.log('üîµ [LoadFollowData] Found community button:', communityBtnIsFollowing ? 'Following' : 'Follow');

            // Use community button state as source of truth
            if (communityBtnIsFollowing) {
              followBtn.classList.add('following');
              followBtn.querySelector('.follow-btn-text').textContent = 'Following';
              followBtn.querySelector('.follow-btn-icon').textContent = '‚úì';
              console.log('‚úÖ [LoadFollowData] Synced from community button: Following');
            } else {
              followBtn.classList.remove('following');
              followBtn.querySelector('.follow-btn-text').textContent = 'Follow';
              followBtn.querySelector('.follow-btn-icon').textContent = '+';
              console.log('‚úÖ [LoadFollowData] Synced from community button: Follow');
            }
            return; // Don't check database if community button exists
          }

          // Only check database if community button doesn't exist
          console.log('üîµ [LoadFollowData] No community button found, checking database for:', window.currentProfileWallet);
          const statusResponse = await fetch(
            `${API_BASE_URL}/api/follow/status?follower_wallet=${currentUserWallet}&following_wallet=${window.currentProfileWallet}`
          );
          console.log('üîµ [LoadFollowData] Status response:', statusResponse.status);
          if (statusResponse.ok) {
            const statusData = await statusResponse.json();
            console.log('üîµ [LoadFollowData] Status data:', statusData);
            console.log('üîµ [LoadFollowData] isFollowing:', statusData.isFollowing);
            if (statusData.success && statusData.isFollowing) {
              followBtn.classList.add('following');
              followBtn.querySelector('.follow-btn-text').textContent = 'Following';
              followBtn.querySelector('.follow-btn-icon').textContent = '‚úì';
              console.log('‚úÖ [LoadFollowData] Set button to: Following');
            } else {
              followBtn.classList.remove('following');
              followBtn.querySelector('.follow-btn-text').textContent = 'Follow';
              followBtn.querySelector('.follow-btn-icon').textContent = '+';
              console.log('‚úÖ [LoadFollowData] Set button to: Follow');
            }
          }
        }
      } catch (error) {
        console.error('Error loading follow data:', error);
      }
    }

    // Make follow functions global
    let isTogglingFollow = false; // Guard against multiple simultaneous clicks

    window.toggleFollow = async function() {
      console.log('üîµ [Follow] toggleFollow called');
      console.log('üîµ [Follow] currentUserWallet:', currentUserWallet);
      console.log('üîµ [Follow] window.currentProfileWallet:', window.currentProfileWallet);

      if (!currentUserWallet || !window.currentProfileWallet) {
        console.log('‚ùå [Follow] Missing wallet addresses');
        return;
      }
      if (currentUserWallet === window.currentProfileWallet) {
        console.log('‚ùå [Follow] Cannot follow yourself');
        return;
      }

      // Prevent multiple simultaneous operations
      if (isTogglingFollow) {
        console.log('‚è∏Ô∏è [Follow] Already processing a follow/unfollow action');
        return;
      }

      const followBtn = document.getElementById('followBtn');
      const isFollowing = followBtn.classList.contains('following');
      console.log('üîµ [Follow] Current state - isFollowing:', isFollowing);

      // Set the guard flag
      isTogglingFollow = true;

      // Disable button and show loading state
      followBtn.disabled = true;
      const btnText = followBtn.querySelector('.follow-btn-text');
      const btnIcon = followBtn.querySelector('.follow-btn-icon');

      // Show brief loading animation
      btnText.textContent = 'Loading';
      btnIcon.textContent = '‚è≥';
      followBtn.style.opacity = '0.7';
      followBtn.style.transform = 'scale(0.95)';

      // Get follower count element
      const followersCountEl = document.getElementById('followersCount');
      const currentCount = parseInt(followersCountEl.textContent) || 0;

      // Wait 200ms for loading feedback, then optimistically update UI
      await new Promise(resolve => setTimeout(resolve, 200));

      // Optimistically update UI immediately for instant feedback
      if (!isFollowing) {
        // Show as following immediately
        followBtn.style.transform = 'scale(1.1)';
        followBtn.classList.add('following');
        btnText.textContent = 'Following';
        btnIcon.textContent = '‚úì';

        // Add success ripple effect
        const ripple = document.createElement('div');
        ripple.style.cssText = 'position:absolute;top:50%;left:50%;width:100%;height:100%;border-radius:50px;background:rgba(7,174,8,0.4);transform:translate(-50%,-50%) scale(0);pointer-events:none;z-index:100;';
        followBtn.style.position = 'relative';
        followBtn.appendChild(ripple);

        // Animate ripple
        ripple.animate([
          { transform: 'translate(-50%, -50%) scale(0)', opacity: 1 },
          { transform: 'translate(-50%, -50%) scale(2.5)', opacity: 0 }
        ], {
          duration: 600,
          easing: 'ease-out'
        }).onfinish = () => ripple.remove();

        // Update count
        followersCountEl.textContent = currentCount + 1;
        followersCountEl.style.transform = 'scale(1.3)';
        followersCountEl.style.color = 'var(--gold)';
        setTimeout(() => {
          followersCountEl.style.transform = '';
          followersCountEl.style.color = '';
        }, 300);
      } else {
        // Show as unfollowed immediately
        followBtn.style.transform = 'scale(1.05)';
        followBtn.classList.remove('following');
        btnText.textContent = 'Follow';
        btnIcon.textContent = '+';

        // Update count
        followersCountEl.textContent = Math.max(0, currentCount - 1);
        followersCountEl.style.transform = 'scale(0.9)';
        setTimeout(() => {
          followersCountEl.style.transform = '';
        }, 300);
      }

      // Reset transform after animation
      setTimeout(() => {
        followBtn.style.transform = '';
      }, 200);

      // Now send to backend (fire and forget - UI already updated)
      try {
        const response = await fetch(`${API_BASE_URL}/api/follow`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            follower_wallet: currentUserWallet,
            following_wallet: window.currentProfileWallet
          })
        });

        console.log('üîµ [Follow] Response status:', response.status);
        if (response.ok) {
          const data = await response.json();
          console.log('üîµ [Follow] Response data:', data);

          // Verify backend agrees with our optimistic update
          if (data.success) {
            if (data.action === 'followed') {
              console.log('‚úÖ [Follow] Backend confirmed: followed');
            } else if (data.action === 'unfollowed') {
              console.log('‚úÖ [Follow] Backend confirmed: unfollowed');
            }

            // SYNC: Also update the community list follow button if it exists
            const communityBtn = document.querySelector(`.community-follow-btn[data-wallet="${window.currentProfileWallet}"]`);
            if (communityBtn) {
              if (data.action === 'followed') {
                communityBtn.classList.add('following');
                communityBtn.textContent = 'Following';
              } else {
                communityBtn.classList.remove('following');
                communityBtn.textContent = 'Follow';
              }
            }

            // Also update the community list follower count
            const communityFollowerCount = document.querySelector(`.community-user-stat-value[data-wallet="${window.currentProfileWallet}"][data-type="followers"]`);
            if (communityFollowerCount) {
              let currentCount = parseInt(communityFollowerCount.textContent) || 0;
              if (data.action === 'followed') {
                communityFollowerCount.textContent = currentCount + 1;
              } else {
                communityFollowerCount.textContent = Math.max(0, currentCount - 1);
              }
            }
          } else {
            console.warn('‚ö†Ô∏è [Follow] Backend returned success:false, but UI already updated');
          }
        } else {
          console.error('‚ùå [Follow] Response not OK:', response.status, response.statusText);
          // Could revert UI here if needed, but for now trust the optimistic update
        }
      } catch (error) {
        console.error('‚ùå [Follow] Error toggling follow:', error);
        // Could revert UI here if needed, but for now trust the optimistic update
      } finally {
        // Always re-enable the button and clear the guard flag
        followBtn.disabled = false;
        followBtn.style.opacity = '';
        isTogglingFollow = false;
        console.log('üîµ [Follow] Operation complete, button re-enabled');
      }
    };

    window.showFollowersList = async function(event) {
      if (event) event.stopPropagation();
      if (!window.currentProfileWallet) return;

      // Store current button state to preserve it
      const followBtn = document.getElementById('followBtn');
      const wasFollowing = followBtn ? followBtn.classList.contains('following') : false;

      try {
        const response = await fetch(`${API_BASE_URL}/api/follow/followers/${window.currentProfileWallet}`);
        if (response.ok) {
          const data = await response.json();
          if (data.success) {
            showFollowListModal('Followers', data.followers, 'follower_wallet');

            // Restore button state after modal is shown
            if (followBtn && wasFollowing) {
              setTimeout(() => {
                followBtn.classList.add('following');
              }, 0);
            }
          }
        }
      } catch (error) {
        console.error('Error loading followers:', error);
      }
    };

    window.showFollowingList = async function(event) {
      if (event) event.stopPropagation();
      if (!window.currentProfileWallet) return;

      // Store current button state to preserve it
      const followBtn = document.getElementById('followBtn');
      const wasFollowing = followBtn ? followBtn.classList.contains('following') : false;

      try {
        const response = await fetch(`${API_BASE_URL}/api/follow/following/${window.currentProfileWallet}`);
        if (response.ok) {
          const data = await response.json();
          if (data.success) {
            showFollowListModal('Following', data.following, 'following_wallet');

            // Restore button state after modal is shown
            if (followBtn && wasFollowing) {
              setTimeout(() => {
                followBtn.classList.add('following');
              }, 0);
            }
          }
        }
      } catch (error) {
        console.error('Error loading following:', error);
      }
    };

    function showFollowListModal(title, users, walletKey) {
      // Create modal HTML
      const modalHTML = `
        <div class="follow-list-modal-overlay" onclick="closeFollowListModal()">
          <div class="follow-list-modal" onclick="event.stopPropagation()">
            <div class="follow-list-header">
              <h3>${title}</h3>
              <button class="follow-list-close" onclick="closeFollowListModal()">&times;</button>
            </div>
            <div class="follow-list-body">
              ${users.length === 0 ? `
                <div class="follow-list-empty">
                  <p>No ${title.toLowerCase()} yet!</p>
                </div>
              ` : users.map(user => {
                const displayName = user.display_name || 'Anonymous BEAR';
                const wallet = user[walletKey];
                let avatarHTML = '';

                if (user.avatar_nft) {
                  try {
                    const avatarData = JSON.parse(user.avatar_nft);
                    const avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl;
                    avatarHTML = `<img src="${avatarUrl}" class="follow-list-avatar" alt="${displayName}" onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png'">`;
                  } catch (e) {
                    avatarHTML = `<img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png" class="follow-list-avatar" alt="${displayName}">`;
                  }
                } else {
                  avatarHTML = `<img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png" class="follow-list-avatar" alt="${displayName}">`;
                }

                return `
                  <div class="follow-list-item" onclick="viewUserProfile('${wallet}')">
                    <div class="follow-list-avatar-container">
                      ${avatarHTML}
                    </div>
                    <div class="follow-list-info">
                      <h4 class="follow-list-name">${displayName}</h4>
                      <p class="follow-list-wallet">${wallet.substring(0, 8)}...${wallet.substring(wallet.length - 6)}</p>
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        </div>
      `;

      // Append to body
      document.body.insertAdjacentHTML('beforeend', modalHTML);
    }

    window.closeFollowListModal = function() {
      const modal = document.querySelector('.follow-list-modal-overlay');
      if (modal) {
        modal.remove();
      }
    };

    editBioBtn.addEventListener('click', () => {
      bioDisplay.style.display = 'none';
      bioEditor.style.display = 'block';
      bioTextarea.value = bioDisplay.textContent === 'No bio yet. Click Edit to add one!' ? '' : bioDisplay.textContent;
      bioTextarea.focus();
    });

    cancelBioBtn.addEventListener('click', () => {
      bioEditor.style.display = 'none';
      bioDisplay.style.display = 'block';
    });

    saveBioBtn.addEventListener('click', async () => {
      const bio = bioTextarea.value.trim();

      try {
        const response = await fetch(`${API_BASE_URL}/api/profile/bio`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet_address: currentUserWallet,
            bio: bio
          })
        });

        if (response.ok) {
          bioDisplay.textContent = bio || 'No bio yet. Click Edit to add one!';
          bioEditor.style.display = 'none';
          bioDisplay.style.display = 'block';

          const profileKey = `bearpark_profile_${currentUserWallet}`;
          const localProfile = JSON.parse(localStorage.getItem(profileKey) || '{}');
          localProfile.bio = bio;
          localStorage.setItem(profileKey, JSON.stringify(localProfile));

          alert('Bio updated successfully! üêª');
        } else {
          alert('Failed to update bio. Please try again.');
        }
      } catch (error) {
        console.error('Error saving bio:', error);
        alert('Error updating bio. Please try again.');
      }
    });

    async function loadComments() {
      try {
        console.log('üîÑ [LoadComments] Fetching comments for:', window.currentProfileWallet);
        const response = await fetch(`${API_BASE_URL}/api/comments/${window.currentProfileWallet}`);
        if (!response.ok) throw new Error('Failed to load comments');

        const data = await response.json();
        console.log(`‚úÖ [LoadComments] Received ${data.comments?.length || 0} comments`);
        await displayComments(data.comments || []);
        console.log('‚úÖ [LoadComments] Comments displayed');
      } catch (error) {
        console.error('‚ùå [LoadComments] Error loading comments:', error);
        commentsList.innerHTML = '<div class="comments-empty">Unable to load comments. Please try again later.</div>';
      }
    }

    // Build nested comment tree from flat array
    function buildCommentTree(comments) {
      const commentMap = {};
      const rootComments = [];

      // First pass: create map of all comments
      comments.forEach(comment => {
        commentMap[comment.id] = { ...comment, children: [] };
      });

      // Second pass: build tree structure
      comments.forEach(comment => {
        if (comment.parent_id && commentMap[comment.parent_id]) {
          commentMap[comment.parent_id].children.push(commentMap[comment.id]);
        } else {
          rootComments.push(commentMap[comment.id]);
        }
      });

      return rootComments;
    }

    // Render a single comment with its replies
    async function renderComment(comment, depth = 0, parentName = null) {
      const maxDepth = 8;
      const isOwner = comment.commenter_wallet === currentUserWallet || comment.profile_wallet === currentUserWallet;
      const timeAgo = getTimeAgo(comment.created_at);
      const hasReplies = comment.children && comment.children.length > 0;
      const replyCount = hasReplies ? comment.children.length : 0;

      let avatarHTML = '';
      if (comment.commenter_avatar) {
        try {
          const avatarData = JSON.parse(comment.commenter_avatar);
          const avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl;
          avatarHTML = `<img src="${avatarUrl}" class="comment-avatar" alt="${comment.commenter_name}" onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png';">`;
        } catch (e) {
          avatarHTML = `<img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png" class="comment-avatar" alt="${comment.commenter_name}">`;
        }
      } else {
        avatarHTML = `<img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png" class="comment-avatar" alt="${comment.commenter_name}">`;
      }

      // Load reactions
      const reactions = await loadCommentReactions(comment.id);
      const userReactions = reactions.userReactions?.[currentUserWallet] || [];
      const hasReacted = userReactions.length > 0;

      // Reply indicator for nested comments
      let replyIndicator = '';
      if (depth > 0 && parentName) {
        replyIndicator = `<div class="reply-indicator">
          <span class="reply-arrow">‚Ü©</span>
          <span class="reply-to-text">Replying to <span class="reply-to-name">@${parentName}</span></span>
        </div>`;
      }

      const commentHTML = `
        <div class="comment-thread ${depth > 0 ? 'is-reply' : ''}" data-comment-id="${comment.id}" data-depth="${depth}">
          <div class="comment-item">
            ${hasReplies ? `<button class="thread-toggle" onclick="toggleThread(${comment.id})" aria-label="Toggle replies">
              <span class="toggle-icon">‚ñº</span>
            </button>` : '<div class="thread-spacer"></div>'}
            <div class="comment-content">
              ${replyIndicator}
              <div class="comment-header">
                <div class="comment-author-clickable" onclick="openProfileModal('${comment.commenter_wallet}')" style="cursor: pointer; display: flex; align-items: center; gap: 12px; flex: 1;">
                  ${avatarHTML}
                  <div class="comment-author-info">
                    <p class="comment-author-name">${comment.commenter_name || 'Anonymous'}</p>
                    <p class="comment-timestamp">${timeAgo}${hasReplies ? `<span class="reply-count">${replyCount} ${replyCount === 1 ? 'reply' : 'replies'}</span>` : ''}</p>
                  </div>
                </div>
                ${isOwner ? `<button class="comment-delete-btn" data-comment-id="${comment.id}">Delete</button>` : ''}
              </div>
              <p class="comment-text">${escapeHtml(comment.comment_text)}</p>
              ${generateReactionSummary(comment.id, reactions, userReactions)}
              <div class="comment-actions">
                <button class="like-button ${hasReacted ? 'reacted' : ''}" data-comment-id="${comment.id}">
                  <span class="like-emoji">üëç</span>
                  <span>Like</span>
                  ${generateReactionPicker(comment.id)}
                </button>
                <button class="reply-button" data-comment-id="${comment.id}" onclick="openReplyBox(${comment.id})">
                  <span class="reply-icon">üí¨</span>
                  <span>Reply</span>
                </button>
              </div>
            </div>
          </div>
          ${hasReplies ? `<div class="comment-replies" data-parent-id="${comment.id}"></div>` : ''}
        </div>
      `;

      return commentHTML;
    }

    // Recursively render replies
    async function renderReplies(replies, parentId, depth, parentComment = null) {
      const maxDepth = 8;
      const repliesContainer = document.querySelector(`.comment-replies[data-parent-id="${parentId}"]`);
      if (!repliesContainer) return;

      for (const reply of replies) {
        const parentName = parentComment ? (parentComment.commenter_name || 'Anonymous') : 'a bear';
        const replyHTML = await renderComment(reply, depth, parentName);
        repliesContainer.insertAdjacentHTML('beforeend', replyHTML);

        // Render nested replies
        if (reply.children && reply.children.length > 0 && depth < maxDepth) {
          await renderReplies(reply.children, reply.id, depth + 1, reply);
        }
      }
    }

    // Toggle collapse/expand thread
    window.toggleThread = function(commentId) {
      const threadElement = document.querySelector(`.comment-thread[data-comment-id="${commentId}"]`);
      if (!threadElement) return;

      const repliesContainer = threadElement.querySelector('.comment-replies');
      const toggleIcon = threadElement.querySelector('.toggle-icon');

      if (!repliesContainer) return;

      if (repliesContainer.style.display === 'none') {
        repliesContainer.style.display = 'block';
        toggleIcon.textContent = '‚ñº';
        threadElement.classList.remove('collapsed');
      } else {
        repliesContainer.style.display = 'none';
        toggleIcon.textContent = '‚ñ∂';
        threadElement.classList.add('collapsed');
      }
    };

    // Main display function with Reddit-style threading
    async function displayComments(comments) {
      const totalCount = comments.length;
      commentsCount.textContent = totalCount;

      console.log('üîç [DisplayComments] Received comments:', comments.map(c => c.id));

      if (totalCount === 0) {
        commentsList.innerHTML = '<div class="comments-empty">No comments yet. Be the first to comment!</div>';
        return;
      }

      console.log('üßπ [DisplayComments] Clearing commentsList innerHTML');
      commentsList.innerHTML = '';

      // Build nested comment tree
      const commentTree = buildCommentTree(comments);
      console.log('üå≥ [DisplayComments] Built comment tree with root comments:', commentTree.map(c => c.id));

      // Render root comments
      for (const comment of commentTree) {
        console.log('üé® [DisplayComments] Rendering comment:', comment.id);
        const commentHTML = await renderComment(comment, 0);
        commentsList.insertAdjacentHTML('beforeend', commentHTML);

        // Render replies recursively
        if (comment.children && comment.children.length > 0) {
          await renderReplies(comment.children, comment.id, 1, comment);
        }
      }

      console.log('‚úÖ [DisplayComments] Finished rendering. DOM should now have', commentTree.length, 'root comments');

      // Debug: Check what's actually in the DOM
      const renderedComments = commentsList.querySelectorAll('.comment-thread');
      console.log('üîç [DisplayComments] DOM contains', renderedComments.length, 'comment elements');
      const renderedIds = Array.from(renderedComments).map(el => {
        const deleteBtn = el.querySelector('.comment-delete-btn');
        return deleteBtn ? deleteBtn.getAttribute('data-comment-id') : 'no-id';
      });
      console.log('üîç [DisplayComments] Comment IDs in DOM:', renderedIds);

      // Event listeners are now attached once via event delegation - no need to re-attach
      // attachLikeButtonListeners(); // REMOVED - causes duplicate listeners
    }

    async function loadCommentReactions(commentId) {
      try {
        const response = await fetch(`${API_BASE_URL}/api/comments/${commentId}/reactions`);
        if (!response.ok) return { counts: {}, userReactions: {} };

        const data = await response.json();
        return data;
      } catch (error) {
        console.error('Error loading reactions:', error);
        return { counts: {}, userReactions: {} };
      }
    }

    function generateReactionSummary(commentId, reactions, userReactions = []) {
      const counts = reactions.counts || {};
      const hasCounts = Object.keys(counts).some(key => counts[key] > 0);

      if (!hasCounts) return '';

      const reactionTypes = [
        { type: 'like', emoji: 'üëç' },
        { type: 'laugh', emoji: 'üòÇ' },
        { type: 'heart', emoji: '‚ù§Ô∏è' },
        { type: 'cry', emoji: 'üò¢' },
        { type: 'thumbs_down', emoji: 'üëé' },
        { type: 'troll', emoji: 'ü§°' }
      ];

      const pills = reactionTypes
        .filter(({ type }) => counts[type] > 0)
        .map(({ type, emoji }) => {
          const isUserReaction = userReactions.includes(type);
          // If user already reacted, clicking removes it. Otherwise, clicking adds it.
          const clickHandler = isUserReaction
            ? `removeReaction(${commentId}, '${type}', this)`
            : `toggleReaction(${commentId}, '${type}')`;
          return `
            <div class="reaction-pill ${isUserReaction ? 'user-reacted' : ''}"
                 data-comment-id="${commentId}"
                 data-reaction-type="${type}"
                 onclick="${clickHandler}">
              <span class="pill-emoji">${emoji}</span>
              <span class="pill-count">${counts[type]}</span>
            </div>
          `;
        }).join('');

      return `<div class="reaction-summary">${pills}</div>`;
    }

    function generateReactionPicker(commentId) {
      const reactionTypes = [
        { type: 'like', emoji: 'üëç', label: 'Like' },
        { type: 'laugh', emoji: 'üòÇ', label: 'Laugh' },
        { type: 'heart', emoji: '‚ù§Ô∏è', label: 'Love' },
        { type: 'cry', emoji: 'üò¢', label: 'Sad' },
        { type: 'thumbs_down', emoji: 'üëé', label: 'Dislike' },
        { type: 'troll', emoji: 'ü§°', label: 'Troll' }
      ];

      const items = reactionTypes.map(({ type, emoji, label }) => `
        <div class="reaction-picker-item" data-reaction-type="${type}" data-label="${label}">
          ${emoji}
        </div>
      `).join('');

      return `<div class="reaction-picker" data-comment-id="${commentId}">${items}</div>`;
    }

    // Event delegation for like buttons - attach once, works forever
    // State storage for each button's picker state
    const buttonStates = new Map();

    function getButtonState(btn) {
      if (!buttonStates.has(btn)) {
        buttonStates.set(btn, {
          longPressTimer: null,
          picker: null,
          currentHoveredItem: null,
          selectedReaction: null,
          pickerShown: false
        });
      }
      return buttonStates.get(btn);
    }

    function showPicker(btn) {
      const state = getButtonState(btn);
      state.picker = btn.querySelector('.reaction-picker');
      if (state.picker) {
        state.picker.classList.add('visible');
        state.pickerShown = true;
        if (navigator.vibrate) navigator.vibrate(10);
      }
    }

    function hidePicker(btn) {
      const state = getButtonState(btn);
      if (state.picker) {
        state.picker.classList.remove('visible');
        state.pickerShown = false;
        const items = state.picker.querySelectorAll('.reaction-picker-item');
        items.forEach(item => { item.style.transform = ''; });
      }
    }

    function getEmojiAtTouch(picker, touch) {
      const pickerItems = picker?.querySelectorAll('.reaction-picker-item');
      if (!pickerItems) return null;

      for (const item of pickerItems) {
        const rect = item.getBoundingClientRect();
        if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
            touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
          return item;
        }
      }
      return null;
    }

    function updateHoveredEmoji(btn, touch) {
      const state = getButtonState(btn);
      if (!state.picker || !state.pickerShown) return;

      const hoveredItem = getEmojiAtTouch(state.picker, touch);

      if (hoveredItem !== state.currentHoveredItem) {
        if (state.currentHoveredItem) {
          state.currentHoveredItem.style.transform = '';
        }
        if (hoveredItem) {
          hoveredItem.style.transform = 'scale(1.8) translateY(-12px)';
          hoveredItem.style.filter = 'drop-shadow(0 8px 20px rgba(237,183,35,0.8))';
          if (navigator.vibrate) navigator.vibrate(5);
          state.selectedReaction = hoveredItem.getAttribute('data-reaction-type');
        } else {
          state.selectedReaction = null;
        }
        state.currentHoveredItem = hoveredItem;
      }
    }

    // Attach event listeners ONCE to commentsList using delegation
    if (commentsList && !commentsList.dataset.likeListenersAttached) {
      commentsList.dataset.likeListenersAttached = 'true';

      // Mousedown - start long press timer
      commentsList.addEventListener('mousedown', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getButtonState(btn);
        state.longPressTimer = setTimeout(() => showPicker(btn), 300);
      });

      // Mouseup - clear timer
      commentsList.addEventListener('mouseup', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getButtonState(btn);
        clearTimeout(state.longPressTimer);
      });

      // Mouseleave - clear timer but keep picker open
      commentsList.addEventListener('mouseleave', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getButtonState(btn);
        clearTimeout(state.longPressTimer);
      }, true);

      // Click - quick like or picker item selection
      commentsList.addEventListener('click', async (e) => {
        // Check if clicked on picker item first
        const pickerItem = e.target.closest('.reaction-picker-item');
        if (pickerItem) {
          e.stopPropagation();
          const btn = e.target.closest('.like-button');
          if (btn) {
            const reactionType = pickerItem.getAttribute('data-reaction-type');
            const commentId = btn.getAttribute('data-comment-id');
            await toggleReaction(commentId, reactionType);
            hidePicker(btn);
          }
          return;
        }

        // Otherwise check if clicked on button itself
        const btn = e.target.closest('.like-button');
        if (!btn) return;

        const state = getButtonState(btn);
        state.picker = btn.querySelector('.reaction-picker');
        if (!state.picker || !state.picker.classList.contains('visible')) {
          const commentId = btn.getAttribute('data-comment-id');
          await toggleReaction(commentId, 'like');
        }
      });

      // Touchstart - start long press (faster on mobile: 150ms)
      commentsList.addEventListener('touchstart', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        e.preventDefault();
        const state = getButtonState(btn);
        state.selectedReaction = null;
        state.currentHoveredItem = null;
        // Add visual feedback that hold is in progress
        btn.style.transform = 'scale(0.95)';
        state.longPressTimer = setTimeout(() => {
          btn.style.transform = '';
          showPicker(btn);
        }, 150);
      }, { passive: false });

      // Touchmove - slide to select emoji
      commentsList.addEventListener('touchmove', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getButtonState(btn);

        if (!state.pickerShown) {
          clearTimeout(state.longPressTimer);
          return;
        }

        e.preventDefault();
        const touch = e.touches[0];
        updateHoveredEmoji(btn, touch);
      }, { passive: false });

      // Touchend - complete reaction
      commentsList.addEventListener('touchend', async (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getButtonState(btn);
        clearTimeout(state.longPressTimer);
        btn.style.transform = '';
        state.picker = btn.querySelector('.reaction-picker');

        if (state.pickerShown && state.selectedReaction) {
          const commentId = btn.getAttribute('data-comment-id');
          await toggleReaction(commentId, state.selectedReaction);
          if (navigator.vibrate) navigator.vibrate([10, 20, 10]);
          hidePicker(btn);
          state.selectedReaction = null;
          state.currentHoveredItem = null;
        } else if (!state.pickerShown) {
          const commentId = btn.getAttribute('data-comment-id');
          await toggleReaction(commentId, 'like');
        } else {
          hidePicker(btn);
        }
      });

      // Touchcancel - cleanup
      commentsList.addEventListener('touchcancel', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getButtonState(btn);
        clearTimeout(state.longPressTimer);
        btn.style.transform = '';
        hidePicker(btn);
        state.selectedReaction = null;
        state.currentHoveredItem = null;
      });

      // Hide picker when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.like-button')) {
          // Clicked outside - hide all pickers
          buttonStates.forEach((state, btn) => {
            if (state.pickerShown) {
              hidePicker(btn);
            }
          });
        }
      });

      // Event delegation for delete buttons
      commentsList.addEventListener('click', (e) => {
        const deleteBtn = e.target.closest('.comment-delete-btn');
        if (deleteBtn) {
          const commentId = parseInt(deleteBtn.getAttribute('data-comment-id'));
          console.log('üóëÔ∏è Delete button clicked for comment:', commentId);
          deleteProfileComment(commentId);
        }
      });
    }

    // No-op function for compatibility (in case it's called somewhere)
    function attachLikeButtonListeners() {
      // Event delegation is now used - this function does nothing
    }

    postCommentBtn.addEventListener('click', async () => {
      const commentText = commentTextarea.value.trim();
      if (!commentText) {
        alert('Please enter a comment!');
        return;
      }

      if (!currentUserWallet) {
        alert('Please connect your wallet first!');
        return;
      }

      try {
        const profileKey = `bearpark_profile_${currentUserWallet}`;
        const localProfile = JSON.parse(localStorage.getItem(profileKey) || '{}');

        const response = await fetch(`${API_BASE_URL}/api/comments`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            profile_wallet: window.currentProfileWallet,
            commenter_wallet: currentUserWallet,
            comment_text: commentText,
            commenter_name: localProfile.display_name || 'Anonymous',
            commenter_avatar: localProfile.avatar_nft || null
          })
        });

        if (response.ok) {
          commentTextarea.value = '';
          await loadComments();
        } else {
          alert('Failed to post comment. Please try again.');
        }
      } catch (error) {
        console.error('Error posting comment:', error);
        alert('Error posting comment. Please try again.');
      }
    });

    // Profile comment delete function
    window.deleteProfileComment = async function(commentId) {
      if (!confirm('Are you sure you want to delete this comment?')) return;

      try {
        console.log('üîµ [Delete Profile Comment] Deleting comment:', commentId);
        console.log('üîµ [Delete] Current user wallet:', currentUserWallet);

        if (!currentUserWallet) {
          alert('Please connect your wallet first!');
          return;
        }

        const response = await fetch(`${API_BASE_URL}/api/comments/${commentId}`, {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet_address: currentUserWallet,
            is_admin: false
          })
        });

        console.log('üîµ [Delete] Response status:', response.status);

        if (response.ok) {
          console.log('‚úÖ [Delete] Comment deleted successfully');
          console.log('üîÑ [Delete] Reloading comments...');
          await loadComments();
          console.log('‚úÖ [Delete] Comments reloaded');
        } else {
          const errorData = await response.json();
          console.error('‚ùå [Delete] Error response:', errorData);
          alert(`Failed to delete comment: ${errorData.error || 'Unknown error'}`);
        }
      } catch (error) {
        console.error('‚ùå [Delete] Error deleting comment:', error);
        alert('Error deleting comment.');
      }
    };

    // Open Reply Box
    window.openReplyBox = function(commentId) {
      // Close any other open reply boxes
      document.querySelectorAll('.reply-box').forEach(box => {
        box.classList.remove('visible');
      });

      // Find the comment thread
      const threadElement = document.querySelector(`.comment-thread[data-comment-id="${commentId}"]`);
      if (!threadElement) return;

      const commentContent = threadElement.querySelector('.comment-content');
      let replyBox = commentContent.querySelector('.reply-box');

      if (!replyBox) {
        // Create reply box
        const replyBoxHTML = `
          <div class="reply-box visible" data-parent-id="${commentId}">
            <textarea placeholder="Write a reply..." maxlength="500"></textarea>
            <div class="reply-box-actions">
              <button class="reply-cancel-btn" onclick="closeReplyBox(${commentId})">Cancel</button>
              <button class="reply-submit-btn" onclick="submitReply(${commentId})">Reply</button>
            </div>
          </div>
        `;
        commentContent.insertAdjacentHTML('beforeend', replyBoxHTML);
        replyBox = commentContent.querySelector('.reply-box');

        // Focus textarea
        setTimeout(() => {
          const textarea = replyBox.querySelector('textarea');
          textarea.focus();
        }, 100);
      } else {
        replyBox.classList.add('visible');
        setTimeout(() => {
          const textarea = replyBox.querySelector('textarea');
          textarea.focus();
        }, 100);
      }
    };

    // Close Reply Box
    window.closeReplyBox = function(commentId) {
      const threadElement = document.querySelector(`.comment-thread[data-comment-id="${commentId}"]`);
      if (!threadElement) return;

      const replyBox = threadElement.querySelector('.reply-box');
      if (replyBox) {
        replyBox.classList.remove('visible');
        replyBox.querySelector('textarea').value = '';
      }
    };

    // Submit Reply
    window.submitReply = async function(parentCommentId) {
      if (!currentUserWallet) {
        alert('Please connect your wallet first!');
        return;
      }

      const threadElement = document.querySelector(`.comment-thread[data-comment-id="${parentCommentId}"]`);
      if (!threadElement) return;

      const replyBox = threadElement.querySelector('.reply-box');
      const textarea = replyBox.querySelector('textarea');
      const replyText = textarea.value.trim();

      if (!replyText) {
        alert('Please enter a reply!');
        return;
      }

      try {
        // Get user profile data
        const profileKey = `bearpark_profile_${currentUserWallet}`;
        const localProfile = JSON.parse(localStorage.getItem(profileKey) || '{}');

        const response = await fetch(`${API_BASE_URL}/api/comments`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            profile_wallet: window.currentProfileWallet,
            commenter_wallet: currentUserWallet,
            comment_text: replyText,
            commenter_name: localProfile.display_name || 'Anonymous',
            commenter_avatar: localProfile.avatar_nft || null,
            parent_id: parentCommentId
          })
        });

        if (response.ok) {
          closeReplyBox(parentCommentId);
          await loadComments();
        } else {
          alert('Failed to post reply.');
        }
      } catch (error) {
        console.error('Error posting reply:', error);
        alert('Error posting reply. Please try again.');
      }
    };

    // Prevent double-clicking reactions
    const reactionLocks = new Set();

    window.toggleReaction = async function(commentId, reactionType) {
      if (!currentUserWallet) {
        alert('Please connect your wallet first!');
        return;
      }

      // Create unique lock key for this specific reaction
      const lockKey = `${commentId}-${reactionType}`;

      // If already processing this reaction, ignore
      if (reactionLocks.has(lockKey)) {
        console.log('‚è≥ Already processing this reaction, ignoring duplicate request');
        return;
      }

      // Lock this reaction
      reactionLocks.add(lockKey);

      try {
        const response = await fetch(`${API_BASE_URL}/api/comments/${commentId}/react`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet_address: currentUserWallet,
            reaction_type: reactionType
          })
        });

        let result;
        try {
          result = await response.json();
        } catch (parseError) {
          console.error('‚ùå Failed to parse response JSON:', parseError);
          console.error('‚ùå Response status:', response.status, response.statusText);
          alert('Server error - invalid response');
          return;
        }

        if (response.ok && result.success) {
          console.log('‚úÖ toggleReaction Backend confirmed:', result.action);
          console.log('üì¶ Backend returned updated counts:', result.counts);
          console.log('üì¶ Backend returned user reactions:', result.userReactions);

          // Use the fresh data directly from backend response (no fetching needed!)
          updateCommentReactionsWithData(commentId, {
            counts: result.counts || {},
            userReactions: result.userReactions || {}
          });
        } else {
          console.error('‚ùå toggleReaction Backend error:', result);
          console.error('‚ùå Response status:', response.status);
          console.error('‚ùå Failed request: commentId=' + commentId + ', reactionType=' + reactionType);
          // Don't show alert for duplicate errors (user probably double-clicked)
          if (!result.error?.includes('duplicate key')) {
            alert('Failed to toggle reaction: ' + (result.error || 'Unknown error'));
          }
        }
      } catch (error) {
        console.error('Error toggling reaction:', error);
        alert('Error adding reaction.');
      } finally {
        // Always unlock after request completes
        reactionLocks.delete(lockKey);
      }
    };

    // Update reactions using data directly (no fetch needed)
    function updateCommentReactionsWithData(commentId, reactionsData) {
      try {
        const userReactions = reactionsData.userReactions?.[currentUserWallet] || [];

        console.log('üîÑ Updating reactions UI for comment', commentId);
        console.log('üìä Reaction counts:', reactionsData.counts);
        console.log('üë§ User reactions:', userReactions);

        // Find the comment element (data-comment-id is on .comment-thread, not .comment-item)
        const commentThread = document.querySelector(`.comment-thread[data-comment-id="${commentId}"]`);
        if (!commentThread) return;
        const commentElement = commentThread.querySelector('.comment-item');
        if (!commentElement) return;

        const commentContent = commentElement.querySelector('.comment-content');
        const commentActions = commentContent.querySelector('.comment-actions');
        let existingReactionSummary = commentContent.querySelector('.reaction-summary');

        // Generate the new reaction summary HTML
        const newReactionHTML = generateReactionSummary(commentId, reactionsData, userReactions);

        console.log('üé® New reaction HTML:', newReactionHTML ? 'Generated' : 'Empty (no reactions)');

        if (existingReactionSummary) {
          // If there's an existing summary and new HTML, replace it
          if (newReactionHTML) {
            existingReactionSummary.outerHTML = newReactionHTML;
          } else {
            // No reactions left, remove the summary
            existingReactionSummary.remove();
          }
        } else if (newReactionHTML) {
          // No existing summary but we have reactions, insert before actions
          commentActions.insertAdjacentHTML('beforebegin', newReactionHTML);
        }

        // Update the like button state
        const likeButton = commentElement.querySelector('.like-button');
        if (likeButton) {
          if (userReactions.length > 0) {
            likeButton.classList.add('reacted');
          } else {
            likeButton.classList.remove('reacted');
          }
        }

        // Event listeners use delegation - no need to re-attach
        // attachLikeButtonListeners(); // REMOVED - causes duplicate listeners
      } catch (error) {
        console.error('Error updating reactions:', error);
      }
    }

    // Update reactions for a specific comment without reloading all comments
    async function updateCommentReactions(commentId) {
      try {
        // Add cache-busting parameter to ensure fresh data
        const timestamp = new Date().getTime();
        const reactionsResponse = await fetch(`${API_BASE_URL}/api/comments/${commentId}/reactions?_=${timestamp}`);
        if (!reactionsResponse.ok) return;

        const reactions = await reactionsResponse.json();
        const userReactions = reactions.userReactions?.[currentUserWallet] || [];

        console.log('üîÑ Updating reactions UI for comment', commentId);
        console.log('üìä Reaction counts:', reactions.counts);
        console.log('üë§ User reactions:', userReactions);

        // Find the comment element (data-comment-id is on .comment-thread, not .comment-item)
        const commentThread = document.querySelector(`.comment-thread[data-comment-id="${commentId}"]`);
        if (!commentThread) return;
        const commentElement = commentThread.querySelector('.comment-item');
        if (!commentElement) return;

        const commentContent = commentElement.querySelector('.comment-content');
        const commentActions = commentContent.querySelector('.comment-actions');
        let existingReactionSummary = commentContent.querySelector('.reaction-summary');

        // Generate the new reaction summary HTML
        const newReactionHTML = generateReactionSummary(commentId, reactions, userReactions);

        console.log('üé® New reaction HTML:', newReactionHTML ? 'Generated' : 'Empty (no reactions)');

        if (existingReactionSummary) {
          // If there's an existing summary and new HTML, replace it
          if (newReactionHTML) {
            existingReactionSummary.outerHTML = newReactionHTML;
          } else {
            // No reactions left, remove the summary
            existingReactionSummary.remove();
          }
        } else if (newReactionHTML) {
          // No existing summary but we have reactions, insert before actions
          commentActions.insertAdjacentHTML('beforebegin', newReactionHTML);
        }

        // Update the like button state
        const likeButton = commentElement.querySelector('.like-button');
        if (likeButton) {
          if (userReactions.length > 0) {
            likeButton.classList.add('reacted');
          } else {
            likeButton.classList.remove('reacted');
          }
        }

        // Event listeners use delegation - no need to re-attach
        // attachLikeButtonListeners(); // REMOVED - causes duplicate listeners
      } catch (error) {
        console.error('Error updating reactions:', error);
      }
    }

    window.removeReaction = async function(commentId, reactionType, pillElement) {
      if (!currentUserWallet) {
        alert('Please connect your wallet first!');
        return;
      }

      console.log('üóëÔ∏è REMOVING reaction:', reactionType, 'from comment', commentId);

      // Add the removing animation
      pillElement.classList.add('removing');

      // Haptic feedback
      if (navigator.vibrate) {
        navigator.vibrate([5, 10, 5]);
      }

      try {
        const response = await fetch(`${API_BASE_URL}/api/comments/${commentId}/react`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet_address: currentUserWallet,
            reaction_type: reactionType
          })
        });

        const result = await response.json();
        console.log('üì° Backend response:', result);

        if (response.ok && result.success) {
          console.log('‚úÖ Backend confirmed:', result.action);
          console.log('üì¶ Backend returned updated counts:', result.counts);
          console.log('üì¶ Backend returned user reactions:', result.userReactions);

          // Use the fresh data directly from backend response (no fetching needed!)
          setTimeout(() => {
            console.log('‚è∞ Animation complete, updating UI with backend data...');
            // Update UI directly with the counts from backend response
            updateCommentReactionsWithData(commentId, {
              counts: result.counts || {},
              userReactions: result.userReactions || {}
            });
          }, 400); // Match animation duration
        } else {
          console.error('‚ùå Backend error:', result);
          pillElement.classList.remove('removing');
          alert('Failed to remove reaction: ' + (result.error || 'Unknown error'));
        }
      } catch (error) {
        pillElement.classList.remove('removing');
        console.error('Error removing reaction:', error);
        alert('Error removing reaction: ' + error.message);
      }
    };

    async function loadProfileNFTs() {
      try {
        const walletAddress = window.currentProfileWallet;
        console.log('üñºÔ∏è Loading NFTs for wallet:', walletAddress);

        // Fetch ALL NFTs with pagination
        let allNfts = [];
        let marker = null;
        let pageCount = 0;

        // XRPL API endpoints - only xrplcluster.com supports CORS for browser requests
        const xrplEndpoints = [
          'https://xrplcluster.com/'
        ];

        do {
          pageCount++;
          console.log(`üñºÔ∏è Fetching NFT page ${pageCount}...`);

          let response = null;
          let lastError = null;

          // Try each endpoint until one works
          for (const endpoint of xrplEndpoints) {
            try {
              console.log(`üñºÔ∏è Trying endpoint: ${endpoint}`);
              response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  method: 'account_nfts',
                  params: [{
                    account: walletAddress,
                    ledger_index: 'validated',
                    limit: 400,
                    ...(marker && { marker })
                  }]
                })
              });
              if (response.ok) {
                console.log(`üñºÔ∏è Success with endpoint: ${endpoint}`);
                break;
              }
            } catch (err) {
              console.log(`üñºÔ∏è Endpoint ${endpoint} failed:`, err.message);
              lastError = err;
            }
          }

          if (!response || !response.ok) {
            console.log('üñºÔ∏è All NFT API endpoints failed');
            break;
          }

          const data = await response.json();
          const pageNfts = data.result?.account_nfts || [];
          allNfts = allNfts.concat(pageNfts);
          marker = data.result?.marker;

          console.log(`üñºÔ∏è Page ${pageCount}: ${pageNfts.length} NFTs, Total so far: ${allNfts.length}`);

        } while (marker);

        console.log('üñºÔ∏è Total NFTs in wallet (all pages):', allNfts.length);

        // Debug: Show sample NFT structure and unique issuers
        if (allNfts.length > 0) {
          console.log('üñºÔ∏è Sample NFT structure:', allNfts[0]);
          const uniqueIssuers = [...new Set(allNfts.map(nft => nft.Issuer))];
          console.log('üñºÔ∏è Unique issuers in wallet:', uniqueIssuers);
        }

        // Filter for BEAR NFTs by issuer (check multiple known BEAR issuers)
        const bearIssuers = [
          'rBEARGUAsyu7tUw53rufQzFdWmJHpJEqFW',  // Original BEAR issuer
          'rBEARbo4Prn33894evmvYcAf9yAQjp4VJF'   // Alternative BEAR issuer
        ];
        const nfts = allNfts.filter(nft => bearIssuers.includes(nft.Issuer));
        console.log('üñºÔ∏è Looking for BEAR issuers:', bearIssuers);
        console.log('üñºÔ∏è BEAR NFTs found:', nfts.length);
        if (nfts.length > 0) {
          console.log('üñºÔ∏è BEAR NFT sample FULL OBJECT:', JSON.stringify(nfts[0], null, 2));
          console.log('üñºÔ∏è NFT fields:', Object.keys(nfts[0]));
          console.log('üñºÔ∏è Found from issuer:', nfts[0].Issuer);
        }

        // Debug: Check what taxons are actually in the BEAR NFTs
        const taxons = [...new Set(nfts.map(nft => nft.NFTokenTaxon))];
        console.log('üîç Taxon values found in BEAR NFTs:', taxons);

        // Count NFTs by each taxon
        taxons.forEach(taxon => {
          const count = nfts.filter(nft => nft.NFTokenTaxon === taxon).length;
          console.log(`üìä Taxon ${taxon}: ${count} NFTs`);
        });

        // Categorize NFTs by taxon
        // Taxon 0 = Ultra Rare BEARS
        // Taxon 1 = Pixel BEARS
        // Taxon 2 = Pixel BEARS (alternative issuer)
        let pixelBears = nfts.filter(nft => nft.NFTokenTaxon === 1 || nft.NFTokenTaxon === 2);
        let ultraRareBears = nfts.filter(nft => nft.NFTokenTaxon === 0);

        console.log('üé® Pixel BEARS (taxon 1 or 2):', pixelBears.length);
        console.log('üíé Ultra Rare BEARS (taxon 0):', ultraRareBears.length);

        const pixelBearsSection = document.getElementById('pixelBearsSection');
        const ultraRareBearsSection = document.getElementById('ultraRareBearsSection');
        const noNFTsMessage = document.getElementById('noNFTsMessage');

        // Show/hide sections based on what user owns
        if (pixelBears.length > 0) {
          console.log('‚úÖ Showing Pixel BEARS section');
          pixelBearsSection.style.display = 'block';
          document.getElementById('pixelBearsCount').textContent = pixelBears.length;
          await displayNFTCollection('pixelBearsGrid', pixelBears);
          noNFTsMessage.style.display = 'none';
        } else {
          pixelBearsSection.style.display = 'none';
        }

        if (ultraRareBears.length > 0) {
          console.log('‚úÖ Showing Ultra Rare BEARS section');
          ultraRareBearsSection.style.display = 'block';
          document.getElementById('ultraRareBearsCount').textContent = ultraRareBears.length;
          await displayNFTCollection('ultraRareBearsGrid', ultraRareBears);
          noNFTsMessage.style.display = 'none';
        } else {
          ultraRareBearsSection.style.display = 'none';
        }

        // Show "no NFTs" message if user has none
        if (pixelBears.length === 0 && ultraRareBears.length === 0) {
          console.log('‚ùå No BEAR NFTs found - showing empty message');
          noNFTsMessage.style.display = 'block';
        }
      } catch (error) {
        console.error('Error loading profile NFTs:', error);
        document.getElementById('noNFTsMessage').style.display = 'block';
      }
    }

    async function displayNFTCollection(gridId, nfts) {
      console.log(`üé¨ Displaying ${nfts.length} NFTs in grid: ${gridId}`);
      const grid = document.getElementById(gridId);
      if (!grid) {
        console.error(`‚ùå Grid element not found: ${gridId}`);
        return;
      }

      // Limit to 20 NFTs for performance
      const nftsToShow = nfts.slice(0, 20);
      console.log(`üîç Processing ${nftsToShow.length} NFTs - fetching metadata...`);

      // Show loading state
      grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 20px; color: #edb723;">Loading NFT images...</div>';

      // Fetch metadata for each NFT to get actual image URLs
      const nftWithImages = [];
      for (let i = 0; i < nftsToShow.length; i++) {
        const nft = nftsToShow[i];
        let imageUrl = null;
        let bearName = null;
        let bearRarity = null;

        if (nft.URI) {
          try {
            // Use backend API to fetch image URL (handles IPFS encoding properly)
            console.log(`üì° [${i+1}/${nftsToShow.length}] Fetching image via API...`);
            const apiResponse = await fetch(`${API_BASE_URL}/api/nft/image/${nft.URI}`);
            const apiData = await apiResponse.json();

            if (apiData.success && apiData.imageUrl) {
              imageUrl = apiData.imageUrl;
              bearName = apiData.name || null;
              console.log(`‚úÖ [${i+1}/${nftsToShow.length}] ${bearName || 'NFT'} loaded via API`);
            } else {
              console.warn(`‚ö†Ô∏è [${i+1}/${nftsToShow.length}] API failed:`, apiData.error);

              // Fallback: try direct IPFS fetch
              const uriString = nft.URI.match(/.{1,2}/g).map(byte => String.fromCharCode(parseInt(byte, 16))).join('');
              let metadataUrl = uriString;
              if (uriString.startsWith('ipfs://')) {
                const ipfsPath = uriString.replace('ipfs://', '');
                const parts = ipfsPath.split('/');
                const encodedPath = parts.map(part => encodeURIComponent(part)).join('/');
                metadataUrl = 'https://ipfs.io/ipfs/' + encodedPath;
              }

              const response = await fetch(metadataUrl);
              if (response.ok) {
                const metadata = await response.json();
                bearName = metadata.name || null;

                // Extract rarity from attributes
                if (metadata.attributes && Array.isArray(metadata.attributes)) {
                  const rarityAttr = metadata.attributes.find(attr =>
                    attr.trait_type === 'Rarity' || attr.trait_type === 'rarity' ||
                    attr.trait === 'Rarity' || attr.name === 'Rarity'
                  );
                  if (rarityAttr) {
                    bearRarity = rarityAttr.value || rarityAttr.val || rarityAttr.content;
                  }
                }

                // Get image URL
                const imgField = metadata.animation || metadata.animation_url ||
                               metadata.image || metadata.image_url || metadata.media;
                if (imgField) {
                  if (imgField.startsWith('ipfs://')) {
                    const ipfsPath = imgField.replace('ipfs://', '');
                    const parts = ipfsPath.split('/');
                    const encodedPath = parts.map(part => encodeURIComponent(part)).join('/');
                    imageUrl = 'https://ipfs.io/ipfs/' + encodedPath;
                  } else {
                    imageUrl = imgField;
                  }
                  console.log(`‚úÖ [${i+1}/${nftsToShow.length}] ${bearName || 'NFT'} loaded (fallback)`);
                }
              }
            }
          } catch (error) {
            console.error(`‚ùå [${i+1}/${nftsToShow.length}] Error:`, error.message);
          }
        }

        nftWithImages.push({ ...nft, imageUrl, bearName, bearRarity });

        // Update grid every 5 NFTs for progressive loading
        if ((i + 1) % 5 === 0 || i === nftsToShow.length - 1) {
          grid.innerHTML = nftWithImages.map((nft, index) => {
            const imageUrl = nft.imageUrl || 'data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27100%27 height=%27100%27%3E%3Crect fill=%27%23333%27 width=%27100%27 height=%27100%27/%3E%3Ctext fill=%27%23edb723%27 x=%2750%25%27 y=%2750%25%27 text-anchor=%27middle%27 dy=%27.3em%27%3ENFT%3C/text%3E%3C/svg%3E';

            // Extract BEAR # from name (e.g., "Pixel BEAR #3018" -> "3018")
            let bearNumber = index + 1;
            if (nft.bearName) {
              const match = nft.bearName.match(/#(\d+)/);
              if (match) {
                bearNumber = match[1];
              }
            }

            // Use rarity from metadata or calculate rarity number
            let rarityText;
            if (nft.bearRarity) {
              rarityText = nft.bearRarity;
            } else if (nft.NFTokenTaxon === 0) {
              // Ultra Rare BEARS show "RARITY #0"
              rarityText = 'RARITY #0';
            } else {
              // For Pixel BEARS, calculate rarity score (simplified - using modulo)
              const rarityScore = parseInt(bearNumber) % 1000;
              rarityText = `RARITY ${rarityScore}`;
            }

            // Debug logging
            if (index === 0) {
              console.log(`üé® NFT Card Info - bearName: "${nft.bearName}", bearNumber: "${bearNumber}", bearRarity: "${nft.bearRarity}", rarityText: "${rarityText}"`);
            }

            const htmlTemplate = `
              <div class="profile-nft-item">
                <div class="nft-image-container">
                  <img src="${imageUrl}" alt="BEAR #${bearNumber}" style="width:100%; height:100%; object-fit:contain; image-rendering:pixelated;">
                  <a href="https://xrp.cafe/nft/${nft.NFTokenID}" target="_blank" rel="noopener noreferrer" class="nft-logo-badge" title="View on XRP.cafe">
                    <img src="https://avatars.githubusercontent.com/u/109316848?s=280&v=4" alt="XRP Cafe">
                  </a>
                </div>
                <div class="nft-info">
                  <div class="nft-title">BEAR #${bearNumber}</div>
                  <div class="nft-rarity">${rarityText}</div>
                </div>
              </div>
            `;

            // Debug first NFT HTML
            if (index === 0) {
              console.log(`üé® Generated HTML:`, htmlTemplate);
            }

            return htmlTemplate;
          }).join('');
        }
      }

      console.log(`‚úÖ Rendered ${nftWithImages.length} NFTs to ${gridId}`);
    }

    // Toggle NFT collection expansion
    window.toggleNFTCollection = function(collectionName) {
      const grid = document.getElementById(`${collectionName}Grid`);
      const arrow = document.getElementById(`${collectionName}Arrow`);
      const button = grid.previousElementSibling;

      if (grid.style.display === 'none' || grid.style.display === '') {
        grid.style.display = 'grid';
        button.classList.add('expanded');
      } else {
        grid.style.display = 'none';
        button.classList.remove('expanded');
      }
    };

    function getTimeAgo(timestamp) {
      const now = new Date();
      const then = new Date(timestamp);
      const seconds = Math.floor((now - then) / 1000);

      if (seconds < 60) return 'Just now';
      if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
      if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
      if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
      return then.toLocaleDateString();
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    console.log('‚úÖ Profile Modal System initialized');
  })();

  (function wireUpWelcomeButton() {
    const welcomeBtn = document.getElementById('welcomeBtn');
    console.log('üîç [Welcome Button] Found button:', welcomeBtn);
    if (welcomeBtn) {
      welcomeBtn.addEventListener('click', () => {
        console.log('üêª Welcome button clicked!');
        const wallet = localStorage.getItem('bearpark_wallet');
        console.log('üîç [Welcome Button] Wallet:', wallet);
        if (!wallet) {
          // No wallet - shouldn't happen since user needs wallet to access site
          console.log('‚ö†Ô∏è [Welcome Button] No wallet found');
          return;
        }

        // Check if user has completed profile setup
        // NOTE: Using bear_profile_ (without "park") to match updateWelcomeButton
        const profileKey = `bear_profile_${wallet}`;
        const localProfile = localStorage.getItem(profileKey);
        console.log('üîç [Welcome Button] Profile key:', profileKey);
        console.log('üîç [Welcome Button] Local profile:', localProfile);

        let hasProfile = false;
        if (localProfile) {
          try {
            const profile = JSON.parse(localProfile);
            // Profile is considered "set" if it has both display_name and avatar
            hasProfile = profile.display_name && (profile.avatar_nft || profile.avatar_url);
            console.log('üîç [Welcome Button] Has profile:', hasProfile, profile);
          } catch (e) {
            hasProfile = false;
            console.log('‚ùå [Welcome Button] Error parsing profile:', e);
          }
        }

        if (hasProfile) {
          // User has profile - open profile modal
          console.log('‚úÖ [Welcome Button] Opening profile modal');
          openProfileModal();
        } else {
          // New user without profile - open drawer and scroll to profile setup
          console.log('‚úÖ [Welcome Button] Opening profile setup');
          window.openProfileSetup();
        }
      });
      console.log('‚úÖ Welcome button wired to open profile modal');
    } else {
      console.error('‚ùå Welcome button not found!');
    }
  })();

  // PWA Install & Notifications
  let deferredPrompt;

  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    const btn = document.getElementById('installAppBtn');
    if (btn) {
      btn.style.display = 'block';
      document.getElementById('pwaControls').style.display = 'block';
    }
  });

  document.getElementById('installAppBtn')?.addEventListener('click', async () => {
    if (!deferredPrompt) return;
    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;
    console.log(`üêª PWA install: ${outcome}`);
    deferredPrompt = null;
    document.getElementById('installAppBtn').style.display = 'none';
  });


  // ===== NOTIFICATION SYSTEM =====
  (function initNotificationSystem() {
    const API_BASE = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
      ? 'http://localhost:3000'
      : 'https://www.bearpark.xyz';
    let notifications = [];
    let unreadCount = 0;

    // Toggle notification panel
    window.toggleNotificationPanel = function() {
      const panel = document.getElementById('notificationPanel');
      const isVisible = panel.classList.contains('visible');

      if (isVisible) {
        closeNotificationPanel();
      } else {
        openNotificationPanel();
      }
    };

    function closeNotificationPanel() {
      const panel = document.getElementById('notificationPanel');
      panel.classList.remove('visible');
      setTimeout(() => panel.style.display = 'none', 300);
      // Remove click-outside listeners
      document.removeEventListener('mousedown', handleClickOutside, true);
      document.removeEventListener('touchstart', handleClickOutsideTouch, true);
      // Remove touch listeners
      panel.removeEventListener('touchstart', handleTouchStart);
      panel.removeEventListener('touchmove', handleTouchMove);
      panel.removeEventListener('touchend', handleTouchEnd);
    }

    function openNotificationPanel() {
      const panel = document.getElementById('notificationPanel');
      panel.style.display = 'flex';
      setTimeout(() => panel.classList.add('visible'), 10);
      // Mark all as read (stops badge) but keep them visible in the panel
      markAllNotificationsAsRead();

      // Add click-outside listener after a short delay to prevent immediate close
      setTimeout(() => {
        document.addEventListener('mousedown', handleClickOutside, true);
        document.addEventListener('touchstart', handleClickOutsideTouch, { passive: true, capture: true });
      }, 100);

      // Add touch/swipe listeners for mobile
      panel.addEventListener('touchstart', handleTouchStart, { passive: true });
      panel.addEventListener('touchmove', handleTouchMove, { passive: false });
      panel.addEventListener('touchend', handleTouchEnd);
    }

    // Click outside to close (desktop)
    function handleClickOutside(event) {
      const panel = document.getElementById('notificationPanel');
      const bellBtn = document.getElementById('notificationBellBtn');

      // Don't close if clicking the bell button or inside the panel
      if (!panel.contains(event.target) && !bellBtn.contains(event.target)) {
        event.preventDefault();
        event.stopPropagation();
        closeNotificationPanel();
      }
    }

    // Touch outside to close (mobile)
    function handleClickOutsideTouch(event) {
      const panel = document.getElementById('notificationPanel');
      const bellBtn = document.getElementById('notificationBellBtn');

      // Don't close if touching the bell button or inside the panel
      if (!panel.contains(event.target) && !bellBtn.contains(event.target)) {
        event.preventDefault();
        closeNotificationPanel();
      }
    }

    // Touch/swipe handling for mobile
    let touchStartY = 0;
    let touchStartX = 0;
    let currentTranslateY = 0;

    function handleTouchStart(event) {
      const touch = event.touches[0];
      touchStartY = touch.clientY;
      touchStartX = touch.clientX;
      currentTranslateY = 0;
    }

    function handleTouchMove(event) {
      const panel = document.getElementById('notificationPanel');
      const touch = event.touches[0];
      const deltaY = touch.clientY - touchStartY;
      const deltaX = Math.abs(touch.clientX - touchStartX);

      // Only handle vertical swipes (down)
      if (deltaY > 0 && deltaX < 50) {
        currentTranslateY = deltaY;
        panel.style.transform = `translateY(${deltaY}px)`;
        // Prevent page scroll while swiping
        if (deltaY > 10) {
          event.preventDefault();
        }
      }
    }

    function handleTouchEnd(event) {
      const panel = document.getElementById('notificationPanel');

      // If swiped down more than 80px, close the panel
      if (currentTranslateY > 80) {
        panel.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
        panel.style.transform = 'translateY(100%)';
        panel.style.opacity = '0';
        setTimeout(() => {
          closeNotificationPanel();
          panel.style.transform = '';
          panel.style.opacity = '';
          panel.style.transition = '';
        }, 300);
      } else {
        // Snap back
        panel.style.transition = 'transform 0.3s ease';
        panel.style.transform = 'translateY(0)';
        setTimeout(() => {
          panel.style.transition = '';
        }, 300);
      }

      currentTranslateY = 0;
    }

    // Format relative time
    function formatRelativeTime(timestamp) {
      const now = Date.now();
      const diff = now - new Date(timestamp).getTime();
      const seconds = Math.floor(diff / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      if (days > 0) return `${days}d ago`;
      if (hours > 0) return `${hours}h ago`;
      if (minutes > 0) return `${minutes}m ago`;
      return 'Just now';
    }

    // Render notifications
    function renderNotifications() {
      console.log('üé® renderNotifications called, count:', notifications.length);
      const list = document.getElementById('notificationList');

      if (notifications.length === 0) {
        list.innerHTML = `
          <div class="notification-empty">
            <div class="notification-empty-icon">üîï</div>
            <p>No notifications yet!</p>
          </div>
        `;
        return;
      }

      // Sort by created_at - newest first (chronological order with most recent at top)
      const sortedNotifications = [...notifications].sort((a, b) => {
        return new Date(b.created_at) - new Date(a.created_at);
      });

      list.innerHTML = sortedNotifications.map(notif => {
        const unreadClass = notif.read ? '' : 'unread';

        // Helper function to render user avatar
        const renderAvatar = (avatarNft, displayName) => {
          let avatarHTML = '';
          if (avatarNft) {
            try {
              const avatarData = JSON.parse(avatarNft);
              const avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl;
              if (avatarUrl) {
                avatarHTML = `<img src="${avatarUrl}" style="width:40px; height:40px; border-radius:50%; object-fit:cover;" alt="${displayName} avatar" onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png'">`;
              }
            } catch (e) {
              // If not JSON, try using it directly as NFT ID
              avatarHTML = `<img src="https://nft.xrpl-labs.com/${avatarNft}" style="width:40px; height:40px; border-radius:50%; object-fit:cover;" alt="${displayName} avatar" onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png'">`;
            }
          }
          // Default avatar if none provided
          if (!avatarHTML) {
            avatarHTML = `<img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ugu1kl.png" style="width:40px; height:40px; border-radius:50%; object-fit:cover;" alt="${displayName} avatar">`;
          }
          return avatarHTML;
        };

        if (notif.type === 'follower') {
          return `
            <div class="notification-item ${unreadClass}" data-notification-id="${notif.id}">
              ${renderAvatar(notif.data.avatarNft, notif.data.displayName || 'Anonymous')}
              <div class="notification-content">
                <p class="notification-text"><strong>${notif.data.displayName || notif.data.wallet}</strong> followed you!</p>
                <p class="notification-time">${formatRelativeTime(notif.created_at)}</p>
              </div>
            </div>
          `;
        } else if (notif.type === 'reaction') {
          const emojis = notif.data.reactions || [];
          return `
            <div class="notification-item ${unreadClass}" data-notification-id="${notif.id}">
              ${renderAvatar(notif.data.avatarNft, notif.data.displayName || 'Anonymous')}
              <div class="notification-content">
                <p class="notification-text"><strong>${notif.data.displayName || notif.data.wallet}</strong> reacted to your comment</p>
                <div class="notification-reactions">
                  ${emojis.map(emoji => `<span class="notification-reaction-emoji">${emoji}</span>`).join('')}
                </div>
                <p class="notification-time">${formatRelativeTime(notif.created_at)}</p>
              </div>
            </div>
          `;
        } else if (notif.type === 'bulletin_comment') {
          return `
            <div class="notification-item ${unreadClass}" data-notification-id="${notif.id}">
              ${renderAvatar(notif.data.avatarNft, notif.data.displayName || 'Anonymous')}
              <div class="notification-content">
                <p class="notification-text"><strong>${notif.data.displayName || notif.data.wallet}</strong> commented on your bulletin post</p>
                ${notif.data.commentText ? `<p class="notification-preview">"${notif.data.commentText}"</p>` : ''}
                <p class="notification-time">${formatRelativeTime(notif.created_at)}</p>
              </div>
            </div>
          `;
        } else if (notif.type === 'bulletin_reply') {
          return `
            <div class="notification-item ${unreadClass}" data-notification-id="${notif.id}">
              ${renderAvatar(notif.data.avatarNft, notif.data.displayName || 'Anonymous')}
              <div class="notification-content">
                <p class="notification-text"><strong>${notif.data.displayName || notif.data.wallet}</strong> replied to your comment</p>
                ${notif.data.commentText ? `<p class="notification-preview">"${notif.data.commentText}"</p>` : ''}
                <p class="notification-time">${formatRelativeTime(notif.created_at)}</p>
              </div>
            </div>
          `;
        } else if (notif.type === 'bulletin_post_reaction') {
          const emojis = notif.data.reactions || [];
          return `
            <div class="notification-item ${unreadClass}" data-notification-id="${notif.id}">
              ${renderAvatar(notif.data.avatarNft, notif.data.displayName || 'Anonymous')}
              <div class="notification-content">
                <p class="notification-text"><strong>${notif.data.displayName || notif.data.wallet}</strong> reacted to your bulletin post</p>
                <div class="notification-reactions">
                  ${emojis.map(emoji => `<span class="notification-reaction-emoji">${emoji}</span>`).join('')}
                </div>
                <p class="notification-time">${formatRelativeTime(notif.created_at)}</p>
              </div>
            </div>
          `;
        } else if (notif.type === 'bulletin_comment_reaction') {
          const emojis = notif.data.reactions || [];
          return `
            <div class="notification-item ${unreadClass}" data-notification-id="${notif.id}">
              ${renderAvatar(notif.data.avatarNft, notif.data.displayName || 'Anonymous')}
              <div class="notification-content">
                <p class="notification-text"><strong>${notif.data.displayName || notif.data.wallet}</strong> reacted to your bulletin comment</p>
                <div class="notification-reactions">
                  ${emojis.map(emoji => `<span class="notification-reaction-emoji">${emoji}</span>`).join('')}
                </div>
                ${notif.data.commentText ? `<p class="notification-preview">"${notif.data.commentText}"</p>` : ''}
                <p class="notification-time">${formatRelativeTime(notif.created_at)}</p>
              </div>
            </div>
          `;
        } else if (notif.type === 'profile_comment') {
          return `
            <div class="notification-item ${unreadClass}" data-notification-id="${notif.id}">
              ${renderAvatar(notif.data.avatarNft, notif.data.displayName || 'Anonymous')}
              <div class="notification-content">
                <p class="notification-text"><strong>${notif.data.displayName || notif.data.wallet}</strong> commented on your profile</p>
                ${notif.data.commentText ? `<p class="notification-preview">"${notif.data.commentText}"</p>` : ''}
                <p class="notification-time">${formatRelativeTime(notif.created_at)}</p>
              </div>
            </div>
          `;
        } else if (notif.type === 'profile_reply') {
          return `
            <div class="notification-item ${unreadClass}" data-notification-id="${notif.id}">
              ${renderAvatar(notif.data.avatarNft, notif.data.displayName || 'Anonymous')}
              <div class="notification-content">
                <p class="notification-text"><strong>${notif.data.displayName || notif.data.wallet}</strong> replied to your profile comment</p>
                ${notif.data.commentText ? `<p class="notification-preview">"${notif.data.commentText}"</p>` : ''}
                <p class="notification-time">${formatRelativeTime(notif.created_at)}</p>
              </div>
            </div>
          `;
        }
        return '';
      }).join('');
    }

    // Click handler for notification list (event delegation)
    function handleNotificationListClick(e) {
      console.log('üñ±Ô∏è Click detected on notification list', e.target);
      const notificationItem = e.target.closest('.notification-item');
      console.log('üñ±Ô∏è Closest notification item:', notificationItem);
      if (notificationItem) {
        const notificationId = notificationItem.getAttribute('data-notification-id');
        console.log('üñ±Ô∏è Notification ID:', notificationId);
        if (notificationId) {
          handleNotificationClick(notificationId);
        }
      }
    }

    // Update badge
    function updateBadge() {
      const badge = document.getElementById('notificationBadge');
      const bellBtn = document.getElementById('notificationBellBtn');

      if (unreadCount > 0) {
        badge.textContent = unreadCount > 99 ? '99+' : unreadCount;
        badge.style.display = 'flex';
        bellBtn.classList.add('has-notifications');
      } else {
        badge.style.display = 'none';
        bellBtn.classList.remove('has-notifications');
      }
    }

    // Handle notification click
    window.handleNotificationClick = async function(notificationId) {
      console.log('üîî Notification clicked:', notificationId);
      const notif = notifications.find(n => n.id === notificationId);
      if (!notif) {
        console.error('‚ùå Notification not found:', notificationId);
        return;
      }

      console.log('üîî Notification data:', notif);

      // Mark as read
      notif.read = true;
      saveNotificationsToLocalStorage();
      recalculateUnreadCount();
      renderNotifications();
      updateBadge();

      // Navigate based on type
      if (notif.type === 'follower' && notif.data.wallet) {
        console.log('üë§ Opening follower profile:', notif.data.wallet);
        // Open the follower's profile
        toggleNotificationPanel();
        setTimeout(() => openProfileModal(notif.data.wallet), 300);
      } else if (notif.type === 'reaction' && notif.data.profileWallet && notif.data.commentId) {
        console.log('üí¨ Opening profile with comment:', notif.data.profileWallet, notif.data.commentId);
        // Open the profile where the comment was posted and scroll to that comment
        toggleNotificationPanel();
        setTimeout(async () => {
          await openProfileModal(notif.data.profileWallet, true, {
            scrollToCommentId: notif.data.commentId
          });
        }, 300);
      } else if ((notif.type === 'profile_comment' || notif.type === 'profile_reply') && notif.data.profileWallet && notif.data.commentId) {
        console.log('üí¨ Opening profile with comment:', notif.data.profileWallet, notif.data.commentId);
        // Open the profile where the comment was posted and scroll to that comment
        toggleNotificationPanel();
        setTimeout(async () => {
          await openProfileModal(notif.data.profileWallet, true, {
            scrollToCommentId: notif.data.commentId
          });
        }, 300);
      } else if ((notif.type === 'bulletin_comment' || notif.type === 'bulletin_reply' || notif.type === 'bulletin_post_reaction' || notif.type === 'bulletin_comment_reaction') && notif.data.postId) {
        console.log('üì∞ Opening bulletin post:', notif.data.postId);
        // Navigate to bulletin board and open the post DIRECTLY
        toggleNotificationPanel();
        setTimeout(() => {
          // Scroll to bulletin board section
          const bulletinSection = document.getElementById('bulletin-board');
          if (bulletinSection) {
            bulletinSection.scrollIntoView({
              behavior: 'smooth',
              block: 'start'
            });
          }
          // Wait for scroll to complete, then open post
          setTimeout(async () => {
            if (typeof window.openBulletinPost === 'function') {
              await window.openBulletinPost(parseInt(notif.data.postId), notif.data.commentId ? parseInt(notif.data.commentId) : null);
            } else {
              console.error('‚ùå openBulletinPost function not available');
            }
          }, 1000); // Wait for smooth scroll to complete
        }, 300);
      } else {
        console.warn('‚ö†Ô∏è Notification type not handled or missing data:', notif.type, notif.data);
      }
    };

    // Mark all as read (legacy - keeping for compatibility)
    function markAllNotificationsAsRead() {
      let changed = false;
      notifications.forEach(notif => {
        if (!notif.read) {
          notif.read = true;
          changed = true;
        }
      });

      if (changed) {
        saveNotificationsToLocalStorage();
      }

      // Always recalculate and update badge when panel is opened
      recalculateUnreadCount();
      renderNotifications();
      updateBadge();
    }

    // Clear all notifications when panel is opened
    // Once viewed, they should never come back
    function clearAllNotifications() {
      if (notifications.length > 0) {
        console.log('üßπ Clearing all notifications - user viewed them');
        notifications = [];
        saveNotificationsToLocalStorage();
        unreadCount = 0;
        renderNotifications();
        updateBadge();
      }
    }

    // Recalculate unread count
    function recalculateUnreadCount() {
      unreadCount = notifications.filter(n => !n.read).length;
    }

    // Save to localStorage
    function saveNotificationsToLocalStorage() {
      try {
        localStorage.setItem('bearpark_notifications', JSON.stringify(notifications));
      } catch (e) {
        console.error('Failed to save notifications:', e);
      }
    }

    // Load from localStorage
    function loadNotificationsFromLocalStorage() {
      try {
        const stored = localStorage.getItem('bearpark_notifications');
        if (stored) {
          notifications = JSON.parse(stored);
          // Clean old notifications (older than 7 days)
          const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
          notifications = notifications.filter(n => new Date(n.created_at).getTime() > sevenDaysAgo);
          saveNotificationsToLocalStorage();
        }
      } catch (e) {
        console.error('Failed to load notifications:', e);
        notifications = [];
      }
      recalculateUnreadCount();
    }

    // Add notification
    window.addNotification = function(type, data) {
      const notification = {
        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
        type,
        data,
        read: false,
        created_at: new Date().toISOString()
      };

      notifications.unshift(notification);

      // Limit to 50 notifications
      if (notifications.length > 50) {
        notifications = notifications.slice(0, 50);
      }

      saveNotificationsToLocalStorage();
      recalculateUnreadCount();
      renderNotifications();
      updateBadge();

      // Show brief animation
      const bellBtn = document.getElementById('notificationBellBtn');
      bellBtn.style.animation = 'none';
      setTimeout(() => bellBtn.style.animation = '', 10);
    };

    // Fetch notifications from backend
    async function fetchNotifications() {
      const wallet = localStorage.getItem('bearpark_wallet');
      if (!wallet) return;

      try {
        const response = await fetch(`${API_BASE}/api/notifications/${wallet}`);
        if (!response.ok) return;

        const data = await response.json();
        if (data.notifications && Array.isArray(data.notifications)) {
          // Create a signature for deduplication based on type + key data
          const getNotificationSignature = (n) => {
            const type = n.type;
            const d = n.data || {};
            // Create unique signature based on notification type and core data
            switch(type) {
              case 'follower':
                return `follower:${d.wallet}`;
              case 'like':
                return `like:${d.postId}:${d.wallet}`;
              case 'comment':
                return `comment:${d.postId}:${d.wallet}:${d.commentId || ''}`;
              case 'reply':
                return `reply:${d.postId}:${d.wallet}:${d.commentId || ''}`;
              case 'reaction':
                return `reaction:${d.commentId}:${d.wallet}:${d.reactionType || ''}`;
              case 'mention':
                return `mention:${d.postId}:${d.wallet}:${d.commentId || ''}`;
              default:
                return `${type}:${JSON.stringify(d)}`;
            }
          };

          // Build signature map of existing local notifications
          const existingSignatures = new Map();
          notifications.forEach(n => {
            existingSignatures.set(getNotificationSignature(n), n);
          });

          // Also track existing IDs for exact ID matches
          const existingIds = new Set(notifications.map(n => n.id));

          let changed = false;
          const newNotifications = [];

          for (const backendNotif of data.notifications) {
            const signature = getNotificationSignature(backendNotif);
            const existingBySignature = existingSignatures.get(signature);

            if (existingIds.has(backendNotif.id)) {
              // Exact ID match - skip, already have it
              continue;
            } else if (existingBySignature) {
              // Same notification exists locally with different ID (real-time vs backend)
              // Keep the local read status but update the ID to match backend
              if (existingBySignature.read) {
                // Mark the backend version as read too
                backendNotif.read = true;
              }
              // Update local notification to use backend ID (for consistency)
              existingBySignature.id = backendNotif.id;
              changed = true;
            } else {
              // Truly new notification from backend
              newNotifications.push(backendNotif);
              changed = true;
            }
          }

          if (newNotifications.length > 0) {
            notifications = [...newNotifications, ...notifications];
          }

          if (changed) {
            saveNotificationsToLocalStorage();
            recalculateUnreadCount();
            renderNotifications();
            updateBadge();
          }
        }
      } catch (error) {
        console.error('Failed to fetch notifications:', error);
      }
    }

    // Initialize
    loadNotificationsFromLocalStorage();
    renderNotifications();
    updateBadge();

    // Set up click event delegation on notification list (with delay to ensure DOM is ready)
    setTimeout(() => {
      const notificationListEl = document.getElementById('notificationList');
      console.log('üîß Setting up notification click listener on:', notificationListEl);
      if (notificationListEl) {
        notificationListEl.addEventListener('click', handleNotificationListClick);
        console.log('‚úÖ Notification click listener attached!');
      } else {
        console.error('‚ùå Could not find notificationList element!');
      }
    }, 500);

    // Poll for new notifications every 30 seconds
    IntervalManager.set('fetchNotifications', fetchNotifications, 30000); // Use IntervalManager to prevent memory leaks

    // Fetch immediately on load
    setTimeout(fetchNotifications, 2000);

    console.log('‚úÖ Notification system initialized');
  })();

  // Helper: Add follower notification when someone follows you
  window.addEventListener('followerAdded', (e) => {
    if (e.detail && e.detail.followerWallet && e.detail.targetWallet) {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      // Only show notification if someone followed YOU
      if (currentWallet === e.detail.targetWallet) {
        window.addNotification('follower', {
          wallet: e.detail.followerWallet,
          displayName: e.detail.displayName || null
        });
      }
    }
  });

  // Helper: Add reaction notification when someone reacts to your comment
  window.addEventListener('reactionAdded', (e) => {
    if (e.detail && e.detail.commentAuthor && e.detail.reactorWallet) {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      // Only show notification if someone reacted to YOUR comment
      if (currentWallet === e.detail.commentAuthor && currentWallet !== e.detail.reactorWallet) {
        window.addNotification('reaction', {
          wallet: e.detail.reactorWallet,
          displayName: e.detail.displayName || null,
          reactions: e.detail.reactions || [],
          commentText: e.detail.commentText || null
        });
      }
    }
  });

  </script>

  <!-- ===== COSMETICS STORE MODAL ===== -->
  <div id="storeModal" class="store-modal">
    <div class="store-modal-content">
      <div class="store-header">
        <div class="store-title-section">
          <h2 class="store-title">üçØ HONEY POINTS STORE</h2>
          <div class="store-subtitle">Unlock legendary cosmetics with your points</div>
        </div>
        <div class="store-balance-container">
          <div class="store-balance">
            <span class="hp-amount" id="storeHoneyBalance">0</span> <span style="font-size: 20px;">HP</span>
          </div>
          <button class="store-close-btn" onclick="closeStoreModal()">√ó</button>
        </div>
      </div>

      <div class="store-tabs">
        <div class="store-tab active" onclick="switchStoreTab('rings', event)">
          <span>üíç Profile Rings</span>
        </div>
        <div class="store-tab" onclick="switchStoreTab('banners', event)">
          <span>üé® Profile Banners</span>
        </div>
        <div class="store-tab" onclick="switchStoreTab('tokens', event)">
          <span>ü™ô Tokens</span>
        </div>
        <div class="store-tab" onclick="switchStoreTab('nfts', event)">
          <span>üñºÔ∏è NFT's</span>
        </div>
      </div>

      <div class="store-body">
        <div id="storeRingsGrid" class="store-grid"></div>
        <div id="storeBannersGrid" class="store-grid" style="display: none;"></div>
        <div id="storeTokensGrid" class="store-grid" style="display: none;"></div>
        <div id="storeNftsGrid" class="store-grid" style="display: none;"></div>
      </div>
    </div>
  </div>

  <!-- Inventory Modal -->
  <div id="inventoryModal" class="store-modal">
    <div class="store-modal-content">
      <div class="store-header" style="background:linear-gradient(135deg, #8b5cf6, #7c3aed);">
        <div class="store-title-section">
          <h2 class="store-title">üéí MY INVENTORY</h2>
          <div class="store-subtitle">Equip and manage your cosmetics</div>
        </div>
        <div class="store-balance-container">
          <button class="store-close-btn" onclick="closeInventoryModal()">√ó</button>
        </div>
      </div>

      <div class="store-tabs">
        <div class="store-tab active" onclick="switchInventoryTab('rings', event)">
          <span>üíç Profile Rings</span>
        </div>
        <div class="store-tab" onclick="switchInventoryTab('banners', event)">
          <span>üé® Profile Banners</span>
        </div>
      </div>

      <div class="store-body">
        <div id="inventoryRingsGrid" class="store-grid"></div>
        <div id="inventoryBannersGrid" class="store-grid" style="display: none;"></div>
        <div id="inventoryEmptyState" style="display:none; text-align:center; padding:60px 20px; color:#888;">
          <div style="font-size:48px; margin-bottom:20px;">üì¶</div>
          <div style="font-size:20px; font-weight:700; margin-bottom:10px;">Your inventory is empty</div>
          <div style="font-size:16px;">Visit the store to purchase cosmetics!</div>
        </div>
      </div>
    </div>
  </div>

  <!-- ===== MERCH STORE MODAL SYSTEM ===== -->
  <div id="merchStoreModal" class="store-modal">
    <div class="store-modal-content" style="max-width: 900px;">
      <!-- Screen 1: Product Gallery -->
      <div id="merchScreen-gallery" class="merch-screen">
        <div class="store-header" style="background:linear-gradient(135deg, #680cd9, #00ff88); padding: 12px 20px;">
          <div class="store-title-section">
            <h2 class="store-title">üëï BEAR MERCH</h2>
            <div class="store-subtitle">Rock your $BEAR pride with exclusive limited merch!</div>
          </div>
          <div class="store-balance-container" style="display:flex; align-items:center; gap:12px;">
            <button class="merch-cart-btn" onclick="openMerchCart()">
              üõí
              <span id="merchCartBadge" class="merch-cart-badge hidden">0</span>
            </button>
            <button class="store-close-btn" onclick="closeMerchStoreModal()">√ó</button>
          </div>
        </div>
        <div class="store-body" style="padding: 24px;">
          <div id="merchProductsGrid" class="merch-grid"></div>

          <!-- Prior Orders / Receipts Button -->
          <div style="text-align:center; margin-top:20px; padding-top:20px; border-top:1px solid rgba(255,255,255,0.1);">
            <button onclick="openMyReceiptsModal()" style="background:rgba(104,12,217,0.3); border:2px solid rgba(104,12,217,0.5); color:#fff; padding:12px 24px; border-radius:10px; font-size:14px; font-weight:600; cursor:pointer; display:inline-flex; align-items:center; gap:8px; transition:all 0.3s;" onmouseover="this.style.background='rgba(104,12,217,0.5)'; this.style.borderColor='#00ff88';" onmouseout="this.style.background='rgba(104,12,217,0.3)'; this.style.borderColor='rgba(104,12,217,0.5)';">
              üìã Prior Orders / Receipts
            </button>
            <div style="font-size:11px; color:#666; margin-top:8px;">View your purchase history & order status</div>
          </div>

          <div class="merch-privacy-notice">
            <span>üîí</span> All orders shipped discreetly. Your data is encrypted & never shared. We just need to know where to send your awesome merch! üì¶
          </div>
        </div>
      </div>

      <!-- Screen 2: Product Detail -->
      <div id="merchScreen-detail" class="merch-screen" style="display:none;">
        <div class="store-header" style="background:linear-gradient(135deg, #680cd9, #00ff88); padding: 12px 20px;">
          <div class="store-title-section" style="display:flex; align-items:center; gap:12px;">
            <button class="merch-back-btn" onclick="merchGoBack('gallery')">‚Üê Back</button>
            <h2 class="store-title" style="font-size:20px;">Product Details</h2>
          </div>
          <div class="store-balance-container" style="display:flex; align-items:center; gap:12px;">
            <button class="merch-cart-btn" onclick="openMerchCart()">
              üõí
              <span id="merchCartBadge2" class="merch-cart-badge hidden">0</span>
            </button>
            <button class="store-close-btn" onclick="closeMerchStoreModal()">√ó</button>
          </div>
        </div>
        <div class="store-body" style="padding: 24px;">
          <div class="merch-detail-layout">
            <div class="merch-detail-images">
              <div class="merch-main-image">
                <img id="merchDetailMainImg" src="" alt="Product">
              </div>
              <div class="merch-thumbnails" id="merchDetailThumbnails"></div>
            </div>
            <div class="merch-detail-info">
              <h2 id="merchDetailName" class="merch-product-name"></h2>
              <div class="merch-product-badge">‚≠ê Limited Edition</div>
              <div class="merch-price-section">
                <div class="merch-price-main">~<span id="merchXrpPrice">--</span> <span style="font-size:16px; opacity:0.8;">XRP</span></div>
                <div class="merch-price-xrp">or <span id="merchDetailPrice">$30.00</span> RLUSD (stablecoin)</div>
              </div>
              <div class="merch-size-section">
                <label>SELECT SIZE <span style="color:#ef4444;">*</span></label>
                <div class="merch-size-buttons" id="merchSizeButtons"></div>
              </div>
              <div class="merch-stock" id="merchDetailStock"></div>
              <button class="merch-buy-btn" id="merchAddToCartBtn" onclick="addToMerchCart()" disabled>
                üõí SELECT SIZE FIRST
              </button>
              <button class="merch-buy-btn" id="merchBuyNowBtn" onclick="merchProceedToDisclaimer()" disabled style="background:linear-gradient(135deg, #f59e0b, #ef4444); margin-top:10px; font-size:14px; padding:12px 20px;">
                ‚ö° BUY NOW (Skip Cart)
              </button>
              <div class="merch-description" id="merchDetailDesc"></div>
              <div class="merch-features">
                <div>‚Ä¢ 100% Premium Cotton</div>
                <div>‚Ä¢ Screen printed graphics</div>
                <div>‚Ä¢ Unisex sizing</div>
                <div>‚Ä¢ Machine washable</div>
              </div>
              <div class="merch-shipping-notice">
                üîí <strong>SHIPPING NOTICE</strong><br>
                When you purchase, you'll need to provide a shipping address. All personal data is 256-bit encrypted and stored securely. We ONLY use your info to ship your order - nothing else. Your privacy is sacred to us. üêª
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Screen 3: Shipping Disclaimer -->
      <div id="merchScreen-disclaimer" class="merch-screen" style="display:none;">
        <div class="store-header" style="background:linear-gradient(135deg, #680cd9, #00ff88); padding: 12px 20px;">
          <div class="store-title-section" style="display:flex; align-items:center; gap:12px;">
            <button class="merch-back-btn" onclick="merchGoBack('detail')">‚Üê Back</button>
            <h2 class="store-title" style="font-size:20px;">üì¶ Shipping Info Needed</h2>
          </div>
          <div class="store-balance-container">
            <button class="store-close-btn" onclick="closeMerchStoreModal()">√ó</button>
          </div>
        </div>
        <div class="store-body" style="padding: 40px; text-align:center;">
          <div class="merch-disclaimer-content">
            <div style="font-size:64px; margin-bottom:20px;">üì¶</div>
            <h3 style="font-size:24px; margin-bottom:16px; color:#fff;">Shipping Information Required</h3>
            <p style="font-size:16px; color:#ccc; margin-bottom:24px; line-height:1.6;">
              To complete your purchase, we'll need your shipping address so we know where to send your awesome merch!
            </p>
            <div class="merch-privacy-box">
              <h4>üîê YOUR PRIVACY MATTERS</h4>
              <ul>
                <li>All data is 256-bit AES encrypted</li>
                <li>Information is ONLY used for shipping</li>
                <li>We NEVER sell or share your data</li>
                <li>You can request deletion anytime</li>
              </ul>
            </div>
            <p style="font-size:14px; color:#888; margin-top:20px;">
              By continuing, you agree to provide accurate shipping information for order fulfillment.
            </p>
            <div class="merch-disclaimer-buttons">
              <button class="merch-btn-primary" onclick="merchGoToShipping()">‚úì OK, LET'S GO!</button>
              <button class="merch-btn-secondary" onclick="merchGoBack('detail')">‚úï NO THANKS</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Screen 4: Shipping Form -->
      <div id="merchScreen-shipping" class="merch-screen" style="display:none;">
        <div class="store-header" style="background:linear-gradient(135deg, #680cd9, #00ff88); padding: 12px 20px;">
          <div class="store-title-section" style="display:flex; align-items:center; gap:12px;">
            <button class="merch-back-btn" onclick="merchGoBack('disclaimer')">‚Üê Back</button>
            <h2 class="store-title" style="font-size:20px;">üì¶ Shipping Info</h2>
          </div>
          <div class="store-balance-container">
            <button class="store-close-btn" onclick="closeMerchStoreModal()">√ó</button>
          </div>
        </div>
        <div class="store-body" style="padding: 24px; max-height: 70vh; overflow-y: auto;">
          <form id="merchShippingForm" class="merch-shipping-form">
            <div class="merch-form-group">
              <label>üë§ FULL NAME <span class="required">*</span></label>
              <input type="text" id="merchShipName" placeholder="John Doe" required>
            </div>
            <div class="merch-form-group">
              <label>üåç COUNTRY <span class="required">*</span></label>
              <select id="merchShipCountry" onchange="merchUpdateCountryFields()">
                <option value="US" selected>üá∫üá∏ United States</option>
                <option value="CA" disabled>üá®üá¶ Canada (Coming Soon)</option>
                <option value="UK" disabled>üá¨üáß United Kingdom (Coming Soon)</option>
                <option value="AU" disabled>üá¶üá∫ Australia (Coming Soon)</option>
              </select>
              <small style="color:#888;">‚ÑπÔ∏è Currently shipping to US only. More countries coming soon!</small>
            </div>
            <div class="merch-form-group">
              <label>üè† STREET ADDRESS <span class="required">*</span></label>
              <input type="text" id="merchShipStreet" placeholder="123 Bear Street" required>
            </div>
            <div class="merch-form-group">
              <label>üè¢ APT/SUITE/UNIT (Optional)</label>
              <input type="text" id="merchShipApt" placeholder="Apt 4B">
            </div>
            <div class="merch-form-row">
              <div class="merch-form-group">
                <label>üèôÔ∏è CITY <span class="required">*</span></label>
                <input type="text" id="merchShipCity" placeholder="Miami" required>
              </div>
              <div class="merch-form-group">
                <label>üó∫Ô∏è STATE <span class="required">*</span></label>
                <select id="merchShipState" required>
                  <option value="">Select State</option>
                  <option value="AL">Alabama</option><option value="AK">Alaska</option><option value="AZ">Arizona</option>
                  <option value="AR">Arkansas</option><option value="CA">California</option><option value="CO">Colorado</option>
                  <option value="CT">Connecticut</option><option value="DE">Delaware</option><option value="FL">Florida</option>
                  <option value="GA">Georgia</option><option value="HI">Hawaii</option><option value="ID">Idaho</option>
                  <option value="IL">Illinois</option><option value="IN">Indiana</option><option value="IA">Iowa</option>
                  <option value="KS">Kansas</option><option value="KY">Kentucky</option><option value="LA">Louisiana</option>
                  <option value="ME">Maine</option><option value="MD">Maryland</option><option value="MA">Massachusetts</option>
                  <option value="MI">Michigan</option><option value="MN">Minnesota</option><option value="MS">Mississippi</option>
                  <option value="MO">Missouri</option><option value="MT">Montana</option><option value="NE">Nebraska</option>
                  <option value="NV">Nevada</option><option value="NH">New Hampshire</option><option value="NJ">New Jersey</option>
                  <option value="NM">New Mexico</option><option value="NY">New York</option><option value="NC">North Carolina</option>
                  <option value="ND">North Dakota</option><option value="OH">Ohio</option><option value="OK">Oklahoma</option>
                  <option value="OR">Oregon</option><option value="PA">Pennsylvania</option><option value="RI">Rhode Island</option>
                  <option value="SC">South Carolina</option><option value="SD">South Dakota</option><option value="TN">Tennessee</option>
                  <option value="TX">Texas</option><option value="UT">Utah</option><option value="VT">Vermont</option>
                  <option value="VA">Virginia</option><option value="WA">Washington</option><option value="WV">West Virginia</option>
                  <option value="WI">Wisconsin</option><option value="WY">Wyoming</option><option value="DC">Washington D.C.</option>
                </select>
              </div>
            </div>
            <div class="merch-form-group" style="max-width:200px;">
              <label>üìÆ ZIP CODE <span class="required">*</span></label>
              <input type="text" id="merchShipZip" placeholder="33101" pattern="[0-9]{5}(-[0-9]{4})?" required>
            </div>
            <button type="button" class="merch-btn-primary" onclick="merchValidateAndContinue()" style="width:100%; margin-top:20px;">
              ‚û°Ô∏è CONTINUE TO REVIEW
            </button>
          </form>
        </div>
      </div>

      <!-- Screen 5: Address Confirmation -->
      <div id="merchScreen-confirm" class="merch-screen" style="display:none;">
        <div class="store-header" style="background:linear-gradient(135deg, #680cd9, #00ff88); padding: 12px 20px;">
          <div class="store-title-section" style="display:flex; align-items:center; gap:12px;">
            <button class="merch-back-btn" onclick="merchGoBack('shipping')">‚Üê Back</button>
            <h2 class="store-title" style="font-size:20px;">‚úÖ Confirm Address</h2>
          </div>
          <div class="store-balance-container">
            <button class="store-close-btn" onclick="closeMerchStoreModal()">√ó</button>
          </div>
        </div>
        <div class="store-body" style="padding: 24px;">
          <p style="color:#ccc; margin-bottom:20px;">Please verify your shipping address is correct:</p>
          <div class="merch-confirm-box">
            <div class="merch-confirm-label">üì¶ SHIPPING TO:</div>
            <div id="merchConfirmAddress" class="merch-confirm-address"></div>
            <button class="merch-edit-btn" onclick="merchGoBack('shipping')">‚úèÔ∏è EDIT ADDRESS</button>
          </div>
          <div class="merch-order-summary">
            <div class="merch-summary-title">üõí ORDER SUMMARY</div>
            <div id="merchConfirmItems"></div>
            <div class="merch-summary-row">
              <span>Shipping</span>
              <span style="color:#22c55e;">FREE</span>
            </div>
            <div class="merch-summary-divider"></div>
            <div class="merch-summary-row merch-summary-total">
              <span>TOTAL</span>
              <span id="merchConfirmTotal">$30.00</span>
            </div>
          </div>
          <p style="color:#f59e0b; font-size:14px; margin:20px 0;">
            ‚ö†Ô∏è Once confirmed, your address cannot be changed. Double-check everything is correct!
          </p>
          <button class="merch-btn-primary" onclick="merchGoToPayment()" style="width:100%;">
            üí≥ PROCEED TO PAYMENT
          </button>
        </div>
      </div>

      <!-- Screen 6: Payment Selection -->
      <div id="merchScreen-payment" class="merch-screen" style="display:none;">
        <div class="store-header" style="background:linear-gradient(135deg, #680cd9, #00ff88); padding: 12px 20px;">
          <div class="store-title-section" style="display:flex; align-items:center; gap:12px;">
            <button class="merch-back-btn" onclick="merchGoBack('confirm')">‚Üê Back</button>
            <h2 class="store-title" style="font-size:20px;">üí≥ Payment</h2>
          </div>
          <div class="store-balance-container">
            <button class="store-close-btn" onclick="closeMerchStoreModal()">√ó</button>
          </div>
        </div>
        <div class="store-body" style="padding: 24px;">
          <!-- Cart Items Preview -->
          <div id="merchPaymentCartItems" style="margin-bottom:20px; max-height:200px; overflow-y:auto;"></div>

          <p style="color:#ccc; margin-bottom:20px;">Choose your payment method:</p>
          <div class="merch-payment-options">
            <label class="merch-payment-option" id="merchPayXRP">
              <input type="radio" name="merchPayment" value="XRP" checked>
              <div class="merch-payment-content">
                <div class="merch-payment-title">‚ö° PAY WITH XRP</div>
                <div class="merch-payment-amount">~<span id="merchPaymentXrpAmount">--</span> XRP (<span id="merchXrpUsdEquiv">$30.00</span> USD)</div>
                <div class="merch-payment-rate">üìä Live rate: 1 XRP = $<span id="merchXrpRate">--</span></div>
                <div class="merch-payment-refresh">üîÑ Rate refreshes in <span id="merchRateTimer">30</span>s</div>
                <div class="merch-payment-note" style="color:#f59e0b;">‚ö†Ô∏è XRP auto-converts to RLUSD at purchase</div>
              </div>
            </label>
            <label class="merch-payment-option" id="merchPayRLUSD">
              <input type="radio" name="merchPayment" value="RLUSD">
              <div class="merch-payment-content">
                <div class="merch-payment-title">üíµ PAY WITH RLUSD</div>
                <div class="merch-payment-amount"><span id="merchRlusdPayAmount">$30.00</span> RLUSD (Stablecoin)</div>
                <div class="merch-payment-note">‚úì Exact amount, no price fluctuation</div>
              </div>
            </label>
          </div>
          <div class="merch-payment-info">
            <strong>‚ÑπÔ∏è PAYMENT INFO</strong><br>
            Choose your preferred wallet to complete payment. Make sure you have sufficient balance.<br><br>
            If paying with XRP, it will be instantly swapped to RLUSD to lock in the USD value.
          </div>

          <!-- Wallet Selection -->
          <div style="margin-top:20px;">
            <p style="color:#00ff88; font-weight:600; margin-bottom:12px;">SELECT WALLET:</p>
            <div style="display:flex; gap:12px; flex-wrap:wrap;">
              <button class="merch-wallet-btn" id="walletXaman" onclick="selectMerchWallet('xaman')" style="flex:1; min-width:140px; padding:15px; border-radius:12px; border:2px solid #680cd9; background:linear-gradient(135deg, rgba(104,12,217,0.2), rgba(104,12,217,0.1)); color:#fff; cursor:pointer; transition:all 0.3s;">
                <div style="font-size:28px; margin-bottom:8px;">üì±</div>
                <div style="font-weight:700; font-size:16px;">XAMAN</div>
                <div style="font-size:11px; color:#888; margin-top:4px;">(formerly XUMM)</div>
              </button>
              <button class="merch-wallet-btn" id="walletJoey" onclick="selectMerchWallet('joey')" style="flex:1; min-width:140px; padding:15px; border-radius:12px; border:2px solid #f59e0b; background:linear-gradient(135deg, rgba(245,158,11,0.2), rgba(245,158,11,0.1)); color:#fff; cursor:pointer; transition:all 0.3s;">
                <div style="font-size:28px; margin-bottom:8px;">ü¶ò</div>
                <div style="font-weight:700; font-size:16px;">JOEY</div>
                <div style="font-size:11px; color:#888; margin-top:4px;">Wallet</div>
              </button>
            </div>
          </div>

          <button class="merch-btn-primary" id="merchFinalPayBtn" onclick="merchCompletePurchase()" style="width:100%; margin-top:20px;" disabled>
            üîê SELECT A WALLET ABOVE
          </button>
        </div>
      </div>

      <!-- Screen 7: Order Success -->
      <div id="merchScreen-success" class="merch-screen" style="display:none;">
        <div class="store-header" style="background:linear-gradient(135deg, #22c55e, #16a34a);">
          <div class="store-title-section">
            <h2 class="store-title">üéâ ORDER CONFIRMED!</h2>
          </div>
          <div class="store-balance-container">
            <button class="store-close-btn" onclick="closeMerchStoreModal()">√ó</button>
          </div>
        </div>
        <div class="store-body" style="padding: 30px; text-align:center;">
          <div style="font-size:60px; margin-bottom:15px;">‚úÖ</div>
          <h3 style="font-size:22px; color:#22c55e; margin-bottom:20px;">Your order has been placed successfully!</h3>

          <!-- Receipt Box -->
          <div id="merchReceiptBox" class="merch-success-box" style="text-align:left; background:rgba(0,0,0,0.4); border:2px solid rgba(34,197,94,0.3);">
            <div style="text-align:center; margin-bottom:15px; padding-bottom:15px; border-bottom:2px dashed rgba(255,255,255,0.2);">
              <div style="font-size:24px; font-weight:900; color:#00ff88;">BEAR PARK</div>
              <div style="font-size:11px; color:#888; margin-top:5px;">OFFICIAL MERCH RECEIPT</div>
            </div>
            <div class="merch-success-row">
              <span>ORDER #:</span>
              <span id="merchOrderNumber" style="font-family:monospace; color:#00ff88;">BEAR-2024-XXXXXX</span>
            </div>
            <div class="merch-success-row">
              <span>Date:</span>
              <span id="merchOrderDate" style="color:#ccc;">--</span>
            </div>
            <div class="merch-success-divider"></div>
            <div class="merch-success-row">
              <span>Item:</span>
              <span id="merchOrderItem">Product (Size)</span>
            </div>
            <div class="merch-success-row">
              <span>Total Paid:</span>
              <span id="merchOrderTotal" style="color:#00ff88; font-weight:700;">$30.00</span>
            </div>
            <div class="merch-success-row">
              <span>Payment:</span>
              <span id="merchOrderPayment" style="color:#ccc;">RLUSD</span>
            </div>
            <div class="merch-success-row">
              <span>Status:</span>
              <span style="color:#f59e0b; font-weight:600;">‚è≥ Processing</span>
            </div>
            <div class="merch-success-divider"></div>
            <div style="color:#ccc; font-size:13px;">
              <strong style="color:#fff;">üì¶ Shipping to:</strong><br>
              <span id="merchOrderAddress" style="line-height:1.6;"></span>
            </div>
            <div class="merch-success-divider"></div>
            <div style="text-align:center; font-size:11px; color:#666;">
              Thank you for supporting BEAR Park!
            </div>
          </div>

          <!-- Save Receipt Button -->
          <button onclick="saveMerchReceipt()" style="background:linear-gradient(135deg, #680cd9, #8b5cf6); color:#fff; border:none; padding:12px 24px; border-radius:10px; font-size:14px; font-weight:600; cursor:pointer; margin-top:20px; display:inline-flex; align-items:center; gap:8px;">
            üì• SAVE RECEIPT (Screenshot This!)
          </button>

          <p style="color:#888; margin:15px 0 5px; font-size:12px;">üí° Take a screenshot of this receipt for your records!</p>
          <p style="color:#888; margin:5px 0; font-size:12px;">You can also view your orders anytime in "My Receipts"</p>
          <p style="color:#ccc; margin:15px 0;">üì¶ Estimated shipping: 5-10 business days</p>

          <!-- Support Contact Info -->
          <div style="background:rgba(104,12,217,0.2); border:2px solid rgba(104,12,217,0.4); border-radius:12px; padding:15px; margin-top:20px; text-align:center;">
            <div style="font-size:14px; font-weight:700; color:#fff; margin-bottom:10px;">‚ùì Questions or Issues?</div>
            <div style="font-size:13px; color:#ccc; line-height:1.8;">
              <div>üê¶ <strong style="color:#00c3ff;">@APEX_589</strong> on X (Twitter)</div>
              <div>üí¨ <strong style="color:#7c3aed;">cryptoapex</strong> on Discord</div>
            </div>
          </div>

          <div style="display:flex; gap:10px; margin-top:25px; justify-content:center; flex-wrap:wrap;">
            <button class="merch-btn-primary" onclick="openMyReceiptsModal()" style="background:rgba(104,12,217,0.3); border:2px solid #680cd9;">
              üìã VIEW MY RECEIPTS
            </button>
            <button class="merch-btn-primary" onclick="closeMerchStoreModal()">
              üêª BACK TO BEAR PARK
            </button>
          </div>
        </div>
      </div>

      <!-- Screen 8: Processing / Payment Instructions -->
      <div id="merchScreen-processing" class="merch-screen" style="display:none;">
        <div class="store-header" style="background:linear-gradient(135deg, #680cd9, #00ff88); padding: 12px 20px;">
          <div class="store-title-section">
            <h2 class="store-title" id="merchProcessingTitle">Processing...</h2>
          </div>
        </div>
        <div class="store-body" style="padding: 30px; text-align:center;" id="merchProcessingBody">
          <!-- Initial spinner state -->
          <div id="merchSpinnerSection">
            <div class="merch-spinner"></div>
            <h3 style="font-size:20px; color:#fff; margin-top:30px;" id="merchProcessingText">Creating order...</h3>
          </div>

          <!-- Payment instructions (hidden initially) -->
          <div id="merchPaymentInstructions" style="display:none;">
            <div style="background: rgba(0,255,136,0.1); border: 2px solid #00ff88; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
              <h3 style="color:#00ff88; margin:0 0 15px 0; font-size:18px;">üí∞ Send Payment</h3>
              <p style="color:#fff; margin:5px 0;">Send <strong id="merchPayAmount" style="color:#00ff88; font-size:20px;">0</strong> <strong id="merchPayCurrency" style="color:#00ff88;">RLUSD</strong></p>
              <p style="color:#888; font-size:12px; margin-top:5px;">Order: <span id="merchPayOrderNum">BEAR-000000</span></p>
            </div>

            <div style="background: rgba(255,255,255,0.05); border-radius: 12px; padding: 20px; margin-bottom: 15px;">
              <p style="color:#888; margin:0 0 8px 0; font-size:12px;">DESTINATION ADDRESS</p>
              <div style="display:flex; align-items:center; gap:10px;">
                <code id="merchPayAddress" style="flex:1; background:rgba(0,0,0,0.3); padding:10px; border-radius:8px; font-size:11px; color:#fff; word-break:break-all; text-align:left;">rBEARKfWJS1LYdg2g6t99BgbvpWY5pgMB9</code>
                <button onclick="copyToClipboard(document.getElementById('merchPayAddress').textContent, this)" style="background:#680cd9; color:#fff; border:none; padding:8px 15px; border-radius:8px; cursor:pointer; font-size:12px;">Copy</button>
              </div>
            </div>

            <div style="background: rgba(255,136,0,0.1); border: 2px solid #ff8800; border-radius: 12px; padding: 15px; margin-bottom: 20px;">
              <p style="color:#ff8800; margin:0 0 8px 0; font-size:14px; font-weight:bold;">‚ö†Ô∏è IMPORTANT: Include Destination Tag!</p>
              <div style="display:flex; align-items:center; gap:10px; justify-content:center;">
                <span style="color:#fff; font-size:14px;">Tag:</span>
                <code id="merchPayTag" style="background:rgba(0,0,0,0.3); padding:10px 20px; border-radius:8px; font-size:24px; color:#ff8800; font-weight:bold;">000000</code>
                <button onclick="copyToClipboard(document.getElementById('merchPayTag').textContent, this)" style="background:#ff8800; color:#000; border:none; padding:8px 15px; border-radius:8px; cursor:pointer; font-size:12px; font-weight:bold;">Copy</button>
              </div>
            </div>

            <p style="color:#888; font-size:13px; margin-bottom:15px;">Open XAMAN wallet and send payment manually using the details above.</p>

            <div style="margin-top:20px;">
              <div class="merch-spinner" style="width:30px; height:30px; border-width:3px; margin:0 auto;"></div>
              <p style="color:#00ff88; margin-top:10px; font-size:14px;">Watching for your payment...</p>
              <p style="color:#666; font-size:11px;">Payment will be detected automatically</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Bulletin Post Detail Modal -->
  <div id="bulletinPostModal" class="bulletin-post-modal" style="display:none;">
    <div class="bulletin-modal-overlay" onclick="closeBulletinPostModal()"></div>
    <div class="bulletin-modal-content">
      <div class="bulletin-modal-header">
        <h3 class="bulletin-modal-title">Bulletin Post</h3>
        <button class="bulletin-close-btn" onclick="closeBulletinPostModal()">&times;</button>
      </div>
      <div class="bulletin-modal-body">
        <!-- Post Content -->
        <div id="bulletinPostDetail" class="bulletin-post-detail"></div>

        <!-- Comments Section -->
        <div class="bulletin-comments-section">
          <h4 class="comments-title">üí¨ Comments</h4>

          <!-- Comment Input -->
          <div class="comment-input-container">
            <textarea
              id="commentInput"
              class="comment-input"
              placeholder="Add a comment..."
              maxlength="500"
              rows="2"
            ></textarea>
            <button class="btn-post-comment" onclick="postComment()">Post Comment</button>
          </div>

          <!-- Comments List -->
          <div id="commentsList" class="comments-list">
            <div class="loading">Loading comments...</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Celebration Overlay -->
  <div id="celebrationOverlay" class="celebration-overlay">
    <div class="celebration-content">
      <div class="celebration-icon" id="celebrationIcon"></div>
      <div class="celebration-text" id="celebrationText"></div>
      <div class="celebration-subtext" id="celebrationSubtext"></div>
    </div>
  </div>

  <script>
    // ===== BEAR BULLETIN BOARD JAVASCRIPT =====
    let currentPostId = null;
    let bulletinPosts = [];
    const BULLETIN_DEMO_MODE = false; // Using Supabase backend
    let isAdminOrModerator = false; // Will be set after checking admin status

    // State storage for bulletin like buttons
    const bulletinButtonStates = new Map();

    function getBulletinButtonState(btn) {
      if (!bulletinButtonStates.has(btn)) {
        bulletinButtonStates.set(btn, {
          longPressTimer: null,
          picker: null,
          currentHoveredItem: null,
          selectedReaction: null,
          pickerShown: false
        });
      }
      return bulletinButtonStates.get(btn);
    }

    // Build nested comment tree from flat array (bulletin version)
    function buildBulletinCommentTree(comments) {
      const commentMap = {};
      const rootComments = [];

      // First pass: create map of all comments
      comments.forEach(comment => {
        commentMap[comment.id] = { ...comment, children: [] };
      });

      // Second pass: build tree structure
      comments.forEach(comment => {
        if (comment.parent_id && commentMap[comment.parent_id]) {
          commentMap[comment.parent_id].children.push(commentMap[comment.id]);
        } else {
          rootComments.push(commentMap[comment.id]);
        }
      });

      return rootComments;
    }

    // Toggle collapse/expand thread (bulletin version)
    window.toggleBulletinThread = function(commentId) {
      const threadElement = document.querySelector(`.bulletin-comment-thread[data-comment-id="${commentId}"]`);
      if (!threadElement) return;

      const repliesContainer = threadElement.querySelector('.bulletin-comment-replies');
      const toggleIcon = threadElement.querySelector('.bulletin-toggle-icon');

      if (!repliesContainer) return;

      if (repliesContainer.style.display === 'none') {
        repliesContainer.style.display = 'block';
        toggleIcon.textContent = '‚ñº';
        threadElement.classList.remove('collapsed');
      } else {
        repliesContainer.style.display = 'none';
        toggleIcon.textContent = '‚ñ∂';
        threadElement.classList.add('collapsed');
      }
    };

    // Open profile modal and highlight bulletin input
    function openPostBulletinHighlight() {
      // Open the profile modal
      openProfileModal();

      // Wait for modal to open, then highlight the bulletin input
      setTimeout(() => {
        const bulletinContainer = document.querySelector('.bulletin-post-input-container');
        const bulletinInput = document.getElementById('bulletinPostInput');

        if (bulletinContainer && bulletinInput) {
          // Add highlight animation
          bulletinContainer.style.cssText = `
            animation: highlightPulse 2s ease-in-out 3;
            box-shadow: 0 0 30px rgba(237, 183, 35, 0.8), 0 0 60px rgba(237, 183, 35, 0.6);
            border: 3px solid #edb723 !important;
          `;

          // Scroll to bulletin input
          bulletinInput.scrollIntoView({ behavior: 'smooth', block: 'center' });

          // Focus the input
          bulletinInput.focus();

          // Remove highlight after animation
          setTimeout(() => {
            bulletinContainer.style.animation = '';
            bulletinContainer.style.boxShadow = '';
            bulletinContainer.style.border = '';
          }, 6000);
        }
      }, 300);
    }

    // Check if current user is admin or moderator
    async function checkAdminStatus() {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        isAdminOrModerator = false;
        return;
      }

      try {
        const response = await fetch(`${API_BASE_URL}/api/admin/check-role/${currentWallet}`);
        if (response.ok) {
          const data = await response.json();
          isAdminOrModerator = data.is_moderator || data.is_admin || data.is_master || false;

          if (isAdminOrModerator) {
            console.log(`üõ°Ô∏è User has ${data.role?.role || 'admin'} privileges - can moderate bulletin board`);
          }
        } else {
          isAdminOrModerator = false;
        }
      } catch (error) {
        console.error('Error checking admin status:', error);
        isAdminOrModerator = false;
      }
    }

    // Load bulletin feed
    async function loadBulletinFeed() {
      const feed = document.getElementById('bulletinFeed');

      // Check admin status before loading feed
      await checkAdminStatus();

      try {
        if (BULLETIN_DEMO_MODE) {
          // Load from localStorage in demo mode
          const stored = localStorage.getItem('bearpark_bulletin_posts');
          bulletinPosts = stored ? JSON.parse(stored) : [];
          bulletinPosts.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
        } else {
          const response = await fetch(`${API_BASE_URL}/api/bulletin/posts`);
          if (!response.ok) throw new Error('Failed to load posts');
          bulletinPosts = await response.json();
        }

        if (bulletinPosts.length === 0) {
          feed.innerHTML = `
            <div style="text-align:center; padding:60px 20px; color:rgba(255,255,255,0.5);">
              <div style="margin-bottom:20px;"><img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/25ekkd.png" alt="BEARpark" style="height:100px; width:auto;"></div>
              <div style="font-size:20px; font-weight:700; margin-bottom:10px;">No posts yet!</div>
              <div style="font-size:16px;">Be the first BEAR to share something!</div>
            </div>
          `;
          return;
        }

        // Fetch equipped cosmetics for all post authors
        const walletAddresses = [...new Set(bulletinPosts.map(p => p.wallet_address))];
        const equippedCosmetics = {};

        await Promise.all(walletAddresses.map(async (wallet) => {
          try {
            const cosmeticRes = await fetch(`${API_BASE_URL}/api/cosmetics/equipped/${wallet}`);
            const cosmeticData = await cosmeticRes.json();
            if (cosmeticData.success && cosmeticData.equipped) {
              equippedCosmetics[wallet] = cosmeticData.equipped;
            }
          } catch (e) {
            // Ignore errors for individual users
          }
        }));

        feed.innerHTML = bulletinPosts.map(post => createPostCard(post, equippedCosmetics)).join('');
      } catch (error) {
        console.error('Error loading bulletin feed:', error);
        feed.innerHTML = `
          <div style="text-align:center; padding:40px 20px; color:#ff6b6b;">
            <div style="font-size:24px; margin-bottom:12px;">‚ö†Ô∏è</div>
            <div>Failed to load posts. Please try again later.</div>
          </div>
        `;
      }
    }

    // Create post card HTML
    // Convert URLs in text to clickable links
    function linkifyText(text) {
      // First escape HTML for security
      const escaped = escapeHtml(text);
      // Then convert URLs to clickable links
      const urlRegex = /(https?:\/\/[^\s<]+)/g;
      return escaped.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer" onclick="event.stopPropagation()" class="bulletin-link">$1</a>');
    }

    // Helper function to parse avatar JSONB data
    function getAvatarUrl(authorAvatar) {
      if (!authorAvatar) return 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png';

      try {
        const avatarData = typeof authorAvatar === 'string' ? JSON.parse(authorAvatar) : authorAvatar;
        return avatarData.imageUrl || avatarData.fallbackImageUrl || 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png';
      } catch (e) {
        return 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png';
      }
    }

    function createPostCard(post, equippedCosmetics) {
      const timeAgo = getTimeAgo(post.created_at);
      const linkPreview = post.link_preview ? createLinkPreview(post.link_preview) : '';
      const currentWallet = localStorage.getItem('bearpark_wallet');
      const isOwner = currentWallet && post.wallet_address === currentWallet;
      const avatarUrl = getAvatarUrl(post.author_avatar);

      // Get equipped ring for this post author
      const equippedRing = equippedCosmetics && equippedCosmetics[post.wallet_address]?.ring || null;

      // Calculate total reaction count
      const reactionCount = post.reaction_count || 0;

      return `
        <div class="bulletin-post-card" onclick="openBulletinPost(${post.id})">
          <div class="bulletin-post-header">
            <div class="bulletin-post-avatar-container">
              <img
                src="${avatarUrl}"
                alt="${post.author_name}"
                class="bulletin-post-avatar"
                onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png';"
              />
              ${equippedRing ? `<img src="${equippedRing.image_url}" class="bulletin-post-cosmetic-ring ${equippedRing.ring_type}" alt="${equippedRing.name}" style="${equippedRing.rarity === 'bearableguy123' ? 'animation: spinRingImage 3s linear infinite !important;' : ''}">` : ''}
            </div>
            <div class="bulletin-post-info">
              <div class="bulletin-post-author">${escapeHtml(post.author_name)}</div>
              <div class="bulletin-post-time">${timeAgo}</div>
            </div>
            ${isOwner ? `
              <button class="bulletin-delete-btn" onclick="event.stopPropagation(); deletePost(${post.id})" title="Delete post">
                üóëÔ∏è
              </button>
            ` : ''}
          </div>
          <div class="bulletin-post-content">${linkifyText(post.content)}</div>
          ${linkPreview}
          <div class="bulletin-post-footer">
            ${reactionCount > 0 ? `
              <div class="bulletin-post-stat">
                ‚ù§Ô∏è ${reactionCount} ${reactionCount === 1 ? 'reaction' : 'reactions'}
              </div>
            ` : ''}
            <div class="bulletin-post-stat">
              üí¨ ${post.comment_count || 0} ${post.comment_count === 1 ? 'comment' : 'comments'}
            </div>
          </div>
        </div>
      `;
    }

    // Create link preview HTML (Twitter/X style)
    function createLinkPreview(preview) {
      if (!preview || !preview.url) return '';

      const isYouTube = preview.type === 'youtube';
      const hostname = new URL(preview.url).hostname.replace('www.', '');

      return `
        <div class="bulletin-post-link-preview ${isYouTube ? 'youtube-preview' : ''}" onclick="event.stopPropagation(); window.open('${escapeHtml(preview.url)}', '_blank')">
          ${preview.image ? `
            <div class="bulletin-post-link-image-container">
              <img src="${escapeHtml(preview.image)}" alt="" class="bulletin-post-link-image" onerror="this.style.display='none'">
              ${isYouTube ? '<div class="youtube-play-overlay">‚ñ∂</div>' : ''}
            </div>
          ` : ''}
          <div class="bulletin-post-link-info">
            <div class="bulletin-post-link-title">${escapeHtml(preview.title || 'Link')}</div>
            ${preview.description ? `<div class="bulletin-post-link-description">${escapeHtml(preview.description)}</div>` : ''}
            <div class="bulletin-post-link-url">
              üîó ${escapeHtml(hostname)}
            </div>
          </div>
        </div>
      `;
    }

    // Post to bulletin board
    async function postToBulletin() {
      const input = document.getElementById('bulletinPostInput');
      const button = document.getElementById('postToBulletinBtn');
      const content = input.value.trim();

      if (!content) {
        showBulletinNotification('‚ö†Ô∏è Please enter some content to post!', 'warning');
        return;
      }

      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        showBulletinNotification('‚ö†Ô∏è Please connect your wallet first!', 'warning');
        return;
      }

      button.disabled = true;
      button.textContent = 'Posting...';

      try {
        // Check if content contains URLs
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        const urls = content.match(urlRegex);
        let linkPreview = null;

        if (urls && urls.length > 0 && !BULLETIN_DEMO_MODE) {
          // Fetch link preview for the first URL (not in demo mode)
          try {
            const previewResponse = await fetch(`${API_BASE_URL}/api/link-preview?url=${encodeURIComponent(urls[0])}`);
            if (previewResponse.ok) {
              linkPreview = await previewResponse.json();
              console.log('‚úÖ Link preview fetched:', linkPreview);
            }
          } catch (e) {
            console.log('‚ùå Link preview failed, continuing without it:', e);
          }
        }

        let newPost;

        if (BULLETIN_DEMO_MODE) {
          // Demo mode: save to localStorage
          // Get profile from localStorage or fetch from API
          let authorName = 'Anonymous BEAR';
          let authorAvatar = 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png';

          // Try to get from current session first
          const cachedProfile = localStorage.getItem(`bearpark_profile_${currentWallet}`);
          console.log('üêª Loading profile for wallet:', currentWallet);
          console.log('üíæ Cached profile:', cachedProfile);

          if (cachedProfile) {
            try {
              const profileData = JSON.parse(cachedProfile);
              // Handle nested structure from API (profile.profile.display_name)
              const profile = profileData.profile || profileData;
              authorName = profile.display_name || 'Anonymous BEAR';

              // Parse avatar_nft JSON to get imageUrl
              if (profile.avatar_nft) {
                try {
                  const avatarData = typeof profile.avatar_nft === 'string'
                    ? JSON.parse(profile.avatar_nft)
                    : profile.avatar_nft;
                  authorAvatar = avatarData.imageUrl || avatarData.fallbackImageUrl || 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png';
                } catch (e) {
                  console.log('Failed to parse avatar_nft, using default');
                  authorAvatar = 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png';
                }
              } else {
                authorAvatar = profile.avatar_url || 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png';
              }

              console.log('‚úÖ Using cached profile:', { authorName, authorAvatar });
            } catch (e) {
              console.log('‚ùå Failed to parse cached profile:', e);
            }
          } else {
            // Fetch from API
            console.log('üì° No cached profile, fetching from API...');
            try {
              const apiUrl = window.location.hostname === 'localhost' ? 'http://localhost:3000' : '';
              const profileResponse = await fetch(`${apiUrl}/api/profile/${currentWallet}`);
              if (profileResponse.ok) {
                const profileData = await profileResponse.json();
                const profile = profileData.profile || profileData;
                authorName = profile.display_name || 'Anonymous BEAR';

                // Parse avatar_nft JSON to get imageUrl
                if (profile.avatar_nft) {
                  try {
                    const avatarData = typeof profile.avatar_nft === 'string'
                      ? JSON.parse(profile.avatar_nft)
                      : profile.avatar_nft;
                    authorAvatar = avatarData.imageUrl || avatarData.fallbackImageUrl || 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png';
                  } catch (e) {
                    authorAvatar = 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png';
                  }
                } else {
                  authorAvatar = profile.avatar_url || profile.profile_picture || 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png';
                }

                // Cache it
                localStorage.setItem(`bearpark_profile_${currentWallet}`, JSON.stringify(profileData));
                console.log('‚úÖ Fetched and cached profile:', { authorName, authorAvatar });
              }
            } catch (e) {
              console.log('‚ùå Failed to fetch profile, using defaults:', e);
            }
          }

          // Generate link preview for demo mode using microlink.io
          if (urls && urls.length > 0) {
            try {
              const previewUrl = `https://api.microlink.io/?url=${encodeURIComponent(urls[0])}`;
              const previewResponse = await fetch(previewUrl);
              if (previewResponse.ok) {
                const previewData = await previewResponse.json();
                if (previewData.status === 'success' && previewData.data) {
                  linkPreview = {
                    url: urls[0],
                    title: previewData.data.title || urls[0],
                    description: previewData.data.description || 'Click to open link',
                    image: previewData.data.image?.url || previewData.data.logo?.url || null
                  };
                }
              }
            } catch (e) {
              console.log('Link preview fetch failed, using simple preview');
              linkPreview = {
                url: urls[0],
                title: urls[0],
                description: 'Click to open link',
                image: null
              };
            }
          }

          newPost = {
            id: Date.now().toString(),
            wallet_address: currentWallet,
            author_name: authorName,
            author_avatar: authorAvatar,
            content: content,
            link_preview: linkPreview,
            created_at: new Date().toISOString(),
            comment_count: 0
          };

          const stored = localStorage.getItem('bearpark_bulletin_posts');
          const posts = stored ? JSON.parse(stored) : [];
          posts.unshift(newPost);
          localStorage.setItem('bearpark_bulletin_posts', JSON.stringify(posts));

          // Also initialize comments storage for this post
          localStorage.setItem(`bearpark_bulletin_comments_${newPost.id}`, JSON.stringify([]));
        } else {
          const response = await fetch(`${API_BASE_URL}/api/bulletin/posts`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              wallet_address: currentWallet,
              content: content,
              link_preview: linkPreview
            })
          });

          if (!response.ok) throw new Error('Failed to create post');
          newPost = await response.json();
        }

        // Clear input
        input.value = '';

        // Reload feed
        await loadBulletinFeed();

        showBulletinNotification('Your post is now on the bulletin board!', 'success');

        // Scroll bulletin board into view
        const bulletinSection = document.getElementById('bulletin-board');
        if (bulletinSection) {
          bulletinSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      } catch (error) {
        console.error('Error posting to bulletin:', error);
        showBulletinNotification('‚ùå Failed to post. Please try again.', 'error');
      } finally {
        button.disabled = false;
        button.textContent = 'üì¢ Post to Bulletin Board';
      }
    }

    // Open bulletin post modal
    // Make openBulletinPost globally accessible for notifications
    window.openBulletinPost = async function(postId, scrollToCommentId = null) {
      currentPostId = postId;
      const modal = document.getElementById('bulletinPostModal');
      const detailContainer = document.getElementById('bulletinPostDetail');
      const commentsContainer = document.getElementById('commentsList');

      if (!modal) {
        console.error('‚ùå Bulletin post modal not found - bulletin board may not be initialized');
        return;
      }

      modal.style.display = 'flex';
      document.body.style.overflow = 'hidden';

      // If bulletinPosts is empty, load it first
      if (bulletinPosts.length === 0) {
        console.log('üì• Bulletin posts not loaded yet, loading now...');
        await loadBulletinFeed();
      }

      // Find the post
      const post = bulletinPosts.find(p => p.id === postId);
      if (!post) {
        detailContainer.innerHTML = '<div class="loading">Post not found</div>';
        return;
      }

      // Render post detail
      const timeAgo = getTimeAgo(post.created_at);
      const linkPreview = post.link_preview ? createLinkPreview(post.link_preview) : '';
      const avatarUrl = getAvatarUrl(post.author_avatar);

      // Fetch equipped cosmetics for post author
      let equippedRing = null;
      try {
        const cosmeticRes = await fetch(`${API_BASE_URL}/api/cosmetics/equipped/${post.wallet_address}`);
        const cosmeticData = await cosmeticRes.json();
        if (cosmeticData.success && cosmeticData.equipped) {
          equippedRing = cosmeticData.equipped.ring || null;
        }
      } catch (e) {
        // Ignore errors
      }

      detailContainer.innerHTML = `
        <div class="bulletin-post-header">
          <div class="bulletin-post-avatar-container">
            <img
              src="${avatarUrl}"
              alt="${post.author_name}"
              class="bulletin-post-avatar"
              onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png';"
            />
            ${equippedRing ? `<img src="${equippedRing.image_url}" class="bulletin-post-cosmetic-ring ${equippedRing.ring_type}" alt="${equippedRing.name}" style="${equippedRing.rarity === 'bearableguy123' ? 'animation: spinRingImage 3s linear infinite !important;' : ''}">` : ''}
          </div>
          <div class="bulletin-post-info">
            <div class="bulletin-post-author">${escapeHtml(post.author_name)}</div>
            <div class="bulletin-post-time">${timeAgo}</div>
          </div>
        </div>
        <div class="bulletin-post-content">${linkifyText(post.content)}</div>
        ${linkPreview}
        <div id="postReactionContainer" style="margin-top: 20px; padding-top: 16px; border-top: 1px solid rgba(237, 183, 35, 0.2);">
          <div id="postReactionSummary" style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 12px;"></div>
          <div class="comment-actions">
            <button class="like-button" id="postLikeButton" data-post-id="${postId}">
              <span class="like-emoji">üëç</span>
              <span>Like</span>
              ${generatePostReactionPicker(postId)}
            </button>
          </div>
        </div>
      `;

      // Load post reactions
      await loadPostReactions(postId);

      // Attach post reaction listener
      attachPostReactionListener();

      // Load comments
      await loadComments(postId);

      // Scroll to specific comment if provided (from notification)
      if (scrollToCommentId) {
        setTimeout(() => {
          const commentThread = document.querySelector(`.bulletin-comment-thread[data-comment-id="${scrollToCommentId}"]`);
          if (commentThread) {
            // If this is a reply, we need to expand all parent threads first
            if (commentThread.classList.contains('is-reply')) {
              // Find all ancestor reply containers and expand them
              let currentElement = commentThread.parentElement;
              while (currentElement && currentElement !== modal) {
                if (currentElement.classList.contains('bulletin-comment-replies')) {
                  // This is a replies container - make sure it's visible
                  if (currentElement.style.display === 'none') {
                    currentElement.style.display = 'block';
                    // Update the toggle icon
                    const parentThread = currentElement.parentElement;
                    if (parentThread) {
                      const toggleIcon = parentThread.querySelector('.bulletin-toggle-icon');
                      if (toggleIcon) {
                        toggleIcon.textContent = '‚ñº';
                      }
                      parentThread.classList.remove('collapsed');
                    }
                  }
                }
                currentElement = currentElement.parentElement;
              }
            }

            // Now scroll to the comment
            setTimeout(() => {
              const modalBody = modal.querySelector('.bulletin-modal-body');
              if (modalBody) {
                const commentTop = commentThread.offsetTop;
                modalBody.scrollTo({
                  top: commentTop - 100,
                  behavior: 'smooth'
                });
                // Add gold glow highlight effect
                commentThread.style.backgroundColor = 'rgba(237, 183, 35, 0.3)';
                commentThread.style.boxShadow = '0 0 20px rgba(237, 183, 35, 0.5)';
                commentThread.style.transition = 'all 0.3s ease';
                setTimeout(() => {
                  commentThread.style.backgroundColor = '';
                  commentThread.style.boxShadow = '';
                }, 2500);
              }
            }, 200);
          } else {
            console.warn('‚ö†Ô∏è Comment not found:', scrollToCommentId);
          }
        }, 500);
      }
    }

    // Close bulletin post modal
    function closeBulletinPostModal() {
      const modal = document.getElementById('bulletinPostModal');
      modal.style.display = 'none';
      document.body.style.overflow = '';
      currentPostId = null;
    }

    // Load reactions for the bulletin post
    async function loadPostReactions(postId) {
      try {
        const response = await fetch(`${API_BASE_URL}/api/bulletin/posts/${postId}/reactions`);
        if (!response.ok) return;

        const data = await response.json();
        updatePostReactionSummary(postId, data);
      } catch (error) {
        console.error('Error loading post reactions:', error);
      }
    }

    // Update post reaction summary display
    function updatePostReactionSummary(postId, reactionsData) {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      const userReactions = reactionsData.userReactions?.[currentWallet] || [];
      const counts = reactionsData.counts || {};

      const summaryContainer = document.getElementById('postReactionSummary');
      if (!summaryContainer) return;

      // Generate reaction pills
      const reactionTypes = [
        { type: 'like', emoji: 'üëç' },
        { type: 'laugh', emoji: 'üòÇ' },
        { type: 'heart', emoji: '‚ù§Ô∏è' },
        { type: 'cry', emoji: 'üò¢' },
        { type: 'thumbs_down', emoji: 'üëé' },
        { type: 'troll', emoji: 'ü§°' }
      ];

      const pills = reactionTypes
        .filter(({ type }) => counts[type] > 0)
        .map(({ type, emoji }) => {
          const isUserReaction = userReactions.includes(type);
          const clickHandler = `togglePostReaction(${postId}, '${type}')`;
          return `
            <div class="reaction-pill ${isUserReaction ? 'user-reacted' : ''}"
                 data-post-id="${postId}"
                 data-reaction-type="${type}"
                 onclick="${clickHandler}">
              <span class="pill-emoji">${emoji}</span>
              <span class="pill-count">${counts[type]}</span>
            </div>
          `;
        }).join('');

      summaryContainer.innerHTML = pills;

      // Update like button state
      const likeButton = document.getElementById('postLikeButton');
      if (likeButton && userReactions.length > 0) {
        likeButton.classList.add('reacted');
      } else if (likeButton) {
        likeButton.classList.remove('reacted');
      }
    }

    // Generate reaction picker for post
    function generatePostReactionPicker(postId) {
      const reactionTypes = [
        { type: 'like', emoji: 'üëç', label: 'Like' },
        { type: 'laugh', emoji: 'üòÇ', label: 'Laugh' },
        { type: 'heart', emoji: '‚ù§Ô∏è', label: 'Love' },
        { type: 'cry', emoji: 'üò¢', label: 'Sad' },
        { type: 'thumbs_down', emoji: 'üëé', label: 'Dislike' },
        { type: 'troll', emoji: 'ü§°', label: 'Troll' }
      ];

      const items = reactionTypes.map(({ type, emoji, label }) => `
        <div class="reaction-picker-item" data-reaction-type="${type}" data-label="${label}">
          ${emoji}
        </div>
      `).join('');

      return `<div class="reaction-picker" data-post-id="${postId}">${items}</div>`;
    }

    // Toggle reaction on the post
    window.togglePostReaction = async function(postId, reactionType) {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        showBulletinNotification('‚ö†Ô∏è Please connect your wallet first!', 'warning');
        return;
      }

      try {
        const response = await fetch(`${API_BASE_URL}/api/bulletin/posts/${postId}/react`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet_address: currentWallet,
            reaction_type: reactionType
          })
        });

        const result = await response.json();

        if (response.ok && result.success) {
          // Update UI with new counts
          updatePostReactionSummary(postId, {
            counts: result.counts || {},
            userReactions: result.userReactions || {}
          });
        }
      } catch (error) {
        console.error('Error toggling post reaction:', error);
        showBulletinNotification('‚ùå Failed to add reaction.', 'error');
      }
    };

    // Attach event listeners to post reaction button using delegation (like comments)
    function attachPostReactionListener() {
      const postReactionContainer = document.getElementById('postReactionContainer');
      if (!postReactionContainer || postReactionContainer.dataset.likeListenersAttached) return;

      postReactionContainer.dataset.likeListenersAttached = 'true';

      const buttonState = {
        longPressTimer: null,
        pickerShown: false,
        selectedReaction: null,
        currentHoveredItem: null,
        picker: null
      };

      function showPicker() {
        const btn = document.getElementById('postLikeButton');
        if (!btn) return;
        buttonState.picker = btn.querySelector('.reaction-picker');
        if (buttonState.picker) {
          buttonState.picker.classList.add('visible');
          buttonState.pickerShown = true;
          if (navigator.vibrate) navigator.vibrate(10);
        }
      }

      function hidePicker() {
        if (buttonState.picker) {
          buttonState.picker.classList.remove('visible');
          buttonState.pickerShown = false;
          const items = buttonState.picker.querySelectorAll('.reaction-picker-item');
          items.forEach(item => { item.style.transform = ''; item.style.filter = ''; });
        }
      }

      function getEmojiAtTouch(picker, touch) {
        const pickerItems = picker?.querySelectorAll('.reaction-picker-item');
        if (!pickerItems) return null;

        for (const item of pickerItems) {
          const rect = item.getBoundingClientRect();
          if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
              touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
            return item;
          }
        }
        return null;
      }

      function updateHoveredEmoji(touch) {
        if (!buttonState.picker || !buttonState.pickerShown) return;

        const hoveredItem = getEmojiAtTouch(buttonState.picker, touch);

        if (hoveredItem !== buttonState.currentHoveredItem) {
          if (buttonState.currentHoveredItem) {
            buttonState.currentHoveredItem.style.transform = '';
            buttonState.currentHoveredItem.style.filter = '';
          }
          if (hoveredItem) {
            hoveredItem.style.transform = 'scale(1.8) translateY(-12px)';
            hoveredItem.style.filter = 'drop-shadow(0 8px 20px rgba(237,183,35,0.8))';
            if (navigator.vibrate) navigator.vibrate(5);
            buttonState.selectedReaction = hoveredItem.getAttribute('data-reaction-type');
          } else {
            buttonState.selectedReaction = null;
          }
          buttonState.currentHoveredItem = hoveredItem;
        }
      }

      // Mousedown - start long press timer
      postReactionContainer.addEventListener('mousedown', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        buttonState.longPressTimer = setTimeout(() => showPicker(), 300);
      });

      // Mouseup - clear timer
      postReactionContainer.addEventListener('mouseup', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        clearTimeout(buttonState.longPressTimer);
      });

      // Mouseleave - clear timer but keep picker open
      postReactionContainer.addEventListener('mouseleave', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        clearTimeout(buttonState.longPressTimer);
      }, true);

      // Click - quick like or picker item selection
      postReactionContainer.addEventListener('click', async (e) => {
        // Check if clicked on picker item first
        const pickerItem = e.target.closest('.reaction-picker-item');
        if (pickerItem) {
          e.stopPropagation();
          const btn = e.target.closest('.like-button');
          if (btn) {
            const reactionType = pickerItem.getAttribute('data-reaction-type');
            const postId = btn.getAttribute('data-post-id');
            await togglePostReaction(postId, reactionType);
            hidePicker();
          }
          return;
        }

        // Otherwise check if clicked on button itself
        const btn = e.target.closest('.like-button');
        if (!btn) return;

        buttonState.picker = btn.querySelector('.reaction-picker');
        if (!buttonState.picker || !buttonState.picker.classList.contains('visible')) {
          const postId = btn.getAttribute('data-post-id');
          await togglePostReaction(postId, 'like');
        }
      });

      // Touchstart - start long press (faster on mobile: 150ms)
      postReactionContainer.addEventListener('touchstart', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        e.preventDefault();
        buttonState.selectedReaction = null;
        buttonState.currentHoveredItem = null;
        // Add visual feedback that hold is in progress
        btn.style.transform = 'scale(0.95)';
        buttonState.longPressTimer = setTimeout(() => {
          btn.style.transform = '';
          showPicker();
        }, 150);
      }, { passive: false });

      // Touchmove - slide to select emoji
      postReactionContainer.addEventListener('touchmove', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;

        if (!buttonState.pickerShown) {
          clearTimeout(buttonState.longPressTimer);
          return;
        }

        e.preventDefault();
        const touch = e.touches[0];
        updateHoveredEmoji(touch);
      }, { passive: false });

      // Touchend - complete reaction
      postReactionContainer.addEventListener('touchend', async (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        clearTimeout(buttonState.longPressTimer);
        btn.style.transform = '';
        buttonState.picker = btn.querySelector('.reaction-picker');

        if (buttonState.pickerShown && buttonState.selectedReaction) {
          const postId = btn.getAttribute('data-post-id');
          await togglePostReaction(postId, buttonState.selectedReaction);
          if (navigator.vibrate) navigator.vibrate([10, 20, 10]);
          hidePicker();
          buttonState.selectedReaction = null;
          buttonState.currentHoveredItem = null;
        } else if (!buttonState.pickerShown) {
          const postId = btn.getAttribute('data-post-id');
          await togglePostReaction(postId, 'like');
        } else {
          hidePicker();
        }
      });
    }

    // Load comments for a post (USING TREE STRUCTURE AND ASYNC RENDERING)
    async function loadComments(postId) {
      console.log('üì• Loading bulletin comments for post:', postId);

      const commentsSection = document.querySelector('.bulletin-comments-section');
      if (!commentsSection) {
        console.error('‚ùå Comments section not found');
        return;
      }

      // Clear ALL previous content (comments, empty state, loading)
      const allDivs = Array.from(commentsSection.children).filter(el =>
        el.id !== 'commentInput' && !el.classList.contains('comment-input-container') && !el.classList.contains('comments-title')
      );
      allDivs.forEach(el => el.remove());

      // Show loading state
      commentsSection.insertAdjacentHTML('beforeend', '<div class="loading">Loading comments...</div>');

      try {
        // Fetch comments from Supabase API
        const response = await fetch(`${API_BASE_URL}/api/bulletin/posts/${postId}/comments`);
        if (!response.ok) throw new Error('Failed to load comments');
        const comments = await response.json();

        // Remove loading indicator
        document.querySelectorAll('.loading').forEach(el => el.remove());

        if (comments.length === 0) {
          console.log('üìù No comments found for this post');
          commentsSection.insertAdjacentHTML('beforeend', `
            <div style="text-align:center; padding:40px 20px; color:rgba(255,255,255,0.5);">
              <div style="font-size:32px; margin-bottom:12px;">üí¨</div>
              <div style="font-size:16px;">No comments yet. Be the first!</div>
            </div>
          `);
          return;
        }

        console.log('‚úÖ Building comment tree from', comments.length, 'comments');

        // Build nested tree structure
        const commentTree = buildBulletinCommentTree(comments);
        console.log('üå≥ Comment tree built with', commentTree.length, 'root comments');

        // Render root comments and their replies recursively
        for (const rootComment of commentTree) {
          const commentHTML = await renderBulletinComment(rootComment, 0, null);
          commentsSection.insertAdjacentHTML('beforeend', commentHTML);

          // Render nested replies
          if (rootComment.children && rootComment.children.length > 0) {
            await renderBulletinReplies(rootComment.children, rootComment.id, 1, rootComment);
          }
        }

        console.log('üí• Rendered all bulletin comments with nested replies');

        // Attach event listeners for like buttons (only once)
        attachBulletinLikeListeners();

      } catch (error) {
        console.error('‚ùå Error loading bulletin comments:', error);
        document.querySelectorAll('.loading').forEach(el => el.remove());
        commentsSection.insertAdjacentHTML('beforeend', `
          <div style="text-align:center; padding:20px; color:#ff6b6b;">
            Failed to load comments. Please try again.
          </div>
        `);
      }
    }

    // ===== BULLETIN REACTION SYSTEM (IDENTICAL to profile modal) =====

    // Load reactions for a bulletin comment
    async function loadBulletinCommentReactions(commentId) {
      try {
        const response = await fetch(`${API_BASE_URL}/api/bulletin/comments/${commentId}/reactions`);
        if (!response.ok) return { counts: {}, userReactions: {} };

        const data = await response.json();
        return data;
      } catch (error) {
        console.error('Error loading bulletin reactions:', error);
        return { counts: {}, userReactions: {} };
      }
    }

    // Generate reaction summary pills for bulletin comments
    function generateBulletinReactionSummary(commentId, reactions, userReactions = []) {
      const counts = reactions.counts || {};
      const hasCounts = Object.keys(counts).some(key => counts[key] > 0);

      if (!hasCounts) return '';

      const reactionTypes = [
        { type: 'like', emoji: 'üëç' },
        { type: 'laugh', emoji: 'üòÇ' },
        { type: 'heart', emoji: '‚ù§Ô∏è' },
        { type: 'cry', emoji: 'üò¢' },
        { type: 'thumbs_down', emoji: 'üëé' },
        { type: 'troll', emoji: 'ü§°' }
      ];

      const pills = reactionTypes
        .filter(({ type }) => counts[type] > 0)
        .map(({ type, emoji }) => {
          const isUserReaction = userReactions.includes(type);
          // If user already reacted, clicking removes it. Otherwise, clicking adds it.
          const clickHandler = isUserReaction
            ? `removeBulletinReaction(${commentId}, '${type}', this)`
            : `toggleBulletinReaction(${commentId}, '${type}')`;
          return `
            <div class="reaction-pill ${isUserReaction ? 'user-reacted' : ''}"
                 data-comment-id="${commentId}"
                 data-reaction-type="${type}"
                 onclick="${clickHandler}">
              <span class="pill-emoji">${emoji}</span>
              <span class="pill-count">${counts[type]}</span>
            </div>
          `;
        }).join('');

      return `<div class="reaction-summary">${pills}</div>`;
    }

    // Generate reaction picker for bulletin comments
    function generateBulletinReactionPicker(commentId) {
      const reactionTypes = [
        { type: 'like', emoji: 'üëç', label: 'Like' },
        { type: 'laugh', emoji: 'üòÇ', label: 'Laugh' },
        { type: 'heart', emoji: '‚ù§Ô∏è', label: 'Love' },
        { type: 'cry', emoji: 'üò¢', label: 'Sad' },
        { type: 'thumbs_down', emoji: 'üëé', label: 'Dislike' },
        { type: 'troll', emoji: 'ü§°', label: 'Troll' }
      ];

      const items = reactionTypes.map(({ type, emoji, label }) => `
        <div class="reaction-picker-item" data-reaction-type="${type}" data-label="${label}">
          ${emoji}
        </div>
      `).join('');

      return `<div class="reaction-picker" data-comment-id="${commentId}">${items}</div>`;
    }

    // ===== BULLETIN EVENT DELEGATION FOR LIKE BUTTONS =====

    function showBulletinPicker(btn) {
      const state = getBulletinButtonState(btn);
      state.picker = btn.querySelector('.reaction-picker');
      if (state.picker) {
        state.picker.classList.add('visible');
        state.pickerShown = true;
        if (navigator.vibrate) navigator.vibrate(10);
      }
    }

    function hideBulletinPicker(btn) {
      const state = getBulletinButtonState(btn);
      if (state.picker) {
        state.picker.classList.remove('visible');
        state.pickerShown = false;
        const items = state.picker.querySelectorAll('.reaction-picker-item');
        items.forEach(item => { item.style.transform = ''; });
      }
    }

    function getBulletinEmojiAtTouch(picker, touch) {
      const pickerItems = picker?.querySelectorAll('.reaction-picker-item');
      if (!pickerItems) return null;

      for (const item of pickerItems) {
        const rect = item.getBoundingClientRect();
        if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
            touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
          return item;
        }
      }
      return null;
    }

    function updateBulletinHoveredEmoji(btn, touch) {
      const state = getBulletinButtonState(btn);
      if (!state.picker || !state.pickerShown) return;

      const hoveredItem = getBulletinEmojiAtTouch(state.picker, touch);

      if (hoveredItem !== state.currentHoveredItem) {
        if (state.currentHoveredItem) {
          state.currentHoveredItem.style.transform = '';
        }
        if (hoveredItem) {
          hoveredItem.style.transform = 'scale(1.8) translateY(-12px)';
          hoveredItem.style.filter = 'drop-shadow(0 8px 20px rgba(237,183,35,0.8))';
          if (navigator.vibrate) navigator.vibrate(5);
          state.selectedReaction = hoveredItem.getAttribute('data-reaction-type');
        } else {
          state.selectedReaction = null;
        }
        state.currentHoveredItem = hoveredItem;
      }
    }

    // Attach event listeners to bulletin comments section using delegation
    function attachBulletinLikeListeners() {
      const bulletinCommentsSection = document.querySelector('.bulletin-comments-section');
      if (!bulletinCommentsSection || bulletinCommentsSection.dataset.likeListenersAttached) return;

      bulletinCommentsSection.dataset.likeListenersAttached = 'true';

      // Mousedown - start long press timer
      bulletinCommentsSection.addEventListener('mousedown', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getBulletinButtonState(btn);
        state.longPressTimer = setTimeout(() => showBulletinPicker(btn), 300);
      });

      // Mouseup - clear timer
      bulletinCommentsSection.addEventListener('mouseup', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getBulletinButtonState(btn);
        clearTimeout(state.longPressTimer);
      });

      // Mouseleave - clear timer but keep picker open
      bulletinCommentsSection.addEventListener('mouseleave', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getBulletinButtonState(btn);
        clearTimeout(state.longPressTimer);
      }, true);

      // Click - quick like or picker item selection
      bulletinCommentsSection.addEventListener('click', async (e) => {
        // Check if clicked on picker item first
        const pickerItem = e.target.closest('.reaction-picker-item');
        if (pickerItem) {
          e.stopPropagation();
          const btn = e.target.closest('.like-button');
          if (btn) {
            const reactionType = pickerItem.getAttribute('data-reaction-type');
            const commentId = btn.getAttribute('data-comment-id');
            await toggleBulletinReaction(commentId, reactionType);
            hideBulletinPicker(btn);
          }
          return;
        }

        // Otherwise check if clicked on button itself
        const btn = e.target.closest('.like-button');
        if (!btn) return;

        const state = getBulletinButtonState(btn);
        state.picker = btn.querySelector('.reaction-picker');
        if (!state.picker || !state.picker.classList.contains('visible')) {
          const commentId = btn.getAttribute('data-comment-id');
          await toggleBulletinReaction(commentId, 'like');
        }
      });

      // Touchstart - start long press (faster on mobile: 150ms)
      bulletinCommentsSection.addEventListener('touchstart', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        e.preventDefault();
        const state = getBulletinButtonState(btn);
        state.selectedReaction = null;
        state.currentHoveredItem = null;
        // Add visual feedback that hold is in progress
        btn.style.transform = 'scale(0.95)';
        state.longPressTimer = setTimeout(() => {
          btn.style.transform = '';
          showBulletinPicker(btn);
        }, 150);
      }, { passive: false });

      // Touchmove - slide to select emoji
      bulletinCommentsSection.addEventListener('touchmove', (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getBulletinButtonState(btn);

        if (!state.pickerShown) {
          clearTimeout(state.longPressTimer);
          return;
        }

        e.preventDefault();
        const touch = e.touches[0];
        updateBulletinHoveredEmoji(btn, touch);
      }, { passive: false });

      // Touchend - complete reaction
      bulletinCommentsSection.addEventListener('touchend', async (e) => {
        const btn = e.target.closest('.like-button');
        if (!btn) return;
        const state = getBulletinButtonState(btn);
        clearTimeout(state.longPressTimer);
        btn.style.transform = '';
        state.picker = btn.querySelector('.reaction-picker');

        if (state.pickerShown && state.selectedReaction) {
          const commentId = btn.getAttribute('data-comment-id');
          await toggleBulletinReaction(commentId, state.selectedReaction);
          if (navigator.vibrate) navigator.vibrate([10, 20, 10]);
          hideBulletinPicker(btn);
          state.selectedReaction = null;
          state.currentHoveredItem = null;
        } else if (!state.pickerShown) {
          const commentId = btn.getAttribute('data-comment-id');
          await toggleBulletinReaction(commentId, 'like');
        } else {
          hideBulletinPicker(btn);
        }
      });
    }

    // ===== BULLETIN REPLY FUNCTIONALITY =====

    // Open Reply Box for bulletin comments
    window.openBulletinReplyBox = function(commentId) {
      // Close any other open reply boxes
      document.querySelectorAll('.reply-box').forEach(box => {
        box.classList.remove('visible');
      });

      // Find the comment thread
      const threadElement = document.querySelector(`.bulletin-comment-thread[data-comment-id="${commentId}"]`);
      if (!threadElement) return;

      const commentContent = threadElement.querySelector('.comment-content');
      let replyBox = commentContent.querySelector('.reply-box');

      if (!replyBox) {
        // Create reply box
        const replyBoxHTML = `
          <div class="reply-box visible" data-parent-id="${commentId}">
            <textarea placeholder="Write a reply..." maxlength="500"></textarea>
            <div class="reply-box-actions">
              <button class="reply-cancel-btn" onclick="closeBulletinReplyBox(${commentId})">Cancel</button>
              <button class="reply-submit-btn" onclick="submitBulletinReply(${commentId})">Reply</button>
            </div>
          </div>
        `;
        commentContent.insertAdjacentHTML('beforeend', replyBoxHTML);
        replyBox = commentContent.querySelector('.reply-box');

        // Focus textarea
        setTimeout(() => {
          const textarea = replyBox.querySelector('textarea');
          textarea.focus();
        }, 100);
      } else {
        replyBox.classList.add('visible');
        setTimeout(() => {
          const textarea = replyBox.querySelector('textarea');
          textarea.focus();
        }, 100);
      }
    };

    // Close Reply Box for bulletin comments
    window.closeBulletinReplyBox = function(commentId) {
      const threadElement = document.querySelector(`.bulletin-comment-thread[data-comment-id="${commentId}"]`);
      if (!threadElement) return;

      const replyBox = threadElement.querySelector('.reply-box');
      if (replyBox) {
        replyBox.classList.remove('visible');
        replyBox.querySelector('textarea').value = '';
      }
    };

    // Submit Reply for bulletin comments
    window.submitBulletinReply = async function(parentCommentId) {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        showBulletinNotification('‚ö†Ô∏è Please connect your wallet first!', 'warning');
        return;
      }

      const threadElement = document.querySelector(`.bulletin-comment-thread[data-comment-id="${parentCommentId}"]`);
      if (!threadElement) return;

      const replyBox = threadElement.querySelector('.reply-box');
      const textarea = replyBox.querySelector('textarea');
      const replyText = textarea.value.trim();

      if (!replyText) {
        showBulletinNotification('‚ö†Ô∏è Please enter a reply!', 'warning');
        return;
      }

      try {
        // Backend will fetch author info from profiles table automatically
        const response = await fetch(`${API_BASE_URL}/api/bulletin/comments`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            post_id: currentPostId,
            wallet_address: currentWallet,
            content: replyText,
            parent_id: parentCommentId
          })
        });

        if (response.ok) {
          closeBulletinReplyBox(parentCommentId);
          await loadComments(currentPostId);
          showBulletinNotification('‚úÖ Reply posted!', 'success');
        } else {
          showBulletinNotification('‚ùå Failed to post reply.', 'error');
        }
      } catch (error) {
        console.error('Error posting reply:', error);
        showBulletinNotification('‚ùå Error posting reply. Please try again.', 'error');
      }
    };

    // ===== BULLETIN REACTION API FUNCTIONS =====

    // Prevent double-clicking reactions
    const bulletinReactionLocks = new Set();

    // Toggle reaction on bulletin comment
    window.toggleBulletinReaction = async function(commentId, reactionType) {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        showBulletinNotification('‚ö†Ô∏è Please connect your wallet first!', 'warning');
        return;
      }

      // Create unique lock key for this specific reaction
      const lockKey = `${commentId}-${reactionType}`;

      // If already processing this reaction, ignore
      if (bulletinReactionLocks.has(lockKey)) {
        console.log('‚è≥ Already processing this reaction, ignoring duplicate request');
        return;
      }

      // Lock this reaction
      bulletinReactionLocks.add(lockKey);

      try {
        const response = await fetch(`${API_BASE_URL}/api/bulletin/comments/${commentId}/react`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet_address: currentWallet,
            reaction_type: reactionType
          })
        });

        let result;
        try {
          result = await response.json();
        } catch (parseError) {
          console.error('‚ùå Failed to parse response JSON:', parseError);
          console.error('‚ùå Response status:', response.status, response.statusText);
          showBulletinNotification('‚ùå Server error - invalid response', 'error');
          return;
        }

        if (response.ok && result.success) {
          console.log('‚úÖ toggleBulletinReaction Backend confirmed:', result.action);
          console.log('üì¶ Backend returned updated counts:', result.counts);
          console.log('üì¶ Backend returned user reactions:', result.userReactions);

          // Use the fresh data directly from backend response (no fetching needed!)
          updateBulletinCommentReactionsWithData(commentId, {
            counts: result.counts || {},
            userReactions: result.userReactions || {}
          });
        } else {
          console.error('‚ùå toggleBulletinReaction Backend error:', result);
          console.error('‚ùå Response status:', response.status);
          console.error('‚ùå Failed request: commentId=' + commentId + ', reactionType=' + reactionType);
          // Don't show alert for duplicate errors (user probably double-clicked)
          if (!result.error?.includes('duplicate key')) {
            showBulletinNotification('‚ùå Failed to toggle reaction: ' + (result.error || 'Unknown error'), 'error');
          }
        }
      } catch (error) {
        console.error('Error toggling bulletin reaction:', error);
        showBulletinNotification('‚ùå Error adding reaction.', 'error');
      } finally {
        // Unlock after a short delay
        setTimeout(() => bulletinReactionLocks.delete(lockKey), 500);
      }
    };

    // Remove reaction from bulletin comment
    window.removeBulletinReaction = async function(commentId, reactionType, pillElement) {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        showBulletinNotification('‚ö†Ô∏è Please connect your wallet first!', 'warning');
        return;
      }

      console.log('üóëÔ∏è REMOVING bulletin reaction:', reactionType, 'from comment', commentId);

      // Add the removing animation
      pillElement.classList.add('removing');

      // Haptic feedback
      if (navigator.vibrate) {
        navigator.vibrate([5, 10, 5]);
      }

      try {
        const response = await fetch(`${API_BASE_URL}/api/bulletin/comments/${commentId}/react`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet_address: currentWallet,
            reaction_type: reactionType
          })
        });

        const result = await response.json();
        console.log('üì° Backend response:', result);

        if (response.ok && result.success) {
          console.log('‚úÖ Backend confirmed:', result.action);
          console.log('üì¶ Backend returned updated counts:', result.counts);
          console.log('üì¶ Backend returned user reactions:', result.userReactions);

          // Use the fresh data directly from backend response (no fetching needed!)
          setTimeout(() => {
            console.log('‚è∞ Animation complete, updating UI with backend data...');
            // Update UI directly with the counts from backend response
            updateBulletinCommentReactionsWithData(commentId, {
              counts: result.counts || {},
              userReactions: result.userReactions || {}
            });
          }, 400); // Match animation duration
        } else {
          console.error('‚ùå Backend error:', result);
          pillElement.classList.remove('removing');
          showBulletinNotification('‚ùå Failed to remove reaction: ' + (result.error || 'Unknown error'), 'error');
        }
      } catch (error) {
        pillElement.classList.remove('removing');
        console.error('Error removing bulletin reaction:', error);
        showBulletinNotification('‚ùå Error removing reaction: ' + error.message, 'error');
      }
    };

    // Update bulletin comment reactions using data directly (no fetch needed)
    function updateBulletinCommentReactionsWithData(commentId, reactionsData) {
      try {
        const currentWallet = localStorage.getItem('bearpark_wallet');
        const userReactions = reactionsData.userReactions?.[currentWallet] || [];

        console.log('üîÑ Updating bulletin reactions UI for comment', commentId);
        console.log('üìä Reaction counts:', reactionsData.counts);
        console.log('üë§ User reactions:', userReactions);

        // Find the comment element (data-comment-id is on .bulletin-comment-thread, not .comment-item)
        const commentThread = document.querySelector(`.bulletin-comment-thread[data-comment-id="${commentId}"]`);
        if (!commentThread) return;
        const commentElement = commentThread.querySelector('.comment-item');
        if (!commentElement) return;

        const commentContent = commentElement.querySelector('.comment-content');
        const commentActions = commentContent.querySelector('.comment-actions');
        let existingReactionSummary = commentContent.querySelector('.reaction-summary');

        // Generate the new reaction summary HTML
        const newReactionHTML = generateBulletinReactionSummary(commentId, reactionsData, userReactions);

        console.log('üé® New reaction HTML:', newReactionHTML ? 'Generated' : 'Empty (no reactions)');

        if (existingReactionSummary) {
          // If there's an existing summary and new HTML, replace it
          if (newReactionHTML) {
            existingReactionSummary.outerHTML = newReactionHTML;
          } else {
            // No reactions left, remove the summary
            existingReactionSummary.remove();
          }
        } else if (newReactionHTML) {
          // No existing summary but we have reactions, insert before actions
          commentActions.insertAdjacentHTML('beforebegin', newReactionHTML);
        }

        // Update the like button state
        const likeButton = commentElement.querySelector('.like-button');
        if (likeButton) {
          if (userReactions.length > 0) {
            likeButton.classList.add('reacted');
          } else {
            likeButton.classList.remove('reacted');
          }
        }

        // Event listeners use delegation - no need to re-attach
      } catch (error) {
        console.error('Error updating bulletin reactions:', error);
      }
    }

    // Create comment HTML
    // Render a single bulletin comment with reactions and replies (IDENTICAL to profile modal)
    async function renderBulletinComment(comment, depth = 0, parentName = null) {
      const maxDepth = 8;
      const currentWallet = localStorage.getItem('bearpark_wallet');
      const isOwner = comment.wallet_address === currentWallet;
      const canDelete = isOwner || isAdminOrModerator; // Show delete for owner OR admin/moderator
      const timeAgo = getTimeAgo(comment.created_at);
      const hasReplies = comment.children && comment.children.length > 0;
      const replyCount = hasReplies ? comment.children.length : 0;

      // Parse avatar using helper function
      const avatarUrl = getAvatarUrl(comment.author_avatar);

      // Fetch equipped cosmetics for comment author
      let equippedRing = null;
      try {
        const cosmeticRes = await fetch(`${API_BASE_URL}/api/cosmetics/equipped/${comment.wallet_address}`);
        const cosmeticData = await cosmeticRes.json();
        if (cosmeticData.success && cosmeticData.equipped) {
          equippedRing = cosmeticData.equipped.ring || null;
        }
      } catch (e) {
        // Ignore errors
      }

      const avatarHTML = `
        <div class="bulletin-comment-avatar-container">
          <img src="${avatarUrl}" class="comment-avatar" alt="${comment.author_name || 'Anonymous'}" onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/esp426.png';">
          ${equippedRing ? `<img src="${equippedRing.image_url}" class="bulletin-comment-cosmetic-ring ${equippedRing.ring_type}" alt="${equippedRing.name}" style="${equippedRing.rarity === 'bearableguy123' ? 'animation: spinRingImage 3s linear infinite !important;' : ''}">` : ''}
        </div>
      `;

      // Load reactions
      const reactions = await loadBulletinCommentReactions(comment.id);
      const userReactions = reactions.userReactions?.[currentWallet] || [];
      const hasReacted = userReactions.length > 0;

      // Reply indicator for nested comments
      let replyIndicator = '';
      if (depth > 0 && parentName) {
        replyIndicator = `<div class="reply-indicator">
          <span class="reply-arrow">‚Ü©</span>
          <span class="reply-to-text">Replying to <span class="reply-to-name">@${parentName}</span></span>
        </div>`;
      }

      const commentHTML = `
        <div class="bulletin-comment-thread ${depth > 0 ? 'is-reply' : ''}" data-comment-id="${comment.id}" data-depth="${depth}">
          <div class="comment-item">
            ${hasReplies ? `<button class="thread-toggle" onclick="toggleBulletinThread(${comment.id})" aria-label="Toggle replies">
              <span class="bulletin-toggle-icon">‚ñº</span>
            </button>` : '<div class="thread-spacer"></div>'}
            <div class="comment-content">
              ${replyIndicator}
              <div class="comment-header">
                <div class="comment-author-clickable" onclick="openProfileModal('${comment.wallet_address}')" style="cursor: pointer; display: flex; align-items: center; gap: 12px; flex: 1;">
                  ${avatarHTML}
                  <div class="comment-author-info">
                    <p class="comment-author-name">${comment.author_name || 'Anonymous'}</p>
                    <p class="comment-timestamp">${timeAgo}${hasReplies ? `<span class="reply-count">${replyCount} ${replyCount === 1 ? 'reply' : 'replies'}</span>` : ''}</p>
                  </div>
                </div>
                ${canDelete ? `<button class="comment-delete-btn" onclick="deleteBulletinComment('${comment.id}')">Delete</button>` : ''}
              </div>
              <p class="comment-text">${escapeHtml(comment.content)}</p>
              ${generateBulletinReactionSummary(comment.id, reactions, userReactions)}
              <div class="comment-actions">
                <button class="like-button ${hasReacted ? 'reacted' : ''}" data-comment-id="${comment.id}">
                  <span class="like-emoji">üëç</span>
                  <span>Like</span>
                  ${generateBulletinReactionPicker(comment.id)}
                </button>
                <button class="reply-button" data-comment-id="${comment.id}" onclick="openBulletinReplyBox(${comment.id})">
                  <span class="reply-icon">üí¨</span>
                  <span>Reply</span>
                </button>
              </div>
            </div>
          </div>
          ${hasReplies ? `<div class="bulletin-comment-replies" data-parent-id="${comment.id}"></div>` : ''}
        </div>
      `;

      return commentHTML;
    }

    // Recursively render bulletin replies
    async function renderBulletinReplies(replies, parentId, depth, parentComment = null) {
      const maxDepth = 8;
      const repliesContainer = document.querySelector(`.bulletin-comment-replies[data-parent-id="${parentId}"]`);
      if (!repliesContainer) return;

      for (const reply of replies) {
        const parentName = parentComment ? (parentComment.author_name || 'Anonymous') : 'a bear';
        const replyHTML = await renderBulletinComment(reply, depth, parentName);
        repliesContainer.insertAdjacentHTML('beforeend', replyHTML);

        // Render nested replies
        if (reply.children && reply.children.length > 0 && depth < maxDepth) {
          await renderBulletinReplies(reply.children, reply.id, depth + 1, reply);
        }
      }
    }

    // Post a comment (using Supabase API)
    async function postComment() {
      if (!currentPostId) return;

      const input = document.getElementById('commentInput');
      const content = input.value.trim();

      if (!content) {
        showBulletinNotification('‚ö†Ô∏è Please enter a comment!', 'warning');
        return;
      }

      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        showBulletinNotification('‚ö†Ô∏è Please connect your wallet first!', 'warning');
        return;
      }

      try {
        // Backend will fetch author info from profiles table automatically
        const response = await fetch(`${API_BASE_URL}/api/bulletin/comments`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            post_id: currentPostId,
            wallet_address: currentWallet,
            content: content,
            parent_id: null  // Top-level comment (no parent)
          })
        });

        if (!response.ok) throw new Error('Failed to post comment');

        // Clear input
        input.value = '';

        console.log('üí¨ Comment posted successfully, reloading comments...');

        // Reload comments
        await loadComments(currentPostId);

        // Update comment count in feed
        const post = bulletinPosts.find(p => p.id === currentPostId);
        if (post) {
          post.comment_count = (post.comment_count || 0) + 1;
        }
        await loadBulletinFeed();

        showBulletinNotification('‚úÖ Your comment has been posted!', 'success');
      } catch (error) {
        console.error('Error posting comment:', error);
        showBulletinNotification('‚ùå Failed to post comment. Please try again.', 'error');
      }
    }

    // Delete a bulletin comment
    window.deleteBulletinComment = async function(commentId) {
      const currentWallet = localStorage.getItem('bearpark_wallet');
      if (!currentWallet) {
        showBulletinNotification('‚ö†Ô∏è Please connect your wallet first!', 'warning');
        return;
      }

      if (!confirm('Are you sure you want to delete this comment?')) {
        return;
      }

      try {
        const response = await fetch(`${API_BASE_URL}/api/bulletin/comments/${commentId}`, {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            wallet_address: currentWallet
          })
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to delete comment');
        }

        console.log('‚úÖ Comment deleted successfully');
        showBulletinNotification('‚úÖ Comment deleted!', 'success');

        // Reload comments
        await loadComments(currentPostId);

        // Update comment count in feed
        const post = bulletinPosts.find(p => p.id === currentPostId);
        if (post && post.comment_count > 0) {
          post.comment_count--;
        }
        await loadBulletinFeed();

      } catch (error) {
        console.error('‚ùå Error deleting bulletin comment:', error);
        showBulletinNotification('‚ùå Failed to delete comment: ' + error.message, 'error');
      }
    };

    // Delete a post
    async function deletePost(postId) {
      if (!confirm('Are you sure you want to delete this post? This cannot be undone.')) {
        return;
      }

      try {
        if (BULLETIN_DEMO_MODE) {
          // Delete from localStorage
          const stored = localStorage.getItem('bearpark_bulletin_posts');
          if (stored) {
            const posts = JSON.parse(stored);
            const filtered = posts.filter(p => p.id !== postId);
            localStorage.setItem('bearpark_bulletin_posts', JSON.stringify(filtered));
          }
          // Also delete associated comments
          localStorage.removeItem(`bearpark_bulletin_comments_${postId}`);
        } else {
          const currentWallet = localStorage.getItem('bearpark_wallet');
          const response = await fetch(`${API_BASE_URL}/api/bulletin/posts/${postId}`, {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              wallet_address: currentWallet
            })
          });
          if (!response.ok) throw new Error('Failed to delete post');
        }

        // Reload feed
        await loadBulletinFeed();

        // Close modal if it's open
        if (currentPostId === postId) {
          closeBulletinPostModal();
        }

        showBulletinNotification('Post deleted', 'success');
      } catch (error) {
        console.error('Error deleting post:', error);
        showBulletinNotification('‚ùå Failed to delete post. Please try again.', 'error');
      }
    }

    // Delete a comment
    async function deleteComment(commentId) {
      if (!confirm('Are you sure you want to delete this comment?')) {
        return;
      }

      if (!currentPostId) return;

      try {
        if (BULLETIN_DEMO_MODE) {
          // Delete from localStorage
          const stored = localStorage.getItem(`bearpark_bulletin_comments_${currentPostId}`);
          if (stored) {
            const comments = JSON.parse(stored);
            const filtered = comments.filter(c => c.id !== commentId);
            localStorage.setItem(`bearpark_bulletin_comments_${currentPostId}`, JSON.stringify(filtered));
          }

          // Update comment count
          const postsStored = localStorage.getItem('bearpark_bulletin_posts');
          if (postsStored) {
            const posts = JSON.parse(postsStored);
            const post = posts.find(p => p.id === currentPostId);
            if (post && post.comment_count > 0) {
              post.comment_count -= 1;
              localStorage.setItem('bearpark_bulletin_posts', JSON.stringify(posts));
            }
          }
        } else {
          const response = await fetch(`${API_BASE_URL}/bulletin/posts/${currentPostId}/comments/${commentId}`, {
            method: 'DELETE'
          });
          if (!response.ok) throw new Error('Failed to delete comment');
        }

        // Reload comments
        await loadComments(currentPostId);

        // Update feed
        await loadBulletinFeed();

        showBulletinNotification('Comment deleted', 'success');
      } catch (error) {
        console.error('Error deleting comment:', error);
        showBulletinNotification('‚ùå Failed to delete comment. Please try again.', 'error');
      }
    }

    // Utility function to get time ago
    function getTimeAgo(timestamp) {
      const now = new Date();
      const posted = new Date(timestamp);
      const diffMs = now - posted;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      const diffDays = Math.floor(diffMs / 86400000);

      if (diffMins < 1) return 'Just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays < 7) return `${diffDays}d ago`;
      return posted.toLocaleDateString();
    }

    // Utility function to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Show notification
    function showBulletinNotification(message, type = 'info') {
      if (type === 'success') {
        // Use the existing celebration system with green checkmark
        const overlay = document.getElementById('celebrationOverlay');
        const icon = document.getElementById('celebrationIcon');
        const text = document.getElementById('celebrationText');
        const subtext = document.getElementById('celebrationSubtext');

        icon.textContent = '‚úÖ';
        text.textContent = 'POSTED!';
        text.style.color = '#22c55e';
        subtext.textContent = message;
        subtext.style.color = '#22c55e';

        overlay.classList.add('active');

        // Create confetti
        const confettiCount = 150;
        const color = '#22c55e';
        for (let i = 0; i < confettiCount; i++) {
          const confetti = document.createElement('div');
          confetti.className = 'confetti';
          confetti.style.left = Math.random() * 100 + '%';
          confetti.style.background = i % 3 === 0 ? color : (i % 3 === 1 ? '#ffae00' : '#ffffff');
          confetti.style.animationDelay = Math.random() * 0.3 + 's';
          confetti.style.animationDuration = (Math.random() * 1.5 + 2.5) + 's';
          confetti.style.setProperty('--drift', (Math.random() - 0.5) * 200 + 'px');
          confetti.style.boxShadow = `0 0 10px ${i % 3 === 0 ? color : '#ffae00'}`;
          overlay.appendChild(confetti);
        }

        setTimeout(() => {
          overlay.classList.remove('active');
          setTimeout(() => {
            const confettiElements = overlay.querySelectorAll('.confetti');
            confettiElements.forEach(c => c.remove());
          }, 500);
        }, 3000);
      } else if (type === 'warning' || type === 'error') {
        console.log(`[${type.toUpperCase()}] ${message}`);
        alert(message);
      }
    }

    // Initialize bulletin board
    document.addEventListener('DOMContentLoaded', () => {
      loadBulletinFeed();

      // Reload feed every 30 seconds (skip if tab hidden)
      setInterval(() => {
        if (document.hidden) return;
        loadBulletinFeed();
      }, 30000);
    });
  </script>

  <script>
    // ===== COSMETICS STORE JAVASCRIPT =====
    let currentStoreTab = 'rings';
    let currentBalance = 0;

    // Cosmetics catalog - loaded from API
    let rings = [];
    let banners = [];
    let catalogLoaded = false;

    // User inventory - loaded from API
    let userInventory = [];
    let inventoryLoaded = false;

    // Load cosmetics catalog from API
    async function loadCosmeticsCatalog() {
      if (catalogLoaded) return; // Only load once

      try {
        console.log('üì¶ Loading cosmetics catalog from API...');
        const response = await fetch(`${API_BASE_URL}/api/cosmetics/catalog`);

        if (!response.ok) throw new Error('Failed to load catalog');

        const data = await response.json();

        if (data.success && data.items) {
          // Separate rings and banners
          rings = data.items
            .filter(item => item.cosmetic_type === 'ring')
            .map(item => ({
              id: item.id,
              name: item.name,
              description: item.description,
              cost: item.honey_cost,
              rarity: item.rarity,
              ringType: item.ring_type,
              imageUrl: item.image_url
            }));

          banners = data.items
            .filter(item => item.cosmetic_type === 'banner')
            .map(item => ({
              id: item.id,
              name: item.name,
              description: item.description,
              cost: item.honey_cost,
              rarity: item.rarity,
              gradient: item.css_gradient,
              imageUrl: item.image_url
            }));

          catalogLoaded = true;
          console.log(`‚úÖ Loaded ${rings.length} rings and ${banners.length} banners`);
        }
      } catch (error) {
        console.error('‚ùå Error loading cosmetics catalog:', error);
        // Fallback to empty arrays
        rings = [];
        banners = [];
      }
    }

    // Load user's inventory from API
    async function loadUserInventory() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) {
        console.log('‚ö†Ô∏è No wallet connected, skipping inventory load');
        userInventory = [];
        return;
      }

      try {
        console.log('üëú Loading user inventory from API...');
        const response = await fetch(`${API_BASE_URL}/api/cosmetics/inventory/${walletAddress}`);

        if (!response.ok) throw new Error('Failed to load inventory');

        const data = await response.json();

        if (data.success && data.items) {
          userInventory = data.items.map(item => item.cosmetic_id);
          inventoryLoaded = true;
          console.log(`‚úÖ Loaded ${userInventory.length} owned items`);
        }
      } catch (error) {
        console.error('‚ùå Error loading user inventory:', error);
        userInventory = [];
      }
    }

    async function openStoreModal() {
      // Load catalog and inventory from API
      await Promise.all([
        loadCosmeticsCatalog(),
        loadUserInventory()
      ]);

      // Get current honey points from the page
      const honeyPointsEl = document.getElementById('totalHoneyPoints');
      if (honeyPointsEl) {
        currentBalance = parseFloat(honeyPointsEl.textContent) || 0;
      }

      document.getElementById('storeModal').classList.add('active');
      document.getElementById('storeHoneyBalance').textContent = currentBalance.toFixed(1);
      loadStoreItems('rings');
    }

    function closeStoreModal() {
      document.getElementById('storeModal').classList.remove('active');
    }

    function switchStoreTab(tab, event) {
      currentStoreTab = tab;
      document.querySelectorAll('#storeModal .store-tab').forEach(btn => btn.classList.remove('active'));
      event.target.closest('.store-tab').classList.add('active');

      document.getElementById('storeRingsGrid').style.display = tab === 'rings' ? 'grid' : 'none';
      document.getElementById('storeBannersGrid').style.display = tab === 'banners' ? 'grid' : 'none';
      document.getElementById('storeTokensGrid').style.display = tab === 'tokens' ? 'grid' : 'none';
      document.getElementById('storeNftsGrid').style.display = tab === 'nfts' ? 'grid' : 'none';

      loadStoreItems(tab);
    }

    // Token store items
    const storeTokens = [
      {
        id: 'FARM',
        name: 'FARM Token',
        currency: 'FARM',
        amount: '25000',
        honeyCost: 4000,
        logo: 'https://img.xmagnetic.org/u/rPrAEfVATUNDTJm9CUa8tYeD7oJrVdEGhU_FARM.webp',
        issuer: 'rPrAEfVATUNDTJm9CUa8tYeD7oJrVdEGhU',
        description: 'Get 25,000 FARM tokens!'
      },
      {
        id: 'SPIFFY',
        name: 'SPIFFY Token',
        currency: 'SPIFFY',
        amount: '250',
        honeyCost: 4000,
        logo: 'https://img.xmagnetic.org/u/rZ4yugfiQQMWx1a2ZxvzskL75TZeGgMFp_SPIFFY.webp',
        issuer: 'rZ4yugfiQQMWx1a2ZxvzskL75TZeGgMFp',
        description: 'Get 250 SPIFFY tokens!'
      }
    ];

    // NFT store items - loaded dynamically from API
    let storeNfts = [];

    function loadStoreItems(tab) {
      // Handle tokens tab
      if (tab === 'tokens') {
        const grid = document.getElementById('storeTokensGrid');
        grid.style.cssText = 'display:flex !important; flex-direction:column; align-items:center; gap:20px; padding:20px 0;';
        let html = '';

        storeTokens.forEach(token => {
          html += `
            <div class="store-item token-store-item" style="background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border:2px solid #f59e0b; border-radius:16px; overflow:hidden; width:100%; max-width:350px;">
              <div style="padding:20px; text-align:center;">
                <img src="${token.logo}" alt="${token.name}" style="width:100px; height:100px; border-radius:50%; margin-bottom:16px; border:3px solid #f59e0b; box-shadow:0 0 20px rgba(245,158,11,0.3);">
                <h3 style="color:#f59e0b; font-size:20px; font-weight:900; margin:0 0 8px;">${token.name}</h3>
                <div style="color:#4ade80; font-size:24px; font-weight:700; margin-bottom:8px;">${Number(token.amount).toLocaleString()} ${token.currency}</div>
                <p style="color:#888; font-size:14px; margin:0 0 16px;">${token.description}</p>
                <div style="display:flex; align-items:center; justify-content:center; gap:8px; margin-bottom:16px;">
                  <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="honey" style="width:24px; height:24px;">
                  <span style="color:#fbbf24; font-size:18px; font-weight:700;">${token.honeyCost.toLocaleString()} HP</span>
                </div>
                <button onclick="purchaseToken('${token.id}')" class="btn gold" style="width:100%; font-size:16px; padding:12px;">
                  üõí PURCHASE
                </button>
              </div>
            </div>
          `;
        });

        grid.innerHTML = html;
        return;
      }

      // Handle NFTs tab - fetch from API
      if (tab === 'nfts') {
        const grid = document.getElementById('storeNftsGrid');
        grid.innerHTML = '<div style="text-align:center; padding:40px; color:#888;"><div style="font-size:32px; margin-bottom:16px;">‚è≥</div>Loading NFTs...</div>';

        loadNFTsFromAPI();
        return;
      }

      const items = tab === 'rings' ? rings : banners;
      const gridId = tab === 'rings' ? 'storeRingsGrid' : 'storeBannersGrid';
      const grid = document.getElementById(gridId);

      // Group items by rarity
      const rarityOrder = ['common', 'rare', 'epic', 'legendary', 'bearableguy123'];
      const rarityLabels = {
        common: 'üåø COMMON',
        rare: 'üíé RARE',
        epic: '‚ö° EPIC',
        legendary: 'üëë LEGENDARY',
        bearableguy123: 'üåë BEARABLEGUY123'
      };

      const groupedItems = {};
      rarityOrder.forEach(rarity => {
        groupedItems[rarity] = items.filter(item => item.rarity === rarity);
      });

      let htmlContent = '';

      rarityOrder.forEach(rarity => {
        const rarityItems = groupedItems[rarity];
        if (rarityItems.length === 0) return;

        htmlContent += `<div class="rarity-section ${rarity}-section">`;
        htmlContent += `<div class="rarity-header ${rarity}-header">${rarityLabels[rarity]}</div>`;
        htmlContent += `<div class="store-grid">`;

        rarityItems.forEach(item => {
          // Check if user owns this item
          const isOwned = userInventory.includes(item.id);

          let previewHTML;

          if (item.ringType) {
            // Ring preview
            if (item.imageUrl) {
              // Image-based ring (like ouroboros or waves)
              const spinAnimation = item.rarity === 'bearableguy123'
                ? `animation: spinRingImage 3s linear infinite;`
                : '';

              // Determine ring size based on type
              let baseRingSize = '160px';
              if (item.ringType === 'castle' || item.ringType === 'castle-static') {
                baseRingSize = '160px';
              } else if (item.ringType === 'waves-static') {
                baseRingSize = '160px';
              } else if (item.rarity === 'bearableguy123' && (item.ringType === 'ouroboros' || item.ringType === 'waves')) {
                baseRingSize = '160px';
              }

              const ouroborosSize = baseRingSize;
              const glowSize = '100px';

              const glowWrapper = item.rarity === 'bearableguy123'
                ? `<div class="ring-glow-wrapper ${item.ringType}" style="width: ${glowSize}; height: ${glowSize};"></div>`
                : '';

              const finalRingSize = item.ringType === 'ouroboros' ? ouroborosSize : baseRingSize;
              const ouroborosRotation = item.ringType === 'ouroboros' ? ' rotate(180deg)' : '';

              previewHTML = `
                <div class="ring-demo">
                  <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/2f0v9c.webp" alt="Avatar" style="position: relative; z-index: 1;">
                  ${glowWrapper}
                  <img src="${item.imageUrl}" alt="${item.name}" class="image-ring-${item.ringType}" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%)${ouroborosRotation}; object-fit: contain; z-index: 2; pointer-events: none; ${spinAnimation}">
                </div>
              `;
            } else {
              // CSS-based ring (like purple, tricolor, etc)
              previewHTML = `
                <div class="ring-demo">
                  <div class="ring-border ${item.ringType}"></div>
                  <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/2f0v9c.webp" alt="Avatar">
                </div>
              `;
            }
          } else if (item.imageUrl || item.gradient) {
            // Banner preview with profile picture overlay
            if (item.imageUrl) {
              // Image-based banner (legendary and bearableguy123)
              const imgStyle = item.rarity === 'bearableguy123'
                ? `position: absolute; top: 50%; left: 50%; width: 200%; height: 200%; min-width: 200%; min-height: 200%; object-fit: cover; z-index: 0; will-change: transform; animation: profile-banner-pan 60s ease-in-out infinite; transform: translate(-50%, -50%);`
                : `position: absolute; top: 50%; left: 50%; width: 200%; height: 200%; min-width: 200%; min-height: 200%; object-fit: cover; z-index: 0; transform: translate(-50%, -50%);`;

              previewHTML = `
                <div class="banner-demo" style="background: #000; overflow: hidden; position: relative;">
                  <img src="${item.imageUrl}" alt="${item.name}" style="${imgStyle}">
                  <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(circle at center, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.6) 100%); z-index: 1;"></div>
                  <div class="banner-profile-preview" style="position: relative; z-index: 2;">
                    <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/2f0v9c.webp" alt="Profile">
                  </div>
                </div>
              `;
            } else if (item.gradient) {
              // Gradient-based banner (common, rare, epic)
              previewHTML = `
                <div class="banner-demo" style="background: ${item.gradient};">
                  <div class="banner-profile-preview">
                    <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/2f0v9c.webp" alt="Profile">
                  </div>
                </div>
              `;
            }
          }

          // Button text and state based on ownership
          const buttonText = isOwned ? 'OWNED' : 'BUY NOW';
          const buttonDisabled = isOwned ? 'disabled' : '';
          const buttonClass = isOwned ? 'store-item-btn owned' : 'store-item-btn';

          htmlContent += `
            <div class="store-item ${item.rarity}">
              <div class="store-item-preview">
                ${previewHTML}
                <div class="store-item-badge rarity-${item.rarity}">${item.rarity.toUpperCase()}</div>
                ${isOwned ? '<div class="store-item-owned-badge">‚úì OWNED</div>' : ''}
              </div>
              <div class="store-item-name">${item.name}</div>
              <div class="store-item-description">${item.description}</div>
              <div class="store-item-footer">
                <div class="store-item-price">${item.cost} HP</div>
                <button class="${buttonClass}" ${buttonDisabled} onclick="purchaseItem(${item.id}, ${item.cost}, '${item.rarity}', '${item.name}', event)">${buttonText}</button>
              </div>
            </div>
          `;
        });

        htmlContent += `</div></div>`;
      });

      grid.innerHTML = htmlContent;
    }

    async function purchaseItem(id, cost, rarity, name, event) {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) {
        alert('Please connect your wallet first!');
        return;
      }

      if (currentBalance < cost) {
        alert(`Not enough Honey Points! You need ${cost} HP but only have ${currentBalance.toFixed(1)} HP.`);
        return;
      }

      // Get the button element
      const button = event?.target || document.querySelector(`button[onclick*="purchaseItem(${id}"]`);

      // Disable button during purchase
      if (button) {
        button.disabled = true;
        button.textContent = 'PURCHASING...';
      }

      try {
        // Show hype message
        showHypeMessage();

        // Call API to purchase item
        const response = await fetch(`${API_BASE_URL}/api/cosmetics/purchase`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            wallet_address: walletAddress,
            cosmetic_id: id
          })
        });

        const data = await response.json();

        if (!response.ok || !data.success) {
          throw new Error(data.error || 'Purchase failed');
        }

        console.log('‚úÖ Purchase successful!', data);

        // Update balance and button after 400ms
        setTimeout(() => {
          currentBalance = data.new_balance;
          document.getElementById('storeHoneyBalance').textContent = currentBalance.toFixed(1);

          // Update main honey points display
          const honeyPointsEl = document.getElementById('totalHoneyPoints');
          if (honeyPointsEl) {
            honeyPointsEl.textContent = currentBalance.toFixed(1);
          }

          // ‚ùå REMOVED localStorage updates - backend is ONLY source of truth
          // Points are updated in backend database, UI will refresh from backend
          console.log('üíæ Updated localStorage with new balance:', data.new_balance);

          // Update welcomePoints button
          const welcomePoints = document.getElementById('welcomePoints');
          if (welcomePoints) {
            welcomePoints.textContent = currentBalance.toFixed(1);
          }

          // Add to user inventory
          userInventory.push(id);

          // Update button to show "OWNED"
          if (button) {
            button.textContent = 'OWNED';
            button.classList.add('owned');
            button.disabled = true;
            button.onclick = null;
          }

          // Add OWNED badge to preview
          const storeItem = button.closest('.store-item');
          if (storeItem) {
            const preview = storeItem.querySelector('.store-item-preview');
            if (preview && !preview.querySelector('.store-item-owned-badge')) {
              const ownedBadge = document.createElement('div');
              ownedBadge.className = 'store-item-owned-badge';
              ownedBadge.textContent = '‚úì OWNED';
              preview.appendChild(ownedBadge);
            }
          }
        }, 400);

        // Show celebration after hype message completes (2.6s total)
        setTimeout(() => {
          showCelebration(rarity, name);
        }, 2600);

      } catch (error) {
        console.error('‚ùå Purchase error:', error);
        alert(`Purchase failed: ${error.message}`);

        // Re-enable button on error
        if (button) {
          button.disabled = false;
          button.textContent = 'BUY NOW';
        }
      }
    }

    // Purchase token from store (FARM, SPIFFY)
    async function purchaseToken(tokenType) {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) {
        alert('Please connect your wallet first!');
        return;
      }

      const token = storeTokens.find(t => t.id === tokenType);
      if (!token) {
        alert('Invalid token type');
        return;
      }

      if (currentBalance < token.honeyCost) {
        alert(`Not enough Honey Points! You need ${token.honeyCost.toLocaleString()} HP but only have ${Math.floor(currentBalance).toLocaleString()} HP.`);
        return;
      }

      // Find the button
      const buttons = document.querySelectorAll('.token-store-item button');
      let button = null;
      buttons.forEach(btn => {
        if (btn.onclick && btn.onclick.toString().includes(tokenType)) {
          button = btn;
        }
      });
      // Fallback to finding by parent content
      if (!button) {
        document.querySelectorAll('.token-store-item').forEach(item => {
          if (item.innerHTML.includes(token.name)) {
            button = item.querySelector('button');
          }
        });
      }

      // Disable button during purchase
      if (button) {
        button.disabled = true;
        button.innerHTML = '‚è≥ PURCHASING...';
      }

      try {
        // Show hype message
        showHypeMessage();

        // Call API to purchase token
        const response = await fetch(`${API_BASE_URL}/api/store/purchase-token`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            wallet_address: walletAddress,
            token_type: tokenType
          })
        });

        let data;
        try {
          data = await response.json();
        } catch (e) {
          throw new Error(`Server error (${response.status}). Please try again.`);
        }

        if (!response.ok || !data.success) {
          // Check if it's a trustline error
          if (data.needsTrustline) {
            throw new Error(`YOU NEED TO SET THE ${token.currency} TRUST LINE FIRST!\n\nIssuer: ${token.issuer}`);
          }
          throw new Error(data.error || data.message || `Server error (${response.status})`);
        }

        console.log('‚úÖ Token purchase successful!', data);

        // Update balance
        setTimeout(() => {
          currentBalance = data.new_balance;
          document.getElementById('storeHoneyBalance').textContent = currentBalance.toFixed(1);

          const honeyPointsEl = document.getElementById('totalHoneyPoints');
          if (honeyPointsEl) {
            honeyPointsEl.textContent = currentBalance.toFixed(1);
          }

          const welcomePoints = document.getElementById('welcomePoints');
          if (welcomePoints) {
            welcomePoints.textContent = currentBalance.toFixed(1);
          }

          // Re-enable button for re-purchase
          if (button) {
            button.disabled = false;
            button.innerHTML = 'üõí PURCHASE';
          }
        }, 400);

        // Show success celebration
        setTimeout(() => {
          showTokenCelebration(token, data.tx_hash);
        }, 2600);

      } catch (error) {
        console.error('‚ùå Token purchase error:', error);
        alert(`Purchase failed: ${error.message}`);

        // Re-enable button on error
        if (button) {
          button.disabled = false;
          button.innerHTML = 'üõí PURCHASE';
        }
      }
    }

    // Show celebration for token purchase
    function showTokenCelebration(token, txHash) {
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.9);
        z-index: 30000;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: fadeIn 0.3s ease;
      `;

      overlay.innerHTML = `
        <div style="text-align:center; padding:40px; max-width:400px;">
          <img src="${token.logo}" alt="${token.name}" style="width:120px; height:120px; border-radius:50%; margin-bottom:24px; border:4px solid #4ade80; box-shadow:0 0 40px rgba(74,222,128,0.5); animation: pulse 1s ease infinite;">
          <h2 style="color:#4ade80; font-size:32px; font-weight:900; margin:0 0 16px;">SUCCESS!</h2>
          <p style="color:#fff; font-size:20px; margin:0 0 24px;">You received <strong style="color:#fbbf24;">${Number(token.amount).toLocaleString()} ${token.currency}</strong>!</p>
          <a href="https://xrpscan.com/tx/${txHash}" target="_blank" rel="noopener noreferrer" style="color:#60a5fa; font-size:14px; text-decoration:underline;">View Transaction</a>
          <button onclick="this.closest('div').parentElement.remove()" style="display:block; margin:24px auto 0; padding:12px 32px; background:linear-gradient(135deg, #f59e0b, #d97706); color:#000; font-size:16px; font-weight:700; border:none; border-radius:8px; cursor:pointer;">
            AWESOME!
          </button>
        </div>
      `;

      document.body.appendChild(overlay);

      // Auto-close after 10 seconds
      setTimeout(() => {
        if (overlay.parentElement) {
          overlay.remove();
        }
      }, 10000);
    }

    // Load NFTs from API
    async function loadNFTsFromAPI() {
      const grid = document.getElementById('storeNftsGrid');

      try {
        const response = await fetch(`${API_BASE_URL}/api/store/nfts`);
        const data = await response.json();

        if (!data.success) {
          throw new Error(data.error || 'Failed to load NFTs');
        }

        storeNfts = data.nfts;

        if (storeNfts.length === 0) {
          grid.innerHTML = `
            <div style="grid-column: 1/-1; text-align:center; padding:60px 20px;">
              <div style="font-size:64px; margin-bottom:20px;">üé®</div>
              <div style="font-size:24px; font-weight:700; color:#8b5cf6; margin-bottom:10px;">ALL SOLD OUT!</div>
              <div style="font-size:16px; color:#888;">All Pixel BEAR NFTs have been claimed. Check back later for more!</div>
            </div>
          `;
          return;
        }

        let html = `
          <div style="grid-column: 1/-1; text-align:center; margin-bottom:20px;">
            <span style="background:rgba(139,92,246,0.2); color:#8b5cf6; padding:8px 16px; border-radius:20px; font-weight:700;">
              ${storeNfts.length} NFT${storeNfts.length > 1 ? 's' : ''} Available
            </span>
          </div>
          <div class="store-grid" style="display:grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap:20px;">
        `;

        storeNfts.forEach((nft, index) => {
          html += `
            <div class="store-item nft-store-item" data-token-id="${nft.nftTokenId}" style="background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border:2px solid #8b5cf6; border-radius:16px; overflow:hidden;">
              <div style="padding:16px; text-align:center;">
                <div style="position:relative;">
                  <img src="${nft.imageUrl}" alt="${nft.name}" style="width:140px; height:140px; border-radius:12px; margin-bottom:12px; border:3px solid #8b5cf6; box-shadow:0 0 20px rgba(139,92,246,0.3); object-fit:cover;" onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/v2jedg.png'">
                  <div style="position:absolute; top:8px; right:8px; background:rgba(0,0,0,0.7); color:#8b5cf6; padding:4px 8px; border-radius:8px; font-size:11px; font-weight:700;">#${index + 1}</div>
                </div>
                <h3 style="color:#8b5cf6; font-size:16px; font-weight:900; margin:0 0 8px;">${nft.name}</h3>
                <div style="display:flex; align-items:center; justify-content:center; gap:6px; margin-bottom:12px;">
                  <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="honey" style="width:20px; height:20px;">
                  <span style="color:#fbbf24; font-size:16px; font-weight:700;">${nft.honeyCost.toLocaleString()} HP</span>
                </div>
                <button onclick="requestNFT('${nft.nftTokenId}', this)" class="btn" style="width:100%; font-size:14px; padding:10px; background:linear-gradient(135deg, #8b5cf6, #7c3aed); color:#fff;">
                  üé® CLAIM NFT
                </button>
              </div>
            </div>
          `;
        });

        html += '</div>';
        html += '<p style="grid-column: 1/-1; text-align:center; color:#666; font-size:12px; margin-top:16px; font-style:italic;">NFTs will be sent to your wallet manually after claiming</p>';
        grid.innerHTML = html;

      } catch (error) {
        console.error('Error loading NFTs:', error);
        grid.innerHTML = `
          <div style="grid-column: 1/-1; text-align:center; padding:60px 20px;">
            <div style="font-size:64px; margin-bottom:20px;">‚ùå</div>
            <div style="font-size:18px; color:#ef4444; margin-bottom:10px;">Failed to load NFTs</div>
            <div style="font-size:14px; color:#888;">${error.message}</div>
            <button onclick="loadNFTsFromAPI()" style="margin-top:20px; padding:10px 20px; background:#8b5cf6; color:#fff; border:none; border-radius:8px; cursor:pointer;">Try Again</button>
          </div>
        `;
      }
    }

    // Request NFT from store (by NFTokenID)
    async function requestNFT(nftTokenId, buttonElement) {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) {
        alert('Please connect your wallet first!');
        return;
      }

      const nft = storeNfts.find(n => n.nftTokenId === nftTokenId);
      if (!nft) {
        alert('NFT not found. Please refresh the page.');
        loadNFTsFromAPI();
        return;
      }

      if (currentBalance < nft.honeyCost) {
        alert(`Not enough Honey Points! You need ${nft.honeyCost.toLocaleString()} HP but only have ${Math.floor(currentBalance).toLocaleString()} HP.`);
        return;
      }

      // Use provided button or find it
      const button = buttonElement || document.querySelector(`[data-token-id="${nftTokenId}"] button`);

      // Disable button during request
      if (button) {
        button.disabled = true;
        button.innerHTML = '‚è≥ CLAIMING...';
      }

      try {
        // Show hype message
        showHypeMessage();

        // Call API to request NFT
        const response = await fetch(`${API_BASE_URL}/api/store/request-nft`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            wallet_address: walletAddress,
            nft_token_id: nftTokenId
          })
        });

        const data = await response.json();

        if (!response.ok || !data.success) {
          // Check for already purchased error
          if (data.alreadyPurchased) {
            alert('NFT ALREADY PURCHASED!\n\nThis NFT has been claimed by another user. Refreshing available NFTs...');
            loadNFTsFromAPI(); // Refresh the list
            return;
          }
          throw new Error(data.error || 'Request failed');
        }

        console.log('‚úÖ NFT request successful!', data);

        // Update balance
        currentBalance = data.new_balance;
        document.getElementById('storeHoneyBalance').textContent = currentBalance.toFixed(1);

        const honeyPointsEl = document.getElementById('totalHoneyPoints');
        if (honeyPointsEl) {
          honeyPointsEl.textContent = currentBalance.toFixed(1);
        }

        const welcomePoints = document.getElementById('welcomePoints');
        if (welcomePoints) {
          welcomePoints.textContent = currentBalance.toFixed(1);
        }

        // Remove this NFT from the list and refresh display
        storeNfts = storeNfts.filter(n => n.nftTokenId !== nftTokenId);

        // Show success message
        setTimeout(() => {
          showNFTRequestSuccess(nft, data.request_id);
          // Refresh NFT display after success modal
          setTimeout(() => loadNFTsFromAPI(), 500);
        }, 2600);

      } catch (error) {
        console.error('‚ùå NFT request error:', error);
        alert(`Request failed: ${error.message}`);

        // Re-enable button on error
        if (button) {
          button.disabled = false;
          button.innerHTML = 'üé® CLAIM NFT';
        }
      }
    }

    // Show success message for NFT request
    function showNFTRequestSuccess(nft, requestId) {
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.9);
        z-index: 30000;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: fadeIn 0.3s ease;
      `;

      overlay.innerHTML = `
        <div style="text-align:center; padding:40px; max-width:400px;">
          <img src="${nft.imageUrl || nft.image || 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/v2jedg.png'}" alt="${nft.name}" style="width:120px; height:120px; border-radius:12px; margin-bottom:24px; border:4px solid #8b5cf6; box-shadow:0 0 40px rgba(139,92,246,0.5); animation: pulse 1s ease infinite; object-fit:cover;">
          <h2 style="color:#8b5cf6; font-size:28px; font-weight:900; margin:0 0 16px;">NFT CLAIMED!</h2>
          <p style="color:#fff; font-size:18px; margin:0 0 16px;">Your <strong style="color:#fbbf24;">${nft.name}</strong> has been reserved!</p>
          <p style="color:#888; font-size:14px; margin:0 0 24px;">Request ID: ${requestId}<br>The NFT will be sent to your wallet shortly.</p>
          <button onclick="this.closest('div').parentElement.remove()" style="display:block; margin:0 auto; padding:12px 32px; background:linear-gradient(135deg, #8b5cf6, #7c3aed); color:#fff; font-size:16px; font-weight:700; border:none; border-radius:8px; cursor:pointer;">
            AWESOME!
          </button>
        </div>
      `;

      document.body.appendChild(overlay);

      // Auto-close after 10 seconds
      setTimeout(() => {
        if (overlay.parentElement) {
          overlay.remove();
        }
      }, 10000);
    }

    function showHypeMessage() {
      const messages = [
        "WOO!!! SEND IT! üöÄ",
        "LET'S GOOO! üöÄ",
        "YESSS! SEND IT! üöÄ",
        "HELL YEAH! üöÄ",
        "YOU'RE A LEGEND! üöÄ"
      ];

      const message = messages[Math.floor(Math.random() * messages.length)];

      const hypeDiv = document.createElement('div');
      hypeDiv.textContent = message;
      hypeDiv.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.5);
        font-size: 48px;
        font-weight: 900;
        color: #ffae00;
        text-shadow: 0 4px 20px rgba(255, 174, 0, 0.8);
        z-index: 30000;
        pointer-events: none;
        font-family: "Luckiest Guy", "Arial Black", Impact, sans-serif;
      `;

      document.body.appendChild(hypeDiv);

      // Animate in
      setTimeout(() => {
        hypeDiv.style.animation = 'hypePopIn 2.5s cubic-bezier(0.16, 1, 0.3, 1) forwards';
      }, 10);

      setTimeout(() => {
        hypeDiv.remove();
      }, 2500);
    }

    let celebrationTimeout = null;

    function clearCelebration() {
      const overlay = document.getElementById('celebrationOverlay');
      if (overlay.classList.contains('active')) {
        overlay.classList.remove('active');
        overlay.innerHTML = '<div class="celebration-content"><div class="celebration-icon" id="celebrationIcon"></div><div class="celebration-text" id="celebrationText"></div><div class="celebration-subtext" id="celebrationSubtext"></div></div>';

        if (celebrationTimeout) {
          clearTimeout(celebrationTimeout);
          celebrationTimeout = null;
        }
      }
    }

    function showCelebration(rarity, itemName) {
      const overlay = document.getElementById('celebrationOverlay');
      const icon = document.getElementById('celebrationIcon');
      const text = document.getElementById('celebrationText');
      const subtext = document.getElementById('celebrationSubtext');

      const celebrations = {
        common: { icon: 'üëë', text: 'UNLOCKED!', color: '#22c55e', confettiCount: 150, shake: 'shake' },
        rare: { icon: 'üíé', text: 'RARE UNLOCK!', color: '#3b82f6', confettiCount: 200, shake: 'shake-medium' },
        epic: { icon: 'üåü', text: 'EPIC UNLOCK!', color: '#a855f7', confettiCount: 300, shake: 'shake-heavy' },
        legendary: { icon: 'üî•', text: 'LEGENDARY!', color: '#f59e0b', confettiCount: 500, shake: 'shake-legendary' },
        bearableguy123: { icon: 'üåë', text: 'BEARABLEGUY123!!!', color: '#ff0000', confettiCount: 800, shake: 'shake-bearableguy123' }
      };

      const config = celebrations[rarity] || celebrations.common;
      icon.textContent = config.icon;
      text.textContent = config.text;
      text.style.color = config.color;
      subtext.textContent = itemName;
      subtext.style.color = config.color;

      overlay.classList.add('active');
      createConfetti(config.confettiCount, config.color);

      // Add shake effect to modal
      const modal = document.getElementById('storeModal');
      if (modal && config.shake) {
        modal.style.animation = `${config.shake} 1s ease-in-out`;
        setTimeout(() => {
          modal.style.animation = '';
        }, 1000);
      }

      celebrationTimeout = setTimeout(() => {
        clearCelebration();
      }, 5000);
    }

    function createConfetti(count, color) {
      const overlay = document.getElementById('celebrationOverlay');
      for (let i = 0; i < count; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + '%';
        confetti.style.background = i % 3 === 0 ? color : (i % 3 === 1 ? '#ffae00' : '#ffffff');
        confetti.style.animationDelay = Math.random() * 0.3 + 's';
        confetti.style.animationDuration = (Math.random() * 1.5 + 2.5) + 's';
        confetti.style.setProperty('--drift', (Math.random() - 0.5) * 200 + 'px');
        confetti.style.boxShadow = `0 0 10px ${i % 3 === 0 ? color : '#ffae00'}`;
        overlay.appendChild(confetti);
      }
    }

    // Add hype animation keyframes dynamically
    const style = document.createElement('style');
    style.textContent = `
      @keyframes hypePopIn {
        0% {
          transform: translate(-50%, -50%) scale(0.3) rotate(-15deg);
          opacity: 0;
          filter: blur(10px);
        }
        15% {
          transform: translate(-50%, -50%) scale(1.15) rotate(3deg);
          opacity: 1;
          filter: blur(0px);
        }
        25% {
          transform: translate(-50%, -50%) scale(0.95) rotate(-2deg);
        }
        35% {
          transform: translate(-50%, -50%) scale(1) rotate(0deg);
        }
        75% {
          transform: translate(-50%, -50%) scale(1) rotate(0deg);
          opacity: 1;
          filter: blur(0px);
        }
        100% {
          transform: translate(-50%, -50%) scale(0.85) rotate(5deg);
          opacity: 0;
          filter: blur(15px);
        }
      }
    `;
    document.head.appendChild(style);

    // Close modal when clicking outside
    document.getElementById('storeModal')?.addEventListener('click', (e) => {
      if (e.target.id === 'storeModal') {
        closeStoreModal();
      } else {
        clearCelebration();
      }
    });

    // ===== INVENTORY MODAL JAVASCRIPT =====
    let currentInventoryTab = 'rings';
    let equippedItems = { ring: null, banner: null };

    async function openInventoryModal() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) {
        alert('Please connect your wallet first!');
        return;
      }

      // Load catalog, inventory, and equipped items
      await Promise.all([
        loadCosmeticsCatalog(),
        loadUserInventory(),
        loadEquippedItems()
      ]);

      document.getElementById('inventoryModal').classList.add('active');
      loadInventoryItems('rings');
    }

    function closeInventoryModal() {
      document.getElementById('inventoryModal').classList.remove('active');
    }

    function switchInventoryTab(tab, event) {
      currentInventoryTab = tab;
      document.querySelectorAll('#inventoryModal .store-tab').forEach(btn => btn.classList.remove('active'));
      event.target.closest('.store-tab').classList.add('active');

      document.getElementById('inventoryRingsGrid').style.display = tab === 'rings' ? 'grid' : 'none';
      document.getElementById('inventoryBannersGrid').style.display = tab === 'banners' ? 'grid' : 'none';

      loadInventoryItems(tab);
    }

    async function loadEquippedItems() {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) return;

      try {
        console.log('üëî Loading equipped items from API...');
        const response = await fetch(`${API_BASE_URL}/api/cosmetics/equipped/${walletAddress}`);

        if (!response.ok) throw new Error('Failed to load equipped items');

        const data = await response.json();

        if (data.success && data.equipped) {
          equippedItems = {
            ring: data.equipped.ring?.cosmetic_id || null,
            banner: data.equipped.banner?.cosmetic_id || null
          };
          console.log(`‚úÖ Loaded equipped items:`, equippedItems);
        }
      } catch (error) {
        console.error('‚ùå Error loading equipped items:', error);
        equippedItems = { ring: null, banner: null };
      }
    }

    function loadInventoryItems(tab) {
      const type = tab === 'rings' ? 'ring' : 'banner';
      const allItems = tab === 'rings' ? rings : banners;
      const ownedItems = allItems.filter(item => userInventory.includes(item.id));

      const gridId = tab === 'rings' ? 'inventoryRingsGrid' : 'inventoryBannersGrid';
      const grid = document.getElementById(gridId);
      const emptyState = document.getElementById('inventoryEmptyState');

      if (ownedItems.length === 0) {
        grid.style.display = 'none';
        emptyState.style.display = 'block';
        return;
      }

      emptyState.style.display = 'none';
      grid.style.display = 'grid';

      // Group items by rarity
      const rarityOrder = ['common', 'rare', 'epic', 'legendary', 'bearableguy123'];
      const rarityLabels = {
        common: 'üåø COMMON',
        rare: 'üíé RARE',
        epic: '‚ö° EPIC',
        legendary: 'üëë LEGENDARY',
        bearableguy123: 'üåë BEARABLEGUY123'
      };

      const groupedItems = {};
      rarityOrder.forEach(rarity => {
        groupedItems[rarity] = ownedItems.filter(item => item.rarity === rarity);
      });

      let htmlContent = '';

      rarityOrder.forEach(rarity => {
        const rarityItems = groupedItems[rarity];
        if (rarityItems.length === 0) return;

        htmlContent += `<div class="rarity-section ${rarity}-section">`;
        htmlContent += `<div class="rarity-header ${rarity}-header">${rarityLabels[rarity]}</div>`;
        htmlContent += `<div class="store-grid">`;

        rarityItems.forEach(item => {
          const isEquipped = type === 'ring' ? equippedItems.ring === item.id : equippedItems.banner === item.id;

          let previewHTML;

          if (item.ringType) {
            // Ring preview (same as store)
            if (item.imageUrl) {
              const spinAnimation = item.rarity === 'bearableguy123' ? `animation: spinRingImage 3s linear infinite;` : '';
              const glowWrapper = item.rarity === 'bearableguy123'
                ? `<div class="ring-glow-wrapper ${item.ringType}" style="width: 100px; height: 100px;"></div>`
                : '';
              const ouroborosRotation = item.ringType === 'ouroboros' ? ' rotate(180deg)' : '';

              previewHTML = `
                <div class="ring-demo">
                  <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/2f0v9c.webp" alt="Avatar" style="position: relative; z-index: 1;">
                  ${glowWrapper}
                  <img src="${item.imageUrl}" alt="${item.name}" class="image-ring-${item.ringType}" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%)${ouroborosRotation}; object-fit: contain; z-index: 2; pointer-events: none; ${spinAnimation}">
                </div>
              `;
            } else {
              previewHTML = `
                <div class="ring-demo">
                  <div class="ring-border ${item.ringType}"></div>
                  <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/2f0v9c.webp" alt="Avatar">
                </div>
              `;
            }
          } else if (item.imageUrl || item.gradient) {
            // Banner preview
            if (item.imageUrl) {
              // Image-based banner (legendary and bearableguy123)
              const panAnimation = item.rarity === 'bearableguy123'
                ? `animation: profile-banner-pan 60s ease-in-out infinite; width: 200%; height: 200%; min-width: 200%; min-height: 200%;`
                : `width: 200%; height: 200%; min-width: 200%; min-height: 200%;`;

              previewHTML = `
                <div class="banner-demo" style="background: #000; overflow: hidden; position: relative;">
                  <img src="${item.imageUrl}" alt="${item.name}" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); object-fit: cover; z-index: 0; ${panAnimation}">
                  <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(circle at center, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.6) 100%); z-index: 1;"></div>
                  <div class="banner-profile-preview" style="position: relative; z-index: 2;">
                    <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/2f0v9c.webp" alt="Profile">
                  </div>
                </div>
              `;
            } else if (item.gradient) {
              // Gradient-based banner (common, rare, epic)
              previewHTML = `
                <div class="banner-demo" style="background: ${item.gradient};">
                  <div class="banner-profile-preview">
                    <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/2f0v9c.webp" alt="Profile">
                  </div>
                </div>
              `;
            }
          }

          const buttonText = isEquipped ? '‚úì EQUIPPED' : 'EQUIP';
          const buttonClass = isEquipped ? 'store-item-btn equipped' : 'store-item-btn';
          const buttonAction = isEquipped ? `unequipItem(${item.id}, '${type}', event)` : `equipItem(${item.id}, '${type}', '${item.name}', event)`;

          htmlContent += `
            <div class="store-item ${item.rarity}">
              <div class="store-item-preview">
                ${previewHTML}
                <div class="store-item-badge rarity-${item.rarity}">${item.rarity.toUpperCase()}</div>
                ${isEquipped ? '<div class="store-item-equipped-badge">‚ö° EQUIPPED</div>' : ''}
              </div>
              <div class="store-item-name">${item.name}</div>
              <div class="store-item-description">${item.description}</div>
              <div class="store-item-footer">
                <button class="${buttonClass}" onclick="${buttonAction}">${buttonText}</button>
              </div>
            </div>
          `;
        });

        htmlContent += `</div></div>`;
      });

      grid.innerHTML = htmlContent;
    }

    // Equip an item
    async function equipItem(cosmeticId, type, itemName, event) {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) {
        alert('Please connect your wallet first!');
        return;
      }

      const button = event?.target;
      if (button) {
        button.disabled = true;
        button.textContent = 'EQUIPPING...';
      }

      try {
        console.log(`‚ö° Equipping ${type}:`, cosmeticId);
        const response = await fetch(`${API_BASE_URL}/api/cosmetics/equip`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            wallet_address: walletAddress,
            cosmetic_id: cosmeticId,
            cosmetic_type: type
          })
        });

        const data = await response.json();

        if (!response.ok || !data.success) {
          throw new Error(data.error || 'Failed to equip item');
        }

        console.log('‚úÖ Item equipped successfully!');

        // Update local equipped state
        if (type === 'ring') {
          equippedItems.ring = cosmeticId;
        } else {
          equippedItems.banner = cosmeticId;
        }

        // Reload inventory to show new equipped state
        loadInventoryItems(currentInventoryTab);

        // Show success message
        showHypeMessage();
        setTimeout(() => {
          const overlay = document.getElementById('celebrationOverlay');
          const icon = document.getElementById('celebrationIcon');
          const text = document.getElementById('celebrationText');
          const subtext = document.getElementById('celebrationSubtext');

          icon.textContent = '‚ö°';
          text.textContent = 'EQUIPPED!';
          text.style.color = '#fbbf24';
          subtext.textContent = itemName;
          subtext.style.color = '#fbbf24';

          overlay.classList.add('active');
          createConfetti(100, '#fbbf24');

          setTimeout(() => {
            clearCelebration();
          }, 2000);
        }, 400);

      } catch (error) {
        console.error('‚ùå Equip error:', error);
        alert(`Failed to equip item: ${error.message}`);

        // Reset button on error
        if (button) {
          button.disabled = false;
          button.textContent = 'EQUIP';
        }
      }
    }

    // Unequip an item
    async function unequipItem(cosmeticId, type, event) {
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) {
        alert('Please connect your wallet first!');
        return;
      }

      const button = event?.target;
      if (button) {
        button.disabled = true;
        button.textContent = 'UNEQUIPPING...';
      }

      try {
        console.log(`üîì Unequipping ${type}:`, cosmeticId);
        const response = await fetch(`${API_BASE_URL}/api/cosmetics/unequip`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            wallet_address: walletAddress,
            cosmetic_type: type
          })
        });

        const data = await response.json();

        if (!response.ok || !data.success) {
          throw new Error(data.error || 'Failed to unequip item');
        }

        console.log('‚úÖ Item unequipped successfully!');

        // Update local equipped state
        if (type === 'ring') {
          equippedItems.ring = null;
        } else {
          equippedItems.banner = null;
        }

        // Reload inventory to show new state
        loadInventoryItems(currentInventoryTab);

      } catch (error) {
        console.error('‚ùå Unequip error:', error);
        alert(`Failed to unequip item: ${error.message}`);

        // Reset button on error
        if (button) {
          button.disabled = false;
          button.textContent = '‚úì EQUIPPED';
        }
      }
    }

    // Close inventory modal when clicking outside
    document.getElementById('inventoryModal')?.addEventListener('click', (e) => {
      if (e.target.id === 'inventoryModal') {
        closeInventoryModal();
      }
    });

    // ===== MERCH STORE JAVASCRIPT =====
    // Products fetched from database - no more hardcoded inventory!
    let MERCH_PRODUCTS = [];

    // Fetch products from database API
    async function fetchMerchProducts() {
      try {
        const response = await fetch('https://bearpark-api-production.up.railway.app/api/merch/products');
        const data = await response.json();
        if (data.success && data.products) {
          MERCH_PRODUCTS = data.products.map(p => ({
            ...p,
            // Normalize price field (API returns 'price', cart uses 'price_usd')
            price_usd: p.price_usd || p.price || 30,
            // Map 2XL from database to XXL for frontend display
            sizes: {
              S: p.sizes?.S || 0,
              M: p.sizes?.M || 0,
              L: p.sizes?.L || 0,
              XL: p.sizes?.XL || 0,
              XXL: p.sizes?.['2XL'] || p.sizes?.XXL || 0
            },
            total_stock: Object.values(p.sizes || {}).reduce((a, b) => a + b, 0)
          }));
          console.log('‚úÖ Merch products loaded from database:', MERCH_PRODUCTS);
        }
      } catch (error) {
        console.error('‚ùå Failed to fetch merch products:', error);
        // Fallback to empty - store will show no products
        MERCH_PRODUCTS = [];
      }
    }

    // Fetch products on page load
    fetchMerchProducts();

    let merchCurrentProduct = null;
    let merchSelectedSize = null;
    let merchShippingData = {};
    let merchXrpPrice = 2.10;
    let merchRateInterval = null;
    let merchSelectedWallet = null; // 'xaman' or 'joey'

    // Shopping Cart State
    let merchCart = [];

    // Load cart from localStorage on page load
    function loadMerchCart() {
      try {
        const saved = localStorage.getItem('merchCart');
        if (saved) {
          merchCart = JSON.parse(saved);
          updateCartBadge();
        }
      } catch (e) {
        merchCart = [];
      }
    }

    // Save cart to localStorage
    function saveMerchCart() {
      try {
        localStorage.setItem('merchCart', JSON.stringify(merchCart));
      } catch (e) {
        console.error('Failed to save cart:', e);
      }
    }

    // Update cart badge (both in gallery and detail views)
    function updateCartBadge() {
      const totalItems = merchCart.reduce((sum, item) => sum + item.quantity, 0);

      // Update both badges
      ['merchCartBadge', 'merchCartBadge2'].forEach(id => {
        const badge = document.getElementById(id);
        if (badge) {
          badge.textContent = totalItems;
          badge.classList.toggle('hidden', totalItems === 0);
        }
      });
    }

    // Add item to cart (with stock validation)
    function addToMerchCart() {
      if (!merchCurrentProduct || !merchSelectedSize) {
        alert('Please select a size first!');
        return;
      }

      // Get available stock for this size
      let sizeKey = merchSelectedSize;
      if (sizeKey === 'XXL') sizeKey = '2XL';
      const availableStock = merchCurrentProduct.sizes?.[sizeKey] || merchCurrentProduct.sizes?.[merchSelectedSize] || 0;

      // Check if item already in cart (same product + size)
      const existingIndex = merchCart.findIndex(
        item => item.productId === merchCurrentProduct.id && item.size === merchSelectedSize
      );

      // Calculate current quantity in cart for this item
      const currentQtyInCart = existingIndex >= 0 ? merchCart[existingIndex].quantity : 0;
      const newQty = currentQtyInCart + 1;

      // Check stock before adding
      if (newQty > availableStock) {
        showCartStockError(`Only ${availableStock} available in size ${merchSelectedSize}${currentQtyInCart > 0 ? ` (${currentQtyInCart} already in cart)` : ''}`);
        return;
      }

      if (existingIndex >= 0) {
        // Increase quantity
        merchCart[existingIndex].quantity += 1;
      } else {
        // Add new item
        merchCart.push({
          productId: merchCurrentProduct.id,
          name: merchCurrentProduct.name,
          size: merchSelectedSize,
          price: merchCurrentProduct.price_usd || 30,
          image: merchCurrentProduct.images?.[0] || 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/n3rrso.webp',
          quantity: 1
        });
      }

      saveMerchCart();
      updateCartBadge();

      // Play add-to-cart animation
      playAddToCartAnimation();

      // Show confirmation
      const btn = document.getElementById('merchAddToCartBtn');
      const originalText = btn.innerHTML;
      btn.innerHTML = '‚úÖ ADDED TO CART!';
      btn.style.background = 'linear-gradient(135deg, #22c55e, #10b981)';
      setTimeout(() => {
        btn.innerHTML = originalText;
        btn.style.background = '';
      }, 1500);
    }

    // Play beautiful add-to-cart animation
    function playAddToCartAnimation() {
      const imgSrc = merchCurrentProduct?.images?.[0] || 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/n3rrso.webp';
      const mainImg = document.getElementById('merchDetailMainImg');

      // Get start position (from the product image)
      const imgRect = mainImg?.getBoundingClientRect() || { left: window.innerWidth / 2, top: window.innerHeight / 2 };

      // Get cart button position (find the visible one)
      const cartBtn = document.querySelector('.merch-cart-btn:not([style*="display: none"])');
      const cartRect = cartBtn?.getBoundingClientRect() || { left: window.innerWidth - 80, top: 80 };

      // Create flying element
      const flyEl = document.createElement('div');
      flyEl.className = 'cart-add-animation';
      flyEl.innerHTML = `<img src="${imgSrc}" alt="">`;
      flyEl.style.left = `${imgRect.left + 50}px`;
      flyEl.style.top = `${imgRect.top + 50}px`;
      document.body.appendChild(flyEl);

      // Animate to cart
      requestAnimationFrame(() => {
        flyEl.style.left = `${cartRect.left + 20}px`;
        flyEl.style.top = `${cartRect.top + 20}px`;
      });

      // Bounce the cart icon
      setTimeout(() => {
        document.querySelectorAll('.merch-cart-btn').forEach(btn => {
          btn.classList.add('cart-bounce');
          setTimeout(() => btn.classList.remove('cart-bounce'), 500);
        });
      }, 400);

      // Show success flash
      const flash = document.createElement('div');
      flash.className = 'cart-success-flash';
      flash.innerHTML = `<span style="font-size:24px;">‚úì</span> Added to Cart!`;
      document.body.appendChild(flash);

      // Cleanup
      setTimeout(() => {
        flyEl.remove();
        flash.remove();
      }, 800);
    }

    // Remove item from cart
    function removeFromMerchCart(index) {
      merchCart.splice(index, 1);
      saveMerchCart();
      updateCartBadge();
      renderMerchCart();
    }

    // Update item quantity (with stock validation)
    function updateMerchCartQty(index, delta) {
      if (!merchCart[index]) return;

      const item = merchCart[index];
      const newQty = item.quantity + delta;

      // If decreasing, just do it
      if (delta < 0) {
        if (newQty <= 0) {
          removeFromMerchCart(index);
        } else {
          merchCart[index].quantity = newQty;
          saveMerchCart();
          updateCartBadge();
          renderMerchCart();
        }
        return;
      }

      // If increasing, check stock
      const product = MERCH_PRODUCTS.find(p => p.id === item.productId);
      if (!product) {
        showCartStockError('Product not found');
        return;
      }

      // Map size for stock check (XXL -> 2XL in some cases)
      let sizeKey = item.size;
      if (sizeKey === 'XXL') sizeKey = '2XL';
      const availableStock = product.sizes?.[sizeKey] || product.sizes?.[item.size] || 0;

      // Check if we have enough stock
      if (newQty > availableStock) {
        showCartStockError(`Only ${availableStock} available in size ${item.size}`);
        return;
      }

      merchCart[index].quantity = newQty;
      saveMerchCart();
      updateCartBadge();
      renderMerchCart();
    }

    // Show stock error message in cart
    function showCartStockError(message) {
      // Create toast notification
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed;
        top: 20%;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #ef4444, #dc2626);
        color: white;
        padding: 16px 28px;
        border-radius: 12px;
        font-weight: 700;
        font-size: 15px;
        z-index: 10002;
        box-shadow: 0 10px 40px rgba(239,68,68,0.5);
        animation: shakeToast 0.5s ease-out;
        display: flex;
        align-items: center;
        gap: 10px;
      `;
      toast.innerHTML = `<span style="font-size:20px;">‚ö†Ô∏è</span> ${message}`;
      document.body.appendChild(toast);

      // Add shake animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes shakeToast {
          0%, 100% { transform: translateX(-50%) rotate(0); }
          20% { transform: translateX(-50%) rotate(-3deg); }
          40% { transform: translateX(-50%) rotate(3deg); }
          60% { transform: translateX(-50%) rotate(-2deg); }
          80% { transform: translateX(-50%) rotate(2deg); }
        }
      `;
      document.head.appendChild(style);

      setTimeout(() => {
        toast.remove();
        style.remove();
      }, 2500);
    }

    // Calculate cart subtotal
    function getMerchCartSubtotal() {
      return merchCart.reduce((sum, item) => sum + (item.price * item.quantity), 0);
    }

    // Get total items in cart
    function getMerchCartItemCount() {
      return merchCart.reduce((sum, item) => sum + item.quantity, 0);
    }

    // Open cart modal
    function openMerchCart() {
      let modal = document.getElementById('merchCartModal');
      if (!modal) {
        // Create modal if it doesn't exist
        modal = document.createElement('div');
        modal.id = 'merchCartModal';
        modal.className = 'store-modal';
        modal.innerHTML = `
          <div class="merch-cart-modal">
            <div class="merch-cart-header">
              <h3>üõí Your Cart</h3>
              <button class="store-close-btn" onclick="closeMerchCart()">√ó</button>
            </div>
            <div class="merch-cart-body" id="merchCartBody">
              <!-- Cart items rendered here -->
            </div>
            <div class="merch-cart-footer" id="merchCartFooter">
              <!-- Footer with subtotal and checkout -->
            </div>
          </div>
        `;
        modal.addEventListener('click', (e) => {
          if (e.target === modal) closeMerchCart();
        });
        document.body.appendChild(modal);
      }
      renderMerchCart();
      modal.classList.add('active');
    }

    // Close cart modal
    function closeMerchCart() {
      const modal = document.getElementById('merchCartModal');
      if (modal) modal.classList.remove('active');
    }

    // Render cart contents
    function renderMerchCart() {
      const body = document.getElementById('merchCartBody');
      const footer = document.getElementById('merchCartFooter');
      if (!body || !footer) return;

      if (merchCart.length === 0) {
        body.innerHTML = `
          <div class="merch-cart-empty">
            <div class="merch-cart-empty-icon">üõí</div>
            <h3 style="color:#fff; margin-bottom:10px;">Your cart is empty</h3>
            <p style="color:#888; margin-bottom:20px;">Add some awesome BEAR merch!</p>
            <button onclick="closeMerchCart()" class="merch-cart-continue">
              üëï Continue Shopping
            </button>
          </div>
        `;
        footer.innerHTML = '';
        return;
      }

      // Render cart items
      let itemsHtml = '';
      merchCart.forEach((item, index) => {
        const itemXrp = (item.price / merchXrpPrice).toFixed(2);
        itemsHtml += `
          <div class="merch-cart-item">
            <img src="${item.image}" alt="${item.name}" class="merch-cart-item-img">
            <div class="merch-cart-item-info">
              <div class="merch-cart-item-name">${item.name}</div>
              <div class="merch-cart-item-size">Size: ${item.size}</div>
              <div class="merch-cart-item-price">~${itemXrp} XRP <span style="font-size:12px; color:#888; font-weight:normal;">($${item.price.toFixed(2)} RLUSD)</span></div>
            </div>
            <div class="merch-cart-item-actions">
              <button class="merch-cart-remove-btn" onclick="removeFromMerchCart(${index})">üóëÔ∏è Remove</button>
              <div class="merch-cart-qty">
                <button class="merch-cart-qty-btn" onclick="updateMerchCartQty(${index}, -1)">‚àí</button>
                <span class="merch-cart-qty-num">${item.quantity}</span>
                <button class="merch-cart-qty-btn" onclick="updateMerchCartQty(${index}, 1)">+</button>
              </div>
            </div>
          </div>
        `;
      });
      body.innerHTML = itemsHtml;

      // Render footer with subtotal
      const subtotal = getMerchCartSubtotal();
      const itemCount = getMerchCartItemCount();
      const xrpEquiv = (subtotal / merchXrpPrice).toFixed(2);
      footer.innerHTML = `
        <div class="merch-cart-subtotal">
          <span class="merch-cart-subtotal-label">${itemCount} item${itemCount > 1 ? 's' : ''}</span>
          <div>
            <div class="merch-cart-subtotal-value">~${xrpEquiv} XRP</div>
            <div style="font-size:13px; color:#888; text-align:right;">$${subtotal.toFixed(2)} RLUSD</div>
          </div>
        </div>
        <button class="merch-cart-checkout-btn" onclick="startCartCheckout()">
          üí≥ PROCEED TO CHECKOUT
        </button>
        <button class="merch-cart-continue" onclick="closeMerchCart()">
          üëï Continue Shopping
        </button>
      `;
    }

    // Multi-item checkout state
    let merchCheckoutItems = []; // Items being checked out
    let merchCheckoutTotal = 0;  // Total price for checkout

    // Start checkout from cart (supports multiple items)
    function startCartCheckout() {
      if (merchCart.length === 0) {
        alert('Your cart is empty!');
        return;
      }

      // Copy cart items for checkout
      console.log('üõí Starting cart checkout with cart:', merchCart);
      merchCheckoutItems = merchCart.map(item => ({
        ...item,
        product: MERCH_PRODUCTS.find(p => p.id === item.productId)
      }));
      console.log('üõí Checkout items prepared:', merchCheckoutItems);

      // Validate all products exist
      const missingProducts = merchCheckoutItems.filter(item => !item.product);
      if (missingProducts.length > 0) {
        alert('Some products are no longer available. Please update your cart.');
        return;
      }

      // Calculate total
      merchCheckoutTotal = merchCheckoutItems.reduce((sum, item) => sum + (item.price * item.quantity), 0);

      // For single item checkout, also set the legacy variables for compatibility
      if (merchCheckoutItems.length === 1) {
        merchCurrentProduct = merchCheckoutItems[0].product;
        merchSelectedSize = merchCheckoutItems[0].size;
      } else {
        // Multi-item checkout - clear legacy variables to avoid confusion
        merchCurrentProduct = null;
        merchSelectedSize = null;
      }

      // Close cart modal and proceed to checkout
      closeMerchCart();
      merchShowScreen('disclaimer');
    }

    // Generate checkout items summary for display
    function getCheckoutItemsSummary() {
      return merchCheckoutItems.map(item =>
        `${item.quantity}x ${item.name} (${item.size})`
      ).join(', ');
    }

    // Generate detailed checkout items HTML
    function getCheckoutItemsHTML() {
      return merchCheckoutItems.map(item => {
        const itemTotal = item.price * item.quantity;
        const itemXrp = (itemTotal / merchXrpPrice).toFixed(2);
        return `
        <div style="display:flex; gap:12px; align-items:center; padding:12px; background:rgba(0,0,0,0.2); border-radius:10px; margin-bottom:8px;">
          <img src="${item.image}" style="width:50px; height:50px; border-radius:8px; object-fit:cover;">
          <div style="flex:1;">
            <div style="font-weight:700; color:#fff;">${item.name}</div>
            <div style="font-size:12px; color:#888;">Size: ${item.size} | Qty: ${item.quantity}</div>
          </div>
          <div style="text-align:right;">
            <div style="font-weight:700; color:#00ff88;">~${itemXrp} XRP</div>
            <div style="font-size:11px; color:#888;">$${itemTotal.toFixed(2)} RLUSD</div>
          </div>
        </div>
      `}).join('');
    }

    // Load cart when page loads
    loadMerchCart();

    // ü¶ò JOEY WALLET: WalletConnect configuration
    const WALLETCONNECT_PROJECT_ID = 'da711418529df39d15cc68772619e270';
    let joeyWcClient = null;
    let joeyWcSession = null;
    let joeyPairingTopic = null;

    // Wait for WalletConnect module to load
    async function waitForWalletConnect(maxWait = 5000) {
      const start = Date.now();
      while (!(window.WalletConnectSignClient || window.SignClient) && (Date.now() - start) < maxWait) {
        await new Promise(r => setTimeout(r, 100));
      }
      // UMD bundle exposes as window.SignClient
      return window.WalletConnectSignClient || window.SignClient;
    }

    // Initialize WalletConnect client for Joey
    async function initJoeyWalletConnect() {
      if (joeyWcClient) return joeyWcClient;

      try {
        // Wait for WalletConnect Sign Client to load
        const SignClient = await waitForWalletConnect();

        if (!SignClient) {
          console.error('WalletConnect SignClient failed to load after 5 seconds');
          return null;
        }

        joeyWcClient = await SignClient.init({
          projectId: WALLETCONNECT_PROJECT_ID,
          metadata: {
            name: 'BEAR Park Merch Store',
            description: 'BEAR Park merchandise store - pay with XRPL',
            url: 'https://bearpark.xyz',
            icons: ['https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/qnd2tx.png']
          }
        });

        // Listen for session events
        joeyWcClient.on('session_event', (event) => {
          console.log('WalletConnect session event:', event);
        });

        joeyWcClient.on('session_update', ({ topic, params }) => {
          console.log('WalletConnect session update:', topic, params);
        });

        joeyWcClient.on('session_delete', () => {
          console.log('WalletConnect session deleted');
          joeyWcSession = null;
        });

        return joeyWcClient;
      } catch (error) {
        console.error('Failed to init WalletConnect:', error);
        return null;
      }
    }

    // Connect Joey wallet via WalletConnect and create payment
    async function startJoeyWalletConnectPayment(paymentData, orderNumber) {
      try {
        // Initialize client if needed
        const client = await initJoeyWalletConnect();
        if (!client) {
          throw new Error('WalletConnect not available. Please try again or use manual payment.');
        }

        // Create new pairing
        const { uri, approval } = await client.connect({
          requiredNamespaces: {
            xrpl: {
              methods: ['xrpl_signTransaction'],
              chains: ['xrpl:0'],  // XRPL mainnet
              events: ['chainChanged', 'accountsChanged']
            }
          }
        });

        // Generate QR code from WalletConnect URI
        const wcQrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=250x250&data=${encodeURIComponent(uri)}`;

        // Update UI with QR code
        document.getElementById('merchSpinnerSection').innerHTML = `
          <style>
            @keyframes joey-bounce {
              0%, 100% { transform: translateY(0); }
              50% { transform: translateY(-10px); }
            }
            @keyframes joey-rotate {
              0% { transform: rotate(0deg); }
              100% { transform: rotate(360deg); }
            }
            @keyframes joey-glow {
              0%, 100% { box-shadow: 0 0 20px rgba(245,158,11,0.3); }
              50% { box-shadow: 0 0 40px rgba(245,158,11,0.6); }
            }
            .joey-qr-container {
              background: #fff;
              padding: 15px;
              border-radius: 16px;
              display: inline-block;
              margin: 15px 0;
              animation: joey-glow 2s ease-in-out infinite;
            }
            .joey-spinner-ring {
              width: 40px; height: 40px;
              border: 3px solid rgba(245,158,11,0.2);
              border-top: 3px solid #f59e0b;
              border-radius: 50%;
              animation: joey-rotate 1s linear infinite;
              margin: 10px auto;
            }
            .joey-waiting-container {
              background: linear-gradient(135deg, rgba(245,158,11,0.1), rgba(234,88,12,0.1));
              border-radius: 16px;
              padding: 20px;
              margin-top: 15px;
              border: 1px solid rgba(245,158,11,0.3);
            }
            .joey-step {
              display: flex; align-items: center; gap: 12px;
              padding: 8px 0; color: #888; font-size: 14px;
              transition: all 0.3s ease;
            }
            .joey-step.active { color: #f59e0b; }
            .joey-step.completed { color: #f59e0b; }
            .joey-step-icon {
              width: 24px; height: 24px;
              border-radius: 50%;
              display: flex; align-items: center; justify-content: center;
              font-size: 12px;
              background: rgba(255,255,255,0.1);
              border: 2px solid currentColor;
            }
            .joey-step.active .joey-step-icon {
              background: #f59e0b;
              color: #000;
              border-color: #f59e0b;
            }
            .joey-step.completed .joey-step-icon {
              background: #f59e0b;
              color: #000;
            }
          </style>

          <p style="color:#f59e0b; font-size:18px; font-weight:700; margin-bottom:10px;">Scan with Joey Wallet</p>

          <div class="joey-qr-container">
            <img src="${wcQrUrl}" alt="Scan with Joey" style="width:200px; height:200px; display:block;">
          </div>

          <p style="color:#888; font-size:13px; margin:10px 0;">
            <strong>Order:</strong> ${orderNumber}<br>
            <strong>Amount:</strong> ${paymentData.amount} ${paymentData.currency}
          </p>

          <div class="joey-waiting-container">
            <div class="joey-spinner-ring"></div>
            <p id="joeyStatusText" style="color:#f59e0b; font-size:16px; font-weight:600; margin-top:10px;">
              Waiting for Joey connection...
            </p>
            <p style="color:#666; font-size:12px;">Open Joey Wallet and scan the QR code</p>

            <div style="margin-top:15px; text-align:left; max-width:280px; margin-left:auto; margin-right:auto;">
              <div class="joey-step active" id="joeyStep1">
                <div class="joey-step-icon">1</div>
                <span>Connect Joey Wallet</span>
              </div>
              <div class="joey-step" id="joeyStep2">
                <div class="joey-step-icon">2</div>
                <span>Approve payment</span>
              </div>
              <div class="joey-step" id="joeyStep3">
                <div class="joey-step-icon">3</div>
                <span>Payment confirmed</span>
              </div>
            </div>
          </div>

          <p style="color:#ff6b6b; font-size:12px; margin-top:15px; padding:10px; background:rgba(255,107,107,0.1); border-radius:8px;">
            ‚ö†Ô∏è Don't close this page until payment is complete
          </p>
        `;

        // Wait for user to approve in Joey
        joeyWcSession = await approval();
        console.log('Joey WalletConnect session established:', joeyWcSession);

        // Update UI - connected
        const step1 = document.getElementById('joeyStep1');
        const step2 = document.getElementById('joeyStep2');
        const statusText = document.getElementById('joeyStatusText');
        if (step1 && step2 && statusText) {
          step1.classList.remove('active');
          step1.classList.add('completed');
          step1.querySelector('.joey-step-icon').innerHTML = '‚úì';
          step2.classList.add('active');
          statusText.textContent = 'Approve payment in Joey...';
        }

        // Get the connected account
        const accounts = joeyWcSession.namespaces.xrpl?.accounts || [];
        const userAccount = accounts[0]?.split(':')[2];  // Format: xrpl:0:rXXX

        if (!userAccount) {
          throw new Error('No XRPL account connected');
        }

        // Build XRPL payment transaction
        let txPayload;
        if (paymentData.currency === 'XRP') {
          // XRP payment
          txPayload = {
            TransactionType: 'Payment',
            Account: userAccount,
            Destination: paymentData.destination_address,
            Amount: String(Math.floor(paymentData.amount * 1000000)),  // Convert to drops
            DestinationTag: paymentData.destination_tag
          };
        } else {
          // RLUSD payment
          txPayload = {
            TransactionType: 'Payment',
            Account: userAccount,
            Destination: paymentData.destination_address,
            Amount: {
              currency: paymentData.currency === 'RLUSD' ? '524C555344000000000000000000000000000000' : paymentData.currency,
              value: String(paymentData.amount),
              issuer: paymentData.issuer
            },
            DestinationTag: paymentData.destination_tag
          };
        }

        // Request signature from Joey
        const result = await client.request({
          topic: joeyWcSession.topic,
          chainId: 'xrpl:0',
          request: {
            method: 'xrpl_signTransaction',
            params: {
              tx_json: txPayload
            }
          }
        });

        console.log('Joey payment result:', result);

        // Update UI - payment sent
        if (step2 && statusText) {
          step2.classList.remove('active');
          step2.classList.add('completed');
          step2.querySelector('.joey-step-icon').innerHTML = '‚úì';
          const step3 = document.getElementById('joeyStep3');
          if (step3) {
            step3.classList.add('active');
          }
          statusText.textContent = 'Confirming on XRPL...';
        }

        return { success: true, result };

      } catch (error) {
        console.error('Joey WalletConnect error:', error);
        throw error;
      }
    }

    async function openMerchStoreModal() {
      document.getElementById('merchStoreModal').classList.add('active');
      merchShowScreen('gallery');
      // Always fetch fresh inventory from database when opening store!
      await fetchMerchProducts();
      loadMerchProducts();
      fetchXrpPrice();
    }

    function closeMerchStoreModal() {
      document.getElementById('merchStoreModal').classList.remove('active');
      merchResetState();
      if (merchRateInterval) clearInterval(merchRateInterval);
    }

    function selectMerchWallet(wallet) {
      merchSelectedWallet = wallet;
      const xamanBtn = document.getElementById('walletXaman');
      const joeyBtn = document.getElementById('walletJoey');
      const payBtn = document.getElementById('merchFinalPayBtn');

      // Reset both buttons
      xamanBtn.style.border = '2px solid #680cd9';
      xamanBtn.style.background = 'linear-gradient(135deg, rgba(104,12,217,0.2), rgba(104,12,217,0.1))';
      xamanBtn.style.transform = 'scale(1)';
      joeyBtn.style.border = '2px solid #f59e0b';
      joeyBtn.style.background = 'linear-gradient(135deg, rgba(245,158,11,0.2), rgba(245,158,11,0.1))';
      joeyBtn.style.transform = 'scale(1)';

      // Highlight selected wallet
      if (wallet === 'xaman') {
        xamanBtn.style.border = '3px solid #00ff88';
        xamanBtn.style.background = 'linear-gradient(135deg, rgba(0,255,136,0.3), rgba(104,12,217,0.2))';
        xamanBtn.style.transform = 'scale(1.05)';
        payBtn.innerHTML = 'üì± COMPLETE PAYMENT WITH XAMAN';
      } else if (wallet === 'joey') {
        joeyBtn.style.border = '3px solid #00ff88';
        joeyBtn.style.background = 'linear-gradient(135deg, rgba(0,255,136,0.3), rgba(245,158,11,0.2))';
        joeyBtn.style.transform = 'scale(1.05)';
        payBtn.innerHTML = 'ü¶ò COMPLETE PAYMENT WITH JOEY';
      }

      payBtn.disabled = false;
      payBtn.style.opacity = '1';
      payBtn.style.cursor = 'pointer';
    }

    function merchResetState() {
      merchCurrentProduct = null;
      merchSelectedSize = null;
      merchShippingData = {};
      merchSelectedWallet = null;
      document.querySelectorAll('.merch-screen').forEach(s => s.style.display = 'none');
      document.getElementById('merchScreen-gallery').style.display = 'block';
      // Reset wallet selection UI
      const payBtn = document.getElementById('merchFinalPayBtn');
      if (payBtn) {
        payBtn.innerHTML = 'üîê SELECT A WALLET ABOVE';
        payBtn.disabled = true;
      }
    }

    function merchShowScreen(screen) {
      document.querySelectorAll('.merch-screen').forEach(s => s.style.display = 'none');
      document.getElementById('merchScreen-' + screen).style.display = 'block';
    }

    function merchGoBack(screen) {
      merchShowScreen(screen);
    }

    // Sync store products with inventory from API (full sync - name, description, price, images, stock)
    async function syncMerchInventory() {
      try {
        const res = await fetch(`${API_BASE}/api/merch/inventory`);
        if (res.ok) {
          const data = await res.json();
          if (data.success && data.inventory && data.inventory.length > 0) {
            // Clear and rebuild MERCH_PRODUCTS from API data
            MERCH_PRODUCTS.length = 0;

            data.inventory.forEach(invItem => {
              // Map inventory stock to product sizes (handle 2XL vs XXL)
              const sizes = {
                S: invItem.stock?.S || 0,
                M: invItem.stock?.M || 0,
                L: invItem.stock?.L || 0,
                XL: invItem.stock?.XL || 0,
                XXL: invItem.stock?.['2XL'] || invItem.stock?.XXL || 0
              };

              MERCH_PRODUCTS.push({
                id: invItem.id,
                name: invItem.name,
                description: invItem.description || '',
                price_usd: invItem.price,
                images: invItem.images || [],
                sizes: sizes,
                total_stock: Object.values(sizes).reduce((a, b) => a + b, 0)
              });
            });

            console.log(`üì¶ Inventory fully synced from API: ${MERCH_PRODUCTS.length} products`);
          }
        }
      } catch (e) {
        console.log('Using default inventory - API unavailable');
      }
    }

    async function loadMerchProducts() {
      // First sync with inventory from API
      await syncMerchInventory();

      const grid = document.getElementById('merchProductsGrid');
      let html = '';

      MERCH_PRODUCTS.forEach(product => {
        const totalStock = Object.values(product.sizes).reduce((a, b) => a + b, 0);
        let stockBadge = '';
        let soldOutClass = '';

        if (totalStock === 0) {
          stockBadge = '<span class="merch-stock-badge sold-out">SOLD OUT</span>';
          soldOutClass = 'sold-out';
        } else if (totalStock < 10) {
          stockBadge = `<span class="merch-stock-badge low-stock">${totalStock} left!</span>`;
        } else {
          stockBadge = '<span class="merch-stock-badge in-stock">In Stock</span>';
        }

        const xrpAmount = (product.price_usd / (merchXrpPrice || 2.10)).toFixed(2);
        html += `
          <div class="merch-product-card ${soldOutClass}" onclick="${totalStock > 0 ? `openMerchProduct('${product.id}')` : ''}">
            <img src="${product.images[0]}" alt="${product.name}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
            <div class="merch-img-placeholder" style="display:none; width:100%; aspect-ratio:1; background:linear-gradient(135deg, #680cd9, #00ff88); align-items:center; justify-content:center; font-size:48px;">üëï</div>
            <div class="merch-product-info">
              <h3>${product.name}</h3>
              <div class="merch-price">~${xrpAmount} XRP</div>
              <div class="merch-price-secondary" style="font-size:12px; color:#888; margin-top:2px;">$${product.price_usd} RLUSD</div>
              ${stockBadge}
            </div>
          </div>
        `;
      });

      grid.innerHTML = html;
    }

    function openMerchProduct(productId) {
      const product = MERCH_PRODUCTS.find(p => p.id === productId);
      if (!product) return;

      merchCurrentProduct = product;
      merchSelectedSize = null;

      // Set product details
      document.getElementById('merchDetailMainImg').src = product.images[0];
      document.getElementById('merchDetailName').textContent = product.name;
      document.getElementById('merchDetailDesc').textContent = product.description;

      // Set dynamic price
      const price = product.price_usd || 30;
      document.getElementById('merchDetailPrice').textContent = `$${price.toFixed(2)}`;

      // Load thumbnails
      const thumbsContainer = document.getElementById('merchDetailThumbnails');
      thumbsContainer.innerHTML = product.images.map((img, i) => `
        <div class="merch-thumbnail ${i === 0 ? 'active' : ''}" onclick="merchSetMainImage('${img}', this)">
          <img src="${img}" alt="View ${i + 1}">
        </div>
      `).join('');

      // Load size buttons
      const sizesContainer = document.getElementById('merchSizeButtons');
      sizesContainer.innerHTML = ['S', 'M', 'L', 'XL', 'XXL'].map(size => {
        const stock = product.sizes[size] || 0;
        return `<button class="merch-size-btn" ${stock === 0 ? 'disabled' : ''} onclick="merchSelectSize('${size}', this)">${size}</button>`;
      }).join('');

      // Update stock display
      const totalStock = Object.values(product.sizes).reduce((a, b) => a + b, 0);
      document.getElementById('merchDetailStock').textContent = `Stock: ${totalStock} remaining`;

      // Reset buttons
      const addToCartBtn = document.getElementById('merchAddToCartBtn');
      const buyNowBtn = document.getElementById('merchBuyNowBtn');
      addToCartBtn.disabled = true;
      addToCartBtn.textContent = 'üõí SELECT SIZE FIRST';
      buyNowBtn.disabled = true;

      // Update XRP price
      updateMerchXrpDisplay();

      merchShowScreen('detail');
    }

    function merchSetMainImage(src, thumb) {
      document.getElementById('merchDetailMainImg').src = src;
      document.querySelectorAll('.merch-thumbnail').forEach(t => t.classList.remove('active'));
      thumb.classList.add('active');
    }

    function merchSelectSize(size, btn) {
      merchSelectedSize = size;
      document.querySelectorAll('.merch-size-btn').forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');

      // Enable both buttons
      const addToCartBtn = document.getElementById('merchAddToCartBtn');
      const buyNowBtn = document.getElementById('merchBuyNowBtn');
      addToCartBtn.disabled = false;
      buyNowBtn.disabled = false;

      // Show price on Add to Cart button (XRP first)
      const price = merchCurrentProduct.price_usd || 30;
      const xrpAmount = (price / merchXrpPrice).toFixed(2);
      addToCartBtn.innerHTML = 'üõí ADD TO CART - <span style="color:#00ff88;">~' + xrpAmount + ' XRP</span>';

      // Update stock for selected size
      const stock = merchCurrentProduct.sizes[size] || 0;
      document.getElementById('merchDetailStock').textContent = `Size ${size}: ${stock} remaining`;
    }

    function merchProceedToDisclaimer() {
      if (!merchSelectedSize) {
        alert('Please select a size first!');
        return;
      }
      merchShowScreen('disclaimer');
    }

    function merchGoToShipping() {
      merchShowScreen('shipping');
    }

    function merchUpdateCountryFields() {
      // For now, only US is supported
      const country = document.getElementById('merchShipCountry').value;
      if (country !== 'US') {
        alert('Sorry, we only ship to the US at this time. More countries coming soon!');
        document.getElementById('merchShipCountry').value = 'US';
      }
    }

    function merchValidateAndContinue() {
      const name = document.getElementById('merchShipName').value.trim();
      const street = document.getElementById('merchShipStreet').value.trim();
      const apt = document.getElementById('merchShipApt').value.trim();
      const city = document.getElementById('merchShipCity').value.trim();
      const state = document.getElementById('merchShipState').value;
      const zip = document.getElementById('merchShipZip').value.trim();
      const country = document.getElementById('merchShipCountry').value;

      if (!name || name.length < 2) {
        alert('Please enter a valid name');
        return;
      }
      if (!street) {
        alert('Please enter your street address');
        return;
      }
      if (!city) {
        alert('Please enter your city');
        return;
      }
      if (!state) {
        alert('Please select your state');
        return;
      }
      if (!zip || !/^\d{5}(-\d{4})?$/.test(zip)) {
        alert('Please enter a valid ZIP code (e.g., 12345 or 12345-6789)');
        return;
      }

      merchShippingData = { name, street, apt, city, state, zip, country };

      // Update confirmation screen
      const stateNames = {
        AL:'Alabama',AK:'Alaska',AZ:'Arizona',AR:'Arkansas',CA:'California',CO:'Colorado',
        CT:'Connecticut',DE:'Delaware',FL:'Florida',GA:'Georgia',HI:'Hawaii',ID:'Idaho',
        IL:'Illinois',IN:'Indiana',IA:'Iowa',KS:'Kansas',KY:'Kentucky',LA:'Louisiana',
        ME:'Maine',MD:'Maryland',MA:'Massachusetts',MI:'Michigan',MN:'Minnesota',MS:'Mississippi',
        MO:'Missouri',MT:'Montana',NE:'Nebraska',NV:'Nevada',NH:'New Hampshire',NJ:'New Jersey',
        NM:'New Mexico',NY:'New York',NC:'North Carolina',ND:'North Dakota',OH:'Ohio',OK:'Oklahoma',
        OR:'Oregon',PA:'Pennsylvania',RI:'Rhode Island',SC:'South Carolina',SD:'South Dakota',
        TN:'Tennessee',TX:'Texas',UT:'Utah',VT:'Vermont',VA:'Virginia',WA:'Washington',
        WV:'West Virginia',WI:'Wisconsin',WY:'Wyoming',DC:'Washington D.C.'
      };

      const addressHtml = `
        ${name}<br>
        ${street}${apt ? ', ' + apt : ''}<br>
        ${city}, ${stateNames[state] || state} ${zip}<br>
        United States üá∫üá∏
      `;

      document.getElementById('merchConfirmAddress').innerHTML = addressHtml;

      // Populate order summary with all cart items
      const confirmItemsContainer = document.getElementById('merchConfirmItems');
      console.log('üì¶ Checkout items:', merchCheckoutItems);
      console.log('üì¶ Checkout total:', merchCheckoutTotal);

      if (merchCheckoutItems && merchCheckoutItems.length > 0) {
        // Multi-item checkout from cart - format like "1x PRODUCT NAME (SIZE)"
        const totalItems = merchCheckoutItems.reduce((sum, item) => sum + item.quantity, 0);
        const totalXrp = (merchCheckoutTotal / merchXrpPrice).toFixed(2);
        confirmItemsContainer.innerHTML = merchCheckoutItems.map(item => {
          const itemXrp = ((item.price * item.quantity) / merchXrpPrice).toFixed(2);
          return `
          <div class="merch-summary-row" style="display:flex; justify-content:space-between; align-items:center; padding:10px 0; border-bottom:1px solid rgba(255,255,255,0.1);">
            <span style="color:#fff;">${item.quantity}x ${item.name} (${item.size})</span>
            <span style="text-align:right;">
              <span style="color:#00ff88; font-weight:600;">~${itemXrp} XRP</span>
              <span style="font-size:11px; color:#888; margin-left:6px;">($${(item.price * item.quantity).toFixed(2)})</span>
            </span>
          </div>
        `}).join('') + `
          <div style="font-size:12px; color:#888; margin-top:8px; text-align:right;">${totalItems} item(s) total</div>
        `;
        document.getElementById('merchConfirmTotal').innerHTML = `~${totalXrp} XRP <span style="font-size:14px; color:#888;">($${merchCheckoutTotal.toFixed(2)})</span>`;
      } else if (merchCurrentProduct) {
        // Single item direct checkout
        const price = merchCurrentProduct.price_usd || 30;
        const singleXrp = (price / merchXrpPrice).toFixed(2);
        confirmItemsContainer.innerHTML = `
          <div class="merch-summary-row" style="display:flex; justify-content:space-between; align-items:center; padding:10px 0; border-bottom:1px solid rgba(255,255,255,0.1);">
            <span style="color:#fff;">1x ${merchCurrentProduct.name} (${merchSelectedSize})</span>
            <span style="text-align:right;">
              <span style="color:#00ff88; font-weight:600;">~${singleXrp} XRP</span>
              <span style="font-size:11px; color:#888; margin-left:6px;">($${price.toFixed(2)})</span>
            </span>
          </div>
          <div style="font-size:12px; color:#888; margin-top:8px; text-align:right;">1 item(s) total</div>
        `;
        document.getElementById('merchConfirmTotal').innerHTML = `~${singleXrp} XRP <span style="font-size:14px; color:#888;">($${price.toFixed(2)})</span>`;
      } else {
        // Fallback - no items found (shouldn't happen)
        console.error('No checkout items or product found');
        alert('Error: No items in checkout. Please try again.');
        merchShowScreen('gallery');
        return;
      }

      merchShowScreen('confirm');
    }

    function merchGoToPayment() {
      updateMerchXrpDisplay();
      startMerchRateRefresh();
      merchShowScreen('payment');
    }

    async function fetchXrpPrice() {
      try {
        const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd');
        const data = await response.json();
        merchXrpPrice = data.ripple?.usd || 2.10;
        updateMerchXrpDisplay();
        // Re-render product grid with updated XRP prices
        if (MERCH_PRODUCTS.length > 0) {
          loadMerchProducts();
        }
      } catch (error) {
        console.error('Error fetching XRP price:', error);
        merchXrpPrice = 2.10;
      }
    }

    function updateMerchXrpDisplay() {
      // Use cart total if checking out from cart, otherwise use single product price
      let price;
      if (merchCheckoutItems.length > 0) {
        price = merchCheckoutTotal;
      } else if (merchCurrentProduct) {
        price = merchCurrentProduct.price_usd || 30;
      } else {
        price = 30;
      }

      const xrpAmount = (price / merchXrpPrice).toFixed(2);
      const priceFormatted = `$${price.toFixed(2)}`;

      // Update XRP amounts
      document.querySelectorAll('#merchXrpPrice, #merchPaymentXrpAmount').forEach(el => {
        if (el) el.textContent = xrpAmount;
      });

      // Update XRP rate
      const rateEl = document.getElementById('merchXrpRate');
      if (rateEl) rateEl.textContent = merchXrpPrice.toFixed(2);

      // Update RLUSD price on payment screen
      const rlusdEl = document.getElementById('merchRlusdPayAmount');
      if (rlusdEl) rlusdEl.textContent = priceFormatted;

      // Update USD equivalent on XRP option
      const usdEquivEl = document.getElementById('merchXrpUsdEquiv');
      if (usdEquivEl) usdEquivEl.textContent = priceFormatted;

      // Update cart items preview on payment screen
      const cartPreview = document.getElementById('merchPaymentCartItems');
      if (cartPreview && merchCheckoutItems.length > 0) {
        cartPreview.innerHTML = getCheckoutItemsHTML();
      }
    }

    function startMerchRateRefresh() {
      let countdown = 30;
      const timerEl = document.getElementById('merchRateTimer');

      if (merchRateInterval) clearInterval(merchRateInterval);

      merchRateInterval = setInterval(() => {
        countdown--;
        if (timerEl) timerEl.textContent = countdown;

        if (countdown <= 0) {
          countdown = 30;
          fetchXrpPrice();
        }
      }, 1000);
    }

    async function merchCompletePurchase() {
      const paymentMethod = document.querySelector('input[name="merchPayment"]:checked')?.value || 'RLUSD';
      const walletAddress = localStorage.getItem('bearpark_wallet');

      if (!walletAddress) {
        alert('Please connect your wallet first!');
        return;
      }

      if (!merchSelectedWallet) {
        alert('Please select a wallet (XAMAN or Joey) to continue!');
        return;
      }

      // Reset processing screen to spinner state
      document.getElementById('merchSpinnerSection').style.display = 'block';
      document.getElementById('merchPaymentInstructions').style.display = 'none';
      document.getElementById('merchProcessingTitle').textContent = 'Processing...';
      document.getElementById('merchProcessingText').textContent = 'Creating order...';

      merchShowScreen('processing');

      try {
        // Prepare items for order - support both single item and cart checkout
        let orderItems;
        let totalAmount;

        if (merchCheckoutItems.length > 0) {
          // Multi-item checkout from cart
          orderItems = merchCheckoutItems.map(item => ({
            product_id: item.productId,
            name: item.name,
            size: item.size,
            quantity: item.quantity,
            price: item.price,
            image: item.image
          }));
          totalAmount = merchCheckoutTotal;
        } else {
          // Single item checkout (Buy Now)
          orderItems = [{
            product_id: merchCurrentProduct.id,
            name: merchCurrentProduct.name,
            size: merchSelectedSize,
            quantity: 1,
            price: merchCurrentProduct.price_usd || 30,
            image: merchCurrentProduct.images?.[0] || ''
          }];
          totalAmount = merchCurrentProduct.price_usd || 30;
        }

        // Generate items summary for memo/description
        const itemsSummary = orderItems.map(item =>
          `${item.quantity}x ${item.name} (${item.size})`
        ).join(' | ');

        // Create order on backend first
        const orderResponse = await fetch(`${API_BASE_URL}/api/merch/orders`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet_address: walletAddress,
            items: orderItems,
            items_summary: itemsSummary,
            total_amount: totalAmount,
            // Legacy single-item fields for backward compatibility
            product_id: orderItems[0].product_id,
            size: orderItems[0].size,
            payment_method: paymentMethod,
            shipping: merchShippingData
          })
        });

        const orderData = await orderResponse.json();

        if (!orderData.success) {
          throw new Error(orderData.error || 'Failed to create order');
        }

        // Now request payment instructions
        document.getElementById('merchProcessingText').textContent = 'Getting payment details...';

        const paymentResponse = await fetch(`${API_BASE_URL}/api/merch/request-payment`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            order_id: orderData.order_id,
            payment_method: paymentMethod,
            amount_usd: totalAmount,
            xrp_price: merchXrpPrice,
            wallet_type: merchSelectedWallet // 'xaman' or 'joey'
          })
        });

        const paymentData = await paymentResponse.json();

        if (!paymentData.success) {
          const errorMsg = paymentData.details
            ? `${paymentData.error}: ${paymentData.details}`
            : paymentData.error || 'Failed to create payment request';
          throw new Error(errorMsg);
        }

        // Handle wallet-specific payment flows
        if (merchSelectedWallet === 'joey') {
          // Joey wallet flow - use WalletConnect for automated payment
          document.getElementById('merchProcessingTitle').textContent = 'Connect Joey Wallet';

          // Start WalletConnect payment flow
          try {
            await startJoeyWalletConnectPayment(paymentData, paymentData.order_number);
            // Payment was successful, the monitor will pick it up
          } catch (wcError) {
            console.error('WalletConnect error:', wcError);
            // Fall back to manual payment details if WalletConnect fails
            const joeyAmount = paymentData.amount;
            const joeyDestination = paymentData.destination_address;
            const joeyTag = paymentData.destination_tag;
            const joeyCurrency = paymentData.currency;
            const joeyIssuer = paymentData.issuer || '';

            document.getElementById('merchProcessingTitle').textContent = 'Send Payment in Joey';
            document.getElementById('merchSpinnerSection').innerHTML = `
              <style>
                @keyframes joey-rotate {
                  0% { transform: rotate(0deg); }
                  100% { transform: rotate(360deg); }
                }
                @keyframes joey-glow {
                  0%, 100% { box-shadow: 0 0 20px rgba(245,158,11,0.3); }
                  50% { box-shadow: 0 0 40px rgba(245,158,11,0.6); }
                }
                .joey-spinner-ring {
                  width: 50px; height: 50px;
                  border: 4px solid rgba(245,158,11,0.2);
                  border-top: 4px solid #f59e0b;
                  border-radius: 50%;
                  animation: joey-rotate 1s linear infinite;
                  margin: 10px auto;
                }
                .joey-waiting-container {
                  background: linear-gradient(135deg, rgba(245,158,11,0.1), rgba(234,88,12,0.1));
                  border-radius: 16px;
                  padding: 20px;
                  margin-top: 15px;
                  border: 1px solid rgba(245,158,11,0.3);
                  animation: joey-glow 2s ease-in-out infinite;
                }
              </style>

              <p style="color:#ff6b6b; font-size:14px; margin-bottom:15px;">
                WalletConnect unavailable - please send manually
              </p>

              <!-- Manual Payment Details -->
              <div style="background: linear-gradient(135deg, rgba(245,158,11,0.2), rgba(234,88,12,0.15)); border:2px solid #f59e0b; border-radius:16px; padding:20px; margin:15px 0; text-align:left;">
                <p style="color:#f59e0b; font-weight:700; margin-bottom:15px; font-size:16px; text-align:center;">Send this payment in Joey:</p>
                <div style="font-family:monospace; font-size:14px; color:#fff; background:rgba(0,0,0,0.3); padding:15px; border-radius:10px;">
                  <p style="margin:8px 0;"><strong style="color:#f59e0b;">To:</strong> <span style="word-break:break-all;">${joeyDestination}</span></p>
                  <p style="margin:8px 0;"><strong style="color:#f59e0b;">Amount:</strong> ${joeyAmount} ${joeyCurrency}</p>
                  <p style="margin:8px 0; padding:10px; background:rgba(255,107,107,0.2); border-radius:8px; border:1px solid #ff6b6b;">
                    <strong style="color:#ff6b6b;">DESTINATION TAG:</strong> <span style="color:#fff; font-size:18px; font-weight:bold;">${joeyTag}</span>
                  </p>
                  ${joeyIssuer ? `<p style="margin:8px 0;"><strong style="color:#f59e0b;">Issuer:</strong> <span style="word-break:break-all;">${joeyIssuer}</span></p>` : ''}
                </div>
                <p style="color:#ff6b6b; font-size:12px; margin-top:12px; text-align:center;">You MUST include the Destination Tag!</p>
              </div>

              <p style="color:#888; font-size:13px; margin-bottom:15px;">
                <strong>Order:</strong> ${paymentData.order_number}
              </p>

              <div class="joey-waiting-container">
                <div class="joey-spinner-ring"></div>
                <p style="color:#f59e0b; font-size:16px; font-weight:600; margin-top:10px;">
                  Waiting for payment...
                </p>
                <p style="color:#888; font-size:12px;">We'll detect it automatically once you send</p>
              </div>
            `;
          }

        } else if (paymentData.xumm_payload && paymentData.xumm_payload.next_url) {
          // XAMAN wallet flow - use XUMM payload with QR code
          document.getElementById('merchProcessingTitle').textContent = 'Complete Transaction in XAMAN';
          const qrUrl = paymentData.xumm_payload.qr_png || '';
          const deepLink = paymentData.xumm_payload.next_url;

          document.getElementById('merchSpinnerSection').innerHTML = `
            <style>
              @keyframes xaman-pulse {
                0%, 100% { transform: scale(1); opacity: 1; }
                50% { transform: scale(1.05); opacity: 0.8; }
              }
              @keyframes xaman-rotate {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
              }
              @keyframes xaman-dots {
                0%, 20% { content: '.'; }
                40% { content: '..'; }
                60%, 100% { content: '...'; }
              }
              @keyframes xaman-glow {
                0%, 100% { box-shadow: 0 0 20px rgba(0,255,136,0.3); }
                50% { box-shadow: 0 0 40px rgba(0,255,136,0.6); }
              }
              @keyframes xaman-progress {
                0% { width: 0%; }
                100% { width: 100%; }
              }
              .xaman-qr-container {
                animation: xaman-pulse 2s ease-in-out infinite;
              }
              .xaman-spinner-ring {
                width: 60px; height: 60px;
                border: 4px solid rgba(0,255,136,0.2);
                border-top: 4px solid #00ff88;
                border-radius: 50%;
                animation: xaman-rotate 1s linear infinite;
                margin: 0 auto;
              }
              .xaman-status-text::after {
                animation: xaman-dots 1.5s steps(1) infinite;
                content: '...';
              }
              .xaman-waiting-container {
                background: linear-gradient(135deg, rgba(0,255,136,0.1), rgba(104,12,217,0.1));
                border-radius: 16px;
                padding: 25px;
                margin-top: 20px;
                border: 1px solid rgba(0,255,136,0.3);
                animation: xaman-glow 2s ease-in-out infinite;
              }
              .xaman-step {
                display: flex; align-items: center; gap: 12px;
                padding: 10px 0; color: #888; font-size: 14px;
                transition: all 0.3s ease;
              }
              .xaman-step.active { color: #00ff88; }
              .xaman-step.completed { color: #00ff88; }
              .xaman-step-icon {
                width: 24px; height: 24px;
                border-radius: 50%;
                display: flex; align-items: center; justify-content: center;
                font-size: 12px;
                background: rgba(255,255,255,0.1);
                border: 2px solid currentColor;
              }
              .xaman-step.active .xaman-step-icon {
                background: #00ff88;
                color: #000;
                border-color: #00ff88;
              }
              .xaman-step.completed .xaman-step-icon {
                background: #00ff88;
                color: #000;
              }
            </style>

            <p style="color:#00ff88; font-size:16px; margin-bottom:15px;">Scan with XAMAN app or tap to open</p>

            ${qrUrl ? `
              <div class="xaman-qr-container" style="background:#fff; padding:15px; border-radius:16px; display:inline-block; margin-bottom:20px;">
                <img src="${qrUrl}" alt="Scan with XAMAN" style="width:200px; height:200px; display:block;">
              </div>
            ` : ''}

            <div style="margin-bottom:15px;">
              <a href="${deepLink}" target="_blank"
                 style="display:inline-block; background: linear-gradient(135deg, #3052ff, #00c3ff); color:#fff; text-decoration:none; padding:15px 30px; border-radius:12px; font-size:18px; font-weight:bold;">
                Open XAMAN Wallet
              </a>
            </div>

            <p style="color:#888; font-size:13px; margin-bottom:10px;">
              <strong>Amount:</strong> ${paymentData.amount} ${paymentData.currency} &nbsp;|&nbsp; <strong>Order:</strong> ${paymentData.order_number}
            </p>

            <div class="xaman-waiting-container">
              <div class="xaman-spinner-ring"></div>
              <p class="xaman-status-text" id="xamanStatusText" style="color:#00ff88; font-size:18px; font-weight:600; margin-top:15px;">
                Waiting for signature
              </p>
              <p style="color:#888; font-size:12px; margin-top:5px;">This may take a moment</p>

              <div style="margin-top:20px; text-align:left; max-width:280px; margin-left:auto; margin-right:auto;">
                <div class="xaman-step active" id="step1">
                  <div class="xaman-step-icon">1</div>
                  <span>Open XAMAN & sign transaction</span>
                </div>
                <div class="xaman-step" id="step2">
                  <div class="xaman-step-icon">2</div>
                  <span>Confirming on XRP Ledger</span>
                </div>
                <div class="xaman-step" id="step3">
                  <div class="xaman-step-icon">3</div>
                  <span>Payment verified</span>
                </div>
              </div>
            </div>

            <p style="color:#ff6b6b; font-size:13px; margin-top:20px; padding:12px 15px; background:rgba(255,107,107,0.1); border-radius:10px; border:1px solid rgba(255,107,107,0.3);">
              <strong>Please wait after signing.</strong> Do not refresh or close this page!
            </p>
          `;

          // Animate steps after a delay (simulating signature detection)
          setTimeout(() => {
            const step1 = document.getElementById('step1');
            const step2 = document.getElementById('step2');
            const statusText = document.getElementById('xamanStatusText');
            if (step1 && step2 && statusText) {
              step1.classList.remove('active');
              step1.classList.add('completed');
              step1.querySelector('.xaman-step-icon').innerHTML = '‚úì';
              step2.classList.add('active');
              statusText.textContent = 'Confirming payment';
            }
          }, 8000);
        } else {
          // Manual payment flow (for RLUSD or fallback)
          document.getElementById('merchProcessingTitle').textContent = 'Complete Payment';
          document.getElementById('merchSpinnerSection').style.display = 'none';
          document.getElementById('merchPaymentInstructions').style.display = 'block';

          // Populate payment details
          document.getElementById('merchPayAmount').textContent = paymentData.amount;
          document.getElementById('merchPayCurrency').textContent = paymentData.currency;
          document.getElementById('merchPayOrderNum').textContent = paymentData.order_number;
          document.getElementById('merchPayAddress').textContent = paymentData.destination_address;
          document.getElementById('merchPayTag').textContent = paymentData.destination_tag;
        }

        // Poll for payment status
        let pollCount = 0;
        const maxPolls = 120; // 10 minutes at 5 second intervals

        const pollPayment = async () => {
          try {
            const statusResponse = await fetch(`${API_BASE_URL}/api/merch/orders/${orderData.order_id}/status`);
            const statusData = await statusResponse.json();

            if (statusData.status === 'paid' || statusData.status === 'processing') {
              // Payment successful!
              showMerchSuccess(orderData.order_id, orderData.order_number);
            } else if (statusData.status === 'failed') {
              alert('Payment failed. Please try again.');
              merchShowScreen('payment');
            } else {
              // Keep polling
              pollCount++;
              if (pollCount < maxPolls) {
                setTimeout(pollPayment, 5000); // Check every 5 seconds
              } else {
                alert('Payment timeout. Your order is saved - if you sent payment, it will be processed automatically.');
                closeMerchStoreModal();
              }
            }
          } catch (e) {
            console.error('Poll error:', e);
            setTimeout(pollPayment, 5000);
          }
        };

        setTimeout(pollPayment, 5000);

      } catch (error) {
        console.error('Merch purchase error:', error);
        alert('Purchase failed: ' + error.message);
        merchShowScreen('payment');
      }
    }

    // Helper function to copy to clipboard
    function copyToClipboard(text, button) {
      navigator.clipboard.writeText(text).then(() => {
        const originalText = button.textContent;
        button.textContent = 'Copied!';
        button.style.background = '#00ff88';
        button.style.color = '#000';
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = '';
          button.style.color = '';
        }, 2000);
      });
    }

    // Store last order data for receipts
    let lastMerchOrderData = null;

    function showMerchSuccess(orderId, orderNumber, paymentMethod = 'RLUSD') {
      const now = new Date();
      const dateStr = now.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });

      document.getElementById('merchOrderNumber').textContent = orderNumber || `BEAR-${Date.now()}`;
      document.getElementById('merchOrderDate').textContent = dateStr;

      // Handle multi-item or single item display
      let itemsText = '';
      let totalPrice = 0;

      if (merchCheckoutItems.length > 0) {
        // Multi-item order
        itemsText = merchCheckoutItems.map(item =>
          `${item.quantity}x ${item.name} (${item.size})`
        ).join('<br>');
        totalPrice = merchCheckoutTotal;
      } else if (merchCurrentProduct) {
        // Single item order
        itemsText = `${merchCurrentProduct.name} (${merchSelectedSize})`;
        totalPrice = merchCurrentProduct.price_usd || 30;
      }

      document.getElementById('merchOrderItem').innerHTML = itemsText;
      document.getElementById('merchOrderTotal').textContent = `$${totalPrice.toFixed(2)}`;
      document.getElementById('merchOrderPayment').textContent = paymentMethod || 'RLUSD';

      const addressHtml = `
        ${merchShippingData.name}<br>
        ${merchShippingData.street}${merchShippingData.apt ? ', ' + merchShippingData.apt : ''}<br>
        ${merchShippingData.city}, ${merchShippingData.state} ${merchShippingData.zip}
      `;
      document.getElementById('merchOrderAddress').innerHTML = addressHtml;

      // Store order data for receipt access
      lastMerchOrderData = {
        orderId,
        orderNumber: orderNumber || `BEAR-${Date.now()}`,
        date: dateStr,
        items: merchCheckoutItems.length > 0 ? merchCheckoutItems : [{
          name: merchCurrentProduct?.name,
          size: merchSelectedSize,
          quantity: 1,
          price: merchCurrentProduct?.price_usd || 30
        }],
        total: `$${totalPrice.toFixed(2)}`,
        payment: paymentMethod || 'RLUSD',
        address: merchShippingData
      };

      if (merchRateInterval) clearInterval(merchRateInterval);

      // Clear purchased items from cart
      if (merchCheckoutItems.length > 0) {
        // Multi-item checkout - clear all checkout items from cart
        merchCheckoutItems.forEach(checkoutItem => {
          const idx = merchCart.findIndex(
            cartItem => cartItem.productId === checkoutItem.productId && cartItem.size === checkoutItem.size
          );
          if (idx >= 0) {
            merchCart.splice(idx, 1);
          }
        });
        // Reset checkout state
        merchCheckoutItems = [];
        merchCheckoutTotal = 0;
      } else if (merchCurrentProduct) {
        // Single item checkout
        const purchasedItemIndex = merchCart.findIndex(
          item => item.productId === merchCurrentProduct.id && item.size === merchSelectedSize
        );
        if (purchasedItemIndex >= 0) {
          merchCart.splice(purchasedItemIndex, 1);
        }
      }

      saveMerchCart();
      updateCartBadge();

      merchShowScreen('success');
    }

    // Save receipt - highlights the receipt box for screenshot
    function saveMerchReceipt() {
      const receiptBox = document.getElementById('merchReceiptBox');
      if (receiptBox) {
        // Flash animation to indicate "screenshot now!"
        receiptBox.style.transition = 'all 0.3s';
        receiptBox.style.boxShadow = '0 0 30px rgba(0,255,136,0.8)';
        receiptBox.style.transform = 'scale(1.02)';

        // Show alert with instructions
        alert('üì∏ Take a screenshot now to save your receipt!\n\nYou can also view all your orders anytime by clicking "VIEW MY RECEIPTS"');

        setTimeout(() => {
          receiptBox.style.boxShadow = '';
          receiptBox.style.transform = '';
        }, 2000);
      }
    }

    // Open My Receipts Modal - shows user's order history
    async function openMyReceiptsModal() {
      // Close merch store modal first
      closeMerchStoreModal();

      // Check if user has wallet connected
      const walletAddress = localStorage.getItem('bearpark_wallet');
      if (!walletAddress) {
        alert('Please connect your wallet to view your order history.');
        return;
      }

      // Show loading
      showMyReceiptsModal(true);

      try {
        // Fetch user's orders from backend
        const response = await fetch(`https://bearpark-api-production.up.railway.app/api/merch/orders/my-orders?wallet=${walletAddress}`);
        const data = await response.json();

        if (data.success && data.orders) {
          renderMyReceipts(data.orders);
        } else {
          renderMyReceipts([]);
        }
      } catch (error) {
        console.error('Error fetching orders:', error);
        renderMyReceipts([]);
      }

      showMyReceiptsModal(false);
    }

    function showMyReceiptsModal(loading = false) {
      let modal = document.getElementById('myReceiptsModal');

      if (!modal) {
        // Create the modal if it doesn't exist
        modal = document.createElement('div');
        modal.id = 'myReceiptsModal';
        modal.className = 'store-modal';
        modal.innerHTML = `
          <div class="store-modal-content" style="max-width:600px;">
            <div class="store-header" style="background:linear-gradient(135deg, #680cd9, #00ff88);">
              <div class="store-title-section">
                <h2 class="store-title">üìã MY PURCHASE RECEIPTS</h2>
              </div>
              <div class="store-balance-container">
                <button class="store-close-btn" onclick="closeMyReceiptsModal()">√ó</button>
              </div>
            </div>
            <div class="store-body" style="padding:20px; max-height:70vh; overflow-y:auto;">
              <div id="myReceiptsContent">
                <div style="text-align:center; padding:40px;">
                  <div class="merch-spinner"></div>
                  <p style="color:#888; margin-top:20px;">Loading your orders...</p>
                </div>
              </div>

              <!-- Support Info -->
              <div style="background:rgba(104,12,217,0.2); border:2px solid rgba(104,12,217,0.4); border-radius:12px; padding:15px; margin-top:20px; text-align:center;">
                <div style="font-size:14px; font-weight:700; color:#fff; margin-bottom:10px;">‚ùì Questions or Issues with an Order?</div>
                <div style="font-size:13px; color:#ccc; line-height:1.8;">
                  <div>üê¶ <strong style="color:#00c3ff;">@APEX_589</strong> on X (Twitter)</div>
                  <div>üí¨ <strong style="color:#7c3aed;">cryptoapex</strong> on Discord</div>
                </div>
              </div>
            </div>
          </div>
        `;
        document.body.appendChild(modal);

        // Close on backdrop click
        modal.addEventListener('click', (e) => {
          if (e.target === modal) closeMyReceiptsModal();
        });
      }

      modal.classList.add('active');
    }

    function closeMyReceiptsModal() {
      const modal = document.getElementById('myReceiptsModal');
      if (modal) modal.classList.remove('active');
    }

    function renderMyReceipts(orders) {
      const container = document.getElementById('myReceiptsContent');

      if (!orders || orders.length === 0) {
        container.innerHTML = `
          <div style="text-align:center; padding:40px;">
            <div style="font-size:60px; margin-bottom:20px;">üì¶</div>
            <h3 style="color:#fff; margin-bottom:10px;">No Orders Yet</h3>
            <p style="color:#888;">Your purchase history will appear here after you make your first order!</p>
            <button onclick="closeMyReceiptsModal(); setTimeout(openMerchStoreModal, 300);" class="merch-btn-primary" style="margin-top:20px;">
              üõí BROWSE MERCH STORE
            </button>
          </div>
        `;
        return;
      }

      // Sort by date, newest first
      orders.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

      let html = `<div style="margin-bottom:15px; color:#888; font-size:13px;">${orders.length} order(s) found</div>`;

      orders.forEach(order => {
        const date = new Date(order.created_at).toLocaleDateString('en-US', {
          year: 'numeric', month: 'short', day: 'numeric'
        });

        const statusColors = {
          'pending': '#f59e0b',
          'paid': '#3b82f6',
          'shipped': '#22c55e',
          'delivered': '#10b981',
          'cancelled': '#ef4444'
        };
        const statusColor = statusColors[order.status] || '#888';
        const statusEmoji = {
          'pending': '‚è≥',
          'paid': '‚úÖ',
          'shipped': 'üì¶',
          'delivered': 'üéâ',
          'cancelled': '‚ùå'
        }[order.status] || 'üìã';

        // Parse items array if present (multi-item orders)
        let orderItems = [];
        try {
          if (order.items) {
            orderItems = typeof order.items === 'string' ? JSON.parse(order.items) : order.items;
          }
        } catch (e) {
          console.warn('Failed to parse order items:', e);
        }

        // Check if this is a multi-item order
        const isMultiItem = orderItems && orderItems.length > 0;

        html += `
          <div style="background:rgba(0,0,0,0.3); border:2px solid rgba(104,12,217,0.3); border-radius:12px; padding:15px; margin-bottom:15px;">
            <!-- Order Header -->
            <div style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:12px; padding-bottom:10px; border-bottom:1px solid rgba(255,255,255,0.1);">
              <div>
                <div style="font-family:monospace; color:#00ff88; font-weight:700; font-size:14px;">${order.order_number || order.id}</div>
                <div style="font-size:11px; color:#888;">${date}</div>
              </div>
              <div style="background:rgba(0,0,0,0.3); padding:4px 10px; border-radius:20px; font-size:11px; font-weight:700; color:${statusColor};">
                ${statusEmoji} ${(order.status || 'pending').toUpperCase()}
              </div>
            </div>

            <!-- Order Items -->
            ${isMultiItem ? orderItems.map(item => {
              const itemProduct = MERCH_PRODUCTS.find(p => p.id === item.product_id);
              const itemImage = item.image || itemProduct?.images?.[0] || 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/n3rrso.webp';
              return `
                <div style="display:flex; gap:12px; align-items:center; padding:10px; background:rgba(0,0,0,0.2); border-radius:10px; margin-bottom:8px;">
                  <img src="${itemImage}" alt="${item.name}" style="width:50px; height:50px; object-fit:cover; border-radius:8px; border:2px solid rgba(104,12,217,0.3);" onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/n3rrso.webp'">
                  <div style="flex:1; min-width:0;">
                    <div style="font-size:13px; color:#fff; font-weight:600;">${item.name || 'Product'}</div>
                    <div style="font-size:11px; color:#888;">Size: ${item.size || 'N/A'} | Qty: ${item.quantity || 1}</div>
                  </div>
                  <div style="font-size:13px; color:#00ff88; font-weight:700;">$${(parseFloat(item.price || 0) * (item.quantity || 1)).toFixed(2)}</div>
                </div>
              `;
            }).join('') : `
              <!-- Single Item Order (legacy) -->
              <div style="display:flex; gap:12px; align-items:center; padding:10px; background:rgba(0,0,0,0.2); border-radius:10px; margin-bottom:8px;">
                <img src="${order.product_image || MERCH_PRODUCTS.find(p => p.id === order.product_id)?.images?.[0] || 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/n3rrso.webp'}" alt="${order.product_name || 'Product'}" style="width:50px; height:50px; object-fit:cover; border-radius:8px; border:2px solid rgba(104,12,217,0.3);" onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/n3rrso.webp'">
                <div style="flex:1; min-width:0;">
                  <div style="font-size:13px; color:#fff; font-weight:600;">${order.product_name || 'Product'}</div>
                  <div style="font-size:11px; color:#888;">Size: ${order.size || 'N/A'}</div>
                </div>
                <div style="font-size:13px; color:#00ff88; font-weight:700;">$${parseFloat(order.amount_usd || 30).toFixed(2)}</div>
              </div>
            `}

            <!-- Order Total -->
            <div style="display:flex; justify-content:space-between; align-items:center; padding-top:10px; border-top:1px solid rgba(255,255,255,0.1); margin-top:4px;">
              <div style="font-size:12px; color:#888;">${isMultiItem ? orderItems.reduce((sum, i) => sum + (i.quantity || 1), 0) : 1} item(s)</div>
              <div style="font-size:16px; color:#00ff88; font-weight:800;">Total: $${parseFloat(order.amount_usd || 30).toFixed(2)}</div>
            </div>

            ${order.tracking_number ? `<div style="font-size:11px; color:#888; margin-top:10px; padding-top:10px; border-top:1px solid rgba(255,255,255,0.1);">üì¶ Tracking: <span style="color:#00c3ff;">${order.tracking_number}</span></div>` : ''}
          </div>
        `;
      });

      container.innerHTML = html;
    }

    // Close merch modal when clicking outside
    document.getElementById('merchStoreModal')?.addEventListener('click', (e) => {
      if (e.target.id === 'merchStoreModal') {
        closeMerchStoreModal();
      }
    });
    // ===== END MERCH STORE JAVASCRIPT =====
  </script>
  <!-- ===== END COSMETICS STORE ===== -->

  <!-- ===== MEME OF THE WEEK JAVASCRIPT ===== -->
  <script>
// üé≠ MEME OF THE WEEK - FIXED VERSION - Global State
let currentMemes = [];
let currentSlide = 0;
let userVotes = new Set();
let weekEndTime = null;
let timerInterval = null;

// üõ°Ô∏è API Call Rate Limiter - Prevent 429 errors
const memeApiCache = {
  timer: { data: null, lastFetch: 0 },
  currentWeek: { data: null, lastFetch: 0 },
  leaderboard: { data: null, lastFetch: 0 }
};
const MEME_API_COOLDOWN = 10000; // 10 seconds between API calls

async function cachedFetch(endpoint, cacheKey) {
  const cache = memeApiCache[cacheKey];
  const now = Date.now();

  // Return cached data if still fresh
  if (cache.data && (now - cache.lastFetch) < MEME_API_COOLDOWN) {
    return cache.data;
  }

  try {
    const response = await fetch(endpoint);
    if (response.status === 429) {
      console.log(`‚è≥ Rate limited on ${endpoint}, using cache`);
      return cache.data || { success: false, error: 'Rate limited' };
    }
    const data = await response.json();
    cache.data = data;
    cache.lastFetch = now;
    return data;
  } catch (error) {
    console.error(`‚ùå Failed to fetch ${endpoint}:`, error);
    return cache.data || { success: false, error: error.message };
  }
}

// üöÄ Initialize Meme of the Week
async function initMemeOfTheWeek() {
  try {
    await loadTimer();
    await loadMemes();
    await loadLeaderboard();

    const walletAddress = localStorage.getItem('bearpark_wallet');
    if (walletAddress) {
      await loadUserVotes();
    }

    // Start timer update
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(updateTimer, 1000);

    // Setup drag and drop
    const dropZone = document.getElementById('meme-dropzone');
    const fileInput = document.getElementById('meme-file-input');

    // Don't add click listener to dropzone - buttons handle it

    dropZone?.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('drag-over');
    });

    dropZone?.addEventListener('dragleave', () => {
      dropZone.classList.remove('drag-over');
    });

    dropZone?.addEventListener('drop', async (e) => {
      e.preventDefault();
      dropZone.classList.remove('drag-over');

      const file = e.dataTransfer.files[0];
      if (file && (file.type.startsWith('image/') || file.type.startsWith('video/'))) {
        handleMemeFileSelect(file);
      } else {
        alert('Please drop a valid media file!\nImages: JPG, PNG, GIF, WEBP\nVideos: MP4, WEBM, MOV, AVI, MPEG');
      }
    });

    fileInput?.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) handleMemeFileSelect(file);
    });

    console.log('üé≠ Meme of the Week initialized!');
  } catch (error) {
    console.error('‚ùå Failed to initialize Meme of the Week:', error);
  }
}

// ‚è∞ Load Timer Info
async function loadTimer() {
  try {
    const data = await cachedFetch('/api/memes/timer', 'timer');

    if (data.success) {
      weekEndTime = new Date(data.next_week_start);
      updateTimer();
    }
  } catch (error) {
    console.error('‚ùå Failed to load timer:', error);
  }
}

// üïê Update Timer Display
let weekEndedRefreshCount = 0;
const MAX_WEEK_END_REFRESHES = 3; // Limit refresh attempts when week ends

function updateTimer() {
  const timerEl = document.getElementById('meme-timer');
  if (!timerEl || !weekEndTime) return;

  const now = new Date();
  const diff = weekEndTime - now;

  if (diff <= 0) {
    // Week ended - check if we should refresh or show waiting message
    if (weekEndedRefreshCount < MAX_WEEK_END_REFRESHES) {
      weekEndedRefreshCount++;
      timerEl.innerHTML = '<span class="days">0d</span><span class="hours">0h</span><span class="mins">0m</span><span class="secs">0s</span>';
      // Try to reload for new week
      setTimeout(async () => {
        await loadTimer();
        await loadMemes();
        await loadLeaderboard();
      }, 3000);
    } else {
      // Stop refreshing, show waiting message
      timerEl.innerHTML = '<span class="days" style="color: var(--gold);">Resetting...</span>';
      // Check again in 30 seconds
      setTimeout(() => {
        weekEndedRefreshCount = 0; // Reset counter to try again
        loadTimer();
      }, 30000);
    }
    return;
  }

  // Week is active - reset the refresh counter
  weekEndedRefreshCount = 0;

  const days = Math.floor(diff / (1000 * 60 * 60 * 24));
  const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
  const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
  const seconds = Math.floor((diff % (1000 * 60)) / 1000);

  timerEl.innerHTML = `<span class="days">${days}d</span><span class="hours">${hours}h</span><span class="mins">${minutes}m</span><span class="secs">${seconds}s</span>`;
}

// üì• Load Memes from API
async function loadMemes() {
  try {
    const data = await cachedFetch('/api/memes/current-week', 'currentWeek');

    if (data.success) {
      currentMemes = data.memes || [];
      currentSlide = 0;
      renderCarousel();
      updateUploadButton();
    }
  } catch (error) {
    console.error('‚ùå Failed to load memes:', error);
  }
}

// üé† Render Carousel
function renderCarousel() {
  const container = document.getElementById('meme-track');
  if (!container) return;

  if (currentMemes.length === 0) {
    container.innerHTML = `
      <div class="empty-state">
        <div style="font-size: 80px;">üé®</div>
        <h3 style="color: var(--gold); font-size: 32px; margin: 20px 0;">No memes yet this week!</h3>
        <p style="color: var(--honey); font-size: 20px;">Be the first to submit a meme and earn 50 honey points!</p>
        <button class="btn btn-gold" onclick="openMemeUploadModal()" style="margin-top: 1rem;">
          üì§ SUBMIT MEME
        </button>
      </div>
    `;
    return;
  }

  const walletAddress = localStorage.getItem('bearpark_wallet');
  container.innerHTML = currentMemes.map((meme, index) => {
    const hasVoted = userVotes.has(meme.id);
    const isCurrentUser = walletAddress && meme.wallet_address.toLowerCase() === walletAddress.toLowerCase();
    const isVideo = meme.image_url.match(/\.(mp4|webm|mov|avi|mpeg)$/i);

    // Parse avatar NFT
    let avatarUrl = 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/1z14d9.jpg';
    if (meme.avatar_nft) {
      try {
        const avatarData = JSON.parse(meme.avatar_nft);
        avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl || avatarUrl;
      } catch (e) {}
    }

    const equippedRing = meme.equipped_ring;

    return `
      <div class="meme-slide ${index === currentSlide ? 'active' : ''}" data-slide="${index}">
        <div class="meme-image-container">
          ${isVideo ?
            `<video src="${meme.image_url}" controls class="meme-image"></video>` :
            `<img src="${meme.image_url}" alt="Meme by ${meme.username || 'Anonymous'}" class="meme-image">`
          }
        </div>
        <div class="meme-info">
          <div class="meme-author">
            <div class="meme-avatar-container" style="position: relative; width: 60px; height: 60px; flex-shrink: 0; display: flex; align-items: center; justify-content: center; overflow: visible;">
              <img src="${avatarUrl}" alt="${meme.username || 'Anonymous'}" class="meme-avatar" onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/1z14d9.jpg';">
              ${equippedRing ? `<img src="${equippedRing.image_url}" class="meme-cosmetic-ring ${equippedRing.ring_type}" alt="${equippedRing.name}" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; height: 100%; pointer-events: none; z-index: 1; ${equippedRing.rarity === 'bearableguy123' ? 'animation: spinRingImage 3s linear infinite !important;' : ''}">` : ''}
            </div>
            <span class="meme-username">${meme.username || 'Anonymous'}</span>
          </div>
          ${meme.caption ? `<p class="meme-caption">${escapeHtml(meme.caption)}</p>` : ''}
          <div class="meme-actions">
            <button
              class="meme-vote-btn ${hasVoted ? 'voted' : ''}"
              onclick="voteMeme(${meme.id})"
              ${!walletAddress || isCurrentUser ? 'disabled' : ''}
              title="${!walletAddress ? 'Connect wallet to vote' : isCurrentUser ? 'Cannot vote for your own meme' : hasVoted ? 'Click to remove vote' : 'Vote for this meme'}"
            >
              <span class="vote-icon">${hasVoted ? '‚úÖ' : '‚¨ÜÔ∏è'}</span>
              <span class="vote-count">${meme.vote_count || 0}</span>
            </button>
          </div>
        </div>
        <div class="meme-counter">${index + 1} / ${currentMemes.length}</div>
      </div>
    `;
  }).join('');
}

// ‚¨ÖÔ∏è Previous Slide
function prevMemeSlide() {
  if (currentSlide > 0) {
    currentSlide--;
    renderCarousel();
  }
}

// ‚û°Ô∏è Next Slide
function nextMemeSlide() {
  if (currentSlide < currentMemes.length - 1) {
    currentSlide++;
    renderCarousel();
  }
}

// üó≥Ô∏è Vote for Meme
async function voteMeme(memeId) {
  console.log('üó≥Ô∏è voteMeme called for meme ID:', memeId);
  console.log('üìã Current userVotes:', Array.from(userVotes));

  const walletAddress = localStorage.getItem('bearpark_wallet');
  console.log('üëõ Wallet address:', walletAddress);

  if (!walletAddress) {
    alert('Please connect your wallet to vote!');
    return;
  }

  // If user already voted for THIS meme, unvote it
  if (userVotes.has(memeId)) {
    console.log('üîÑ User already voted for this meme, calling unvote');
    await unvoteMeme(memeId);
    return;
  }

  // Find the meme
  const meme = currentMemes.find(m => m.id === memeId);
  console.log('üé≠ Found meme:', meme);
  if (!meme) {
    console.error('‚ùå Meme not found in currentMemes');
    alert('DEBUG: Meme not found in currentMemes!');
    return;
  }

  // Check if voting for own meme
  if (meme.wallet_address.toLowerCase() === walletAddress.toLowerCase()) {
    console.log('‚ö†Ô∏è Cannot vote for own meme');
    alert('You cannot vote for your own meme!');
    return;
  }

  console.log('üì§ Sending vote request to backend...');

  try {
    const response = await fetch(`/api/memes/${memeId}/vote`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        wallet_address: walletAddress
      })
    });

    console.log('üì• Response status:', response.status);
    const data = await response.json();
    console.log('üì¶ Response data:', data);

    // TEMPORARY DEBUG ALERT
    if (!response.ok) {
      alert(`VOTE FAILED!\nStatus: ${response.status}\nError: ${data.error || 'Unknown'}\n\nDID YOU RUN THE SQL SCRIPT IN SUPABASE?`);
    }

    if (!response.ok || !data.success) {
      throw new Error(data.error || 'Failed to vote');
    }

    // Handle vote switching
    if (data.switched && data.oldMemeId) {
      userVotes.delete(data.oldMemeId);
      const oldMeme = currentMemes.find(m => m.id === data.oldMemeId);
      if (oldMeme) {
        oldMeme.vote_count = Math.max(0, (oldMeme.vote_count || 0) - 1);
      }
      console.log('üîÑ Vote switched from meme', data.oldMemeId, 'to meme', data.newMemeId);
    }

    // Add new vote
    userVotes.clear();
    userVotes.add(memeId);
    meme.vote_count = (meme.vote_count || 0) + 1;

    // Re-render
    renderCarousel();
    loadLeaderboard();

    console.log(data.switched ? 'üîÑ Vote switched successfully!' : '‚úÖ Vote recorded!');

    // TEMPORARY DEBUG ALERT
    alert(`‚úÖ VOTE SUCCESS!\nMeme ID: ${memeId}\nNew vote count: ${meme.vote_count}`);
  } catch (error) {
    console.error('‚ùå Vote error:', error);
    alert(`‚ùå VOTE ERROR!\n${error.message}\n\nCheck if database tables exist in Supabase!`);
  }
}

// üó≥Ô∏è Unvote (remove vote from a meme)
async function unvoteMeme(memeId) {
  const walletAddress = localStorage.getItem('bearpark_wallet');
  if (!walletAddress) {
    alert('Please connect your wallet!');
    return;
  }

  // Find the meme
  const meme = currentMemes.find(m => m.id === memeId);
  if (!meme) return;

  try {
    // Use query parameter for DELETE request
    const response = await fetch(`/api/memes/${memeId}/vote?wallet_address=${encodeURIComponent(walletAddress)}`, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
      }
    });

    const data = await response.json();

    if (!response.ok || !data.success) {
      throw new Error(data.error || 'Failed to remove vote');
    }

    // Remove vote from local state
    userVotes.delete(memeId);
    meme.vote_count = Math.max(0, (meme.vote_count || 0) - 1);

    // Re-render
    renderCarousel();
    loadLeaderboard();

    console.log('‚ùå Vote removed!');
  } catch (error) {
    console.error('‚ùå Unvote error:', error);
    alert(`Failed to remove vote: ${error.message}`);
  }
}

// üìä Load Leaderboard
async function loadLeaderboard() {
  try {
    const data = await cachedFetch('/api/memes/leaderboard', 'leaderboard');

    const container = document.getElementById('meme-leaderboard-list');
    if (!container) return;

    if (!data.success || !data.leaderboard || data.leaderboard.length === 0) {
      container.innerHTML = `
        <div class="leaderboard-empty">No memes yet!</div>
      `;
      return;
    }

    const medals = ['ü•á', 'ü•à', 'ü•â'];
    const rewards = [50, 35, 20];

    container.innerHTML = data.leaderboard.map((meme, index) => {
      const isVideo = meme.image_url.match(/\.(mp4|webm|mov|avi|mpeg)$/i);

      // Parse avatar NFT
      let avatarUrl = 'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/1z14d9.jpg';
      if (meme.avatar_nft) {
        try {
          const avatarData = JSON.parse(meme.avatar_nft);
          avatarUrl = avatarData.imageUrl || avatarData.fallbackImageUrl || avatarUrl;
        } catch (e) {}
      }

      const equippedRing = meme.equipped_ring;

      return `
        <div class="leaderboard-item" onclick="jumpToMeme(${meme.id})" style="cursor: pointer;">
          <div class="leaderboard-rank">${medals[index] || `#${index + 1}`}</div>
          ${isVideo ?
            `<video src="${meme.image_url}" class="leaderboard-meme-thumb" muted loop autoplay playsinline></video>` :
            `<img src="${meme.image_url}" alt="Meme" class="leaderboard-meme-thumb">`
          }
          <div class="leaderboard-info">
            <div class="leaderboard-user">
              <div class="leaderboard-avatar-container" style="position: relative; width: 48px; height: 48px; flex-shrink: 0; display: flex; align-items: center; justify-content: center; overflow: visible;">
                <img src="${avatarUrl}" alt="${meme.username || 'Anonymous'}" class="leaderboard-avatar" onerror="this.src='https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/1z14d9.jpg';">
                ${equippedRing ? `<img src="${equippedRing.image_url}" class="leaderboard-cosmetic-ring ${equippedRing.ring_type}" alt="${equippedRing.name}" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; height: 100%; pointer-events: none; z-index: 1; ${equippedRing.rarity === 'bearableguy123' ? 'animation: spinRingImage 3s linear infinite !important;' : ''}">` : ''}
              </div>
              <span class="leaderboard-username">${meme.username || 'Anonymous'}</span>
            </div>
            <div class="leaderboard-stats">
              <span class="leaderboard-votes">‚¨ÜÔ∏è ${meme.vote_count || 0}</span>
              ${index < 3 ? `<span class="leaderboard-reward">+${rewards[index]} üçØ</span>` : ''}
            </div>
          </div>
        </div>
      `;
    }).join('');

  } catch (error) {
    console.error('‚ùå Failed to load leaderboard:', error);
  }
}

// üéØ Jump to specific meme in carousel
function jumpToMeme(memeId) {
  // Find the index of this meme in currentMemes
  const memeIndex = currentMemes.findIndex(m => m.id === memeId);

  if (memeIndex === -1) {
    console.error('Meme not found in carousel:', memeId);
    return;
  }

  // Set the current slide to this meme
  currentSlide = memeIndex;

  // Re-render the carousel to show this meme
  renderCarousel();

  // Scroll to the meme carousel section
  const carouselSection = document.getElementById('meme-carousel-container');
  if (carouselSection) {
    carouselSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }

  console.log(`üéØ Jumped to meme ${memeId} (slide ${memeIndex + 1}/${currentMemes.length})`);
}

// üì• Load User's Votes
async function loadUserVotes() {
  const walletAddress = localStorage.getItem('bearpark_wallet');
  if (!walletAddress) {
    console.log('‚ö†Ô∏è No wallet address, skipping vote load');
    return;
  }

  try {
    console.log('üì• Loading user votes for:', walletAddress);
    const response = await fetch(`/api/memes/user-votes/${walletAddress}`);
    const data = await response.json();

    console.log('üì¶ User votes response:', data);

    if (data.success && data.votes) {
      // Clear existing votes and add new ones
      userVotes.clear();
      data.votes.forEach(v => {
        console.log('Adding vote for meme ID:', v.meme_id);
        userVotes.add(v.meme_id);
      });
      console.log('‚úÖ Loaded votes:', Array.from(userVotes));
    } else {
      console.log('‚ö†Ô∏è No votes found or failed:', data);
    }
  } catch (error) {
    console.error('‚ùå Failed to load user votes:', error);
    alert(`DEBUG: Failed to load votes!\n${error.message}`);
  }
}

// üîÑ Update Upload Button based on whether user has a meme
function updateUploadButton() {
  const walletAddress = localStorage.getItem('bearpark_wallet');
  if (!walletAddress) return;

  const btn = document.getElementById('meme-upload-btn');
  if (!btn) return;

  // Check if current user has a meme in currentMemes
  const userMeme = currentMemes.find(m =>
    m.wallet_address.toLowerCase() === walletAddress.toLowerCase()
  );

  if (userMeme) {
    // User has a meme - show delete button
    btn.innerHTML = `
      <span class="upload-icon">üóëÔ∏è</span>
      <span class="upload-text">DELETE YOUR UPLOADED MEME</span>
    `;
    btn.onclick = () => deleteMeme(userMeme.id);
  } else {
    // User doesn't have a meme - show upload button
    btn.innerHTML = `
      <span class="upload-icon">üì§</span>
      <span class="upload-text">ADD YOUR OWN MEME</span>
      <span class="upload-reward">+50 üçØ</span>
    `;
    btn.onclick = openMemeUploadModal;
  }
}

// üóëÔ∏è Delete Meme
async function deleteMeme(memeId) {
  const confirmed = confirm('If you delete your meme, you will lose all of your votes. Press OK to confirm.');

  if (!confirmed) return;

  const walletAddress = localStorage.getItem('bearpark_wallet');
  if (!walletAddress) {
    alert('Please connect your wallet!');
    return;
  }

  try {
    const response = await fetch(`/api/memes/${memeId}`, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        wallet_address: walletAddress
      })
    });

    const data = await response.json();

    if (!response.ok || !data.success) {
      throw new Error(data.error || 'Failed to delete meme');
    }

    alert('üóëÔ∏è Meme deleted successfully!');

    // Refresh data
    await loadMemes();
    await loadLeaderboard();

  } catch (error) {
    console.error('‚ùå Delete error:', error);
    alert(`Failed to delete meme: ${error.message}`);
  }
}

// üì§ Open Upload Modal
function openMemeUploadModal() {
  const walletAddress = localStorage.getItem('bearpark_wallet');
  if (!walletAddress) {
    alert('Please connect your wallet to submit a meme!');
    return;
  }

  const modal = document.getElementById('meme-upload-modal');
  if (modal) {
    modal.style.display = 'flex';
    document.body.style.overflow = 'hidden';
  }
}

// ‚ùå Close Upload Modal
function closeMemeUploadModal() {
  const modal = document.getElementById('meme-upload-modal');
  if (modal) {
    modal.style.display = 'none';
    document.body.style.overflow = '';
  }
}

// üìÅ Handle File Selection
function handleMemeFileSelect(file) {
  const isVideo = file.type.startsWith('video/');
  const maxSize = isVideo ? 50 * 1024 * 1024 : 5 * 1024 * 1024; // 50MB for videos, 5MB for images

  // Validate file size
  if (file.size > maxSize) {
    alert(`File too large! Maximum size is ${isVideo ? '50MB' : '5MB'}.`);
    return;
  }

  const validTypes = [
    'image/jpeg', 'image/png', 'image/gif', 'image/webp',
    'video/mp4', 'video/webm', 'video/quicktime', 'video/x-msvideo', 'video/mpeg'
  ];
  if (!validTypes.includes(file.type)) {
    alert('Invalid file type! Please upload:\nImages: JPG, PNG, GIF, WEBP\nVideos: MP4, WEBM, MOV, AVI, MPEG');
    return;
  }

  // Store file reference
  window.selectedMemeFile = file;

  // Update browse button text to show file selected
  const browseBtn = document.querySelector('.browse-btn');
  if (browseBtn) {
    browseBtn.textContent = isVideo ? '‚úÖ VIDEO SELECTED' : '‚úÖ IMAGE SELECTED';
    browseBtn.style.background = 'linear-gradient(135deg, #4ade80 0%, #22c55e 100%)';
  }

  // Enable submit button
  const submitBtn = document.getElementById('meme-submit-btn');
  if (submitBtn) submitBtn.disabled = false;
}

// üì§ Submit Meme
async function submitMeme() {
  const walletAddress = localStorage.getItem('bearpark_wallet');
  if (!walletAddress) {
    alert('Please connect your wallet first!');
    return;
  }

  if (!window.selectedMemeFile) {
    alert('Please select an image or video!');
    return;
  }

  const submitBtn = document.getElementById('meme-submit-btn');

  try {
    submitBtn.disabled = true;
    submitBtn.textContent = 'üì§ UPLOADING...';

    // Upload to Supabase Storage via backend
    const fileExt = window.selectedMemeFile.name.split('.').pop();
    const fileName = `${walletAddress}_${Date.now()}.${fileExt}`;

    // Create form data
    const formData = new FormData();
    formData.append('file', window.selectedMemeFile);
    formData.append('wallet_address', walletAddress);
    formData.append('file_name', fileName);

    // Submit to backend
    const response = await fetch('/api/memes/submit', {
      method: 'POST',
      body: formData
    });

    const data = await response.json();

    if (!response.ok || !data.success) {
      throw new Error(data.error || 'Failed to submit meme');
    }

    // Show message based on whether points were awarded
    if (data.points_awarded > 0) {
      alert('üéâ Meme submitted successfully! You earned 50 honey points!');
    } else {
      alert('üéâ Meme submitted successfully!\n\nNote: You already received the 50 point submission bonus this week.');
    }

    // Refresh data
    await loadMemes();
    await loadLeaderboard();

    // Update honey points if function exists
    if (typeof fetchHoneyPoints === 'function') {
      await fetchHoneyPoints();
    }

    // Close modal
    closeMemeUploadModal();

    console.log('‚úÖ Meme submitted successfully!');
  } catch (error) {
    console.error('‚ùå Submit error:', error);
    alert(`Failed to submit meme: ${error.message}`);
  } finally {
    submitBtn.disabled = false;
    submitBtn.textContent = 'üì§ SUBMIT MEME';
  }
}

// üõ°Ô∏è Escape HTML
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// üöÄ Initialize when wallet connects
if (typeof window.addEventListener !== 'undefined') {
  // Wait for DOM and wallet to be ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(initMemeOfTheWeek, 1000);
    });
  } else {
    setTimeout(initMemeOfTheWeek, 1000);
  }

  // Re-initialize when wallet connects
  window.addEventListener('walletConnected', () => {
    setTimeout(initMemeOfTheWeek, 500);
  });
}

  </script>
  <!-- ===== END MEME OF THE WEEK JAVASCRIPT ===== -->

  <!-- üêª BEAR TROLL FLOATING FACES ANIMATION ===== -->
  <script>
  (function() {
    'use strict';

    const section = document.getElementById('meme-of-the-week');
    if (!section) return;

    const bears = document.querySelectorAll('.bear-troll-face');
    if (!bears.length) return;

    // Physics properties for each bear
    const bearData = Array.from(bears).map((bear, i) => ({
      el: bear,
      x: Math.random() * (section.offsetWidth - 80),
      y: Math.random() * (section.offsetHeight - 80),
      vx: (Math.random() - 0.5) * 3,
      vy: (Math.random() - 0.5) * 3,
      rotation: Math.random() * 360,
      rotationSpeed: (Math.random() - 0.5) * 2,
      isDragging: false,
      dragStartX: 0,
      dragStartY: 0
    }));

    // Animation loop
    function animate() {
      const bounds = section.getBoundingClientRect();
      const width = bounds.width;
      const height = bounds.height;

      bearData.forEach(bear => {
        if (bear.isDragging) return;

        // Update position
        bear.x += bear.vx;
        bear.y += bear.vy;

        // Bounce off edges with some randomness
        if (bear.x <= 0 || bear.x >= width - 80) {
          bear.vx *= -1;
          bear.vx += (Math.random() - 0.5) * 0.5;
          bear.rotationSpeed *= -1;
        }
        if (bear.y <= 0 || bear.y >= height - 80) {
          bear.vy *= -1;
          bear.vy += (Math.random() - 0.5) * 0.5;
          bear.rotationSpeed *= -1;
        }

        // Keep within bounds
        bear.x = Math.max(0, Math.min(width - 80, bear.x));
        bear.y = Math.max(0, Math.min(height - 80, bear.y));

        // Update rotation
        bear.rotation += bear.rotationSpeed;

        // Apply transforms
        bear.el.style.transform = `translate(${bear.x}px, ${bear.y}px) rotate(${bear.rotation}deg)`;
      });

      requestAnimationFrame(animate);
    }

    // Drag functionality
    bearData.forEach(bear => {
      let mouseX = 0, mouseY = 0;

      bear.el.addEventListener('mousedown', (e) => {
        bear.isDragging = true;
        mouseX = e.clientX;
        mouseY = e.clientY;
        bear.el.style.transition = 'none';
      });

      document.addEventListener('mousemove', (e) => {
        if (!bear.isDragging) return;

        const bounds = section.getBoundingClientRect();
        const dx = e.clientX - mouseX;
        const dy = e.clientY - mouseY;

        mouseX = e.clientX;
        mouseY = e.clientY;

        bear.x += dx;
        bear.y += dy;

        // Keep within bounds
        const width = bounds.width;
        const height = bounds.height;
        bear.x = Math.max(0, Math.min(width - 80, bear.x));
        bear.y = Math.max(0, Math.min(height - 80, bear.y));

        bear.el.style.transform = `translate(${bear.x}px, ${bear.y}px) rotate(${bear.rotation}deg)`;
      });

      document.addEventListener('mouseup', () => {
        if (bear.isDragging) {
          bear.isDragging = false;
          bear.el.style.transition = 'transform 0.2s ease';

          // Give it a random velocity when released
          bear.vx = (Math.random() - 0.5) * 4;
          bear.vy = (Math.random() - 0.5) * 4;
          bear.rotationSpeed = (Math.random() - 0.5) * 3;
        }
      });

      // Touch support
      bear.el.addEventListener('touchstart', (e) => {
        e.preventDefault();
        bear.isDragging = true;
        const touch = e.touches[0];
        mouseX = touch.clientX;
        mouseY = touch.clientY;
        bear.el.style.transition = 'none';
      }, { passive: false });

      document.addEventListener('touchmove', (e) => {
        if (!bear.isDragging) return;

        const touch = e.touches[0];
        const bounds = section.getBoundingClientRect();
        const dx = touch.clientX - mouseX;
        const dy = touch.clientY - mouseY;

        mouseX = touch.clientX;
        mouseY = touch.clientY;

        bear.x += dx;
        bear.y += dy;

        const width = bounds.width;
        const height = bounds.height;
        bear.x = Math.max(0, Math.min(width - 80, bear.x));
        bear.y = Math.max(0, Math.min(height - 80, bear.y));

        bear.el.style.transform = `translate(${bear.x}px, ${bear.y}px) rotate(${bear.rotation}deg)`;
      });

      document.addEventListener('touchend', () => {
        if (bear.isDragging) {
          bear.isDragging = false;
          bear.el.style.transition = 'transform 0.2s ease';
          bear.vx = (Math.random() - 0.5) * 4;
          bear.vy = (Math.random() - 0.5) * 4;
          bear.rotationSpeed = (Math.random() - 0.5) * 3;
        }
      });
    });

    // Start animation
    animate();
  })();
  </script>
  <!-- ===== END BEAR TROLL ANIMATION ===== -->

  <!-- üêª BEAR HEADS FLOATING ANIMATION - BEAR FRIENDS ===== -->
  <script>
  (function() {
    'use strict';

    const BEAR_IMAGES = [
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/r200gp.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/589p6r.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/yyz3vq.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/zoa3fb.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/pnn9pt.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/hkdkri.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/xbnhl7.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/cld9fy.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/aovok8.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/w9cq2b.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/hqcuoy.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/omd3h3.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/rvj8d0.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/tzufdx.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/bl8tog.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ohccct.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/5tqgpv.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/59lai6.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ybzsk2.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/igefo9.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/i40edm.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/h1j81z.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/vhbxp5.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/9zvr1o.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/9o9os7.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/c3ltc5.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/suxp5j.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/kkqyyd.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wbcxb5.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/3xuks0.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/32tpgd.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/om0rdb.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/greqgo.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/8javcj.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/mr1lk9.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ldgio9.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/9344fv.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/6i74zc.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/rbtqp1.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/nbb05k.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ptg9qj.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/6zm638.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/mmew3l.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/f4jnzq.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ihrh1m.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/1s2f0r.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/4x17oh.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/4jnpdq.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/mzo6zn.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/biihrz.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/jm4rh5.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/17fh0s.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/mxwiet.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/823pds.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ptgqho.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/uhgfb7.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/ujk28i.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/codjlu.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/4fht2m.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/jm5nuv.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/opsj3v.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/n3m7c7.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/lou30d.png',
      'https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/lp2wpw.png'
    ];

    const section = document.getElementById('community');
    if (!section) return;

    const container = section.querySelector('.bear-heads-container');
    if (!container) return;

    const MAX_BEARS = 6;
    const activeBears = [];
    let nextId = 0;

    // Create bear element
    function createBear() {
      const bear = {
        id: nextId++,
        el: null,
        x: Math.random() * (section.offsetWidth - 100),
        y: Math.random() * (section.offsetHeight - 100),
        vx: (Math.random() - 0.5) * 5,
        vy: (Math.random() - 0.5) * 5,
        rotation: Math.random() * 360,
        rotationSpeed: (Math.random() - 0.5) * 0.3,
        scale: 0.7 + Math.random() * 0.6,
        isDragging: false,
        lifeTime: 15000 + Math.random() * 15000
      };

      const img = document.createElement('img');
      img.src = BEAR_IMAGES[Math.floor(Math.random() * BEAR_IMAGES.length)];
      img.className = 'bear-head spawning';
      img.alt = '';
      img.draggable = false;
      img.style.transform = `translate(${bear.x}px, ${bear.y}px) rotate(${bear.rotation}deg) scale(${bear.scale})`;

      container.appendChild(img);
      bear.el = img;

      // Remove spawning class after animation
      setTimeout(() => {
        img.classList.remove('spawning');
      }, 600);

      // Setup drag
      setupDrag(bear);

      // Schedule despawn
      bear.despawnTimeout = setTimeout(() => {
        despawnBear(bear);
      }, bear.lifeTime);

      return bear;
    }

    // Despawn bear with animation
    function despawnBear(bear) {
      if (!bear.el || !bear.el.parentNode) return;

      bear.el.classList.add('despawning');

      setTimeout(() => {
        if (bear.el && bear.el.parentNode) {
          bear.el.remove();
        }
        const index = activeBears.indexOf(bear);
        if (index > -1) activeBears.splice(index, 1);
      }, 500);

      if (bear.despawnTimeout) {
        clearTimeout(bear.despawnTimeout);
      }
    }

    // Setup drag functionality
    function setupDrag(bear) {
      let mouseX = 0, mouseY = 0;

      bear.el.addEventListener('mousedown', (e) => {
        e.preventDefault();
        bear.isDragging = true;
        mouseX = e.clientX;
        mouseY = e.clientY;
        bear.el.style.transition = 'none';
        bear.el.style.animation = 'none';

        // Clear despawn timeout while dragging
        if (bear.despawnTimeout) {
          clearTimeout(bear.despawnTimeout);
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (!bear.isDragging) return;

        const bounds = section.getBoundingClientRect();
        const dx = e.clientX - mouseX;
        const dy = e.clientY - mouseY;

        mouseX = e.clientX;
        mouseY = e.clientY;

        bear.x += dx;
        bear.y += dy;

        const width = bounds.width;
        const height = bounds.height;
        bear.x = Math.max(0, Math.min(width - 100, bear.x));
        bear.y = Math.max(0, Math.min(height - 100, bear.y));

        bear.el.style.transform = `translate(${bear.x}px, ${bear.y}px) rotate(${bear.rotation}deg) scale(${bear.scale})`;
      });

      document.addEventListener('mouseup', () => {
        if (bear.isDragging) {
          bear.isDragging = false;
          bear.el.style.transition = 'transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
          bear.el.style.animation = 'pulse 2s ease-in-out infinite';

          // Fling it!
          bear.vx = (Math.random() - 0.5) * 8;
          bear.vy = (Math.random() - 0.5) * 8;
          bear.rotationSpeed = (Math.random() - 0.5) * 6;

          // Restart despawn timer
          bear.despawnTimeout = setTimeout(() => {
            despawnBear(bear);
          }, 2000 + Math.random() * 3000);
        }
      });

      // Touch support
      bear.el.addEventListener('touchstart', (e) => {
        e.preventDefault();
        bear.isDragging = true;
        const touch = e.touches[0];
        mouseX = touch.clientX;
        mouseY = touch.clientY;
        bear.el.style.transition = 'none';
        bear.el.style.animation = 'none';

        if (bear.despawnTimeout) {
          clearTimeout(bear.despawnTimeout);
        }
      }, { passive: false });

      document.addEventListener('touchmove', (e) => {
        if (!bear.isDragging) return;

        const touch = e.touches[0];
        const bounds = section.getBoundingClientRect();
        const dx = touch.clientX - mouseX;
        const dy = touch.clientY - mouseY;

        mouseX = touch.clientX;
        mouseY = touch.clientY;

        bear.x += dx;
        bear.y += dy;

        const width = bounds.width;
        const height = bounds.height;
        bear.x = Math.max(0, Math.min(width - 100, bear.x));
        bear.y = Math.max(0, Math.min(height - 100, bear.y));

        bear.el.style.transform = `translate(${bear.x}px, ${bear.y}px) rotate(${bear.rotation}deg) scale(${bear.scale})`;
      });

      document.addEventListener('touchend', () => {
        if (bear.isDragging) {
          bear.isDragging = false;
          bear.el.style.transition = 'transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
          bear.el.style.animation = 'pulse 2s ease-in-out infinite';

          bear.vx = (Math.random() - 0.5) * 8;
          bear.vy = (Math.random() - 0.5) * 8;
          bear.rotationSpeed = (Math.random() - 0.5) * 6;

          bear.despawnTimeout = setTimeout(() => {
            despawnBear(bear);
          }, 2000 + Math.random() * 3000);
        }
      });
    }

    // Animation loop
    function animate() {
      const bounds = section.getBoundingClientRect();
      const width = bounds.width;
      const height = bounds.height;

      activeBears.forEach(bear => {
        if (bear.isDragging || !bear.el) return;

        // Update position
        bear.x += bear.vx;
        bear.y += bear.vy;

        // Bounce with elasticity
        if (bear.x <= 0 || bear.x >= width - 100) {
          bear.vx *= -0.9;
          bear.vx += (Math.random() - 0.5) * 2;
          bear.rotationSpeed *= -1;
        }
        if (bear.y <= 0 || bear.y >= height - 100) {
          bear.vy *= -0.9;
          bear.vy += (Math.random() - 0.5) * 2;
          bear.rotationSpeed *= -1;
        }

        bear.x = Math.max(0, Math.min(width - 100, bear.x));
        bear.y = Math.max(0, Math.min(height - 100, bear.y));

        // Check collisions with other bears
        activeBears.forEach(otherBear => {
          if (otherBear.id === bear.id || otherBear.isDragging || !otherBear.el) return;

          const dx = otherBear.x - bear.x;
          const dy = otherBear.y - bear.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const minDistance = 100; // Bear size

          if (distance < minDistance) {
            // Collision detected! Bounce bears apart
            const angle = Math.atan2(dy, dx);
            const targetX = bear.x + Math.cos(angle) * minDistance;
            const targetY = bear.y + Math.sin(angle) * minDistance;

            const ax = (targetX - otherBear.x) * 0.05;
            const ay = (targetY - otherBear.y) * 0.05;

            bear.vx -= ax * 2;
            bear.vy -= ay * 2;
            otherBear.vx += ax;
            otherBear.vy += ay;

            // Add some spin (gentle)
            bear.rotationSpeed += (Math.random() - 0.5) * 0.3;
            otherBear.rotationSpeed += (Math.random() - 0.5) * 0.3;
          }
        });

        bear.rotation += bear.rotationSpeed;

        bear.el.style.transform = `translate(${bear.x}px, ${bear.y}px) rotate(${bear.rotation}deg) scale(${bear.scale})`;
      });

      requestAnimationFrame(animate);
    }

    // Spawn bears randomly
    function spawnLoop() {
      if (activeBears.length < MAX_BEARS && Math.random() < 0.7) {
        const bear = createBear();
        activeBears.push(bear);
      }

      // Random spawn timing (0.5-2 seconds)
      setTimeout(spawnLoop, 500 + Math.random() * 1500);
    }

    // Start everything
    animate();
    spawnLoop();

    // Spawn initial bears
    for (let i = 0; i < 3; i++) {
      setTimeout(() => {
        if (activeBears.length < MAX_BEARS) {
          const bear = createBear();
          activeBears.push(bear);
        }
      }, i * 500);
    }
  })();
  </script>
  <!-- ===== END BEAR HEADS ANIMATION ===== -->

  <!-- üêª‚ùÑÔ∏è COCAINE BEAR PERFORMANCE SCRIPT ===== -->
  <script>
  (function(){
    'use strict';
    // üêª‚ùÑÔ∏è COCAINE BEAR: Lazy load ALL images below the fold
    const lazyImages = document.querySelectorAll('img:not([loading])');
    lazyImages.forEach((img, i) => {
      if (i > 2) { // First 3 images load immediately
        img.loading = 'lazy';
        img.decoding = 'async';
      }
    });

    // üêª‚ùÑÔ∏è COCAINE BEAR: IntersectionObserver for fade-in
    if ('IntersectionObserver' in window) {
      const imgObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('loaded');
            imgObserver.unobserve(entry.target);
          }
        });
      }, { rootMargin: '100px' });
      document.querySelectorAll('img[loading="lazy"]').forEach(img => imgObserver.observe(img));
    }

    // PERFORMANCE: Removed empty passive listeners (they did nothing)
    // Browsers auto-detect passive for scroll/touch since Chrome 56

    // üêª‚ùÑÔ∏è COCAINE BEAR: Reduce motion for low-end devices
    if (navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4) {
      document.documentElement.style.setProperty('--ease-spring', 'linear');
      document.querySelectorAll('.btn').forEach(btn => {
        btn.style.transition = 'none';
      });
    }

    // üêª‚ùÑÔ∏è COCAINE BEAR: Preload next page on link hover
    document.querySelectorAll('a[href^="/"], a[href^="https://bearpark"]').forEach(link => {
      link.addEventListener('mouseenter', function() {
        const href = this.getAttribute('href');
        if (href && !document.querySelector(`link[href="${href}"]`)) {
          const preload = document.createElement('link');
          preload.rel = 'prefetch';
          preload.href = href;
          document.head.appendChild(preload);
        }
      }, { once: true, passive: true });
    });

    console.log('üêª‚ùÑÔ∏è COCAINE BEAR MODE ACTIVATED - MAXIMUM SPEED');
  })();
  </script>

  <!-- ===== NAVIGATION MODAL - WHERE WOULD YOU LIKE TO GO? ===== -->
  <div id="navigationModal" class="nav-modal" style="display: none;">
    <div class="nav-modal-overlay" onclick="closeNavigationModal()"></div>
    <div class="nav-modal-content">
      <div class="nav-modal-header">
        <h2 class="nav-modal-title">WHERE WOULD YOU LIKE TO GO?</h2>
        <p class="nav-modal-subtitle">Choose your destination in BEAR Park!</p>
        <button class="nav-modal-close" onclick="closeNavigationModal()">&times;</button>
      </div>
      <div class="nav-modal-body">
        <!-- COMMUNITY Section -->
        <div class="nav-modal-section">
          <h3 class="nav-modal-section-title purple">Community</h3>
          <div class="nav-modal-grid">
            <div class="nav-modal-item purple" onclick="navigateToSection('community')">
              <span class="nav-modal-icon">üêª</span>
              <span class="nav-modal-item-text">Bear Friends</span>
            </div>
            <div class="nav-modal-item purple" onclick="navigateToSection('bulletin-board')">
              <span class="nav-modal-icon">üìã</span>
              <span class="nav-modal-item-text">Bulletin Board</span>
            </div>
            <div class="nav-modal-item purple" onclick="navigateToSection('leaderboards')">
              <span class="nav-modal-icon">ü•á</span>
              <span class="nav-modal-item-text">Leaderboards</span>
            </div>
          </div>
        </div>

        <!-- HONEY POINTS Section -->
        <div class="nav-modal-section">
          <h3 class="nav-modal-section-title honey">Honey Points</h3>
          <div class="nav-modal-grid">
            <div class="nav-modal-item honey" onclick="navigateToSection('honey-points')">
              <span class="nav-modal-icon">üçØ</span>
              <span class="nav-modal-item-text">Honey Points</span>
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="" class="nav-item-honey">
            </div>
            <div class="nav-modal-item honey" onclick="navigateToSection('meme-of-the-week')">
              <span class="nav-modal-icon">üèÜ</span>
              <span class="nav-modal-item-text">Meme of the Week</span>
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="" class="nav-item-honey">
            </div>
            <div class="nav-modal-item honey" onclick="navigateToSection('raids')">
              <span class="nav-modal-icon">‚öîÔ∏è</span>
              <span class="nav-modal-item-text">Raids</span>
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="" class="nav-item-honey">
            </div>
            <div class="nav-modal-item honey" onclick="navigateToSection('bearcade')">
              <span class="nav-modal-icon">üéÆ</span>
              <span class="nav-modal-item-text">Bearcade</span>
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="" class="nav-item-honey">
            </div>
            <div class="nav-modal-item honey" onclick="navigateToSection('cosmetics-store')">
              <span class="nav-modal-icon">üõí</span>
              <span class="nav-modal-item-text">Bear Store</span>
              <img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/wyfjtc.png" alt="" class="nav-item-honey">
            </div>
          </div>
        </div>

        <!-- $BEAR Section -->
        <div class="nav-modal-section">
          <h3 class="nav-modal-section-title gold">$BEAR</h3>
          <div class="nav-modal-grid">
            <div class="nav-modal-item gold" onclick="navigateToSection('bear-overview')">
              <span class="nav-modal-icon">üìà</span>
              <span class="nav-modal-item-text">Chart & Stats</span>
            </div>
            <div class="nav-modal-item gold" onclick="navigateToSection('network')">
              <span class="nav-modal-icon">üí∞</span>
              <span class="nav-modal-item-text">How To Buy</span>
            </div>
            <div class="nav-modal-item gold" onclick="navigateToSection('nfts')">
              <span class="nav-modal-icon">üñºÔ∏è</span>
              <span class="nav-modal-item-text">NFTs</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Navigation Modal Functions
    function openNavigationModal() {
      document.getElementById('navigationModal').style.display = 'flex';
      document.body.style.overflow = 'hidden';
    }

    function closeNavigationModal() {
      document.getElementById('navigationModal').style.display = 'none';
      document.body.style.overflow = '';
    }

    function navigateToSection(sectionId) {
      closeNavigationModal();
      const section = document.getElementById(sectionId);
      if (section) {
        section.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    // Close modal on Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        closeNavigationModal();
      }
    });
  </script>

  <script>
  (function() {
    'use strict';
    // Whitelist for UI display (claim is still verified server-side)
    const _wl = [
      'rKkkYMCvC63HEgxjQHmayKADaxYqnsMUkT'.toLowerCase(),
      'rBDvrd98rydzvqo7URuknR3m4eJt4bxXub'.toLowerCase(),
      'rGRuuisahMW6pcWMLVFP1Qtb7YieN5oVR6'.toLowerCase(),
      'rG4NCL8TmAx59euPf2GQjuqQVVfDFtWfTR'.toLowerCase(),
      'rnf92YvLeFTcMwqpcMzqM5Xh4qgKxYyRJv'.toLowerCase()
    ];
    const _n = 'rBEARbo4Prn33894evmvYcAf9yAQjp4VJF';
    const _l = 'rwE86ARLXfyKYCVmFpk511ddYfs5Fh6Vcp';
    const _r1 = 1, _r2 = 5, _r3 = 1, _hp = 30;

    // UI eligibility check (claim is still verified server-side so this can't be gamed)
    function _chk() {
      // Get wallet from localStorage (or sessionStorage for backwards compatibility)
      let w = localStorage.getItem('bearpark_wallet');
      if (!w) w = sessionStorage.getItem('bearpark_wallet');
      if (!w) return false;
      return _wl.includes(w.toLowerCase());
    }

    // SECURITY: Global flag to prevent double-claims
    let _claimInProgress = false;

    async function _claim() {
      const w = localStorage.getItem('bearpark_wallet');
      const isEligible = _chk();
      if (!w || !isEligible) return;

      // SECURITY: Prevent double-click / rapid fire
      if (_claimInProgress) {
        console.warn('Claim already in progress, ignoring duplicate request');
        return;
      }

      // SECURITY: Check localStorage cooldown (60 second minimum between attempts)
      const lastClaimAttempt = localStorage.getItem('beardrops_last_claim_attempt');
      if (lastClaimAttempt) {
        const elapsed = Date.now() - parseInt(lastClaimAttempt);
        if (elapsed < 60000) { // 60 seconds
          const remaining = Math.ceil((60000 - elapsed) / 1000);
          alert(`Please wait ${remaining} seconds before trying again.`);
          return;
        }
      }

      _claimInProgress = true;
      localStorage.setItem('beardrops_last_claim_attempt', Date.now().toString());

      const cb = document.getElementById('m7Btn');
      const ct = document.getElementById('m7BtnTxt');
      const ph = document.getElementById('m7Hint');
      if (cb) cb.disabled = true;
      if (cb) cb.onclick = null; // SECURITY: Remove click handler entirely
      if (ct) ct.textContent = 'CLAIMING...';
      try {
        const r = await fetch((window.API_BASE_URL || '') + '/api/beardrops/claim', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ wallet_address: w })
        });
        const d = await r.json();
        if (d.success) {
          if (ph) ph.textContent = '\u2705 Claimed ' + d.amount + ' $BEAR! TX: ' + d.tx_hash.substring(0, 12) + '...';
          if (ct) ct.textContent = 'CLAIMED!';
          // SECURITY: Set claimed flag in localStorage to prevent refresh exploit (per-wallet)
          localStorage.setItem('beardrops_claimed_' + w + '_' + new Date().toISOString().split('T')[0], 'true');
          setTimeout(_init, 3000);
        } else {
          if (ph) ph.textContent = '\u274C ' + (d.error || 'Claim failed');
          if (ct) ct.textContent = 'CLAIM FAILED';
          // Refresh UI after 2 seconds to show correct state
          setTimeout(_init, 2000);
        }
      } catch (e) {
        if (ph) ph.textContent = '\u274C Network error. Try again.';
        if (ct) ct.textContent = 'TRY AGAIN';
        if (cb) cb.disabled = false;
        // Refresh UI after 2 seconds
        setTimeout(_init, 2000);
      } finally {
        // SECURITY: Reset flag after 30 seconds regardless
        setTimeout(() => { _claimInProgress = false; }, 30000);
      }
    }

    async function _checkClaimStatus(w) {
      try {
        const r = await fetch((window.API_BASE_URL || '') + '/api/beardrops/claim-status/' + w);
        if (r.ok) {
          const d = await r.json();
          return d;
        }
        return { claimed_today: false };
      } catch (e) { return { claimed_today: false }; }
    }

    function _startTimer(showClaimedMessage = false, hasPendingClaim = false) {
      const timerEl = document.getElementById('m7Timer');
      const timerText = document.getElementById('m7TimerText');
      if (!timerEl) return;
      timerEl.style.display = 'block';

      // Clear any existing timer interval
      if (window._beardropTimerInterval) {
        clearInterval(window._beardropTimerInterval);
      }

      function updateTimer() {
        const now = new Date();
        const utcHours = now.getUTCHours();
        const utcMinutes = now.getUTCMinutes();
        const utcSeconds = now.getUTCSeconds();

        // Calculate time until midnight UTC
        const hoursToMidnight = 23 - utcHours;
        const minsToMidnight = 59 - utcMinutes;
        const secsToMidnight = 59 - utcSeconds;

        // Format with leading zeros
        const h = hoursToMidnight.toString().padStart(2, '0');
        const m = minsToMidnight.toString().padStart(2, '0');
        const s = secsToMidnight.toString().padStart(2, '0');

        // Reset styles
        timerEl.style.background = 'rgba(251, 191, 36, 0.1)';
        timerEl.style.borderColor = 'rgba(251, 191, 36, 0.3)';
        timerEl.style.color = '#fbbf24';

        if (showClaimedMessage) {
          // Already claimed - show clear "come back tomorrow" message with grey styling
          timerEl.style.background = 'rgba(107, 114, 128, 0.2)';
          timerEl.style.borderColor = 'rgba(107, 114, 128, 0.4)';
          timerEl.style.color = '#9ca3af';
          if (timerText) {
            timerText.innerHTML = `‚úÖ <strong>Already claimed today!</strong> Next window opens in <strong>${h}h ${m}m ${s}s</strong>`;
          }
        } else if (hasPendingClaim) {
          // Has pending claim - show countdown until midnight (when it expires)
          if (timerText) {
            timerText.innerHTML = `üü£ <strong>Claim available!</strong> Expires in <strong>${h}h ${m}m ${s}s</strong>`;
            timerEl.style.background = 'rgba(139, 92, 246, 0.2)';
            timerEl.style.borderColor = 'rgba(139, 92, 246, 0.5)';
            timerEl.style.color = '#A855F7';
          }
        } else {
          // No pending claim - show countdown to next claim window
          if (timerText) {
            timerText.innerHTML = `‚è∞ Next claim window in <strong>${h}h ${m}m ${s}s</strong> (00:00 UTC)`;
          }
        }
      }

      updateTimer();
      // Update every second for live countdown
      window._beardropTimerInterval = setInterval(updateTimer, 1000);
    }

    function _hideTimer() {
      const timerEl = document.getElementById('m7Timer');
      if (timerEl) timerEl.style.display = 'none';
    }

    function _init() {
      const o = document.getElementById('m7Overlay');
      const isEligible = _chk();
      if (isEligible) {
        const t = document.getElementById('m7Title');
        if (t) {
          t.style.display = 'flex';
          t.style.alignItems = 'center';
          t.style.justifyContent = 'center';
          t.style.gap = '12px';
          t.innerHTML = '<img src="https://pub-58cecf0785cc4738a3496a79699fdf1e.r2.dev/images/khrawi.png" alt="BEAR" style="width:clamp(50px, 6vw, 70px); height:auto;"> $BEAR DROPS \u{1FA82}';
        }
        if (o) o.classList.add('hidden');
        _load();
      } else {
        const t = document.getElementById('m7Title');
        if (t) t.textContent = '?????';
        const s = document.getElementById('m7Sub');
        if (s) s.textContent = '?????';
        if (o) o.classList.remove('hidden');
      }
    }

    async function _load() {
      const w = localStorage.getItem('bearpark_wallet');
      const isEligible = _chk();
      if (!w || !isEligible) return;
      try {
        const s = document.getElementById('m7Sub');
        if (s) s.textContent = 'Community appreciation gifts for active participants';
        const nd = await _fn(w);
        const lb = await _fl(w);
        const hp = await _fh(w);
        const pr = nd.a * _r1, ur = nd.b * _r2, lr = Math.floor(lb / 250000) * _r3;
        const tr = pr + ur + lr;

        const l1 = document.querySelector('#sec-m7 .m7-item:nth-child(1) .m7-label');
        const l2 = document.querySelector('#sec-m7 .m7-item:nth-child(2) .m7-label');
        const l3 = document.querySelector('#sec-m7 .m7-item:nth-child(3) .m7-label');
        const i1 = document.querySelector('#sec-m7 .m7-item:nth-child(1) .m7-icon');
        const i2 = document.querySelector('#sec-m7 .m7-item:nth-child(2) .m7-icon');
        const i3 = document.querySelector('#sec-m7 .m7-item:nth-child(3) .m7-icon');
        if (l1) l1.textContent = 'Pixel Bears';
        if (l2) l2.textContent = 'Ultra Rares';
        if (l3) l3.textContent = 'LP Tokens';
        if (i1) i1.textContent = '\u{1F43B}';
        if (i2) i2.textContent = '\u{1F48E}';
        if (i3) i3.textContent = '\u{1F4A7}';

        const v1 = document.getElementById('m7v1');
        const r1 = document.getElementById('m7r1');
        const v2 = document.getElementById('m7v2');
        const r2 = document.getElementById('m7r2');
        const v3 = document.getElementById('m7v3');
        const r3 = document.getElementById('m7r3');
        if (v1) v1.textContent = nd.a;
        if (r1) r1.textContent = '\u2192 ' + pr + ' $BEAR';
        if (v2) v2.textContent = nd.b;
        if (r2) r2.textContent = '\u2192 ' + ur + ' $BEAR';
        if (v3) v3.textContent = lb.toLocaleString();
        if (r3) r3.textContent = '\u2192 ' + lr + ' $BEAR';

        const tl = document.querySelector('#sec-m7 .m7-tot-lbl');
        if (tl) tl.textContent = 'Your Estimated Gift';
        const tv = document.getElementById('m7Total');
        if (tv) tv.textContent = tr + ' $BEAR';

        const pl = document.querySelector('#sec-m7 .m7-prog-lbl');
        if (pl) pl.textContent = '\u{1F36F} Honey Points (24h)';
        const pc = document.getElementById('m7ProgCnt');
        const pf = document.getElementById('m7ProgFill');
        const ph = document.getElementById('m7Hint');
        const cb = document.getElementById('m7Btn');
        const ct = document.getElementById('m7BtnTxt');
        if (pc) pc.textContent = hp + '/' + _hp;
        if (pf) pf.style.width = Math.min((hp / _hp) * 100, 100) + '%';

        // Check claim status from database
        const claimStatus = await _checkClaimStatus(w);
        console.log('BEARDROPS DEBUG - claimStatus:', JSON.stringify(claimStatus));
        console.log('BEARDROPS DEBUG - total_pending:', claimStatus.total_pending, 'tr:', tr);
        // Check BOTH backend status AND localStorage flag (belt and suspenders)
        const todayStr = new Date().toISOString().split('T')[0];
        const localClaimedFlag = localStorage.getItem('beardrops_claimed_' + w + '_' + todayStr) === 'true';
        const claimedToday = claimStatus.claimed_today || localClaimedFlag;

        // CRITICAL: Use backend's can_claim flag - it knows the real claim window rules
        // hasPendingClaim = true if there's ANY pending reward in database (even if can't claim yet due to low honey points)
        // canActuallyClaim = true only if they meet ALL requirements (pending + honey points + not already claimed)
        const hasPendingClaim = (claimStatus.total_pending || 0) > 0 && !claimedToday && !localClaimedFlag;
        const canActuallyClaim = claimStatus.can_claim === true && !claimedToday && !localClaimedFlag;
        const pendingAmount = hasPendingClaim ? (claimStatus.total_pending || 0) : 0;
        const claimedAmount = claimStatus.claimed_amount || claimStatus.amount || 0;

        console.log('BEARDROPS DEBUG - claimedToday:', claimedToday, 'localFlag:', localClaimedFlag, 'backendFlag:', claimStatus.claimed_today);
        console.log('BEARDROPS DEBUG - hasPendingClaim:', hasPendingClaim, 'total_pending:', claimStatus.total_pending);
        console.log('BEARDROPS DEBUG - canActuallyClaim:', canActuallyClaim, 'can_claim from API:', claimStatus.can_claim);
        console.log('BEARDROPS DEBUG - honey points:', hp, '/', _hp, 'enough:', hp >= _hp);

        if (claimedToday) {
          // Already claimed - show CLEAR claimed state with greyed button
          if (ph) ph.textContent = '';  // Clear hint - timer says it all
          if (cb) {
            cb.disabled = true;
            cb.classList.add('claimed');
            cb.onclick = null;
            cb.style.background = 'linear-gradient(135deg, #374151, #1f2937)';
            cb.style.cursor = 'not-allowed';
            cb.style.boxShadow = 'none';
          }
          if (ct) ct.textContent = 'ALREADY CLAIMED TODAY';
          _startTimer(true, false);
        } else if (hasPendingClaim && hp >= _hp) {
          // Has pending claim and enough honey points - can claim!
          if (ph) ph.textContent = '\u2705 You are eligible! Claim your gift now!';
          if (cb) {
            cb.disabled = false;
            cb.classList.remove('claimed');
            cb.onclick = _claim;
            // Reset to PURPLE claimable style (Material UI 6 luxury theme)
            cb.style.background = 'linear-gradient(135deg, #8B5CF6, #7C3AED)';
            cb.style.cursor = 'pointer';
            cb.style.boxShadow = '0 4px 0 #5B21B6, 0 6px 20px rgba(139, 92, 246, 0.4)';
          }
          if (ct) ct.textContent = 'CLAIM ' + pendingAmount.toFixed(0) + ' $BEAR';
          _startTimer(false, true);
        } else if (hasPendingClaim) {
          // Has pending claim but not enough honey points
          const rm = _hp - hp;
          if (ph) ph.textContent = 'Pending gift available! Be more active to become eligible.';
          if (cb) {
            cb.disabled = true;
            cb.classList.remove('claimed');
            cb.onclick = null;
            // Gold/warning style - needs more points (Material UI 6 luxury theme)
            cb.style.background = 'linear-gradient(135deg, #FBBF24, #F4A012)';
            cb.style.cursor = 'not-allowed';
            cb.style.boxShadow = '0 4px 0 #B45309, 0 6px 20px rgba(251, 191, 36, 0.3)';
          }
          if (ct) ct.textContent = 'NOT YET ELIGIBLE';
          _startTimer(false, true);
        } else {
          // No pending claim - come back tomorrow
          if (ph) ph.textContent = '';
          if (cb) {
            cb.disabled = true;
            cb.classList.remove('claimed');
            cb.onclick = null;
            // Grey disabled style
            cb.style.background = 'linear-gradient(135deg, #374151, #1f2937)';
            cb.style.cursor = 'not-allowed';
            cb.style.boxShadow = 'none';
          }
          if (ct) ct.textContent = 'NO PENDING GIFT';
          _startTimer(false, false);
        }
      } catch (e) {}
    }

    async function _fn(w) {
      // üêª‚ùÑÔ∏è Use WebSocket directly - HTTP s1.ripple.com:51234 doesn't support CORS
      try {
        const ws = new WebSocket('wss://s1.ripple.com');
        return new Promise((res) => {
          let a = 0, b = 0;
          ws.onopen = () => { ws.send(JSON.stringify({ command: 'account_nfts', account: w, limit: 400 })); };
          ws.onmessage = (e) => {
            const d = JSON.parse(e.data);
            if (d.result && d.result.account_nfts) {
              d.result.account_nfts.forEach(n => {
                if (n.Issuer === _n && n.URI) {
                  const u = _hts(n.URI);
                  if (u.includes('Pixel BEAR') || u.includes('Pixel%20BEAR')) { a++; } else { b++; }
                }
              });
            }
            ws.close(); res({ a, b });
          };
          ws.onerror = () => { ws.close(); res({ a: 0, b: 0 }); };
          setTimeout(() => { ws.close(); res({ a, b }); }, 10000);
        });
      } catch (e) { return { a: 0, b: 0 }; }
    }

    async function _fl(w) {
      // üêª‚ùÑÔ∏è Use WebSocket directly - HTTP s1.ripple.com:51234 doesn't support CORS
      try {
        const ws = new WebSocket('wss://s1.ripple.com');
        return new Promise((res) => {
          ws.onopen = () => { ws.send(JSON.stringify({ command: 'account_lines', account: w })); };
          ws.onmessage = (e) => {
            const d = JSON.parse(e.data);
            let b = 0;
            if (d.result && d.result.lines) {
              const ln = d.result.lines.find(l => l.account === _l && l.currency && l.currency.length === 40);
              if (ln) b = parseFloat(ln.balance) || 0;
            }
            ws.close(); res(Math.abs(b));
          };
          ws.onerror = () => { ws.close(); res(0); };
          setTimeout(() => { ws.close(); res(0); }, 10000);
        });
      } catch (e) { return 0; }
    }

    async function _fh(w) {
      try {
        const r = await fetch((window.API_BASE_URL || '') + '/api/honey-points/24h?wallet=' + w);
        if (r.ok) { const d = await r.json(); return d.points || 0; }
        return 0;
      } catch (e) { return 0; }
    }

    function _hts(h) {
      if (!h) return '';
      let s = '';
      for (let i = 0; i < h.length; i += 2) { s += String.fromCharCode(parseInt(h.substr(i, 2), 16)); }
      return s;
    }

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', _init); }
    else { _init(); }
    window.addEventListener('walletConnected', () => { setTimeout(_init, 500); });
    window.addEventListener('walletDisconnected', () => { setTimeout(_init, 500); });
    // Real-time update when honey points change (raids, games, etc.)
    window.addEventListener('honeyPointsUpdated', () => { setTimeout(_init, 500); });
    window._m7r = _init;
  })();
  </script>

</body>
</html><!-- üêª‚ùÑÔ∏è COCAINE BEAR v1.0 -->
