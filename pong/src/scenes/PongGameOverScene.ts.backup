/**
 * PongGameOverScene - Game over screen with results and stats submission
 */
import Phaser from 'phaser';
import { PongAPI } from '../PongAPI';
import { PongClient } from '../networking/PongClient';
import type { PlayerData } from '../networking/types';

export class PongGameOverScene extends Phaser.Scene {
  private didWin: boolean = false;
  private yourScore: number = 0;
  private opponentScore: number = 0;
  private opponent: PlayerData | null = null;
  private pongClient: PongClient | null = null;
  private leaderboard: any[] = [];

  constructor() {
    super({ key: 'PongGameOverScene' });
  }

  init(data: any) {
    this.didWin = data.didWin;
    this.yourScore = data.yourScore;
    this.opponentScore = data.opponentScore;
    this.opponent = data.opponent;
    this.pongClient = data.pongClient;
  }

  async create() {
    const { width, height } = this.cameras.main;

    // Background
    this.add.rectangle(0, 0, width, height, 0x1a1a1a, 1).setOrigin(0);

    // "GAME OVER" title
    const gameOverText = this.add.text(
      width / 2,
      100,
      this.didWin ? 'VICTORY!' : 'GAME OVER',
      {
        fontSize: '56px',
        color: this.didWin ? '#4ade80' : '#ff6b6b',
        fontStyle: 'bold',
        fontFamily: 'Arial Black, sans-serif'
      }
    );
    gameOverText.setOrigin(0.5);
    gameOverText.setStroke('#000000', 4);

    // Star rating (1-5 stars based on score)
    this.displayStarRating(width / 2, 160);

    // Score display with gradient border
    this.displayScoreBox(width / 2, 240);

    // Submit result to API
    await this.submitResult();

    // Award honey points for gameplay time
    this.awardHoneyPoints();

    // Show leaderboard with "TOP 10 PLAYERS" title
    await this.loadAndDisplayLeaderboard(width / 2, 400);

    // Styled buttons
    this.createStyledButtons(width / 2, height - 200);
  }

  /**
   * Submit win/loss to BEARpark API
   */
  private async submitResult() {
    try {
      if (this.didWin) {
        await PongAPI.submitWin({
          opponent: this.opponent?.displayName,
          your_score: this.yourScore,
          opponent_score: this.opponentScore
        });
        console.log('âœ… Win submitted to BEARpark');
      } else {
        await PongAPI.submitLoss({
          opponent: this.opponent?.displayName,
          your_score: this.yourScore,
          opponent_score: this.opponentScore
        });
        console.log('âœ… Loss submitted to BEARpark');
      }
    } catch (error) {
      console.error('âŒ Error submitting result:', error);
    }
  }

  /**
   * Display updated player stats
   */
  private displayStats(x: number, y: number) {
    const stats = PongAPI.getLocalStats();

    const statsContainer = this.add.container(x, y);

    // Title
    const statsTitle = this.add.text(0, 0, 'Your Stats', {
      fontSize: '24px',
      color: '#4a90e2',
      fontStyle: 'bold'
    });
    statsTitle.setOrigin(0.5);
    statsContainer.add(statsTitle);

    // Stats display
    const statsText = this.add.text(
      0,
      40,
      `Wins: ${stats.wins}  |  Losses: ${stats.losses}  |  Win Rate: ${(stats.winRate * 100).toFixed(1)}%`,
      {
        fontSize: '18px',
        color: '#ffffff'
      }
    );
    statsText.setOrigin(0.5);
    statsContainer.add(statsText);

    // Fade in animation
    statsContainer.setAlpha(0);
    this.tweens.add({
      targets: statsContainer,
      alpha: 1,
      duration: 500,
      delay: 300
    });
  }

  /**
   * Load and display leaderboard
   */
  private async loadAndDisplayLeaderboard(x: number, y: number) {
    const leaderboardContainer = this.add.container(x, y);

    // Title
    const title = this.add.text(0, 0, 'Top Players', {
      fontSize: '24px',
      color: '#4a90e2',
      fontStyle: 'bold'
    });
    title.setOrigin(0.5);
    leaderboardContainer.add(title);

    // Loading text
    const loadingText = this.add.text(0, 40, 'Loading...', {
      fontSize: '16px',
      color: '#888888'
    });
    loadingText.setOrigin(0.5);
    leaderboardContainer.add(loadingText);

    // Fetch leaderboard
    try {
      this.leaderboard = await PongAPI.getLeaderboard(5);

      // Remove loading text
      loadingText.destroy();

      // Display leaderboard entries
      if (this.leaderboard.length > 0) {
        this.leaderboard.forEach((entry, index) => {
          const displayName = PongAPI.formatDisplayName(entry);
          const wins = entry.score || entry.metadata?.wins || 0;
          const losses = entry.metadata?.losses || 0;

          const entryText = this.add.text(
            0,
            40 + index * 30,
            `${index + 1}. ${displayName} - ${wins}W ${losses}L`,
            {
              fontSize: '16px',
              color: '#ffffff'
            }
          );
          entryText.setOrigin(0.5);
          leaderboardContainer.add(entryText);
        });
      } else {
        const noDataText = this.add.text(0, 40, 'No leaderboard data yet', {
          fontSize: '16px',
          color: '#888888'
        });
        noDataText.setOrigin(0.5);
        leaderboardContainer.add(noDataText);
      }
    } catch (error) {
      loadingText.setText('Failed to load leaderboard');
      console.error('Error loading leaderboard:', error);
    }

    // Fade in animation
    leaderboardContainer.setAlpha(0);
    this.tweens.add({
      targets: leaderboardContainer,
      alpha: 1,
      duration: 500,
      delay: 600
    });
  }

  /**
   * Create action buttons
   */
  private createButtons(x: number, y: number) {
    // Play Again button
    const playAgainBtn = this.add.text(x, y, '[ Play Again ]', {
      fontSize: '24px',
      color: '#4ade80'
    });
    playAgainBtn.setOrigin(0.5);
    playAgainBtn.setInteractive({ useHandCursor: true });

    playAgainBtn.on('pointerover', () => {
      playAgainBtn.setScale(1.1);
    });

    playAgainBtn.on('pointerout', () => {
      playAgainBtn.setScale(1);
    });

    playAgainBtn.on('pointerdown', () => {
      this.playAgain();
    });

    // Main Menu button
    const menuBtn = this.add.text(x, y + 60, '[ Main Menu ]', {
      fontSize: '20px',
      color: '#888888'
    });
    menuBtn.setOrigin(0.5);
    menuBtn.setInteractive({ useHandCursor: true });

    menuBtn.on('pointerover', () => {
      menuBtn.setScale(1.1);
      menuBtn.setColor('#ffffff');
    });

    menuBtn.on('pointerout', () => {
      menuBtn.setScale(1);
      menuBtn.setColor('#888888');
    });

    menuBtn.on('pointerdown', () => {
      this.returnToMenu();
    });

    // Fade in animations
    playAgainBtn.setAlpha(0);
    menuBtn.setAlpha(0);

    this.tweens.add({
      targets: [playAgainBtn, menuBtn],
      alpha: 1,
      duration: 500,
      delay: 900
    });
  }

  /**
   * Play another game
   */
  private playAgain() {
    // Disconnect previous client if exists
    if (this.pongClient) {
      this.pongClient.disconnect();
    }

    // Go back to lobby to find new opponent
    this.scene.start('PongLobbyScene');
  }

  /**
   * Return to main menu
   */
  private returnToMenu() {
    // Disconnect client if exists
    if (this.pongClient) {
      this.pongClient.disconnect();
    }

    // Redirect to main site
    window.location.href = '/'; // Go back to BEARpark main site
  }

  /**
   * Award honey points for gameplay time
   */
  private awardHoneyPoints() {
    try {
      // Check if the honey points handler exists (from parent window)
      if (typeof (window as any).handlePongGameCompletion === 'function') {
        (window as any).handlePongGameCompletion();
        console.log('âœ… Honey points handler called');
      } else {
        console.log('âš ï¸ Honey points handler not found - game may not be embedded in BEARpark site');
      }
    } catch (error) {
      console.error('âŒ Error calling honey points handler:', error);
    }
  }

  /**
   * Display star rating (1-5 stars based on performance)
   */
  private displayStarRating(x: number, y: number) {
    const stars = this.didWin ? (this.yourScore >= 3 ? 5 : 3) : 1;
    const starSize = 40;
    const spacing = 45;
    const startX = x - (spacing * 2);

    for (let i = 0; i < 5; i++) {
      const star = this.add.text(startX + (i * spacing), y, 'â˜…', {
        fontSize: starSize + 'px',
        color: i < stars ? '#FFD700' : '#404040'
      });
      star.setOrigin(0.5);
    }
  }

  /**
   * Display score with gradient border box
   */
  private displayScoreBox(x: number, y: number) {
    const stats = PongAPI.getLocalStats();
    const { width } = this.cameras.main;

    // Box dimensions
    const boxWidth = width * 0.85;
    const boxHeight = 120;
    const graphics = this.add.graphics();

    // Rainbow gradient border
    graphics.lineStyle(4, 0x5555ff, 1);
    graphics.strokeRoundedRect(x - boxWidth / 2, y - boxHeight / 2, boxWidth, boxHeight, 15);

    graphics.lineStyle(4, 0xffaa00, 1);
    graphics.beginPath();
    graphics.arc(x, y, boxWidth / 2.8, 0, Math.PI, false);
    graphics.strokePath();

    graphics.lineStyle(4, 0x55ff55, 1);
    graphics.beginPath();
    graphics.arc(x, y, boxWidth / 2.8, Math.PI, Math.PI * 2, false);
    graphics.strokePath();

    // Inner box
    graphics.fillStyle(0x2a2a2a, 0.95);
    graphics.fillRoundedRect(x - boxWidth / 2 + 5, y - boxHeight / 2 + 5, boxWidth - 10, boxHeight - 10, 12);

    // Score title
    const scoreTitle = this.add.text(x, y - 30, 'YOUR SCORE', {
      fontSize: '22px',
      color: '#ffaa00',
      fontStyle: 'bold',
      fontFamily: 'Arial'
    });
    scoreTitle.setOrigin(0.5);

    // Score value (total wins)
    const scoreValue = this.add.text(x, y + 10, stats.wins.toString(), {
      fontSize: '52px',
      color: '#ffffff',
      fontStyle: 'bold',
      fontFamily: 'Arial Black'
    });
    scoreValue.setOrigin(0.5);

    // Win badge
    const winsText = this.add.text(x, y + 40, `ðŸ† ${stats.wins} WIN${stats.wins !== 1 ? 'S' : ''}`, {
      fontSize: '18px',
      color: '#FFD700'
    });
    winsText.setOrigin(0.5);
  }

  /**
   * Create styled buttons matching the screenshot
   */
  private createStyledButtons(x: number, y: number) {
    const { width } = this.cameras.main;
    const buttonWidth = width * 0.8;
    const buttonHeight = 55;

    // "TAP TO RETRY" button
    const retryGraphics = this.add.graphics();
    retryGraphics.fillStyle(0xd85c47, 1);
    retryGraphics.fillRoundedRect(x - buttonWidth / 2, y - buttonHeight / 2, buttonWidth, buttonHeight, 10);

    const retryText = this.add.text(x, y, 'TAP TO RETRY', {
      fontSize: '24px',
      color: '#ffffff',
      fontStyle: 'bold',
      fontFamily: 'Arial'
    });
    retryText.setOrigin(0.5);

    const retryContainer = this.add.container(0, 0);
    retryContainer.add([retryGraphics, retryText]);
    retryContainer.setInteractive(
      new Phaser.Geom.Rectangle(x - buttonWidth / 2, y - buttonHeight / 2, buttonWidth, buttonHeight),
      Phaser.Geom.Rectangle.Contains
    );

    retryContainer.on('pointerdown', () => {
      this.playAgain();
    });

    retryContainer.on('pointerover', () => {
      retryGraphics.clear();
      retryGraphics.fillStyle(0xff7055, 1);
      retryGraphics.fillRoundedRect(x - buttonWidth / 2, y - buttonHeight / 2, buttonWidth, buttonHeight, 10);
    });

    retryContainer.on('pointerout', () => {
      retryGraphics.clear();
      retryGraphics.fillStyle(0xd8574c, 1);
      retryGraphics.fillRoundedRect(x - buttonWidth / 2, y - buttonHeight / 2, buttonWidth, buttonHeight, 10);
    });

    // "BACK TO GAME MENU" button
    const menuY = y + 75;
    const menuGraphics = this.add.graphics();

    // Gradient border
    menuGraphics.lineStyle(3, 0x5555ff, 1);
    menuGraphics.strokeRoundedRect(x - buttonWidth / 2, menuY - buttonHeight / 2, buttonWidth / 3, buttonHeight, 10);
    menuGraphics.lineStyle(3, 0xffaa00, 1);
    menuGraphics.strokeRoundedRect(x - buttonWidth / 6, menuY - buttonHeight / 2, buttonWidth / 3, buttonHeight, 10);
    menuGraphics.lineStyle(3, 0x55ff55, 1);
    menuGraphics.strokeRoundedRect(x + buttonWidth / 6, menuY - buttonHeight / 2, buttonWidth / 3, buttonHeight, 10);

    // Inner fill
    menuGraphics.fillStyle(0x1a1a1a, 0.9);
    menuGraphics.fillRoundedRect(x - buttonWidth / 2 + 3, menuY - buttonHeight / 2 + 3, buttonWidth - 6, buttonHeight - 6, 8);

    const menuText = this.add.text(x, menuY, 'BACK TO GAME MENU', {
      fontSize: '20px',
      color: '#ffffff',
      fontStyle: 'bold',
      fontFamily: 'Arial'
    });
    menuText.setOrigin(0.5);

    const menuContainer = this.add.container(0, 0);
    menuContainer.add([menuGraphics, menuText]);
    menuContainer.setInteractive(
      new Phaser.Geom.Rectangle(x - buttonWidth / 2, menuY - buttonHeight / 2, buttonWidth, buttonHeight),
      Phaser.Geom.Rectangle.Contains
    );

    menuContainer.on('pointerdown', () => {
      this.returnToMenu();
    });

    menuContainer.on('pointerover', () => {
      menuText.setColor('#ffaa00');
    });

    menuContainer.on('pointerout', () => {
      menuText.setColor('#ffffff');
    });
  }
}
